/**
 * DevExtreme (esm/core/utils/array.js)
 * Version: 21.2.15
 * Build date: Fri Dec 08 2023
 *
 * Copyright (c) 2012 - 2023 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */
import _extends from "@babel/runtime/helpers/esm/extends";
import {
    isDefined
} from "./type";
import {
    each
} from "./iterator";
import {
    orderEach
} from "./object";
import config from "../config";

function createOccurrenceMap(array) {
    return array.reduce((map, value) => {
        var _map$value;
        map[value] = (null !== (_map$value = map[value]) && void 0 !== _map$value ? _map$value : 0) + 1;
        return map
    }, {})
}
export var getIntersection = function(firstArray, secondArray) {
    var secondArrayMap = createOccurrenceMap(secondArray);
    return firstArray.filter(value => secondArrayMap[value]--)
};
export var removeDuplicates = function() {
    var from = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
    var toRemove = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];
    var toRemoveMap = createOccurrenceMap(toRemove);
    return from.filter(value => !toRemoveMap[value]--)
};
export var isEmpty = function(entity) {
    return Array.isArray(entity) && !entity.length
};
export var wrapToArray = function(entity) {
    return Array.isArray(entity) ? entity : [entity]
};
export var inArray = function(value, object) {
    if (!object) {
        return -1
    }
    var array = Array.isArray(object) ? object : object.toArray();
    return array.indexOf(value)
};
export var uniqueValues = function(data) {
    return [...new Set(data)]
};
export var normalizeIndexes = function(items, indexParameterName, currentItem, needIndexCallback) {
    var indexedItems = {};
    var parameterIndex = 0;
    var useLegacyVisibleIndex = config().useLegacyVisibleIndex;
    each(items, (function(index, item) {
        index = item[indexParameterName];
        if (index >= 0) {
            indexedItems[index] = indexedItems[index] || [];
            if (item === currentItem) {
                indexedItems[index].unshift(item)
            } else {
                indexedItems[index].push(item)
            }
        } else {
            item[indexParameterName] = void 0
        }
    }));
    if (!useLegacyVisibleIndex) {
        each(items, (function() {
            if (!isDefined(this[indexParameterName]) && (!needIndexCallback || needIndexCallback(this))) {
                while (indexedItems[parameterIndex]) {
                    parameterIndex++
                }
                indexedItems[parameterIndex] = [this];
                parameterIndex++
            }
        }))
    }
    parameterIndex = 0;
    orderEach(indexedItems, (function(index, items) {
        each(items, (function() {
            if (index >= 0) {
                this[indexParameterName] = parameterIndex++
            }
        }))
    }));
    if (useLegacyVisibleIndex) {
        each(items, (function() {
            if (!isDefined(this[indexParameterName]) && (!needIndexCallback || needIndexCallback(this))) {
                this[indexParameterName] = parameterIndex++
            }
        }))
    }
    return parameterIndex
};
export var merge = function(array1, array2) {
    for (var i = 0; i < array2.length; i++) {
        array1[array1.length] = array2[i]
    }
    return array1
};
export var find = function(array, condition) {
    for (var i = 0; i < array.length; i++) {
        if (condition(array[i])) {
            return array[i]
        }
    }
};
export var groupBy = (array, cb) => array.reduce((result, item) => _extends({}, result, {
    [cb(item)]: [...result[cb(item)] || [], item]
}), {});
