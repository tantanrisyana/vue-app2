import {
  EMPTY_OBJ,
  NO,
  NOOP,
  PatchFlagNames,
  camelize,
  capitalize,
  extend,
  generateCodeFrame,
  init_runtime_dom_esm_bundler,
  init_shared_esm_bundler,
  isArray,
  isBuiltInDirective,
  isHTMLTag,
  isMathMLTag,
  isObject,
  isOn,
  isReservedProp,
  isSVGTag,
  isString,
  isSymbol,
  isVoidTag,
  makeMap,
  parseStringStyle,
  runtime_dom_esm_bundler_exports,
  shared_esm_bundler_exports,
  slotFlagsText,
  toHandlerKey
} from "./chunk-4IG7KIC4.js";
import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS
} from "./chunk-GFT2G5UO.js";

// node_modules/@vue/compiler-core/dist/compiler-core.esm-bundler.js
function registerRuntimeHelpers(helpers) {
  Object.getOwnPropertySymbols(helpers).forEach((s) => {
    helperNameMap[s] = helpers[s];
  });
}
function createRoot(children, source = "") {
  return {
    type: 0,
    source,
    children,
    helpers: /* @__PURE__ */ new Set(),
    components: [],
    directives: [],
    hoists: [],
    imports: [],
    cached: 0,
    temps: 0,
    codegenNode: void 0,
    loc: locStub
  };
}
function createVNodeCall(context2, tag, props, children, patchFlag, dynamicProps, directives, isBlock = false, disableTracking = false, isComponent2 = false, loc = locStub) {
  if (context2) {
    if (isBlock) {
      context2.helper(OPEN_BLOCK);
      context2.helper(getVNodeBlockHelper(context2.inSSR, isComponent2));
    } else {
      context2.helper(getVNodeHelper(context2.inSSR, isComponent2));
    }
    if (directives) {
      context2.helper(WITH_DIRECTIVES);
    }
  }
  return {
    type: 13,
    tag,
    props,
    children,
    patchFlag,
    dynamicProps,
    directives,
    isBlock,
    disableTracking,
    isComponent: isComponent2,
    loc
  };
}
function createArrayExpression(elements, loc = locStub) {
  return {
    type: 17,
    loc,
    elements
  };
}
function createObjectExpression(properties, loc = locStub) {
  return {
    type: 15,
    loc,
    properties
  };
}
function createObjectProperty(key, value2) {
  return {
    type: 16,
    loc: locStub,
    key: isString(key) ? createSimpleExpression(key, true) : key,
    value: value2
  };
}
function createSimpleExpression(content, isStatic = false, loc = locStub, constType = 0) {
  return {
    type: 4,
    loc,
    content,
    isStatic,
    constType: isStatic ? 3 : constType
  };
}
function createInterpolation(content, loc) {
  return {
    type: 5,
    loc,
    content: isString(content) ? createSimpleExpression(content, false, loc) : content
  };
}
function createCompoundExpression(children, loc = locStub) {
  return {
    type: 8,
    loc,
    children
  };
}
function createCallExpression(callee, args = [], loc = locStub) {
  return {
    type: 14,
    loc,
    callee,
    arguments: args
  };
}
function createFunctionExpression(params, returns = void 0, newline = false, isSlot = false, loc = locStub) {
  return {
    type: 18,
    params,
    returns,
    newline,
    isSlot,
    loc
  };
}
function createConditionalExpression(test, consequent, alternate, newline = true) {
  return {
    type: 19,
    test,
    consequent,
    alternate,
    newline,
    loc: locStub
  };
}
function createCacheExpression(index2, value2, isVNode = false) {
  return {
    type: 20,
    index: index2,
    value: value2,
    isVNode,
    loc: locStub
  };
}
function createBlockStatement(body) {
  return {
    type: 21,
    body,
    loc: locStub
  };
}
function createTemplateLiteral(elements) {
  return {
    type: 22,
    elements,
    loc: locStub
  };
}
function createIfStatement(test, consequent, alternate) {
  return {
    type: 23,
    test,
    consequent,
    alternate,
    loc: locStub
  };
}
function createAssignmentExpression(left, right) {
  return {
    type: 24,
    left,
    right,
    loc: locStub
  };
}
function createSequenceExpression(expressions) {
  return {
    type: 25,
    expressions,
    loc: locStub
  };
}
function createReturnStatement(returns) {
  return {
    type: 26,
    returns,
    loc: locStub
  };
}
function getVNodeHelper(ssr, isComponent2) {
  return ssr || isComponent2 ? CREATE_VNODE : CREATE_ELEMENT_VNODE;
}
function getVNodeBlockHelper(ssr, isComponent2) {
  return ssr || isComponent2 ? CREATE_BLOCK : CREATE_ELEMENT_BLOCK;
}
function convertToBlock(node, { helper, removeHelper, inSSR }) {
  if (!node.isBlock) {
    node.isBlock = true;
    removeHelper(getVNodeHelper(inSSR, node.isComponent));
    helper(OPEN_BLOCK);
    helper(getVNodeBlockHelper(inSSR, node.isComponent));
  }
}
function isTagStartChar(c) {
  return c >= 97 && c <= 122 || c >= 65 && c <= 90;
}
function isWhitespace(c) {
  return c === 32 || c === 10 || c === 9 || c === 12 || c === 13;
}
function isEndOfTagSection(c) {
  return c === 47 || c === 62 || isWhitespace(c);
}
function toCharCodes(str) {
  const ret = new Uint8Array(str.length);
  for (let i = 0; i < str.length; i++) {
    ret[i] = str.charCodeAt(i);
  }
  return ret;
}
function getCompatValue(key, { compatConfig }) {
  const value2 = compatConfig && compatConfig[key];
  if (key === "MODE") {
    return value2 || 3;
  } else {
    return value2;
  }
}
function isCompatEnabled(key, context2) {
  const mode = getCompatValue("MODE", context2);
  const value2 = getCompatValue(key, context2);
  return mode === 3 ? value2 === true : value2 !== false;
}
function checkCompatEnabled(key, context2, loc, ...args) {
  const enabled = isCompatEnabled(key, context2);
  if (enabled) {
    warnDeprecation(key, context2, loc, ...args);
  }
  return enabled;
}
function warnDeprecation(key, context2, loc, ...args) {
  const val = getCompatValue(key, context2);
  if (val === "suppress-warning") {
    return;
  }
  const { message, link } = deprecationData[key];
  const msg = `(deprecation ${key}) ${typeof message === "function" ? message(...args) : message}${link ? `
  Details: ${link}` : ``}`;
  const err = new SyntaxError(msg);
  err.code = key;
  if (loc)
    err.loc = loc;
  context2.onWarn(err);
}
function defaultOnError(error) {
  throw error;
}
function defaultOnWarn(msg) {
  console.warn(`[Vue warn] ${msg.message}`);
}
function createCompilerError(code, loc, messages, additionalMessage) {
  const msg = true ? (messages || errorMessages)[code] + (additionalMessage || ``) : `https://vuejs.org/errors/#compiler-${code}`;
  const error = new SyntaxError(String(msg));
  error.code = code;
  error.loc = loc;
  return error;
}
function walkIdentifiers(root, onIdentifier, includeAll = false, parentStack = [], knownIds = /* @__PURE__ */ Object.create(null)) {
  {
    return;
  }
}
function isReferencedIdentifier(id, parent, parentStack) {
  {
    return false;
  }
}
function isInDestructureAssignment(parent, parentStack) {
  if (parent && (parent.type === "ObjectProperty" || parent.type === "ArrayPattern")) {
    let i = parentStack.length;
    while (i--) {
      const p2 = parentStack[i];
      if (p2.type === "AssignmentExpression") {
        return true;
      } else if (p2.type !== "ObjectProperty" && !p2.type.endsWith("Pattern")) {
        break;
      }
    }
  }
  return false;
}
function isInNewExpression(parentStack) {
  let i = parentStack.length;
  while (i--) {
    const p2 = parentStack[i];
    if (p2.type === "NewExpression") {
      return true;
    } else if (p2.type !== "MemberExpression") {
      break;
    }
  }
  return false;
}
function walkFunctionParams(node, onIdent) {
  for (const p2 of node.params) {
    for (const id of extractIdentifiers(p2)) {
      onIdent(id);
    }
  }
}
function walkBlockDeclarations(block, onIdent) {
  for (const stmt of block.body) {
    if (stmt.type === "VariableDeclaration") {
      if (stmt.declare)
        continue;
      for (const decl of stmt.declarations) {
        for (const id of extractIdentifiers(decl.id)) {
          onIdent(id);
        }
      }
    } else if (stmt.type === "FunctionDeclaration" || stmt.type === "ClassDeclaration") {
      if (stmt.declare || !stmt.id)
        continue;
      onIdent(stmt.id);
    } else if (stmt.type === "ForOfStatement" || stmt.type === "ForInStatement" || stmt.type === "ForStatement") {
      const variable = stmt.type === "ForStatement" ? stmt.init : stmt.left;
      if (variable && variable.type === "VariableDeclaration") {
        for (const decl of variable.declarations) {
          for (const id of extractIdentifiers(decl.id)) {
            onIdent(id);
          }
        }
      }
    }
  }
}
function extractIdentifiers(param, nodes = []) {
  switch (param.type) {
    case "Identifier":
      nodes.push(param);
      break;
    case "MemberExpression":
      let object = param;
      while (object.type === "MemberExpression") {
        object = object.object;
      }
      nodes.push(object);
      break;
    case "ObjectPattern":
      for (const prop of param.properties) {
        if (prop.type === "RestElement") {
          extractIdentifiers(prop.argument, nodes);
        } else {
          extractIdentifiers(prop.value, nodes);
        }
      }
      break;
    case "ArrayPattern":
      param.elements.forEach((element) => {
        if (element)
          extractIdentifiers(element, nodes);
      });
      break;
    case "RestElement":
      extractIdentifiers(param.argument, nodes);
      break;
    case "AssignmentPattern":
      extractIdentifiers(param.left, nodes);
      break;
  }
  return nodes;
}
function unwrapTSNode(node) {
  if (TS_NODE_TYPES.includes(node.type)) {
    return unwrapTSNode(node.expression);
  } else {
    return node;
  }
}
function isCoreComponent(tag) {
  switch (tag) {
    case "Teleport":
    case "teleport":
      return TELEPORT;
    case "Suspense":
    case "suspense":
      return SUSPENSE;
    case "KeepAlive":
    case "keep-alive":
      return KEEP_ALIVE;
    case "BaseTransition":
    case "base-transition":
      return BASE_TRANSITION;
  }
}
function advancePositionWithClone(pos, source, numberOfCharacters = source.length) {
  return advancePositionWithMutation(
    {
      offset: pos.offset,
      line: pos.line,
      column: pos.column
    },
    source,
    numberOfCharacters
  );
}
function advancePositionWithMutation(pos, source, numberOfCharacters = source.length) {
  let linesCount = 0;
  let lastNewLinePos = -1;
  for (let i = 0; i < numberOfCharacters; i++) {
    if (source.charCodeAt(i) === 10) {
      linesCount++;
      lastNewLinePos = i;
    }
  }
  pos.offset += numberOfCharacters;
  pos.line += linesCount;
  pos.column = lastNewLinePos === -1 ? pos.column + numberOfCharacters : numberOfCharacters - lastNewLinePos;
  return pos;
}
function assert(condition, msg) {
  if (!condition) {
    throw new Error(msg || `unexpected compiler condition`);
  }
}
function findDir(node, name2, allowEmpty = false) {
  for (let i = 0; i < node.props.length; i++) {
    const p2 = node.props[i];
    if (p2.type === 7 && (allowEmpty || p2.exp) && (isString(name2) ? p2.name === name2 : name2.test(p2.name))) {
      return p2;
    }
  }
}
function findProp(node, name2, dynamicOnly = false, allowEmpty = false) {
  for (let i = 0; i < node.props.length; i++) {
    const p2 = node.props[i];
    if (p2.type === 6) {
      if (dynamicOnly)
        continue;
      if (p2.name === name2 && (p2.value || allowEmpty)) {
        return p2;
      }
    } else if (p2.name === "bind" && (p2.exp || allowEmpty) && isStaticArgOf(p2.arg, name2)) {
      return p2;
    }
  }
}
function isStaticArgOf(arg, name2) {
  return !!(arg && isStaticExp(arg) && arg.content === name2);
}
function hasDynamicKeyVBind(node) {
  return node.props.some(
    (p2) => p2.type === 7 && p2.name === "bind" && (!p2.arg || // v-bind="obj"
    p2.arg.type !== 4 || // v-bind:[_ctx.foo]
    !p2.arg.isStatic)
    // v-bind:[foo]
  );
}
function isText$1(node) {
  return node.type === 5 || node.type === 2;
}
function isVSlot(p2) {
  return p2.type === 7 && p2.name === "slot";
}
function isTemplateNode(node) {
  return node.type === 1 && node.tagType === 3;
}
function isSlotOutlet(node) {
  return node.type === 1 && node.tagType === 2;
}
function getUnnormalizedProps(props, callPath = []) {
  if (props && !isString(props) && props.type === 14) {
    const callee = props.callee;
    if (!isString(callee) && propsHelperSet.has(callee)) {
      return getUnnormalizedProps(
        props.arguments[0],
        callPath.concat(props)
      );
    }
  }
  return [props, callPath];
}
function injectProp(node, prop, context2) {
  let propsWithInjection;
  let props = node.type === 13 ? node.props : node.arguments[2];
  let callPath = [];
  let parentCall;
  if (props && !isString(props) && props.type === 14) {
    const ret = getUnnormalizedProps(props);
    props = ret[0];
    callPath = ret[1];
    parentCall = callPath[callPath.length - 1];
  }
  if (props == null || isString(props)) {
    propsWithInjection = createObjectExpression([prop]);
  } else if (props.type === 14) {
    const first = props.arguments[0];
    if (!isString(first) && first.type === 15) {
      if (!hasProp(prop, first)) {
        first.properties.unshift(prop);
      }
    } else {
      if (props.callee === TO_HANDLERS) {
        propsWithInjection = createCallExpression(context2.helper(MERGE_PROPS), [
          createObjectExpression([prop]),
          props
        ]);
      } else {
        props.arguments.unshift(createObjectExpression([prop]));
      }
    }
    !propsWithInjection && (propsWithInjection = props);
  } else if (props.type === 15) {
    if (!hasProp(prop, props)) {
      props.properties.unshift(prop);
    }
    propsWithInjection = props;
  } else {
    propsWithInjection = createCallExpression(context2.helper(MERGE_PROPS), [
      createObjectExpression([prop]),
      props
    ]);
    if (parentCall && parentCall.callee === GUARD_REACTIVE_PROPS) {
      parentCall = callPath[callPath.length - 2];
    }
  }
  if (node.type === 13) {
    if (parentCall) {
      parentCall.arguments[0] = propsWithInjection;
    } else {
      node.props = propsWithInjection;
    }
  } else {
    if (parentCall) {
      parentCall.arguments[0] = propsWithInjection;
    } else {
      node.arguments[2] = propsWithInjection;
    }
  }
}
function hasProp(prop, props) {
  let result2 = false;
  if (prop.key.type === 4) {
    const propKeyName = prop.key.content;
    result2 = props.properties.some(
      (p2) => p2.key.type === 4 && p2.key.content === propKeyName
    );
  }
  return result2;
}
function toValidAssetId(name2, type2) {
  return `_${type2}_${name2.replace(/[^\w]/g, (searchValue, replaceValue) => {
    return searchValue === "-" ? "_" : name2.charCodeAt(replaceValue).toString();
  })}`;
}
function hasScopeRef(node, ids) {
  if (!node || Object.keys(ids).length === 0) {
    return false;
  }
  switch (node.type) {
    case 1:
      for (let i = 0; i < node.props.length; i++) {
        const p2 = node.props[i];
        if (p2.type === 7 && (hasScopeRef(p2.arg, ids) || hasScopeRef(p2.exp, ids))) {
          return true;
        }
      }
      return node.children.some((c) => hasScopeRef(c, ids));
    case 11:
      if (hasScopeRef(node.source, ids)) {
        return true;
      }
      return node.children.some((c) => hasScopeRef(c, ids));
    case 9:
      return node.branches.some((b) => hasScopeRef(b, ids));
    case 10:
      if (hasScopeRef(node.condition, ids)) {
        return true;
      }
      return node.children.some((c) => hasScopeRef(c, ids));
    case 4:
      return !node.isStatic && isSimpleIdentifier(node.content) && !!ids[node.content];
    case 8:
      return node.children.some((c) => isObject(c) && hasScopeRef(c, ids));
    case 5:
    case 12:
      return hasScopeRef(node.content, ids);
    case 2:
    case 3:
      return false;
    default:
      if (true)
        ;
      return false;
  }
}
function getMemoedVNodeCall(node) {
  if (node.type === 14 && node.callee === WITH_MEMO) {
    return node.arguments[1].returns;
  } else {
    return node;
  }
}
function parseForExpression(input) {
  const loc = input.loc;
  const exp = input.content;
  const inMatch = exp.match(forAliasRE);
  if (!inMatch)
    return;
  const [, LHS, RHS] = inMatch;
  const createAliasExpression = (content, offset2, asParam = false) => {
    const start = loc.start.offset + offset2;
    const end = start + content.length;
    return createExp(
      content,
      false,
      getLoc(start, end),
      0,
      asParam ? 1 : 0
      /* Normal */
    );
  };
  const result2 = {
    source: createAliasExpression(RHS.trim(), exp.indexOf(RHS, LHS.length)),
    value: void 0,
    key: void 0,
    index: void 0,
    finalized: false
  };
  let valueContent = LHS.trim().replace(stripParensRE, "").trim();
  const trimmedOffset = LHS.indexOf(valueContent);
  const iteratorMatch = valueContent.match(forIteratorRE);
  if (iteratorMatch) {
    valueContent = valueContent.replace(forIteratorRE, "").trim();
    const keyContent = iteratorMatch[1].trim();
    let keyOffset;
    if (keyContent) {
      keyOffset = exp.indexOf(keyContent, trimmedOffset + valueContent.length);
      result2.key = createAliasExpression(keyContent, keyOffset, true);
    }
    if (iteratorMatch[2]) {
      const indexContent = iteratorMatch[2].trim();
      if (indexContent) {
        result2.index = createAliasExpression(
          indexContent,
          exp.indexOf(
            indexContent,
            result2.key ? keyOffset + keyContent.length : trimmedOffset + valueContent.length
          ),
          true
        );
      }
    }
  }
  if (valueContent) {
    result2.value = createAliasExpression(valueContent, trimmedOffset, true);
  }
  return result2;
}
function getSlice(start, end) {
  return currentInput.slice(start, end);
}
function endOpenTag(end) {
  if (tokenizer.inSFCRoot) {
    currentOpenTag.innerLoc = getLoc(end + 1, end + 1);
  }
  addNode(currentOpenTag);
  const { tag, ns } = currentOpenTag;
  if (ns === 0 && currentOptions.isPreTag(tag)) {
    inPre++;
  }
  if (currentOptions.isVoidTag(tag)) {
    onCloseTag(currentOpenTag, end);
  } else {
    stack.unshift(currentOpenTag);
    if (ns === 1 || ns === 2) {
      tokenizer.inXML = true;
    }
  }
  currentOpenTag = null;
}
function onText(content, start, end) {
  var _a;
  {
    const tag = (_a = stack[0]) == null ? void 0 : _a.tag;
    if (tag !== "script" && tag !== "style" && content.includes("&")) {
      content = currentOptions.decodeEntities(content, false);
    }
  }
  const parent = stack[0] || currentRoot;
  const lastNode = parent.children[parent.children.length - 1];
  if ((lastNode == null ? void 0 : lastNode.type) === 2) {
    lastNode.content += content;
    setLocEnd(lastNode.loc, end);
  } else {
    parent.children.push({
      type: 2,
      content,
      loc: getLoc(start, end)
    });
  }
}
function onCloseTag(el, end, isImplied = false) {
  if (isImplied) {
    setLocEnd(el.loc, backTrack(end, 60));
  } else {
    setLocEnd(el.loc, end + 1);
  }
  if (tokenizer.inSFCRoot) {
    if (el.children.length) {
      el.innerLoc.end = extend({}, el.children[el.children.length - 1].loc.end);
    } else {
      el.innerLoc.end = extend({}, el.innerLoc.start);
    }
    el.innerLoc.source = getSlice(
      el.innerLoc.start.offset,
      el.innerLoc.end.offset
    );
  }
  const { tag, ns } = el;
  if (!inVPre) {
    if (tag === "slot") {
      el.tagType = 2;
    } else if (isFragmentTemplate(el)) {
      el.tagType = 3;
    } else if (isComponent(el)) {
      el.tagType = 1;
    }
  }
  if (!tokenizer.inRCDATA) {
    el.children = condenseWhitespace(el.children, el.tag);
  }
  if (ns === 0 && currentOptions.isPreTag(tag)) {
    inPre--;
  }
  if (currentVPreBoundary === el) {
    inVPre = tokenizer.inVPre = false;
    currentVPreBoundary = null;
  }
  if (tokenizer.inXML && (stack[0] ? stack[0].ns : currentOptions.ns) === 0) {
    tokenizer.inXML = false;
  }
  {
    const props = el.props;
    if (isCompatEnabled(
      "COMPILER_V_IF_V_FOR_PRECEDENCE",
      currentOptions
    )) {
      let hasIf = false;
      let hasFor = false;
      for (let i = 0; i < props.length; i++) {
        const p2 = props[i];
        if (p2.type === 7) {
          if (p2.name === "if") {
            hasIf = true;
          } else if (p2.name === "for") {
            hasFor = true;
          }
        }
        if (hasIf && hasFor) {
          warnDeprecation(
            "COMPILER_V_IF_V_FOR_PRECEDENCE",
            currentOptions,
            el.loc
          );
          break;
        }
      }
    }
    if (!tokenizer.inSFCRoot && isCompatEnabled(
      "COMPILER_NATIVE_TEMPLATE",
      currentOptions
    ) && el.tag === "template" && !isFragmentTemplate(el)) {
      warnDeprecation(
        "COMPILER_NATIVE_TEMPLATE",
        currentOptions,
        el.loc
      );
      const parent = stack[0] || currentRoot;
      const index2 = parent.children.indexOf(el);
      parent.children.splice(index2, 1, ...el.children);
    }
    const inlineTemplateProp = props.find(
      (p2) => p2.type === 6 && p2.name === "inline-template"
    );
    if (inlineTemplateProp && checkCompatEnabled(
      "COMPILER_INLINE_TEMPLATE",
      currentOptions,
      inlineTemplateProp.loc
    ) && el.children.length) {
      inlineTemplateProp.value = {
        type: 2,
        content: getSlice(
          el.children[0].loc.start.offset,
          el.children[el.children.length - 1].loc.end.offset
        ),
        loc: inlineTemplateProp.loc
      };
    }
  }
}
function backTrack(index2, c) {
  let i = index2;
  while (currentInput.charCodeAt(i) !== c && i >= 0)
    i--;
  return i;
}
function isFragmentTemplate({ tag, props }) {
  if (tag === "template") {
    for (let i = 0; i < props.length; i++) {
      if (props[i].type === 7 && specialTemplateDir.has(props[i].name)) {
        return true;
      }
    }
  }
  return false;
}
function isComponent({ tag, props }) {
  var _a;
  if (currentOptions.isCustomElement(tag)) {
    return false;
  }
  if (tag === "component" || isUpperCase(tag.charCodeAt(0)) || isCoreComponent(tag) || ((_a = currentOptions.isBuiltInComponent) == null ? void 0 : _a.call(currentOptions, tag)) || currentOptions.isNativeTag && !currentOptions.isNativeTag(tag)) {
    return true;
  }
  for (let i = 0; i < props.length; i++) {
    const p2 = props[i];
    if (p2.type === 6) {
      if (p2.name === "is" && p2.value) {
        if (p2.value.content.startsWith("vue:")) {
          return true;
        } else if (checkCompatEnabled(
          "COMPILER_IS_ON_ELEMENT",
          currentOptions,
          p2.loc
        )) {
          return true;
        }
      }
    } else if (
      // :is on plain element - only treat as component in compat mode
      p2.name === "bind" && isStaticArgOf(p2.arg, "is") && checkCompatEnabled(
        "COMPILER_IS_ON_ELEMENT",
        currentOptions,
        p2.loc
      )
    ) {
      return true;
    }
  }
  return false;
}
function isUpperCase(c) {
  return c > 64 && c < 91;
}
function condenseWhitespace(nodes, tag) {
  var _a, _b;
  const shouldCondense = currentOptions.whitespace !== "preserve";
  let removedWhitespace = false;
  for (let i = 0; i < nodes.length; i++) {
    const node = nodes[i];
    if (node.type === 2) {
      if (!inPre) {
        if (isAllWhitespace(node.content)) {
          const prev = (_a = nodes[i - 1]) == null ? void 0 : _a.type;
          const next = (_b = nodes[i + 1]) == null ? void 0 : _b.type;
          if (!prev || !next || shouldCondense && (prev === 3 && (next === 3 || next === 1) || prev === 1 && (next === 3 || next === 1 && hasNewlineChar(node.content)))) {
            removedWhitespace = true;
            nodes[i] = null;
          } else {
            node.content = " ";
          }
        } else if (shouldCondense) {
          node.content = condense(node.content);
        }
      } else {
        node.content = node.content.replace(windowsNewlineRE, "\n");
      }
    }
  }
  if (inPre && tag && currentOptions.isPreTag(tag)) {
    const first = nodes[0];
    if (first && first.type === 2) {
      first.content = first.content.replace(/^\r?\n/, "");
    }
  }
  return removedWhitespace ? nodes.filter(Boolean) : nodes;
}
function isAllWhitespace(str) {
  for (let i = 0; i < str.length; i++) {
    if (!isWhitespace(str.charCodeAt(i))) {
      return false;
    }
  }
  return true;
}
function hasNewlineChar(str) {
  for (let i = 0; i < str.length; i++) {
    const c = str.charCodeAt(i);
    if (c === 10 || c === 13) {
      return true;
    }
  }
  return false;
}
function condense(str) {
  let ret = "";
  let prevCharIsWhitespace = false;
  for (let i = 0; i < str.length; i++) {
    if (isWhitespace(str.charCodeAt(i))) {
      if (!prevCharIsWhitespace) {
        ret += " ";
        prevCharIsWhitespace = true;
      }
    } else {
      ret += str[i];
      prevCharIsWhitespace = false;
    }
  }
  return ret;
}
function addNode(node) {
  (stack[0] || currentRoot).children.push(node);
}
function getLoc(start, end) {
  return {
    start: tokenizer.getPos(start),
    // @ts-expect-error allow late attachment
    end: end == null ? end : tokenizer.getPos(end),
    // @ts-expect-error allow late attachment
    source: end == null ? end : getSlice(start, end)
  };
}
function setLocEnd(loc, end) {
  loc.end = tokenizer.getPos(end);
  loc.source = getSlice(loc.start.offset, end);
}
function dirToAttr(dir) {
  const attr = {
    type: 6,
    name: dir.rawName,
    nameLoc: getLoc(
      dir.loc.start.offset,
      dir.loc.start.offset + dir.rawName.length
    ),
    value: void 0,
    loc: dir.loc
  };
  if (dir.exp) {
    const loc = dir.exp.loc;
    if (loc.end.offset < dir.loc.end.offset) {
      loc.start.offset--;
      loc.start.column--;
      loc.end.offset++;
      loc.end.column++;
    }
    attr.value = {
      type: 2,
      content: dir.exp.content,
      loc
    };
  }
  return attr;
}
function createExp(content, isStatic = false, loc, constType = 0, parseMode = 0) {
  const exp = createSimpleExpression(content, isStatic, loc, constType);
  return exp;
}
function emitError(code, index2, message) {
  currentOptions.onError(
    createCompilerError(code, getLoc(index2, index2), void 0, message)
  );
}
function reset() {
  tokenizer.reset();
  currentOpenTag = null;
  currentProp = null;
  currentAttrValue = "";
  currentAttrStartIndex = -1;
  currentAttrEndIndex = -1;
  stack.length = 0;
}
function baseParse(input, options2) {
  reset();
  currentInput = input;
  currentOptions = extend({}, defaultParserOptions);
  if (options2) {
    let key;
    for (key in options2) {
      if (options2[key] != null) {
        currentOptions[key] = options2[key];
      }
    }
  }
  if (true) {
    if (!currentOptions.decodeEntities) {
      throw new Error(
        `[@vue/compiler-core] decodeEntities option is required in browser builds.`
      );
    }
  }
  tokenizer.mode = currentOptions.parseMode === "html" ? 1 : currentOptions.parseMode === "sfc" ? 2 : 0;
  tokenizer.inXML = currentOptions.ns === 1 || currentOptions.ns === 2;
  const delimiters = options2 == null ? void 0 : options2.delimiters;
  if (delimiters) {
    tokenizer.delimiterOpen = toCharCodes(delimiters[0]);
    tokenizer.delimiterClose = toCharCodes(delimiters[1]);
  }
  const root = currentRoot = createRoot([], input);
  tokenizer.parse(currentInput);
  root.loc = getLoc(0, input.length);
  root.children = condenseWhitespace(root.children);
  currentRoot = null;
  return root;
}
function hoistStatic(root, context2) {
  walk(
    root,
    context2,
    // Root node is unfortunately non-hoistable due to potential parent
    // fallthrough attributes.
    isSingleElementRoot(root, root.children[0])
  );
}
function isSingleElementRoot(root, child) {
  const { children } = root;
  return children.length === 1 && child.type === 1 && !isSlotOutlet(child);
}
function walk(node, context2, doNotHoistNode = false) {
  const { children } = node;
  const originalCount = children.length;
  let hoistedCount = 0;
  for (let i = 0; i < children.length; i++) {
    const child = children[i];
    if (child.type === 1 && child.tagType === 0) {
      const constantType = doNotHoistNode ? 0 : getConstantType(child, context2);
      if (constantType > 0) {
        if (constantType >= 2) {
          child.codegenNode.patchFlag = -1 + (true ? ` /* HOISTED */` : ``);
          child.codegenNode = context2.hoist(child.codegenNode);
          hoistedCount++;
          continue;
        }
      } else {
        const codegenNode = child.codegenNode;
        if (codegenNode.type === 13) {
          const flag = getPatchFlag(codegenNode);
          if ((!flag || flag === 512 || flag === 1) && getGeneratedPropsConstantType(child, context2) >= 2) {
            const props = getNodeProps(child);
            if (props) {
              codegenNode.props = context2.hoist(props);
            }
          }
          if (codegenNode.dynamicProps) {
            codegenNode.dynamicProps = context2.hoist(codegenNode.dynamicProps);
          }
        }
      }
    }
    if (child.type === 1) {
      const isComponent2 = child.tagType === 1;
      if (isComponent2) {
        context2.scopes.vSlot++;
      }
      walk(child, context2);
      if (isComponent2) {
        context2.scopes.vSlot--;
      }
    } else if (child.type === 11) {
      walk(child, context2, child.children.length === 1);
    } else if (child.type === 9) {
      for (let i2 = 0; i2 < child.branches.length; i2++) {
        walk(
          child.branches[i2],
          context2,
          child.branches[i2].children.length === 1
        );
      }
    }
  }
  if (hoistedCount && context2.transformHoist) {
    context2.transformHoist(children, context2, node);
  }
  if (hoistedCount && hoistedCount === originalCount && node.type === 1 && node.tagType === 0 && node.codegenNode && node.codegenNode.type === 13 && isArray(node.codegenNode.children)) {
    const hoisted = context2.hoist(
      createArrayExpression(node.codegenNode.children)
    );
    if (context2.hmr) {
      hoisted.content = `[...${hoisted.content}]`;
    }
    node.codegenNode.children = hoisted;
  }
}
function getConstantType(node, context2) {
  const { constantCache } = context2;
  switch (node.type) {
    case 1:
      if (node.tagType !== 0) {
        return 0;
      }
      const cached = constantCache.get(node);
      if (cached !== void 0) {
        return cached;
      }
      const codegenNode = node.codegenNode;
      if (codegenNode.type !== 13) {
        return 0;
      }
      if (codegenNode.isBlock && node.tag !== "svg" && node.tag !== "foreignObject") {
        return 0;
      }
      const flag = getPatchFlag(codegenNode);
      if (!flag) {
        let returnType2 = 3;
        const generatedPropsType = getGeneratedPropsConstantType(node, context2);
        if (generatedPropsType === 0) {
          constantCache.set(node, 0);
          return 0;
        }
        if (generatedPropsType < returnType2) {
          returnType2 = generatedPropsType;
        }
        for (let i = 0; i < node.children.length; i++) {
          const childType = getConstantType(node.children[i], context2);
          if (childType === 0) {
            constantCache.set(node, 0);
            return 0;
          }
          if (childType < returnType2) {
            returnType2 = childType;
          }
        }
        if (returnType2 > 1) {
          for (let i = 0; i < node.props.length; i++) {
            const p2 = node.props[i];
            if (p2.type === 7 && p2.name === "bind" && p2.exp) {
              const expType = getConstantType(p2.exp, context2);
              if (expType === 0) {
                constantCache.set(node, 0);
                return 0;
              }
              if (expType < returnType2) {
                returnType2 = expType;
              }
            }
          }
        }
        if (codegenNode.isBlock) {
          for (let i = 0; i < node.props.length; i++) {
            const p2 = node.props[i];
            if (p2.type === 7) {
              constantCache.set(node, 0);
              return 0;
            }
          }
          context2.removeHelper(OPEN_BLOCK);
          context2.removeHelper(
            getVNodeBlockHelper(context2.inSSR, codegenNode.isComponent)
          );
          codegenNode.isBlock = false;
          context2.helper(getVNodeHelper(context2.inSSR, codegenNode.isComponent));
        }
        constantCache.set(node, returnType2);
        return returnType2;
      } else {
        constantCache.set(node, 0);
        return 0;
      }
    case 2:
    case 3:
      return 3;
    case 9:
    case 11:
    case 10:
      return 0;
    case 5:
    case 12:
      return getConstantType(node.content, context2);
    case 4:
      return node.constType;
    case 8:
      let returnType = 3;
      for (let i = 0; i < node.children.length; i++) {
        const child = node.children[i];
        if (isString(child) || isSymbol(child)) {
          continue;
        }
        const childType = getConstantType(child, context2);
        if (childType === 0) {
          return 0;
        } else if (childType < returnType) {
          returnType = childType;
        }
      }
      return returnType;
    default:
      if (true)
        ;
      return 0;
  }
}
function getConstantTypeOfHelperCall(value2, context2) {
  if (value2.type === 14 && !isString(value2.callee) && allowHoistedHelperSet.has(value2.callee)) {
    const arg = value2.arguments[0];
    if (arg.type === 4) {
      return getConstantType(arg, context2);
    } else if (arg.type === 14) {
      return getConstantTypeOfHelperCall(arg, context2);
    }
  }
  return 0;
}
function getGeneratedPropsConstantType(node, context2) {
  let returnType = 3;
  const props = getNodeProps(node);
  if (props && props.type === 15) {
    const { properties } = props;
    for (let i = 0; i < properties.length; i++) {
      const { key, value: value2 } = properties[i];
      const keyType = getConstantType(key, context2);
      if (keyType === 0) {
        return keyType;
      }
      if (keyType < returnType) {
        returnType = keyType;
      }
      let valueType;
      if (value2.type === 4) {
        valueType = getConstantType(value2, context2);
      } else if (value2.type === 14) {
        valueType = getConstantTypeOfHelperCall(value2, context2);
      } else {
        valueType = 0;
      }
      if (valueType === 0) {
        return valueType;
      }
      if (valueType < returnType) {
        returnType = valueType;
      }
    }
  }
  return returnType;
}
function getNodeProps(node) {
  const codegenNode = node.codegenNode;
  if (codegenNode.type === 13) {
    return codegenNode.props;
  }
}
function getPatchFlag(node) {
  const flag = node.patchFlag;
  return flag ? parseInt(flag, 10) : void 0;
}
function createTransformContext(root, {
  filename = "",
  prefixIdentifiers = false,
  hoistStatic: hoistStatic2 = false,
  hmr = false,
  cacheHandlers = false,
  nodeTransforms = [],
  directiveTransforms = {},
  transformHoist = null,
  isBuiltInComponent = NOOP,
  isCustomElement = NOOP,
  expressionPlugins = [],
  scopeId = null,
  slotted = true,
  ssr = false,
  inSSR = false,
  ssrCssVars = ``,
  bindingMetadata = EMPTY_OBJ,
  inline = false,
  isTS = false,
  onError = defaultOnError,
  onWarn = defaultOnWarn,
  compatConfig
}) {
  const nameMatch = filename.replace(/\?.*$/, "").match(/([^/\\]+)\.\w+$/);
  const context2 = {
    // options
    filename,
    selfName: nameMatch && capitalize(camelize(nameMatch[1])),
    prefixIdentifiers,
    hoistStatic: hoistStatic2,
    hmr,
    cacheHandlers,
    nodeTransforms,
    directiveTransforms,
    transformHoist,
    isBuiltInComponent,
    isCustomElement,
    expressionPlugins,
    scopeId,
    slotted,
    ssr,
    inSSR,
    ssrCssVars,
    bindingMetadata,
    inline,
    isTS,
    onError,
    onWarn,
    compatConfig,
    // state
    root,
    helpers: /* @__PURE__ */ new Map(),
    components: /* @__PURE__ */ new Set(),
    directives: /* @__PURE__ */ new Set(),
    hoists: [],
    imports: [],
    constantCache: /* @__PURE__ */ new WeakMap(),
    temps: 0,
    cached: 0,
    identifiers: /* @__PURE__ */ Object.create(null),
    scopes: {
      vFor: 0,
      vSlot: 0,
      vPre: 0,
      vOnce: 0
    },
    parent: null,
    currentNode: root,
    childIndex: 0,
    inVOnce: false,
    // methods
    helper(name2) {
      const count = context2.helpers.get(name2) || 0;
      context2.helpers.set(name2, count + 1);
      return name2;
    },
    removeHelper(name2) {
      const count = context2.helpers.get(name2);
      if (count) {
        const currentCount = count - 1;
        if (!currentCount) {
          context2.helpers.delete(name2);
        } else {
          context2.helpers.set(name2, currentCount);
        }
      }
    },
    helperString(name2) {
      return `_${helperNameMap[context2.helper(name2)]}`;
    },
    replaceNode(node) {
      if (true) {
        if (!context2.currentNode) {
          throw new Error(`Node being replaced is already removed.`);
        }
        if (!context2.parent) {
          throw new Error(`Cannot replace root node.`);
        }
      }
      context2.parent.children[context2.childIndex] = context2.currentNode = node;
    },
    removeNode(node) {
      if (!context2.parent) {
        throw new Error(`Cannot remove root node.`);
      }
      const list = context2.parent.children;
      const removalIndex = node ? list.indexOf(node) : context2.currentNode ? context2.childIndex : -1;
      if (removalIndex < 0) {
        throw new Error(`node being removed is not a child of current parent`);
      }
      if (!node || node === context2.currentNode) {
        context2.currentNode = null;
        context2.onNodeRemoved();
      } else {
        if (context2.childIndex > removalIndex) {
          context2.childIndex--;
          context2.onNodeRemoved();
        }
      }
      context2.parent.children.splice(removalIndex, 1);
    },
    onNodeRemoved: NOOP,
    addIdentifiers(exp) {
    },
    removeIdentifiers(exp) {
    },
    hoist(exp) {
      if (isString(exp))
        exp = createSimpleExpression(exp);
      context2.hoists.push(exp);
      const identifier = createSimpleExpression(
        `_hoisted_${context2.hoists.length}`,
        false,
        exp.loc,
        2
      );
      identifier.hoisted = exp;
      return identifier;
    },
    cache(exp, isVNode = false) {
      return createCacheExpression(context2.cached++, exp, isVNode);
    }
  };
  {
    context2.filters = /* @__PURE__ */ new Set();
  }
  return context2;
}
function transform(root, options2) {
  const context2 = createTransformContext(root, options2);
  traverseNode(root, context2);
  if (options2.hoistStatic) {
    hoistStatic(root, context2);
  }
  if (!options2.ssr) {
    createRootCodegen(root, context2);
  }
  root.helpers = /* @__PURE__ */ new Set([...context2.helpers.keys()]);
  root.components = [...context2.components];
  root.directives = [...context2.directives];
  root.imports = context2.imports;
  root.hoists = context2.hoists;
  root.temps = context2.temps;
  root.cached = context2.cached;
  root.transformed = true;
  {
    root.filters = [...context2.filters];
  }
}
function createRootCodegen(root, context2) {
  const { helper } = context2;
  const { children } = root;
  if (children.length === 1) {
    const child = children[0];
    if (isSingleElementRoot(root, child) && child.codegenNode) {
      const codegenNode = child.codegenNode;
      if (codegenNode.type === 13) {
        convertToBlock(codegenNode, context2);
      }
      root.codegenNode = codegenNode;
    } else {
      root.codegenNode = child;
    }
  } else if (children.length > 1) {
    let patchFlag = 64;
    let patchFlagText = PatchFlagNames[64];
    if (children.filter((c) => c.type !== 3).length === 1) {
      patchFlag |= 2048;
      patchFlagText += `, ${PatchFlagNames[2048]}`;
    }
    root.codegenNode = createVNodeCall(
      context2,
      helper(FRAGMENT),
      void 0,
      root.children,
      patchFlag + (true ? ` /* ${patchFlagText} */` : ``),
      void 0,
      void 0,
      true,
      void 0,
      false
    );
  } else
    ;
}
function traverseChildren(parent, context2) {
  let i = 0;
  const nodeRemoved = () => {
    i--;
  };
  for (; i < parent.children.length; i++) {
    const child = parent.children[i];
    if (isString(child))
      continue;
    context2.parent = parent;
    context2.childIndex = i;
    context2.onNodeRemoved = nodeRemoved;
    traverseNode(child, context2);
  }
}
function traverseNode(node, context2) {
  context2.currentNode = node;
  const { nodeTransforms } = context2;
  const exitFns = [];
  for (let i2 = 0; i2 < nodeTransforms.length; i2++) {
    const onExit = nodeTransforms[i2](node, context2);
    if (onExit) {
      if (isArray(onExit)) {
        exitFns.push(...onExit);
      } else {
        exitFns.push(onExit);
      }
    }
    if (!context2.currentNode) {
      return;
    } else {
      node = context2.currentNode;
    }
  }
  switch (node.type) {
    case 3:
      if (!context2.ssr) {
        context2.helper(CREATE_COMMENT);
      }
      break;
    case 5:
      if (!context2.ssr) {
        context2.helper(TO_DISPLAY_STRING);
      }
      break;
    case 9:
      for (let i2 = 0; i2 < node.branches.length; i2++) {
        traverseNode(node.branches[i2], context2);
      }
      break;
    case 10:
    case 11:
    case 1:
    case 0:
      traverseChildren(node, context2);
      break;
  }
  context2.currentNode = node;
  let i = exitFns.length;
  while (i--) {
    exitFns[i]();
  }
}
function createStructuralDirectiveTransform(name2, fn) {
  const matches = isString(name2) ? (n) => n === name2 : (n) => name2.test(n);
  return (node, context2) => {
    if (node.type === 1) {
      const { props } = node;
      if (node.tagType === 3 && props.some(isVSlot)) {
        return;
      }
      const exitFns = [];
      for (let i = 0; i < props.length; i++) {
        const prop = props[i];
        if (prop.type === 7 && matches(prop.name)) {
          props.splice(i, 1);
          i--;
          const onExit = fn(node, prop, context2);
          if (onExit)
            exitFns.push(onExit);
        }
      }
      return exitFns;
    }
  };
}
function createCodegenContext(ast, {
  mode = "function",
  prefixIdentifiers = mode === "module",
  sourceMap = false,
  filename = `template.vue.html`,
  scopeId = null,
  optimizeImports = false,
  runtimeGlobalName = `Vue`,
  runtimeModuleName = `vue`,
  ssrRuntimeModuleName = "vue/server-renderer",
  ssr = false,
  isTS = false,
  inSSR = false
}) {
  const context2 = {
    mode,
    prefixIdentifiers,
    sourceMap,
    filename,
    scopeId,
    optimizeImports,
    runtimeGlobalName,
    runtimeModuleName,
    ssrRuntimeModuleName,
    ssr,
    isTS,
    inSSR,
    source: ast.source,
    code: ``,
    column: 1,
    line: 1,
    offset: 0,
    indentLevel: 0,
    pure: false,
    map: void 0,
    helper(key) {
      return `_${helperNameMap[key]}`;
    },
    push(code, newlineIndex = -2, node) {
      context2.code += code;
    },
    indent() {
      newline(++context2.indentLevel);
    },
    deindent(withoutNewLine = false) {
      if (withoutNewLine) {
        --context2.indentLevel;
      } else {
        newline(--context2.indentLevel);
      }
    },
    newline() {
      newline(context2.indentLevel);
    }
  };
  function newline(n) {
    context2.push(
      "\n" + `  `.repeat(n),
      0
      /* Start */
    );
  }
  return context2;
}
function generate(ast, options2 = {}) {
  const context2 = createCodegenContext(ast, options2);
  if (options2.onContextCreated)
    options2.onContextCreated(context2);
  const {
    mode,
    push,
    prefixIdentifiers,
    indent,
    deindent,
    newline,
    scopeId,
    ssr
  } = context2;
  const helpers = Array.from(ast.helpers);
  const hasHelpers = helpers.length > 0;
  const useWithBlock = !prefixIdentifiers && mode !== "module";
  const isSetupInlined = false;
  const preambleContext = isSetupInlined ? createCodegenContext(ast, options2) : context2;
  {
    genFunctionPreamble(ast, preambleContext);
  }
  const functionName = ssr ? `ssrRender` : `render`;
  const args = ssr ? ["_ctx", "_push", "_parent", "_attrs"] : ["_ctx", "_cache"];
  const signature = args.join(", ");
  {
    push(`function ${functionName}(${signature}) {`);
  }
  indent();
  if (useWithBlock) {
    push(`with (_ctx) {`);
    indent();
    if (hasHelpers) {
      push(
        `const { ${helpers.map(aliasHelper).join(", ")} } = _Vue
`,
        -1
        /* End */
      );
      newline();
    }
  }
  if (ast.components.length) {
    genAssets(ast.components, "component", context2);
    if (ast.directives.length || ast.temps > 0) {
      newline();
    }
  }
  if (ast.directives.length) {
    genAssets(ast.directives, "directive", context2);
    if (ast.temps > 0) {
      newline();
    }
  }
  if (ast.filters && ast.filters.length) {
    newline();
    genAssets(ast.filters, "filter", context2);
    newline();
  }
  if (ast.temps > 0) {
    push(`let `);
    for (let i = 0; i < ast.temps; i++) {
      push(`${i > 0 ? `, ` : ``}_temp${i}`);
    }
  }
  if (ast.components.length || ast.directives.length || ast.temps) {
    push(
      `
`,
      0
      /* Start */
    );
    newline();
  }
  if (!ssr) {
    push(`return `);
  }
  if (ast.codegenNode) {
    genNode(ast.codegenNode, context2);
  } else {
    push(`null`);
  }
  if (useWithBlock) {
    deindent();
    push(`}`);
  }
  deindent();
  push(`}`);
  return {
    ast,
    code: context2.code,
    preamble: isSetupInlined ? preambleContext.code : ``,
    map: context2.map ? context2.map.toJSON() : void 0
  };
}
function genFunctionPreamble(ast, context2) {
  const {
    ssr,
    prefixIdentifiers,
    push,
    newline,
    runtimeModuleName,
    runtimeGlobalName,
    ssrRuntimeModuleName
  } = context2;
  const VueBinding = runtimeGlobalName;
  const helpers = Array.from(ast.helpers);
  if (helpers.length > 0) {
    {
      push(
        `const _Vue = ${VueBinding}
`,
        -1
        /* End */
      );
      if (ast.hoists.length) {
        const staticHelpers = [
          CREATE_VNODE,
          CREATE_ELEMENT_VNODE,
          CREATE_COMMENT,
          CREATE_TEXT,
          CREATE_STATIC
        ].filter((helper) => helpers.includes(helper)).map(aliasHelper).join(", ");
        push(
          `const { ${staticHelpers} } = _Vue
`,
          -1
          /* End */
        );
      }
    }
  }
  genHoists(ast.hoists, context2);
  newline();
  push(`return `);
}
function genAssets(assets, type2, { helper, push, newline, isTS }) {
  const resolver = helper(
    type2 === "filter" ? RESOLVE_FILTER : type2 === "component" ? RESOLVE_COMPONENT : RESOLVE_DIRECTIVE
  );
  for (let i = 0; i < assets.length; i++) {
    let id = assets[i];
    const maybeSelfReference = id.endsWith("__self");
    if (maybeSelfReference) {
      id = id.slice(0, -6);
    }
    push(
      `const ${toValidAssetId(id, type2)} = ${resolver}(${JSON.stringify(id)}${maybeSelfReference ? `, true` : ``})${isTS ? `!` : ``}`
    );
    if (i < assets.length - 1) {
      newline();
    }
  }
}
function genHoists(hoists, context2) {
  if (!hoists.length) {
    return;
  }
  context2.pure = true;
  const { push, newline, helper, scopeId, mode } = context2;
  newline();
  for (let i = 0; i < hoists.length; i++) {
    const exp = hoists[i];
    if (exp) {
      push(
        `const _hoisted_${i + 1} = ${``}`
      );
      genNode(exp, context2);
      newline();
    }
  }
  context2.pure = false;
}
function isText(n) {
  return isString(n) || n.type === 4 || n.type === 2 || n.type === 5 || n.type === 8;
}
function genNodeListAsArray(nodes, context2) {
  const multilines = nodes.length > 3 || nodes.some((n) => isArray(n) || !isText(n));
  context2.push(`[`);
  multilines && context2.indent();
  genNodeList(nodes, context2, multilines);
  multilines && context2.deindent();
  context2.push(`]`);
}
function genNodeList(nodes, context2, multilines = false, comma = true) {
  const { push, newline } = context2;
  for (let i = 0; i < nodes.length; i++) {
    const node = nodes[i];
    if (isString(node)) {
      push(
        node,
        -3
        /* Unknown */
      );
    } else if (isArray(node)) {
      genNodeListAsArray(node, context2);
    } else {
      genNode(node, context2);
    }
    if (i < nodes.length - 1) {
      if (multilines) {
        comma && push(",");
        newline();
      } else {
        comma && push(", ");
      }
    }
  }
}
function genNode(node, context2) {
  if (isString(node)) {
    context2.push(
      node,
      -3
      /* Unknown */
    );
    return;
  }
  if (isSymbol(node)) {
    context2.push(context2.helper(node));
    return;
  }
  switch (node.type) {
    case 1:
    case 9:
    case 11:
      assert(
        node.codegenNode != null,
        `Codegen node is missing for element/if/for node. Apply appropriate transforms first.`
      );
      genNode(node.codegenNode, context2);
      break;
    case 2:
      genText(node, context2);
      break;
    case 4:
      genExpression(node, context2);
      break;
    case 5:
      genInterpolation(node, context2);
      break;
    case 12:
      genNode(node.codegenNode, context2);
      break;
    case 8:
      genCompoundExpression(node, context2);
      break;
    case 3:
      genComment(node, context2);
      break;
    case 13:
      genVNodeCall(node, context2);
      break;
    case 14:
      genCallExpression(node, context2);
      break;
    case 15:
      genObjectExpression(node, context2);
      break;
    case 17:
      genArrayExpression(node, context2);
      break;
    case 18:
      genFunctionExpression(node, context2);
      break;
    case 19:
      genConditionalExpression(node, context2);
      break;
    case 20:
      genCacheExpression(node, context2);
      break;
    case 21:
      genNodeList(node.body, context2, true, false);
      break;
    case 22:
      break;
    case 23:
      break;
    case 24:
      break;
    case 25:
      break;
    case 26:
      break;
    case 10:
      break;
    default:
      if (true) {
        assert(false, `unhandled codegen node type: ${node.type}`);
        const exhaustiveCheck = node;
        return exhaustiveCheck;
      }
  }
}
function genText(node, context2) {
  context2.push(JSON.stringify(node.content), -3, node);
}
function genExpression(node, context2) {
  const { content, isStatic } = node;
  context2.push(
    isStatic ? JSON.stringify(content) : content,
    -3,
    node
  );
}
function genInterpolation(node, context2) {
  const { push, helper, pure } = context2;
  if (pure)
    push(PURE_ANNOTATION);
  push(`${helper(TO_DISPLAY_STRING)}(`);
  genNode(node.content, context2);
  push(`)`);
}
function genCompoundExpression(node, context2) {
  for (let i = 0; i < node.children.length; i++) {
    const child = node.children[i];
    if (isString(child)) {
      context2.push(
        child,
        -3
        /* Unknown */
      );
    } else {
      genNode(child, context2);
    }
  }
}
function genExpressionAsPropertyKey(node, context2) {
  const { push } = context2;
  if (node.type === 8) {
    push(`[`);
    genCompoundExpression(node, context2);
    push(`]`);
  } else if (node.isStatic) {
    const text = isSimpleIdentifier(node.content) ? node.content : JSON.stringify(node.content);
    push(text, -2, node);
  } else {
    push(`[${node.content}]`, -3, node);
  }
}
function genComment(node, context2) {
  const { push, helper, pure } = context2;
  if (pure) {
    push(PURE_ANNOTATION);
  }
  push(
    `${helper(CREATE_COMMENT)}(${JSON.stringify(node.content)})`,
    -3,
    node
  );
}
function genVNodeCall(node, context2) {
  const { push, helper, pure } = context2;
  const {
    tag,
    props,
    children,
    patchFlag,
    dynamicProps,
    directives,
    isBlock,
    disableTracking,
    isComponent: isComponent2
  } = node;
  if (directives) {
    push(helper(WITH_DIRECTIVES) + `(`);
  }
  if (isBlock) {
    push(`(${helper(OPEN_BLOCK)}(${disableTracking ? `true` : ``}), `);
  }
  if (pure) {
    push(PURE_ANNOTATION);
  }
  const callHelper = isBlock ? getVNodeBlockHelper(context2.inSSR, isComponent2) : getVNodeHelper(context2.inSSR, isComponent2);
  push(helper(callHelper) + `(`, -2, node);
  genNodeList(
    genNullableArgs([tag, props, children, patchFlag, dynamicProps]),
    context2
  );
  push(`)`);
  if (isBlock) {
    push(`)`);
  }
  if (directives) {
    push(`, `);
    genNode(directives, context2);
    push(`)`);
  }
}
function genNullableArgs(args) {
  let i = args.length;
  while (i--) {
    if (args[i] != null)
      break;
  }
  return args.slice(0, i + 1).map((arg) => arg || `null`);
}
function genCallExpression(node, context2) {
  const { push, helper, pure } = context2;
  const callee = isString(node.callee) ? node.callee : helper(node.callee);
  if (pure) {
    push(PURE_ANNOTATION);
  }
  push(callee + `(`, -2, node);
  genNodeList(node.arguments, context2);
  push(`)`);
}
function genObjectExpression(node, context2) {
  const { push, indent, deindent, newline } = context2;
  const { properties } = node;
  if (!properties.length) {
    push(`{}`, -2, node);
    return;
  }
  const multilines = properties.length > 1 || properties.some((p2) => p2.value.type !== 4);
  push(multilines ? `{` : `{ `);
  multilines && indent();
  for (let i = 0; i < properties.length; i++) {
    const { key, value: value2 } = properties[i];
    genExpressionAsPropertyKey(key, context2);
    push(`: `);
    genNode(value2, context2);
    if (i < properties.length - 1) {
      push(`,`);
      newline();
    }
  }
  multilines && deindent();
  push(multilines ? `}` : ` }`);
}
function genArrayExpression(node, context2) {
  genNodeListAsArray(node.elements, context2);
}
function genFunctionExpression(node, context2) {
  const { push, indent, deindent } = context2;
  const { params, returns, body, newline, isSlot } = node;
  if (isSlot) {
    push(`_${helperNameMap[WITH_CTX]}(`);
  }
  push(`(`, -2, node);
  if (isArray(params)) {
    genNodeList(params, context2);
  } else if (params) {
    genNode(params, context2);
  }
  push(`) => `);
  if (newline || body) {
    push(`{`);
    indent();
  }
  if (returns) {
    if (newline) {
      push(`return `);
    }
    if (isArray(returns)) {
      genNodeListAsArray(returns, context2);
    } else {
      genNode(returns, context2);
    }
  } else if (body) {
    genNode(body, context2);
  }
  if (newline || body) {
    deindent();
    push(`}`);
  }
  if (isSlot) {
    if (node.isNonScopedSlot) {
      push(`, undefined, true`);
    }
    push(`)`);
  }
}
function genConditionalExpression(node, context2) {
  const { test, consequent, alternate, newline: needNewline } = node;
  const { push, indent, deindent, newline } = context2;
  if (test.type === 4) {
    const needsParens = !isSimpleIdentifier(test.content);
    needsParens && push(`(`);
    genExpression(test, context2);
    needsParens && push(`)`);
  } else {
    push(`(`);
    genNode(test, context2);
    push(`)`);
  }
  needNewline && indent();
  context2.indentLevel++;
  needNewline || push(` `);
  push(`? `);
  genNode(consequent, context2);
  context2.indentLevel--;
  needNewline && newline();
  needNewline || push(` `);
  push(`: `);
  const isNested = alternate.type === 19;
  if (!isNested) {
    context2.indentLevel++;
  }
  genNode(alternate, context2);
  if (!isNested) {
    context2.indentLevel--;
  }
  needNewline && deindent(
    true
    /* without newline */
  );
}
function genCacheExpression(node, context2) {
  const { push, helper, indent, deindent, newline } = context2;
  push(`_cache[${node.index}] || (`);
  if (node.isVNode) {
    indent();
    push(`${helper(SET_BLOCK_TRACKING)}(-1),`);
    newline();
  }
  push(`_cache[${node.index}] = `);
  genNode(node.value, context2);
  if (node.isVNode) {
    push(`,`);
    newline();
    push(`${helper(SET_BLOCK_TRACKING)}(1),`);
    newline();
    push(`_cache[${node.index}]`);
    deindent();
  }
  push(`)`);
}
function validateBrowserExpression(node, context2, asParams = false, asRawStatements = false) {
  const exp = node.content;
  if (!exp.trim()) {
    return;
  }
  try {
    new Function(
      asRawStatements ? ` ${exp} ` : `return ${asParams ? `(${exp}) => {}` : `(${exp})`}`
    );
  } catch (e) {
    let message = e.message;
    const keywordMatch = exp.replace(stripStringRE, "").match(prohibitedKeywordRE);
    if (keywordMatch) {
      message = `avoid using JavaScript keyword as property name: "${keywordMatch[0]}"`;
    }
    context2.onError(
      createCompilerError(
        45,
        node.loc,
        void 0,
        message
      )
    );
  }
}
function processExpression(node, context2, asParams = false, asRawStatements = false, localVars = Object.create(context2.identifiers)) {
  {
    if (true) {
      validateBrowserExpression(node, context2, asParams, asRawStatements);
    }
    return node;
  }
}
function stringifyExpression(exp) {
  if (isString(exp)) {
    return exp;
  } else if (exp.type === 4) {
    return exp.content;
  } else {
    return exp.children.map(stringifyExpression).join("");
  }
}
function processIf(node, dir, context2, processCodegen) {
  if (dir.name !== "else" && (!dir.exp || !dir.exp.content.trim())) {
    const loc = dir.exp ? dir.exp.loc : node.loc;
    context2.onError(
      createCompilerError(28, dir.loc)
    );
    dir.exp = createSimpleExpression(`true`, false, loc);
  }
  if (dir.exp) {
    validateBrowserExpression(dir.exp, context2);
  }
  if (dir.name === "if") {
    const branch = createIfBranch(node, dir);
    const ifNode = {
      type: 9,
      loc: node.loc,
      branches: [branch]
    };
    context2.replaceNode(ifNode);
    if (processCodegen) {
      return processCodegen(ifNode, branch, true);
    }
  } else {
    const siblings = context2.parent.children;
    const comments = [];
    let i = siblings.indexOf(node);
    while (i-- >= -1) {
      const sibling = siblings[i];
      if (sibling && sibling.type === 3) {
        context2.removeNode(sibling);
        comments.unshift(sibling);
        continue;
      }
      if (sibling && sibling.type === 2 && !sibling.content.trim().length) {
        context2.removeNode(sibling);
        continue;
      }
      if (sibling && sibling.type === 9) {
        if (dir.name === "else-if" && sibling.branches[sibling.branches.length - 1].condition === void 0) {
          context2.onError(
            createCompilerError(30, node.loc)
          );
        }
        context2.removeNode();
        const branch = createIfBranch(node, dir);
        if (comments.length && // #3619 ignore comments if the v-if is direct child of <transition>
        !(context2.parent && context2.parent.type === 1 && (context2.parent.tag === "transition" || context2.parent.tag === "Transition"))) {
          branch.children = [...comments, ...branch.children];
        }
        if (true) {
          const key = branch.userKey;
          if (key) {
            sibling.branches.forEach(({ userKey }) => {
              if (isSameKey(userKey, key)) {
                context2.onError(
                  createCompilerError(
                    29,
                    branch.userKey.loc
                  )
                );
              }
            });
          }
        }
        sibling.branches.push(branch);
        const onExit = processCodegen && processCodegen(sibling, branch, false);
        traverseNode(branch, context2);
        if (onExit)
          onExit();
        context2.currentNode = null;
      } else {
        context2.onError(
          createCompilerError(30, node.loc)
        );
      }
      break;
    }
  }
}
function createIfBranch(node, dir) {
  const isTemplateIf = node.tagType === 3;
  return {
    type: 10,
    loc: node.loc,
    condition: dir.name === "else" ? void 0 : dir.exp,
    children: isTemplateIf && !findDir(node, "for") ? node.children : [node],
    userKey: findProp(node, `key`),
    isTemplateIf
  };
}
function createCodegenNodeForBranch(branch, keyIndex, context2) {
  if (branch.condition) {
    return createConditionalExpression(
      branch.condition,
      createChildrenCodegenNode(branch, keyIndex, context2),
      // make sure to pass in asBlock: true so that the comment node call
      // closes the current block.
      createCallExpression(context2.helper(CREATE_COMMENT), [
        true ? '"v-if"' : '""',
        "true"
      ])
    );
  } else {
    return createChildrenCodegenNode(branch, keyIndex, context2);
  }
}
function createChildrenCodegenNode(branch, keyIndex, context2) {
  const { helper } = context2;
  const keyProperty = createObjectProperty(
    `key`,
    createSimpleExpression(
      `${keyIndex}`,
      false,
      locStub,
      2
    )
  );
  const { children } = branch;
  const firstChild = children[0];
  const needFragmentWrapper = children.length !== 1 || firstChild.type !== 1;
  if (needFragmentWrapper) {
    if (children.length === 1 && firstChild.type === 11) {
      const vnodeCall = firstChild.codegenNode;
      injectProp(vnodeCall, keyProperty, context2);
      return vnodeCall;
    } else {
      let patchFlag = 64;
      let patchFlagText = PatchFlagNames[64];
      if (!branch.isTemplateIf && children.filter((c) => c.type !== 3).length === 1) {
        patchFlag |= 2048;
        patchFlagText += `, ${PatchFlagNames[2048]}`;
      }
      return createVNodeCall(
        context2,
        helper(FRAGMENT),
        createObjectExpression([keyProperty]),
        children,
        patchFlag + (true ? ` /* ${patchFlagText} */` : ``),
        void 0,
        void 0,
        true,
        false,
        false,
        branch.loc
      );
    }
  } else {
    const ret = firstChild.codegenNode;
    const vnodeCall = getMemoedVNodeCall(ret);
    if (vnodeCall.type === 13) {
      convertToBlock(vnodeCall, context2);
    }
    injectProp(vnodeCall, keyProperty, context2);
    return ret;
  }
}
function isSameKey(a, b) {
  if (!a || a.type !== b.type) {
    return false;
  }
  if (a.type === 6) {
    if (a.value.content !== b.value.content) {
      return false;
    }
  } else {
    const exp = a.exp;
    const branchExp = b.exp;
    if (exp.type !== branchExp.type) {
      return false;
    }
    if (exp.type !== 4 || exp.isStatic !== branchExp.isStatic || exp.content !== branchExp.content) {
      return false;
    }
  }
  return true;
}
function getParentCondition(node) {
  while (true) {
    if (node.type === 19) {
      if (node.alternate.type === 19) {
        node = node.alternate;
      } else {
        return node;
      }
    } else if (node.type === 20) {
      node = node.value;
    }
  }
}
function processFor(node, dir, context2, processCodegen) {
  if (!dir.exp) {
    context2.onError(
      createCompilerError(31, dir.loc)
    );
    return;
  }
  const parseResult = dir.forParseResult;
  if (!parseResult) {
    context2.onError(
      createCompilerError(32, dir.loc)
    );
    return;
  }
  finalizeForParseResult(parseResult, context2);
  const { addIdentifiers, removeIdentifiers, scopes } = context2;
  const { source, value: value2, key, index: index2 } = parseResult;
  const forNode = {
    type: 11,
    loc: dir.loc,
    source,
    valueAlias: value2,
    keyAlias: key,
    objectIndexAlias: index2,
    parseResult,
    children: isTemplateNode(node) ? node.children : [node]
  };
  context2.replaceNode(forNode);
  scopes.vFor++;
  const onExit = processCodegen && processCodegen(forNode);
  return () => {
    scopes.vFor--;
    if (onExit)
      onExit();
  };
}
function finalizeForParseResult(result2, context2) {
  if (result2.finalized)
    return;
  if (true) {
    validateBrowserExpression(result2.source, context2);
    if (result2.key) {
      validateBrowserExpression(
        result2.key,
        context2,
        true
      );
    }
    if (result2.index) {
      validateBrowserExpression(
        result2.index,
        context2,
        true
      );
    }
    if (result2.value) {
      validateBrowserExpression(
        result2.value,
        context2,
        true
      );
    }
  }
  result2.finalized = true;
}
function createForLoopParams({ value: value2, key, index: index2 }, memoArgs = []) {
  return createParamsList([value2, key, index2, ...memoArgs]);
}
function createParamsList(args) {
  let i = args.length;
  while (i--) {
    if (args[i])
      break;
  }
  return args.slice(0, i + 1).map((arg, i2) => arg || createSimpleExpression(`_`.repeat(i2 + 1), false));
}
function buildSlots(node, context2, buildSlotFn = buildClientSlotFn) {
  context2.helper(WITH_CTX);
  const { children, loc } = node;
  const slotsProperties = [];
  const dynamicSlots = [];
  let hasDynamicSlots = context2.scopes.vSlot > 0 || context2.scopes.vFor > 0;
  const onComponentSlot = findDir(node, "slot", true);
  if (onComponentSlot) {
    const { arg, exp } = onComponentSlot;
    if (arg && !isStaticExp(arg)) {
      hasDynamicSlots = true;
    }
    slotsProperties.push(
      createObjectProperty(
        arg || createSimpleExpression("default", true),
        buildSlotFn(exp, void 0, children, loc)
      )
    );
  }
  let hasTemplateSlots = false;
  let hasNamedDefaultSlot = false;
  const implicitDefaultChildren = [];
  const seenSlotNames = /* @__PURE__ */ new Set();
  let conditionalBranchIndex = 0;
  for (let i = 0; i < children.length; i++) {
    const slotElement = children[i];
    let slotDir;
    if (!isTemplateNode(slotElement) || !(slotDir = findDir(slotElement, "slot", true))) {
      if (slotElement.type !== 3) {
        implicitDefaultChildren.push(slotElement);
      }
      continue;
    }
    if (onComponentSlot) {
      context2.onError(
        createCompilerError(37, slotDir.loc)
      );
      break;
    }
    hasTemplateSlots = true;
    const { children: slotChildren, loc: slotLoc } = slotElement;
    const {
      arg: slotName = createSimpleExpression(`default`, true),
      exp: slotProps,
      loc: dirLoc
    } = slotDir;
    let staticSlotName;
    if (isStaticExp(slotName)) {
      staticSlotName = slotName ? slotName.content : `default`;
    } else {
      hasDynamicSlots = true;
    }
    const vFor = findDir(slotElement, "for");
    const slotFunction = buildSlotFn(slotProps, vFor, slotChildren, slotLoc);
    let vIf;
    let vElse;
    if (vIf = findDir(slotElement, "if")) {
      hasDynamicSlots = true;
      dynamicSlots.push(
        createConditionalExpression(
          vIf.exp,
          buildDynamicSlot(slotName, slotFunction, conditionalBranchIndex++),
          defaultFallback
        )
      );
    } else if (vElse = findDir(
      slotElement,
      /^else(-if)?$/,
      true
      /* allowEmpty */
    )) {
      let j = i;
      let prev;
      while (j--) {
        prev = children[j];
        if (prev.type !== 3) {
          break;
        }
      }
      if (prev && isTemplateNode(prev) && findDir(prev, "if")) {
        children.splice(i, 1);
        i--;
        let conditional = dynamicSlots[dynamicSlots.length - 1];
        while (conditional.alternate.type === 19) {
          conditional = conditional.alternate;
        }
        conditional.alternate = vElse.exp ? createConditionalExpression(
          vElse.exp,
          buildDynamicSlot(
            slotName,
            slotFunction,
            conditionalBranchIndex++
          ),
          defaultFallback
        ) : buildDynamicSlot(slotName, slotFunction, conditionalBranchIndex++);
      } else {
        context2.onError(
          createCompilerError(30, vElse.loc)
        );
      }
    } else if (vFor) {
      hasDynamicSlots = true;
      const parseResult = vFor.forParseResult;
      if (parseResult) {
        finalizeForParseResult(parseResult, context2);
        dynamicSlots.push(
          createCallExpression(context2.helper(RENDER_LIST), [
            parseResult.source,
            createFunctionExpression(
              createForLoopParams(parseResult),
              buildDynamicSlot(slotName, slotFunction),
              true
            )
          ])
        );
      } else {
        context2.onError(
          createCompilerError(
            32,
            vFor.loc
          )
        );
      }
    } else {
      if (staticSlotName) {
        if (seenSlotNames.has(staticSlotName)) {
          context2.onError(
            createCompilerError(
              38,
              dirLoc
            )
          );
          continue;
        }
        seenSlotNames.add(staticSlotName);
        if (staticSlotName === "default") {
          hasNamedDefaultSlot = true;
        }
      }
      slotsProperties.push(createObjectProperty(slotName, slotFunction));
    }
  }
  if (!onComponentSlot) {
    const buildDefaultSlotProperty = (props, children2) => {
      const fn = buildSlotFn(props, void 0, children2, loc);
      if (context2.compatConfig) {
        fn.isNonScopedSlot = true;
      }
      return createObjectProperty(`default`, fn);
    };
    if (!hasTemplateSlots) {
      slotsProperties.push(buildDefaultSlotProperty(void 0, children));
    } else if (implicitDefaultChildren.length && // #3766
    // with whitespace: 'preserve', whitespaces between slots will end up in
    // implicitDefaultChildren. Ignore if all implicit children are whitespaces.
    implicitDefaultChildren.some((node2) => isNonWhitespaceContent(node2))) {
      if (hasNamedDefaultSlot) {
        context2.onError(
          createCompilerError(
            39,
            implicitDefaultChildren[0].loc
          )
        );
      } else {
        slotsProperties.push(
          buildDefaultSlotProperty(void 0, implicitDefaultChildren)
        );
      }
    }
  }
  const slotFlag = hasDynamicSlots ? 2 : hasForwardedSlots(node.children) ? 3 : 1;
  let slots = createObjectExpression(
    slotsProperties.concat(
      createObjectProperty(
        `_`,
        // 2 = compiled but dynamic = can skip normalization, but must run diff
        // 1 = compiled and static = can skip normalization AND diff as optimized
        createSimpleExpression(
          slotFlag + (true ? ` /* ${slotFlagsText[slotFlag]} */` : ``),
          false
        )
      )
    ),
    loc
  );
  if (dynamicSlots.length) {
    slots = createCallExpression(context2.helper(CREATE_SLOTS), [
      slots,
      createArrayExpression(dynamicSlots)
    ]);
  }
  return {
    slots,
    hasDynamicSlots
  };
}
function buildDynamicSlot(name2, fn, index2) {
  const props = [
    createObjectProperty(`name`, name2),
    createObjectProperty(`fn`, fn)
  ];
  if (index2 != null) {
    props.push(
      createObjectProperty(`key`, createSimpleExpression(String(index2), true))
    );
  }
  return createObjectExpression(props);
}
function hasForwardedSlots(children) {
  for (let i = 0; i < children.length; i++) {
    const child = children[i];
    switch (child.type) {
      case 1:
        if (child.tagType === 2 || hasForwardedSlots(child.children)) {
          return true;
        }
        break;
      case 9:
        if (hasForwardedSlots(child.branches))
          return true;
        break;
      case 10:
      case 11:
        if (hasForwardedSlots(child.children))
          return true;
        break;
    }
  }
  return false;
}
function isNonWhitespaceContent(node) {
  if (node.type !== 2 && node.type !== 12)
    return true;
  return node.type === 2 ? !!node.content.trim() : isNonWhitespaceContent(node.content);
}
function resolveComponentType(node, context2, ssr = false) {
  let { tag } = node;
  const isExplicitDynamic = isComponentTag(tag);
  const isProp = findProp(node, "is");
  if (isProp) {
    if (isExplicitDynamic || isCompatEnabled(
      "COMPILER_IS_ON_ELEMENT",
      context2
    )) {
      const exp = isProp.type === 6 ? isProp.value && createSimpleExpression(isProp.value.content, true) : isProp.exp;
      if (exp) {
        return createCallExpression(context2.helper(RESOLVE_DYNAMIC_COMPONENT), [
          exp
        ]);
      }
    } else if (isProp.type === 6 && isProp.value.content.startsWith("vue:")) {
      tag = isProp.value.content.slice(4);
    }
  }
  const builtIn = isCoreComponent(tag) || context2.isBuiltInComponent(tag);
  if (builtIn) {
    if (!ssr)
      context2.helper(builtIn);
    return builtIn;
  }
  context2.helper(RESOLVE_COMPONENT);
  context2.components.add(tag);
  return toValidAssetId(tag, `component`);
}
function buildProps(node, context2, props = node.props, isComponent2, isDynamicComponent, ssr = false) {
  const { tag, loc: elementLoc, children } = node;
  let properties = [];
  const mergeArgs = [];
  const runtimeDirectives = [];
  const hasChildren = children.length > 0;
  let shouldUseBlock = false;
  let patchFlag = 0;
  let hasRef = false;
  let hasClassBinding = false;
  let hasStyleBinding = false;
  let hasHydrationEventBinding = false;
  let hasDynamicKeys = false;
  let hasVnodeHook = false;
  const dynamicPropNames = [];
  const pushMergeArg = (arg) => {
    if (properties.length) {
      mergeArgs.push(
        createObjectExpression(dedupeProperties(properties), elementLoc)
      );
      properties = [];
    }
    if (arg)
      mergeArgs.push(arg);
  };
  const analyzePatchFlag = ({ key, value: value2 }) => {
    if (isStaticExp(key)) {
      const name2 = key.content;
      const isEventHandler = isOn(name2);
      if (isEventHandler && (!isComponent2 || isDynamicComponent) && // omit the flag for click handlers because hydration gives click
      // dedicated fast path.
      name2.toLowerCase() !== "onclick" && // omit v-model handlers
      name2 !== "onUpdate:modelValue" && // omit onVnodeXXX hooks
      !isReservedProp(name2)) {
        hasHydrationEventBinding = true;
      }
      if (isEventHandler && isReservedProp(name2)) {
        hasVnodeHook = true;
      }
      if (isEventHandler && value2.type === 14) {
        value2 = value2.arguments[0];
      }
      if (value2.type === 20 || (value2.type === 4 || value2.type === 8) && getConstantType(value2, context2) > 0) {
        return;
      }
      if (name2 === "ref") {
        hasRef = true;
      } else if (name2 === "class") {
        hasClassBinding = true;
      } else if (name2 === "style") {
        hasStyleBinding = true;
      } else if (name2 !== "key" && !dynamicPropNames.includes(name2)) {
        dynamicPropNames.push(name2);
      }
      if (isComponent2 && (name2 === "class" || name2 === "style") && !dynamicPropNames.includes(name2)) {
        dynamicPropNames.push(name2);
      }
    } else {
      hasDynamicKeys = true;
    }
  };
  for (let i = 0; i < props.length; i++) {
    const prop = props[i];
    if (prop.type === 6) {
      const { loc, name: name2, nameLoc, value: value2 } = prop;
      let isStatic = true;
      if (name2 === "ref") {
        hasRef = true;
        if (context2.scopes.vFor > 0) {
          properties.push(
            createObjectProperty(
              createSimpleExpression("ref_for", true),
              createSimpleExpression("true")
            )
          );
        }
      }
      if (name2 === "is" && (isComponentTag(tag) || value2 && value2.content.startsWith("vue:") || isCompatEnabled(
        "COMPILER_IS_ON_ELEMENT",
        context2
      ))) {
        continue;
      }
      properties.push(
        createObjectProperty(
          createSimpleExpression(name2, true, nameLoc),
          createSimpleExpression(
            value2 ? value2.content : "",
            isStatic,
            value2 ? value2.loc : loc
          )
        )
      );
    } else {
      const { name: name2, arg, exp, loc, modifiers } = prop;
      const isVBind = name2 === "bind";
      const isVOn = name2 === "on";
      if (name2 === "slot") {
        if (!isComponent2) {
          context2.onError(
            createCompilerError(40, loc)
          );
        }
        continue;
      }
      if (name2 === "once" || name2 === "memo") {
        continue;
      }
      if (name2 === "is" || isVBind && isStaticArgOf(arg, "is") && (isComponentTag(tag) || isCompatEnabled(
        "COMPILER_IS_ON_ELEMENT",
        context2
      ))) {
        continue;
      }
      if (isVOn && ssr) {
        continue;
      }
      if (
        // #938: elements with dynamic keys should be forced into blocks
        isVBind && isStaticArgOf(arg, "key") || // inline before-update hooks need to force block so that it is invoked
        // before children
        isVOn && hasChildren && isStaticArgOf(arg, "vue:before-update")
      ) {
        shouldUseBlock = true;
      }
      if (isVBind && isStaticArgOf(arg, "ref") && context2.scopes.vFor > 0) {
        properties.push(
          createObjectProperty(
            createSimpleExpression("ref_for", true),
            createSimpleExpression("true")
          )
        );
      }
      if (!arg && (isVBind || isVOn)) {
        hasDynamicKeys = true;
        if (exp) {
          if (isVBind) {
            pushMergeArg();
            {
              if (true) {
                const hasOverridableKeys = mergeArgs.some((arg2) => {
                  if (arg2.type === 15) {
                    return arg2.properties.some(({ key }) => {
                      if (key.type !== 4 || !key.isStatic) {
                        return true;
                      }
                      return key.content !== "class" && key.content !== "style" && !isOn(key.content);
                    });
                  } else {
                    return true;
                  }
                });
                if (hasOverridableKeys) {
                  checkCompatEnabled(
                    "COMPILER_V_BIND_OBJECT_ORDER",
                    context2,
                    loc
                  );
                }
              }
              if (isCompatEnabled(
                "COMPILER_V_BIND_OBJECT_ORDER",
                context2
              )) {
                mergeArgs.unshift(exp);
                continue;
              }
            }
            mergeArgs.push(exp);
          } else {
            pushMergeArg({
              type: 14,
              loc,
              callee: context2.helper(TO_HANDLERS),
              arguments: isComponent2 ? [exp] : [exp, `true`]
            });
          }
        } else {
          context2.onError(
            createCompilerError(
              isVBind ? 34 : 35,
              loc
            )
          );
        }
        continue;
      }
      if (isVBind && modifiers.includes("prop")) {
        patchFlag |= 32;
      }
      const directiveTransform = context2.directiveTransforms[name2];
      if (directiveTransform) {
        const { props: props2, needRuntime } = directiveTransform(prop, node, context2);
        !ssr && props2.forEach(analyzePatchFlag);
        if (isVOn && arg && !isStaticExp(arg)) {
          pushMergeArg(createObjectExpression(props2, elementLoc));
        } else {
          properties.push(...props2);
        }
        if (needRuntime) {
          runtimeDirectives.push(prop);
          if (isSymbol(needRuntime)) {
            directiveImportMap.set(prop, needRuntime);
          }
        }
      } else if (!isBuiltInDirective(name2)) {
        runtimeDirectives.push(prop);
        if (hasChildren) {
          shouldUseBlock = true;
        }
      }
    }
  }
  let propsExpression = void 0;
  if (mergeArgs.length) {
    pushMergeArg();
    if (mergeArgs.length > 1) {
      propsExpression = createCallExpression(
        context2.helper(MERGE_PROPS),
        mergeArgs,
        elementLoc
      );
    } else {
      propsExpression = mergeArgs[0];
    }
  } else if (properties.length) {
    propsExpression = createObjectExpression(
      dedupeProperties(properties),
      elementLoc
    );
  }
  if (hasDynamicKeys) {
    patchFlag |= 16;
  } else {
    if (hasClassBinding && !isComponent2) {
      patchFlag |= 2;
    }
    if (hasStyleBinding && !isComponent2) {
      patchFlag |= 4;
    }
    if (dynamicPropNames.length) {
      patchFlag |= 8;
    }
    if (hasHydrationEventBinding) {
      patchFlag |= 32;
    }
  }
  if (!shouldUseBlock && (patchFlag === 0 || patchFlag === 32) && (hasRef || hasVnodeHook || runtimeDirectives.length > 0)) {
    patchFlag |= 512;
  }
  if (!context2.inSSR && propsExpression) {
    switch (propsExpression.type) {
      case 15:
        let classKeyIndex = -1;
        let styleKeyIndex = -1;
        let hasDynamicKey = false;
        for (let i = 0; i < propsExpression.properties.length; i++) {
          const key = propsExpression.properties[i].key;
          if (isStaticExp(key)) {
            if (key.content === "class") {
              classKeyIndex = i;
            } else if (key.content === "style") {
              styleKeyIndex = i;
            }
          } else if (!key.isHandlerKey) {
            hasDynamicKey = true;
          }
        }
        const classProp = propsExpression.properties[classKeyIndex];
        const styleProp2 = propsExpression.properties[styleKeyIndex];
        if (!hasDynamicKey) {
          if (classProp && !isStaticExp(classProp.value)) {
            classProp.value = createCallExpression(
              context2.helper(NORMALIZE_CLASS),
              [classProp.value]
            );
          }
          if (styleProp2 && // the static style is compiled into an object,
          // so use `hasStyleBinding` to ensure that it is a dynamic style binding
          (hasStyleBinding || styleProp2.value.type === 4 && styleProp2.value.content.trim()[0] === `[` || // v-bind:style and style both exist,
          // v-bind:style with static literal object
          styleProp2.value.type === 17)) {
            styleProp2.value = createCallExpression(
              context2.helper(NORMALIZE_STYLE),
              [styleProp2.value]
            );
          }
        } else {
          propsExpression = createCallExpression(
            context2.helper(NORMALIZE_PROPS),
            [propsExpression]
          );
        }
        break;
      case 14:
        break;
      default:
        propsExpression = createCallExpression(
          context2.helper(NORMALIZE_PROPS),
          [
            createCallExpression(context2.helper(GUARD_REACTIVE_PROPS), [
              propsExpression
            ])
          ]
        );
        break;
    }
  }
  return {
    props: propsExpression,
    directives: runtimeDirectives,
    patchFlag,
    dynamicPropNames,
    shouldUseBlock
  };
}
function dedupeProperties(properties) {
  const knownProps = /* @__PURE__ */ new Map();
  const deduped = [];
  for (let i = 0; i < properties.length; i++) {
    const prop = properties[i];
    if (prop.key.type === 8 || !prop.key.isStatic) {
      deduped.push(prop);
      continue;
    }
    const name2 = prop.key.content;
    const existing = knownProps.get(name2);
    if (existing) {
      if (name2 === "style" || name2 === "class" || isOn(name2)) {
        mergeAsArray(existing, prop);
      }
    } else {
      knownProps.set(name2, prop);
      deduped.push(prop);
    }
  }
  return deduped;
}
function mergeAsArray(existing, incoming) {
  if (existing.value.type === 17) {
    existing.value.elements.push(incoming.value);
  } else {
    existing.value = createArrayExpression(
      [existing.value, incoming.value],
      existing.loc
    );
  }
}
function buildDirectiveArgs(dir, context2) {
  const dirArgs = [];
  const runtime = directiveImportMap.get(dir);
  if (runtime) {
    dirArgs.push(context2.helperString(runtime));
  } else {
    {
      context2.helper(RESOLVE_DIRECTIVE);
      context2.directives.add(dir.name);
      dirArgs.push(toValidAssetId(dir.name, `directive`));
    }
  }
  const { loc } = dir;
  if (dir.exp)
    dirArgs.push(dir.exp);
  if (dir.arg) {
    if (!dir.exp) {
      dirArgs.push(`void 0`);
    }
    dirArgs.push(dir.arg);
  }
  if (Object.keys(dir.modifiers).length) {
    if (!dir.arg) {
      if (!dir.exp) {
        dirArgs.push(`void 0`);
      }
      dirArgs.push(`void 0`);
    }
    const trueExpression = createSimpleExpression(`true`, false, loc);
    dirArgs.push(
      createObjectExpression(
        dir.modifiers.map(
          (modifier) => createObjectProperty(modifier, trueExpression)
        ),
        loc
      )
    );
  }
  return createArrayExpression(dirArgs, dir.loc);
}
function stringifyDynamicPropNames(props) {
  let propsNamesString = `[`;
  for (let i = 0, l = props.length; i < l; i++) {
    propsNamesString += JSON.stringify(props[i]);
    if (i < l - 1)
      propsNamesString += ", ";
  }
  return propsNamesString + `]`;
}
function isComponentTag(tag) {
  return tag === "component" || tag === "Component";
}
function processSlotOutlet(node, context2) {
  let slotName = `"default"`;
  let slotProps = void 0;
  const nonNameProps = [];
  for (let i = 0; i < node.props.length; i++) {
    const p2 = node.props[i];
    if (p2.type === 6) {
      if (p2.value) {
        if (p2.name === "name") {
          slotName = JSON.stringify(p2.value.content);
        } else {
          p2.name = camelize(p2.name);
          nonNameProps.push(p2);
        }
      }
    } else {
      if (p2.name === "bind" && isStaticArgOf(p2.arg, "name")) {
        if (p2.exp)
          slotName = p2.exp;
      } else {
        if (p2.name === "bind" && p2.arg && isStaticExp(p2.arg)) {
          p2.arg.content = camelize(p2.arg.content);
        }
        nonNameProps.push(p2);
      }
    }
  }
  if (nonNameProps.length > 0) {
    const { props, directives } = buildProps(
      node,
      context2,
      nonNameProps,
      false,
      false
    );
    slotProps = props;
    if (directives.length) {
      context2.onError(
        createCompilerError(
          36,
          directives[0].loc
        )
      );
    }
  }
  return {
    slotName,
    slotProps
  };
}
function createTransformProps(props = []) {
  return { props };
}
function rewriteFilter(node, context2) {
  if (node.type === 4) {
    parseFilter(node, context2);
  } else {
    for (let i = 0; i < node.children.length; i++) {
      const child = node.children[i];
      if (typeof child !== "object")
        continue;
      if (child.type === 4) {
        parseFilter(child, context2);
      } else if (child.type === 8) {
        rewriteFilter(node, context2);
      } else if (child.type === 5) {
        rewriteFilter(child.content, context2);
      }
    }
  }
}
function parseFilter(node, context2) {
  const exp = node.content;
  let inSingle = false;
  let inDouble = false;
  let inTemplateString = false;
  let inRegex = false;
  let curly = 0;
  let square = 0;
  let paren = 0;
  let lastFilterIndex = 0;
  let c, prev, i, expression, filters = [];
  for (i = 0; i < exp.length; i++) {
    prev = c;
    c = exp.charCodeAt(i);
    if (inSingle) {
      if (c === 39 && prev !== 92)
        inSingle = false;
    } else if (inDouble) {
      if (c === 34 && prev !== 92)
        inDouble = false;
    } else if (inTemplateString) {
      if (c === 96 && prev !== 92)
        inTemplateString = false;
    } else if (inRegex) {
      if (c === 47 && prev !== 92)
        inRegex = false;
    } else if (c === 124 && // pipe
    exp.charCodeAt(i + 1) !== 124 && exp.charCodeAt(i - 1) !== 124 && !curly && !square && !paren) {
      if (expression === void 0) {
        lastFilterIndex = i + 1;
        expression = exp.slice(0, i).trim();
      } else {
        pushFilter();
      }
    } else {
      switch (c) {
        case 34:
          inDouble = true;
          break;
        case 39:
          inSingle = true;
          break;
        case 96:
          inTemplateString = true;
          break;
        case 40:
          paren++;
          break;
        case 41:
          paren--;
          break;
        case 91:
          square++;
          break;
        case 93:
          square--;
          break;
        case 123:
          curly++;
          break;
        case 125:
          curly--;
          break;
      }
      if (c === 47) {
        let j = i - 1;
        let p2;
        for (; j >= 0; j--) {
          p2 = exp.charAt(j);
          if (p2 !== " ")
            break;
        }
        if (!p2 || !validDivisionCharRE.test(p2)) {
          inRegex = true;
        }
      }
    }
  }
  if (expression === void 0) {
    expression = exp.slice(0, i).trim();
  } else if (lastFilterIndex !== 0) {
    pushFilter();
  }
  function pushFilter() {
    filters.push(exp.slice(lastFilterIndex, i).trim());
    lastFilterIndex = i + 1;
  }
  if (filters.length) {
    warnDeprecation(
      "COMPILER_FILTERS",
      context2,
      node.loc
    );
    for (i = 0; i < filters.length; i++) {
      expression = wrapFilter(expression, filters[i], context2);
    }
    node.content = expression;
  }
}
function wrapFilter(exp, filter, context2) {
  context2.helper(RESOLVE_FILTER);
  const i = filter.indexOf("(");
  if (i < 0) {
    context2.filters.add(filter);
    return `${toValidAssetId(filter, "filter")}(${exp})`;
  } else {
    const name2 = filter.slice(0, i);
    const args = filter.slice(i + 1);
    context2.filters.add(name2);
    return `${toValidAssetId(name2, "filter")}(${exp}${args !== ")" ? "," + args : args}`;
  }
}
function getBaseTransformPreset(prefixIdentifiers) {
  return [
    [
      transformOnce,
      transformIf,
      transformMemo,
      transformFor,
      ...[transformFilter],
      ...true ? [transformExpression] : [],
      transformSlotOutlet,
      transformElement,
      trackSlotScopes,
      transformText
    ],
    {
      on: transformOn,
      bind: transformBind,
      model: transformModel
    }
  ];
}
function baseCompile(source, options2 = {}) {
  const onError = options2.onError || defaultOnError;
  const isModuleMode = options2.mode === "module";
  {
    if (options2.prefixIdentifiers === true) {
      onError(createCompilerError(47));
    } else if (isModuleMode) {
      onError(createCompilerError(48));
    }
  }
  const prefixIdentifiers = false;
  if (options2.cacheHandlers) {
    onError(createCompilerError(49));
  }
  if (options2.scopeId && !isModuleMode) {
    onError(createCompilerError(50));
  }
  const resolvedOptions = extend({}, options2, {
    prefixIdentifiers
  });
  const ast = isString(source) ? baseParse(source, resolvedOptions) : source;
  const [nodeTransforms, directiveTransforms] = getBaseTransformPreset();
  transform(
    ast,
    extend({}, resolvedOptions, {
      nodeTransforms: [
        ...nodeTransforms,
        ...options2.nodeTransforms || []
        // user transforms
      ],
      directiveTransforms: extend(
        {},
        directiveTransforms,
        options2.directiveTransforms || {}
        // user transforms
      )
    })
  );
  return generate(ast, resolvedOptions);
}
var FRAGMENT, TELEPORT, SUSPENSE, KEEP_ALIVE, BASE_TRANSITION, OPEN_BLOCK, CREATE_BLOCK, CREATE_ELEMENT_BLOCK, CREATE_VNODE, CREATE_ELEMENT_VNODE, CREATE_COMMENT, CREATE_TEXT, CREATE_STATIC, RESOLVE_COMPONENT, RESOLVE_DYNAMIC_COMPONENT, RESOLVE_DIRECTIVE, RESOLVE_FILTER, WITH_DIRECTIVES, RENDER_LIST, RENDER_SLOT, CREATE_SLOTS, TO_DISPLAY_STRING, MERGE_PROPS, NORMALIZE_CLASS, NORMALIZE_STYLE, NORMALIZE_PROPS, GUARD_REACTIVE_PROPS, TO_HANDLERS, CAMELIZE, CAPITALIZE, TO_HANDLER_KEY, SET_BLOCK_TRACKING, PUSH_SCOPE_ID, POP_SCOPE_ID, WITH_CTX, UNREF, IS_REF, WITH_MEMO, IS_MEMO_SAME, helperNameMap, Namespaces, NodeTypes, ElementTypes, ConstantTypes, locStub, defaultDelimitersOpen, defaultDelimitersClose, Sequences, Tokenizer, CompilerDeprecationTypes, deprecationData, ErrorCodes, errorMessages, isFunctionType, isStaticProperty, isStaticPropertyKey, TS_NODE_TYPES, isStaticExp, nonIdentifierRE, isSimpleIdentifier, validFirstIdentCharRE, validIdentCharRE, whitespaceRE, isMemberExpressionBrowser, isMemberExpressionNode, isMemberExpression, propsHelperSet, forAliasRE, defaultParserOptions, currentOptions, currentRoot, currentInput, currentOpenTag, currentProp, currentAttrValue, currentAttrStartIndex, currentAttrEndIndex, inPre, inVPre, currentVPreBoundary, stack, tokenizer, forIteratorRE, stripParensRE, specialTemplateDir, windowsNewlineRE, allowHoistedHelperSet, PURE_ANNOTATION, aliasHelper, prohibitedKeywordRE, stripStringRE, transformExpression, transformIf, transformFor, defaultFallback, trackSlotScopes, trackVForSlotScopes, buildClientSlotFn, directiveImportMap, transformElement, transformSlotOutlet, fnExpRE, transformOn, transformBind, injectPrefix, transformText, seen$1, transformOnce, transformModel, validDivisionCharRE, transformFilter, seen, transformMemo, BindingTypes, noopDirectiveTransform;
var init_compiler_core_esm_bundler = __esm({
  "node_modules/@vue/compiler-core/dist/compiler-core.esm-bundler.js"() {
    init_shared_esm_bundler();
    init_shared_esm_bundler();
    FRAGMENT = Symbol(true ? `Fragment` : ``);
    TELEPORT = Symbol(true ? `Teleport` : ``);
    SUSPENSE = Symbol(true ? `Suspense` : ``);
    KEEP_ALIVE = Symbol(true ? `KeepAlive` : ``);
    BASE_TRANSITION = Symbol(true ? `BaseTransition` : ``);
    OPEN_BLOCK = Symbol(true ? `openBlock` : ``);
    CREATE_BLOCK = Symbol(true ? `createBlock` : ``);
    CREATE_ELEMENT_BLOCK = Symbol(true ? `createElementBlock` : ``);
    CREATE_VNODE = Symbol(true ? `createVNode` : ``);
    CREATE_ELEMENT_VNODE = Symbol(true ? `createElementVNode` : ``);
    CREATE_COMMENT = Symbol(true ? `createCommentVNode` : ``);
    CREATE_TEXT = Symbol(true ? `createTextVNode` : ``);
    CREATE_STATIC = Symbol(true ? `createStaticVNode` : ``);
    RESOLVE_COMPONENT = Symbol(true ? `resolveComponent` : ``);
    RESOLVE_DYNAMIC_COMPONENT = Symbol(
      true ? `resolveDynamicComponent` : ``
    );
    RESOLVE_DIRECTIVE = Symbol(true ? `resolveDirective` : ``);
    RESOLVE_FILTER = Symbol(true ? `resolveFilter` : ``);
    WITH_DIRECTIVES = Symbol(true ? `withDirectives` : ``);
    RENDER_LIST = Symbol(true ? `renderList` : ``);
    RENDER_SLOT = Symbol(true ? `renderSlot` : ``);
    CREATE_SLOTS = Symbol(true ? `createSlots` : ``);
    TO_DISPLAY_STRING = Symbol(true ? `toDisplayString` : ``);
    MERGE_PROPS = Symbol(true ? `mergeProps` : ``);
    NORMALIZE_CLASS = Symbol(true ? `normalizeClass` : ``);
    NORMALIZE_STYLE = Symbol(true ? `normalizeStyle` : ``);
    NORMALIZE_PROPS = Symbol(true ? `normalizeProps` : ``);
    GUARD_REACTIVE_PROPS = Symbol(true ? `guardReactiveProps` : ``);
    TO_HANDLERS = Symbol(true ? `toHandlers` : ``);
    CAMELIZE = Symbol(true ? `camelize` : ``);
    CAPITALIZE = Symbol(true ? `capitalize` : ``);
    TO_HANDLER_KEY = Symbol(true ? `toHandlerKey` : ``);
    SET_BLOCK_TRACKING = Symbol(true ? `setBlockTracking` : ``);
    PUSH_SCOPE_ID = Symbol(true ? `pushScopeId` : ``);
    POP_SCOPE_ID = Symbol(true ? `popScopeId` : ``);
    WITH_CTX = Symbol(true ? `withCtx` : ``);
    UNREF = Symbol(true ? `unref` : ``);
    IS_REF = Symbol(true ? `isRef` : ``);
    WITH_MEMO = Symbol(true ? `withMemo` : ``);
    IS_MEMO_SAME = Symbol(true ? `isMemoSame` : ``);
    helperNameMap = {
      [FRAGMENT]: `Fragment`,
      [TELEPORT]: `Teleport`,
      [SUSPENSE]: `Suspense`,
      [KEEP_ALIVE]: `KeepAlive`,
      [BASE_TRANSITION]: `BaseTransition`,
      [OPEN_BLOCK]: `openBlock`,
      [CREATE_BLOCK]: `createBlock`,
      [CREATE_ELEMENT_BLOCK]: `createElementBlock`,
      [CREATE_VNODE]: `createVNode`,
      [CREATE_ELEMENT_VNODE]: `createElementVNode`,
      [CREATE_COMMENT]: `createCommentVNode`,
      [CREATE_TEXT]: `createTextVNode`,
      [CREATE_STATIC]: `createStaticVNode`,
      [RESOLVE_COMPONENT]: `resolveComponent`,
      [RESOLVE_DYNAMIC_COMPONENT]: `resolveDynamicComponent`,
      [RESOLVE_DIRECTIVE]: `resolveDirective`,
      [RESOLVE_FILTER]: `resolveFilter`,
      [WITH_DIRECTIVES]: `withDirectives`,
      [RENDER_LIST]: `renderList`,
      [RENDER_SLOT]: `renderSlot`,
      [CREATE_SLOTS]: `createSlots`,
      [TO_DISPLAY_STRING]: `toDisplayString`,
      [MERGE_PROPS]: `mergeProps`,
      [NORMALIZE_CLASS]: `normalizeClass`,
      [NORMALIZE_STYLE]: `normalizeStyle`,
      [NORMALIZE_PROPS]: `normalizeProps`,
      [GUARD_REACTIVE_PROPS]: `guardReactiveProps`,
      [TO_HANDLERS]: `toHandlers`,
      [CAMELIZE]: `camelize`,
      [CAPITALIZE]: `capitalize`,
      [TO_HANDLER_KEY]: `toHandlerKey`,
      [SET_BLOCK_TRACKING]: `setBlockTracking`,
      [PUSH_SCOPE_ID]: `pushScopeId`,
      [POP_SCOPE_ID]: `popScopeId`,
      [WITH_CTX]: `withCtx`,
      [UNREF]: `unref`,
      [IS_REF]: `isRef`,
      [WITH_MEMO]: `withMemo`,
      [IS_MEMO_SAME]: `isMemoSame`
    };
    Namespaces = {
      "HTML": 0,
      "0": "HTML",
      "SVG": 1,
      "1": "SVG",
      "MATH_ML": 2,
      "2": "MATH_ML"
    };
    NodeTypes = {
      "ROOT": 0,
      "0": "ROOT",
      "ELEMENT": 1,
      "1": "ELEMENT",
      "TEXT": 2,
      "2": "TEXT",
      "COMMENT": 3,
      "3": "COMMENT",
      "SIMPLE_EXPRESSION": 4,
      "4": "SIMPLE_EXPRESSION",
      "INTERPOLATION": 5,
      "5": "INTERPOLATION",
      "ATTRIBUTE": 6,
      "6": "ATTRIBUTE",
      "DIRECTIVE": 7,
      "7": "DIRECTIVE",
      "COMPOUND_EXPRESSION": 8,
      "8": "COMPOUND_EXPRESSION",
      "IF": 9,
      "9": "IF",
      "IF_BRANCH": 10,
      "10": "IF_BRANCH",
      "FOR": 11,
      "11": "FOR",
      "TEXT_CALL": 12,
      "12": "TEXT_CALL",
      "VNODE_CALL": 13,
      "13": "VNODE_CALL",
      "JS_CALL_EXPRESSION": 14,
      "14": "JS_CALL_EXPRESSION",
      "JS_OBJECT_EXPRESSION": 15,
      "15": "JS_OBJECT_EXPRESSION",
      "JS_PROPERTY": 16,
      "16": "JS_PROPERTY",
      "JS_ARRAY_EXPRESSION": 17,
      "17": "JS_ARRAY_EXPRESSION",
      "JS_FUNCTION_EXPRESSION": 18,
      "18": "JS_FUNCTION_EXPRESSION",
      "JS_CONDITIONAL_EXPRESSION": 19,
      "19": "JS_CONDITIONAL_EXPRESSION",
      "JS_CACHE_EXPRESSION": 20,
      "20": "JS_CACHE_EXPRESSION",
      "JS_BLOCK_STATEMENT": 21,
      "21": "JS_BLOCK_STATEMENT",
      "JS_TEMPLATE_LITERAL": 22,
      "22": "JS_TEMPLATE_LITERAL",
      "JS_IF_STATEMENT": 23,
      "23": "JS_IF_STATEMENT",
      "JS_ASSIGNMENT_EXPRESSION": 24,
      "24": "JS_ASSIGNMENT_EXPRESSION",
      "JS_SEQUENCE_EXPRESSION": 25,
      "25": "JS_SEQUENCE_EXPRESSION",
      "JS_RETURN_STATEMENT": 26,
      "26": "JS_RETURN_STATEMENT"
    };
    ElementTypes = {
      "ELEMENT": 0,
      "0": "ELEMENT",
      "COMPONENT": 1,
      "1": "COMPONENT",
      "SLOT": 2,
      "2": "SLOT",
      "TEMPLATE": 3,
      "3": "TEMPLATE"
    };
    ConstantTypes = {
      "NOT_CONSTANT": 0,
      "0": "NOT_CONSTANT",
      "CAN_SKIP_PATCH": 1,
      "1": "CAN_SKIP_PATCH",
      "CAN_HOIST": 2,
      "2": "CAN_HOIST",
      "CAN_STRINGIFY": 3,
      "3": "CAN_STRINGIFY"
    };
    locStub = {
      start: { line: 1, column: 1, offset: 0 },
      end: { line: 1, column: 1, offset: 0 },
      source: ""
    };
    defaultDelimitersOpen = new Uint8Array([123, 123]);
    defaultDelimitersClose = new Uint8Array([125, 125]);
    Sequences = {
      Cdata: new Uint8Array([67, 68, 65, 84, 65, 91]),
      // CDATA[
      CdataEnd: new Uint8Array([93, 93, 62]),
      // ]]>
      CommentEnd: new Uint8Array([45, 45, 62]),
      // `-->`
      ScriptEnd: new Uint8Array([60, 47, 115, 99, 114, 105, 112, 116]),
      // `<\/script`
      StyleEnd: new Uint8Array([60, 47, 115, 116, 121, 108, 101]),
      // `</style`
      TitleEnd: new Uint8Array([60, 47, 116, 105, 116, 108, 101]),
      // `</title`
      TextareaEnd: new Uint8Array([
        60,
        47,
        116,
        101,
        120,
        116,
        97,
        114,
        101,
        97
      ])
      // `</textarea
    };
    Tokenizer = class {
      constructor(stack2, cbs) {
        this.stack = stack2;
        this.cbs = cbs;
        this.state = 1;
        this.buffer = "";
        this.sectionStart = 0;
        this.index = 0;
        this.entityStart = 0;
        this.baseState = 1;
        this.inRCDATA = false;
        this.inXML = false;
        this.inVPre = false;
        this.newlines = [];
        this.mode = 0;
        this.delimiterOpen = defaultDelimitersOpen;
        this.delimiterClose = defaultDelimitersClose;
        this.delimiterIndex = -1;
        this.currentSequence = void 0;
        this.sequenceIndex = 0;
      }
      get inSFCRoot() {
        return this.mode === 2 && this.stack.length === 0;
      }
      reset() {
        this.state = 1;
        this.mode = 0;
        this.buffer = "";
        this.sectionStart = 0;
        this.index = 0;
        this.baseState = 1;
        this.inRCDATA = false;
        this.currentSequence = void 0;
        this.newlines.length = 0;
        this.delimiterOpen = defaultDelimitersOpen;
        this.delimiterClose = defaultDelimitersClose;
      }
      /**
       * Generate Position object with line / column information using recorded
       * newline positions. We know the index is always going to be an already
       * processed index, so all the newlines up to this index should have been
       * recorded.
       */
      getPos(index2) {
        let line = 1;
        let column = index2 + 1;
        for (let i = this.newlines.length - 1; i >= 0; i--) {
          const newlineIndex = this.newlines[i];
          if (index2 > newlineIndex) {
            line = i + 2;
            column = index2 - newlineIndex;
            break;
          }
        }
        return {
          column,
          line,
          offset: index2
        };
      }
      peek() {
        return this.buffer.charCodeAt(this.index + 1);
      }
      stateText(c) {
        if (c === 60) {
          if (this.index > this.sectionStart) {
            this.cbs.ontext(this.sectionStart, this.index);
          }
          this.state = 5;
          this.sectionStart = this.index;
        } else if (!this.inVPre && c === this.delimiterOpen[0]) {
          this.state = 2;
          this.delimiterIndex = 0;
          this.stateInterpolationOpen(c);
        }
      }
      stateInterpolationOpen(c) {
        if (c === this.delimiterOpen[this.delimiterIndex]) {
          if (this.delimiterIndex === this.delimiterOpen.length - 1) {
            const start = this.index + 1 - this.delimiterOpen.length;
            if (start > this.sectionStart) {
              this.cbs.ontext(this.sectionStart, start);
            }
            this.state = 3;
            this.sectionStart = start;
          } else {
            this.delimiterIndex++;
          }
        } else if (this.inRCDATA) {
          this.state = 32;
          this.stateInRCDATA(c);
        } else {
          this.state = 1;
          this.stateText(c);
        }
      }
      stateInterpolation(c) {
        if (c === this.delimiterClose[0]) {
          this.state = 4;
          this.delimiterIndex = 0;
          this.stateInterpolationClose(c);
        }
      }
      stateInterpolationClose(c) {
        if (c === this.delimiterClose[this.delimiterIndex]) {
          if (this.delimiterIndex === this.delimiterClose.length - 1) {
            this.cbs.oninterpolation(this.sectionStart, this.index + 1);
            if (this.inRCDATA) {
              this.state = 32;
            } else {
              this.state = 1;
            }
            this.sectionStart = this.index + 1;
          } else {
            this.delimiterIndex++;
          }
        } else {
          this.state = 3;
          this.stateInterpolation(c);
        }
      }
      stateSpecialStartSequence(c) {
        const isEnd = this.sequenceIndex === this.currentSequence.length;
        const isMatch = isEnd ? (
          // If we are at the end of the sequence, make sure the tag name has ended
          isEndOfTagSection(c)
        ) : (
          // Otherwise, do a case-insensitive comparison
          (c | 32) === this.currentSequence[this.sequenceIndex]
        );
        if (!isMatch) {
          this.inRCDATA = false;
        } else if (!isEnd) {
          this.sequenceIndex++;
          return;
        }
        this.sequenceIndex = 0;
        this.state = 6;
        this.stateInTagName(c);
      }
      /** Look for an end tag. For <title> and <textarea>, also decode entities. */
      stateInRCDATA(c) {
        if (this.sequenceIndex === this.currentSequence.length) {
          if (c === 62 || isWhitespace(c)) {
            const endOfText = this.index - this.currentSequence.length;
            if (this.sectionStart < endOfText) {
              const actualIndex = this.index;
              this.index = endOfText;
              this.cbs.ontext(this.sectionStart, endOfText);
              this.index = actualIndex;
            }
            this.sectionStart = endOfText + 2;
            this.stateInClosingTagName(c);
            this.inRCDATA = false;
            return;
          }
          this.sequenceIndex = 0;
        }
        if ((c | 32) === this.currentSequence[this.sequenceIndex]) {
          this.sequenceIndex += 1;
        } else if (this.sequenceIndex === 0) {
          if (this.currentSequence === Sequences.TitleEnd || this.currentSequence === Sequences.TextareaEnd && !this.inSFCRoot) {
            if (c === this.delimiterOpen[0]) {
              this.state = 2;
              this.delimiterIndex = 0;
              this.stateInterpolationOpen(c);
            }
          } else if (this.fastForwardTo(60)) {
            this.sequenceIndex = 1;
          }
        } else {
          this.sequenceIndex = Number(c === 60);
        }
      }
      stateCDATASequence(c) {
        if (c === Sequences.Cdata[this.sequenceIndex]) {
          if (++this.sequenceIndex === Sequences.Cdata.length) {
            this.state = 28;
            this.currentSequence = Sequences.CdataEnd;
            this.sequenceIndex = 0;
            this.sectionStart = this.index + 1;
          }
        } else {
          this.sequenceIndex = 0;
          this.state = 23;
          this.stateInDeclaration(c);
        }
      }
      /**
       * When we wait for one specific character, we can speed things up
       * by skipping through the buffer until we find it.
       *
       * @returns Whether the character was found.
       */
      fastForwardTo(c) {
        while (++this.index < this.buffer.length) {
          const cc = this.buffer.charCodeAt(this.index);
          if (cc === 10) {
            this.newlines.push(this.index);
          }
          if (cc === c) {
            return true;
          }
        }
        this.index = this.buffer.length - 1;
        return false;
      }
      /**
       * Comments and CDATA end with `-->` and `]]>`.
       *
       * Their common qualities are:
       * - Their end sequences have a distinct character they start with.
       * - That character is then repeated, so we have to check multiple repeats.
       * - All characters but the start character of the sequence can be skipped.
       */
      stateInCommentLike(c) {
        if (c === this.currentSequence[this.sequenceIndex]) {
          if (++this.sequenceIndex === this.currentSequence.length) {
            if (this.currentSequence === Sequences.CdataEnd) {
              this.cbs.oncdata(this.sectionStart, this.index - 2);
            } else {
              this.cbs.oncomment(this.sectionStart, this.index - 2);
            }
            this.sequenceIndex = 0;
            this.sectionStart = this.index + 1;
            this.state = 1;
          }
        } else if (this.sequenceIndex === 0) {
          if (this.fastForwardTo(this.currentSequence[0])) {
            this.sequenceIndex = 1;
          }
        } else if (c !== this.currentSequence[this.sequenceIndex - 1]) {
          this.sequenceIndex = 0;
        }
      }
      startSpecial(sequence, offset2) {
        this.enterRCDATA(sequence, offset2);
        this.state = 31;
      }
      enterRCDATA(sequence, offset2) {
        this.inRCDATA = true;
        this.currentSequence = sequence;
        this.sequenceIndex = offset2;
      }
      stateBeforeTagName(c) {
        if (c === 33) {
          this.state = 22;
          this.sectionStart = this.index + 1;
        } else if (c === 63) {
          this.state = 24;
          this.sectionStart = this.index + 1;
        } else if (isTagStartChar(c)) {
          this.sectionStart = this.index;
          if (this.mode === 0) {
            this.state = 6;
          } else if (this.inSFCRoot) {
            this.state = 34;
          } else if (!this.inXML) {
            const lower = c | 32;
            if (lower === 116) {
              this.state = 30;
            } else {
              this.state = lower === 115 ? 29 : 6;
            }
          } else {
            this.state = 6;
          }
        } else if (c === 47) {
          this.state = 8;
        } else {
          this.state = 1;
          this.stateText(c);
        }
      }
      stateInTagName(c) {
        if (isEndOfTagSection(c)) {
          this.handleTagName(c);
        }
      }
      stateInSFCRootTagName(c) {
        if (isEndOfTagSection(c)) {
          const tag = this.buffer.slice(this.sectionStart, this.index);
          if (tag !== "template") {
            this.enterRCDATA(toCharCodes(`</` + tag), 0);
          }
          this.handleTagName(c);
        }
      }
      handleTagName(c) {
        this.cbs.onopentagname(this.sectionStart, this.index);
        this.sectionStart = -1;
        this.state = 11;
        this.stateBeforeAttrName(c);
      }
      stateBeforeClosingTagName(c) {
        if (isWhitespace(c))
          ;
        else if (c === 62) {
          if (true) {
            this.cbs.onerr(14, this.index);
          }
          this.state = 1;
          this.sectionStart = this.index + 1;
        } else {
          this.state = isTagStartChar(c) ? 9 : 27;
          this.sectionStart = this.index;
        }
      }
      stateInClosingTagName(c) {
        if (c === 62 || isWhitespace(c)) {
          this.cbs.onclosetag(this.sectionStart, this.index);
          this.sectionStart = -1;
          this.state = 10;
          this.stateAfterClosingTagName(c);
        }
      }
      stateAfterClosingTagName(c) {
        if (c === 62) {
          this.state = 1;
          this.sectionStart = this.index + 1;
        }
      }
      stateBeforeAttrName(c) {
        if (c === 62) {
          this.cbs.onopentagend(this.index);
          if (this.inRCDATA) {
            this.state = 32;
          } else {
            this.state = 1;
          }
          this.sectionStart = this.index + 1;
        } else if (c === 47) {
          this.state = 7;
          if (this.peek() !== 62) {
            this.cbs.onerr(22, this.index);
          }
        } else if (c === 60 && this.peek() === 47) {
          this.cbs.onopentagend(this.index);
          this.state = 5;
          this.sectionStart = this.index;
        } else if (!isWhitespace(c)) {
          if (c === 61) {
            this.cbs.onerr(
              19,
              this.index
            );
          }
          this.handleAttrStart(c);
        }
      }
      handleAttrStart(c) {
        if (c === 118 && this.peek() === 45) {
          this.state = 13;
          this.sectionStart = this.index;
        } else if (c === 46 || c === 58 || c === 64 || c === 35) {
          this.cbs.ondirname(this.index, this.index + 1);
          this.state = 14;
          this.sectionStart = this.index + 1;
        } else {
          this.state = 12;
          this.sectionStart = this.index;
        }
      }
      stateInSelfClosingTag(c) {
        if (c === 62) {
          this.cbs.onselfclosingtag(this.index);
          this.state = 1;
          this.sectionStart = this.index + 1;
          this.inRCDATA = false;
        } else if (!isWhitespace(c)) {
          this.state = 11;
          this.stateBeforeAttrName(c);
        }
      }
      stateInAttrName(c) {
        if (c === 61 || isEndOfTagSection(c)) {
          this.cbs.onattribname(this.sectionStart, this.index);
          this.handleAttrNameEnd(c);
        } else if (c === 34 || c === 39 || c === 60) {
          this.cbs.onerr(
            17,
            this.index
          );
        }
      }
      stateInDirName(c) {
        if (c === 61 || isEndOfTagSection(c)) {
          this.cbs.ondirname(this.sectionStart, this.index);
          this.handleAttrNameEnd(c);
        } else if (c === 58) {
          this.cbs.ondirname(this.sectionStart, this.index);
          this.state = 14;
          this.sectionStart = this.index + 1;
        } else if (c === 46) {
          this.cbs.ondirname(this.sectionStart, this.index);
          this.state = 16;
          this.sectionStart = this.index + 1;
        }
      }
      stateInDirArg(c) {
        if (c === 61 || isEndOfTagSection(c)) {
          this.cbs.ondirarg(this.sectionStart, this.index);
          this.handleAttrNameEnd(c);
        } else if (c === 91) {
          this.state = 15;
        } else if (c === 46) {
          this.cbs.ondirarg(this.sectionStart, this.index);
          this.state = 16;
          this.sectionStart = this.index + 1;
        }
      }
      stateInDynamicDirArg(c) {
        if (c === 93) {
          this.state = 14;
        } else if (c === 61 || isEndOfTagSection(c)) {
          this.cbs.ondirarg(this.sectionStart, this.index + 1);
          this.handleAttrNameEnd(c);
          if (true) {
            this.cbs.onerr(
              27,
              this.index
            );
          }
        }
      }
      stateInDirModifier(c) {
        if (c === 61 || isEndOfTagSection(c)) {
          this.cbs.ondirmodifier(this.sectionStart, this.index);
          this.handleAttrNameEnd(c);
        } else if (c === 46) {
          this.cbs.ondirmodifier(this.sectionStart, this.index);
          this.sectionStart = this.index + 1;
        }
      }
      handleAttrNameEnd(c) {
        this.sectionStart = this.index;
        this.state = 17;
        this.cbs.onattribnameend(this.index);
        this.stateAfterAttrName(c);
      }
      stateAfterAttrName(c) {
        if (c === 61) {
          this.state = 18;
        } else if (c === 47 || c === 62) {
          this.cbs.onattribend(0, this.sectionStart);
          this.sectionStart = -1;
          this.state = 11;
          this.stateBeforeAttrName(c);
        } else if (!isWhitespace(c)) {
          this.cbs.onattribend(0, this.sectionStart);
          this.handleAttrStart(c);
        }
      }
      stateBeforeAttrValue(c) {
        if (c === 34) {
          this.state = 19;
          this.sectionStart = this.index + 1;
        } else if (c === 39) {
          this.state = 20;
          this.sectionStart = this.index + 1;
        } else if (!isWhitespace(c)) {
          this.sectionStart = this.index;
          this.state = 21;
          this.stateInAttrValueNoQuotes(c);
        }
      }
      handleInAttrValue(c, quote) {
        if (c === quote || this.fastForwardTo(quote)) {
          this.cbs.onattribdata(this.sectionStart, this.index);
          this.sectionStart = -1;
          this.cbs.onattribend(
            quote === 34 ? 3 : 2,
            this.index + 1
          );
          this.state = 11;
        }
      }
      stateInAttrValueDoubleQuotes(c) {
        this.handleInAttrValue(c, 34);
      }
      stateInAttrValueSingleQuotes(c) {
        this.handleInAttrValue(c, 39);
      }
      stateInAttrValueNoQuotes(c) {
        if (isWhitespace(c) || c === 62) {
          this.cbs.onattribdata(this.sectionStart, this.index);
          this.sectionStart = -1;
          this.cbs.onattribend(1, this.index);
          this.state = 11;
          this.stateBeforeAttrName(c);
        } else if (c === 34 || c === 39 || c === 60 || c === 61 || c === 96) {
          this.cbs.onerr(
            18,
            this.index
          );
        } else
          ;
      }
      stateBeforeDeclaration(c) {
        if (c === 91) {
          this.state = 26;
          this.sequenceIndex = 0;
        } else {
          this.state = c === 45 ? 25 : 23;
        }
      }
      stateInDeclaration(c) {
        if (c === 62 || this.fastForwardTo(62)) {
          this.state = 1;
          this.sectionStart = this.index + 1;
        }
      }
      stateInProcessingInstruction(c) {
        if (c === 62 || this.fastForwardTo(62)) {
          this.cbs.onprocessinginstruction(this.sectionStart, this.index);
          this.state = 1;
          this.sectionStart = this.index + 1;
        }
      }
      stateBeforeComment(c) {
        if (c === 45) {
          this.state = 28;
          this.currentSequence = Sequences.CommentEnd;
          this.sequenceIndex = 2;
          this.sectionStart = this.index + 1;
        } else {
          this.state = 23;
        }
      }
      stateInSpecialComment(c) {
        if (c === 62 || this.fastForwardTo(62)) {
          this.cbs.oncomment(this.sectionStart, this.index);
          this.state = 1;
          this.sectionStart = this.index + 1;
        }
      }
      stateBeforeSpecialS(c) {
        const lower = c | 32;
        if (lower === Sequences.ScriptEnd[3]) {
          this.startSpecial(Sequences.ScriptEnd, 4);
        } else if (lower === Sequences.StyleEnd[3]) {
          this.startSpecial(Sequences.StyleEnd, 4);
        } else {
          this.state = 6;
          this.stateInTagName(c);
        }
      }
      stateBeforeSpecialT(c) {
        const lower = c | 32;
        if (lower === Sequences.TitleEnd[3]) {
          this.startSpecial(Sequences.TitleEnd, 4);
        } else if (lower === Sequences.TextareaEnd[3]) {
          this.startSpecial(Sequences.TextareaEnd, 4);
        } else {
          this.state = 6;
          this.stateInTagName(c);
        }
      }
      startEntity() {
      }
      stateInEntity() {
      }
      /**
       * Iterates through the buffer, calling the function corresponding to the current state.
       *
       * States that are more likely to be hit are higher up, as a performance improvement.
       */
      parse(input) {
        this.buffer = input;
        while (this.index < this.buffer.length) {
          const c = this.buffer.charCodeAt(this.index);
          if (c === 10) {
            this.newlines.push(this.index);
          }
          switch (this.state) {
            case 1: {
              this.stateText(c);
              break;
            }
            case 2: {
              this.stateInterpolationOpen(c);
              break;
            }
            case 3: {
              this.stateInterpolation(c);
              break;
            }
            case 4: {
              this.stateInterpolationClose(c);
              break;
            }
            case 31: {
              this.stateSpecialStartSequence(c);
              break;
            }
            case 32: {
              this.stateInRCDATA(c);
              break;
            }
            case 26: {
              this.stateCDATASequence(c);
              break;
            }
            case 19: {
              this.stateInAttrValueDoubleQuotes(c);
              break;
            }
            case 12: {
              this.stateInAttrName(c);
              break;
            }
            case 13: {
              this.stateInDirName(c);
              break;
            }
            case 14: {
              this.stateInDirArg(c);
              break;
            }
            case 15: {
              this.stateInDynamicDirArg(c);
              break;
            }
            case 16: {
              this.stateInDirModifier(c);
              break;
            }
            case 28: {
              this.stateInCommentLike(c);
              break;
            }
            case 27: {
              this.stateInSpecialComment(c);
              break;
            }
            case 11: {
              this.stateBeforeAttrName(c);
              break;
            }
            case 6: {
              this.stateInTagName(c);
              break;
            }
            case 34: {
              this.stateInSFCRootTagName(c);
              break;
            }
            case 9: {
              this.stateInClosingTagName(c);
              break;
            }
            case 5: {
              this.stateBeforeTagName(c);
              break;
            }
            case 17: {
              this.stateAfterAttrName(c);
              break;
            }
            case 20: {
              this.stateInAttrValueSingleQuotes(c);
              break;
            }
            case 18: {
              this.stateBeforeAttrValue(c);
              break;
            }
            case 8: {
              this.stateBeforeClosingTagName(c);
              break;
            }
            case 10: {
              this.stateAfterClosingTagName(c);
              break;
            }
            case 29: {
              this.stateBeforeSpecialS(c);
              break;
            }
            case 30: {
              this.stateBeforeSpecialT(c);
              break;
            }
            case 21: {
              this.stateInAttrValueNoQuotes(c);
              break;
            }
            case 7: {
              this.stateInSelfClosingTag(c);
              break;
            }
            case 23: {
              this.stateInDeclaration(c);
              break;
            }
            case 22: {
              this.stateBeforeDeclaration(c);
              break;
            }
            case 25: {
              this.stateBeforeComment(c);
              break;
            }
            case 24: {
              this.stateInProcessingInstruction(c);
              break;
            }
            case 33: {
              this.stateInEntity();
              break;
            }
          }
          this.index++;
        }
        this.cleanup();
        this.finish();
      }
      /**
       * Remove data that has already been consumed from the buffer.
       */
      cleanup() {
        if (this.sectionStart !== this.index) {
          if (this.state === 1 || this.state === 32 && this.sequenceIndex === 0) {
            this.cbs.ontext(this.sectionStart, this.index);
            this.sectionStart = this.index;
          } else if (this.state === 19 || this.state === 20 || this.state === 21) {
            this.cbs.onattribdata(this.sectionStart, this.index);
            this.sectionStart = this.index;
          }
        }
      }
      finish() {
        this.handleTrailingData();
        this.cbs.onend();
      }
      /** Handle any trailing data. */
      handleTrailingData() {
        const endIndex = this.buffer.length;
        if (this.sectionStart >= endIndex) {
          return;
        }
        if (this.state === 28) {
          if (this.currentSequence === Sequences.CdataEnd) {
            this.cbs.oncdata(this.sectionStart, endIndex);
          } else {
            this.cbs.oncomment(this.sectionStart, endIndex);
          }
        } else if (this.state === 6 || this.state === 11 || this.state === 18 || this.state === 17 || this.state === 12 || this.state === 13 || this.state === 14 || this.state === 15 || this.state === 16 || this.state === 20 || this.state === 19 || this.state === 21 || this.state === 9)
          ;
        else {
          this.cbs.ontext(this.sectionStart, endIndex);
        }
      }
      emitCodePoint(cp, consumed) {
      }
    };
    CompilerDeprecationTypes = {
      "COMPILER_IS_ON_ELEMENT": "COMPILER_IS_ON_ELEMENT",
      "COMPILER_V_BIND_SYNC": "COMPILER_V_BIND_SYNC",
      "COMPILER_V_BIND_OBJECT_ORDER": "COMPILER_V_BIND_OBJECT_ORDER",
      "COMPILER_V_ON_NATIVE": "COMPILER_V_ON_NATIVE",
      "COMPILER_V_IF_V_FOR_PRECEDENCE": "COMPILER_V_IF_V_FOR_PRECEDENCE",
      "COMPILER_NATIVE_TEMPLATE": "COMPILER_NATIVE_TEMPLATE",
      "COMPILER_INLINE_TEMPLATE": "COMPILER_INLINE_TEMPLATE",
      "COMPILER_FILTERS": "COMPILER_FILTERS"
    };
    deprecationData = {
      ["COMPILER_IS_ON_ELEMENT"]: {
        message: `Platform-native elements with "is" prop will no longer be treated as components in Vue 3 unless the "is" value is explicitly prefixed with "vue:".`,
        link: `https://v3-migration.vuejs.org/breaking-changes/custom-elements-interop.html`
      },
      ["COMPILER_V_BIND_SYNC"]: {
        message: (key) => `.sync modifier for v-bind has been removed. Use v-model with argument instead. \`v-bind:${key}.sync\` should be changed to \`v-model:${key}\`.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/v-model.html`
      },
      ["COMPILER_V_BIND_OBJECT_ORDER"]: {
        message: `v-bind="obj" usage is now order sensitive and behaves like JavaScript object spread: it will now overwrite an existing non-mergeable attribute that appears before v-bind in the case of conflict. To retain 2.x behavior, move v-bind to make it the first attribute. You can also suppress this warning if the usage is intended.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/v-bind.html`
      },
      ["COMPILER_V_ON_NATIVE"]: {
        message: `.native modifier for v-on has been removed as is no longer necessary.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/v-on-native-modifier-removed.html`
      },
      ["COMPILER_V_IF_V_FOR_PRECEDENCE"]: {
        message: `v-if / v-for precedence when used on the same element has changed in Vue 3: v-if now takes higher precedence and will no longer have access to v-for scope variables. It is best to avoid the ambiguity with <template> tags or use a computed property that filters v-for data source.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/v-if-v-for.html`
      },
      ["COMPILER_NATIVE_TEMPLATE"]: {
        message: `<template> with no special directives will render as a native template element instead of its inner content in Vue 3.`
      },
      ["COMPILER_INLINE_TEMPLATE"]: {
        message: `"inline-template" has been removed in Vue 3.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/inline-template-attribute.html`
      },
      ["COMPILER_FILTERS"]: {
        message: `filters have been removed in Vue 3. The "|" symbol will be treated as native JavaScript bitwise OR operator. Use method calls or computed properties instead.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/filters.html`
      }
    };
    ErrorCodes = {
      "ABRUPT_CLOSING_OF_EMPTY_COMMENT": 0,
      "0": "ABRUPT_CLOSING_OF_EMPTY_COMMENT",
      "CDATA_IN_HTML_CONTENT": 1,
      "1": "CDATA_IN_HTML_CONTENT",
      "DUPLICATE_ATTRIBUTE": 2,
      "2": "DUPLICATE_ATTRIBUTE",
      "END_TAG_WITH_ATTRIBUTES": 3,
      "3": "END_TAG_WITH_ATTRIBUTES",
      "END_TAG_WITH_TRAILING_SOLIDUS": 4,
      "4": "END_TAG_WITH_TRAILING_SOLIDUS",
      "EOF_BEFORE_TAG_NAME": 5,
      "5": "EOF_BEFORE_TAG_NAME",
      "EOF_IN_CDATA": 6,
      "6": "EOF_IN_CDATA",
      "EOF_IN_COMMENT": 7,
      "7": "EOF_IN_COMMENT",
      "EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT": 8,
      "8": "EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT",
      "EOF_IN_TAG": 9,
      "9": "EOF_IN_TAG",
      "INCORRECTLY_CLOSED_COMMENT": 10,
      "10": "INCORRECTLY_CLOSED_COMMENT",
      "INCORRECTLY_OPENED_COMMENT": 11,
      "11": "INCORRECTLY_OPENED_COMMENT",
      "INVALID_FIRST_CHARACTER_OF_TAG_NAME": 12,
      "12": "INVALID_FIRST_CHARACTER_OF_TAG_NAME",
      "MISSING_ATTRIBUTE_VALUE": 13,
      "13": "MISSING_ATTRIBUTE_VALUE",
      "MISSING_END_TAG_NAME": 14,
      "14": "MISSING_END_TAG_NAME",
      "MISSING_WHITESPACE_BETWEEN_ATTRIBUTES": 15,
      "15": "MISSING_WHITESPACE_BETWEEN_ATTRIBUTES",
      "NESTED_COMMENT": 16,
      "16": "NESTED_COMMENT",
      "UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME": 17,
      "17": "UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME",
      "UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE": 18,
      "18": "UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE",
      "UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME": 19,
      "19": "UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME",
      "UNEXPECTED_NULL_CHARACTER": 20,
      "20": "UNEXPECTED_NULL_CHARACTER",
      "UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME": 21,
      "21": "UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME",
      "UNEXPECTED_SOLIDUS_IN_TAG": 22,
      "22": "UNEXPECTED_SOLIDUS_IN_TAG",
      "X_INVALID_END_TAG": 23,
      "23": "X_INVALID_END_TAG",
      "X_MISSING_END_TAG": 24,
      "24": "X_MISSING_END_TAG",
      "X_MISSING_INTERPOLATION_END": 25,
      "25": "X_MISSING_INTERPOLATION_END",
      "X_MISSING_DIRECTIVE_NAME": 26,
      "26": "X_MISSING_DIRECTIVE_NAME",
      "X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END": 27,
      "27": "X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END",
      "X_V_IF_NO_EXPRESSION": 28,
      "28": "X_V_IF_NO_EXPRESSION",
      "X_V_IF_SAME_KEY": 29,
      "29": "X_V_IF_SAME_KEY",
      "X_V_ELSE_NO_ADJACENT_IF": 30,
      "30": "X_V_ELSE_NO_ADJACENT_IF",
      "X_V_FOR_NO_EXPRESSION": 31,
      "31": "X_V_FOR_NO_EXPRESSION",
      "X_V_FOR_MALFORMED_EXPRESSION": 32,
      "32": "X_V_FOR_MALFORMED_EXPRESSION",
      "X_V_FOR_TEMPLATE_KEY_PLACEMENT": 33,
      "33": "X_V_FOR_TEMPLATE_KEY_PLACEMENT",
      "X_V_BIND_NO_EXPRESSION": 34,
      "34": "X_V_BIND_NO_EXPRESSION",
      "X_V_ON_NO_EXPRESSION": 35,
      "35": "X_V_ON_NO_EXPRESSION",
      "X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET": 36,
      "36": "X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET",
      "X_V_SLOT_MIXED_SLOT_USAGE": 37,
      "37": "X_V_SLOT_MIXED_SLOT_USAGE",
      "X_V_SLOT_DUPLICATE_SLOT_NAMES": 38,
      "38": "X_V_SLOT_DUPLICATE_SLOT_NAMES",
      "X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN": 39,
      "39": "X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN",
      "X_V_SLOT_MISPLACED": 40,
      "40": "X_V_SLOT_MISPLACED",
      "X_V_MODEL_NO_EXPRESSION": 41,
      "41": "X_V_MODEL_NO_EXPRESSION",
      "X_V_MODEL_MALFORMED_EXPRESSION": 42,
      "42": "X_V_MODEL_MALFORMED_EXPRESSION",
      "X_V_MODEL_ON_SCOPE_VARIABLE": 43,
      "43": "X_V_MODEL_ON_SCOPE_VARIABLE",
      "X_V_MODEL_ON_PROPS": 44,
      "44": "X_V_MODEL_ON_PROPS",
      "X_INVALID_EXPRESSION": 45,
      "45": "X_INVALID_EXPRESSION",
      "X_KEEP_ALIVE_INVALID_CHILDREN": 46,
      "46": "X_KEEP_ALIVE_INVALID_CHILDREN",
      "X_PREFIX_ID_NOT_SUPPORTED": 47,
      "47": "X_PREFIX_ID_NOT_SUPPORTED",
      "X_MODULE_MODE_NOT_SUPPORTED": 48,
      "48": "X_MODULE_MODE_NOT_SUPPORTED",
      "X_CACHE_HANDLER_NOT_SUPPORTED": 49,
      "49": "X_CACHE_HANDLER_NOT_SUPPORTED",
      "X_SCOPE_ID_NOT_SUPPORTED": 50,
      "50": "X_SCOPE_ID_NOT_SUPPORTED",
      "X_VNODE_HOOKS": 51,
      "51": "X_VNODE_HOOKS",
      "__EXTEND_POINT__": 52,
      "52": "__EXTEND_POINT__"
    };
    errorMessages = {
      // parse errors
      [0]: "Illegal comment.",
      [1]: "CDATA section is allowed only in XML context.",
      [2]: "Duplicate attribute.",
      [3]: "End tag cannot have attributes.",
      [4]: "Illegal '/' in tags.",
      [5]: "Unexpected EOF in tag.",
      [6]: "Unexpected EOF in CDATA section.",
      [7]: "Unexpected EOF in comment.",
      [8]: "Unexpected EOF in script.",
      [9]: "Unexpected EOF in tag.",
      [10]: "Incorrectly closed comment.",
      [11]: "Incorrectly opened comment.",
      [12]: "Illegal tag name. Use '&lt;' to print '<'.",
      [13]: "Attribute value was expected.",
      [14]: "End tag name was expected.",
      [15]: "Whitespace was expected.",
      [16]: "Unexpected '<!--' in comment.",
      [17]: `Attribute name cannot contain U+0022 ("), U+0027 ('), and U+003C (<).`,
      [18]: "Unquoted attribute value cannot contain U+0022 (\"), U+0027 ('), U+003C (<), U+003D (=), and U+0060 (`).",
      [19]: "Attribute name cannot start with '='.",
      [21]: "'<?' is allowed only in XML context.",
      [20]: `Unexpected null character.`,
      [22]: "Illegal '/' in tags.",
      // Vue-specific parse errors
      [23]: "Invalid end tag.",
      [24]: "Element is missing end tag.",
      [25]: "Interpolation end sign was not found.",
      [27]: "End bracket for dynamic directive argument was not found. Note that dynamic directive argument cannot contain spaces.",
      [26]: "Legal directive name was expected.",
      // transform errors
      [28]: `v-if/v-else-if is missing expression.`,
      [29]: `v-if/else branches must use unique keys.`,
      [30]: `v-else/v-else-if has no adjacent v-if or v-else-if.`,
      [31]: `v-for is missing expression.`,
      [32]: `v-for has invalid expression.`,
      [33]: `<template v-for> key should be placed on the <template> tag.`,
      [34]: `v-bind is missing expression.`,
      [35]: `v-on is missing expression.`,
      [36]: `Unexpected custom directive on <slot> outlet.`,
      [37]: `Mixed v-slot usage on both the component and nested <template>. When there are multiple named slots, all slots should use <template> syntax to avoid scope ambiguity.`,
      [38]: `Duplicate slot names found. `,
      [39]: `Extraneous children found when component already has explicitly named default slot. These children will be ignored.`,
      [40]: `v-slot can only be used on components or <template> tags.`,
      [41]: `v-model is missing expression.`,
      [42]: `v-model value must be a valid JavaScript member expression.`,
      [43]: `v-model cannot be used on v-for or v-slot scope variables because they are not writable.`,
      [44]: `v-model cannot be used on a prop, because local prop bindings are not writable.
Use a v-bind binding combined with a v-on listener that emits update:x event instead.`,
      [45]: `Error parsing JavaScript expression: `,
      [46]: `<KeepAlive> expects exactly one child component.`,
      [51]: `@vnode-* hooks in templates are no longer supported. Use the vue: prefix instead. For example, @vnode-mounted should be changed to @vue:mounted. @vnode-* hooks support has been removed in 3.4.`,
      // generic errors
      [47]: `"prefixIdentifiers" option is not supported in this build of compiler.`,
      [48]: `ES module mode is not supported in this build of compiler.`,
      [49]: `"cacheHandlers" option is only supported when the "prefixIdentifiers" option is enabled.`,
      [50]: `"scopeId" option is only supported in module mode.`,
      // just to fulfill types
      [52]: ``
    };
    isFunctionType = (node) => {
      return /Function(?:Expression|Declaration)$|Method$/.test(node.type);
    };
    isStaticProperty = (node) => node && (node.type === "ObjectProperty" || node.type === "ObjectMethod") && !node.computed;
    isStaticPropertyKey = (node, parent) => isStaticProperty(parent) && parent.key === node;
    TS_NODE_TYPES = [
      "TSAsExpression",
      // foo as number
      "TSTypeAssertion",
      // (<number>foo)
      "TSNonNullExpression",
      // foo!
      "TSInstantiationExpression",
      // foo<string>
      "TSSatisfiesExpression"
      // foo satisfies T
    ];
    isStaticExp = (p2) => p2.type === 4 && p2.isStatic;
    nonIdentifierRE = /^\d|[^\$\w]/;
    isSimpleIdentifier = (name2) => !nonIdentifierRE.test(name2);
    validFirstIdentCharRE = /[A-Za-z_$\xA0-\uFFFF]/;
    validIdentCharRE = /[\.\?\w$\xA0-\uFFFF]/;
    whitespaceRE = /\s+[.[]\s*|\s*[.[]\s+/g;
    isMemberExpressionBrowser = (path) => {
      path = path.trim().replace(whitespaceRE, (s) => s.trim());
      let state = 0;
      let stateStack = [];
      let currentOpenBracketCount = 0;
      let currentOpenParensCount = 0;
      let currentStringType = null;
      for (let i = 0; i < path.length; i++) {
        const char = path.charAt(i);
        switch (state) {
          case 0:
            if (char === "[") {
              stateStack.push(state);
              state = 1;
              currentOpenBracketCount++;
            } else if (char === "(") {
              stateStack.push(state);
              state = 2;
              currentOpenParensCount++;
            } else if (!(i === 0 ? validFirstIdentCharRE : validIdentCharRE).test(char)) {
              return false;
            }
            break;
          case 1:
            if (char === `'` || char === `"` || char === "`") {
              stateStack.push(state);
              state = 3;
              currentStringType = char;
            } else if (char === `[`) {
              currentOpenBracketCount++;
            } else if (char === `]`) {
              if (!--currentOpenBracketCount) {
                state = stateStack.pop();
              }
            }
            break;
          case 2:
            if (char === `'` || char === `"` || char === "`") {
              stateStack.push(state);
              state = 3;
              currentStringType = char;
            } else if (char === `(`) {
              currentOpenParensCount++;
            } else if (char === `)`) {
              if (i === path.length - 1) {
                return false;
              }
              if (!--currentOpenParensCount) {
                state = stateStack.pop();
              }
            }
            break;
          case 3:
            if (char === currentStringType) {
              state = stateStack.pop();
              currentStringType = null;
            }
            break;
        }
      }
      return !currentOpenBracketCount && !currentOpenParensCount;
    };
    isMemberExpressionNode = NOOP;
    isMemberExpression = isMemberExpressionBrowser;
    propsHelperSet = /* @__PURE__ */ new Set([NORMALIZE_PROPS, GUARD_REACTIVE_PROPS]);
    forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/;
    defaultParserOptions = {
      parseMode: "base",
      ns: 0,
      delimiters: [`{{`, `}}`],
      getNamespace: () => 0,
      isVoidTag: NO,
      isPreTag: NO,
      isCustomElement: NO,
      onError: defaultOnError,
      onWarn: defaultOnWarn,
      comments: true,
      prefixIdentifiers: false
    };
    currentOptions = defaultParserOptions;
    currentRoot = null;
    currentInput = "";
    currentOpenTag = null;
    currentProp = null;
    currentAttrValue = "";
    currentAttrStartIndex = -1;
    currentAttrEndIndex = -1;
    inPre = 0;
    inVPre = false;
    currentVPreBoundary = null;
    stack = [];
    tokenizer = new Tokenizer(stack, {
      onerr: emitError,
      ontext(start, end) {
        onText(getSlice(start, end), start, end);
      },
      ontextentity(char, start, end) {
        onText(char, start, end);
      },
      oninterpolation(start, end) {
        if (inVPre) {
          return onText(getSlice(start, end), start, end);
        }
        let innerStart = start + tokenizer.delimiterOpen.length;
        let innerEnd = end - tokenizer.delimiterClose.length;
        while (isWhitespace(currentInput.charCodeAt(innerStart))) {
          innerStart++;
        }
        while (isWhitespace(currentInput.charCodeAt(innerEnd - 1))) {
          innerEnd--;
        }
        let exp = getSlice(innerStart, innerEnd);
        if (exp.includes("&")) {
          {
            exp = currentOptions.decodeEntities(exp, false);
          }
        }
        addNode({
          type: 5,
          content: createExp(exp, false, getLoc(innerStart, innerEnd)),
          loc: getLoc(start, end)
        });
      },
      onopentagname(start, end) {
        const name2 = getSlice(start, end);
        currentOpenTag = {
          type: 1,
          tag: name2,
          ns: currentOptions.getNamespace(name2, stack[0], currentOptions.ns),
          tagType: 0,
          // will be refined on tag close
          props: [],
          children: [],
          loc: getLoc(start - 1, end),
          codegenNode: void 0
        };
      },
      onopentagend(end) {
        endOpenTag(end);
      },
      onclosetag(start, end) {
        const name2 = getSlice(start, end);
        if (!currentOptions.isVoidTag(name2)) {
          let found = false;
          for (let i = 0; i < stack.length; i++) {
            const e = stack[i];
            if (e.tag.toLowerCase() === name2.toLowerCase()) {
              found = true;
              if (i > 0) {
                emitError(24, stack[0].loc.start.offset);
              }
              for (let j = 0; j <= i; j++) {
                const el = stack.shift();
                onCloseTag(el, end, j < i);
              }
              break;
            }
          }
          if (!found) {
            emitError(23, backTrack(start, 60));
          }
        }
      },
      onselfclosingtag(end) {
        var _a;
        const name2 = currentOpenTag.tag;
        currentOpenTag.isSelfClosing = true;
        endOpenTag(end);
        if (((_a = stack[0]) == null ? void 0 : _a.tag) === name2) {
          onCloseTag(stack.shift(), end);
        }
      },
      onattribname(start, end) {
        currentProp = {
          type: 6,
          name: getSlice(start, end),
          nameLoc: getLoc(start, end),
          value: void 0,
          loc: getLoc(start)
        };
      },
      ondirname(start, end) {
        const raw = getSlice(start, end);
        const name2 = raw === "." || raw === ":" ? "bind" : raw === "@" ? "on" : raw === "#" ? "slot" : raw.slice(2);
        if (!inVPre && name2 === "") {
          emitError(26, start);
        }
        if (inVPre || name2 === "") {
          currentProp = {
            type: 6,
            name: raw,
            nameLoc: getLoc(start, end),
            value: void 0,
            loc: getLoc(start)
          };
        } else {
          currentProp = {
            type: 7,
            name: name2,
            rawName: raw,
            exp: void 0,
            arg: void 0,
            modifiers: raw === "." ? ["prop"] : [],
            loc: getLoc(start)
          };
          if (name2 === "pre") {
            inVPre = tokenizer.inVPre = true;
            currentVPreBoundary = currentOpenTag;
            const props = currentOpenTag.props;
            for (let i = 0; i < props.length; i++) {
              if (props[i].type === 7) {
                props[i] = dirToAttr(props[i]);
              }
            }
          }
        }
      },
      ondirarg(start, end) {
        if (start === end)
          return;
        const arg = getSlice(start, end);
        if (inVPre) {
          currentProp.name += arg;
          setLocEnd(currentProp.nameLoc, end);
        } else {
          const isStatic = arg[0] !== `[`;
          currentProp.arg = createExp(
            isStatic ? arg : arg.slice(1, -1),
            isStatic,
            getLoc(start, end),
            isStatic ? 3 : 0
          );
        }
      },
      ondirmodifier(start, end) {
        const mod = getSlice(start, end);
        if (inVPre) {
          currentProp.name += "." + mod;
          setLocEnd(currentProp.nameLoc, end);
        } else if (currentProp.name === "slot") {
          const arg = currentProp.arg;
          if (arg) {
            arg.content += "." + mod;
            setLocEnd(arg.loc, end);
          }
        } else {
          currentProp.modifiers.push(mod);
        }
      },
      onattribdata(start, end) {
        currentAttrValue += getSlice(start, end);
        if (currentAttrStartIndex < 0)
          currentAttrStartIndex = start;
        currentAttrEndIndex = end;
      },
      onattribentity(char, start, end) {
        currentAttrValue += char;
        if (currentAttrStartIndex < 0)
          currentAttrStartIndex = start;
        currentAttrEndIndex = end;
      },
      onattribnameend(end) {
        const start = currentProp.loc.start.offset;
        const name2 = getSlice(start, end);
        if (currentProp.type === 7) {
          currentProp.rawName = name2;
        }
        if (currentOpenTag.props.some(
          (p2) => (p2.type === 7 ? p2.rawName : p2.name) === name2
        )) {
          emitError(2, start);
        }
      },
      onattribend(quote, end) {
        if (currentOpenTag && currentProp) {
          setLocEnd(currentProp.loc, end);
          if (quote !== 0) {
            if (currentAttrValue.includes("&")) {
              currentAttrValue = currentOptions.decodeEntities(
                currentAttrValue,
                true
              );
            }
            if (currentProp.type === 6) {
              if (currentProp.name === "class") {
                currentAttrValue = condense(currentAttrValue).trim();
              }
              if (quote === 1 && !currentAttrValue) {
                emitError(13, end);
              }
              currentProp.value = {
                type: 2,
                content: currentAttrValue,
                loc: quote === 1 ? getLoc(currentAttrStartIndex, currentAttrEndIndex) : getLoc(currentAttrStartIndex - 1, currentAttrEndIndex + 1)
              };
              if (tokenizer.inSFCRoot && currentOpenTag.tag === "template" && currentProp.name === "lang" && currentAttrValue && currentAttrValue !== "html") {
                tokenizer.enterRCDATA(toCharCodes(`</template`), 0);
              }
            } else {
              let expParseMode = 0;
              currentProp.exp = createExp(
                currentAttrValue,
                false,
                getLoc(currentAttrStartIndex, currentAttrEndIndex),
                0,
                expParseMode
              );
              if (currentProp.name === "for") {
                currentProp.forParseResult = parseForExpression(currentProp.exp);
              }
              let syncIndex = -1;
              if (currentProp.name === "bind" && (syncIndex = currentProp.modifiers.indexOf("sync")) > -1 && checkCompatEnabled(
                "COMPILER_V_BIND_SYNC",
                currentOptions,
                currentProp.loc,
                currentProp.rawName
              )) {
                currentProp.name = "model";
                currentProp.modifiers.splice(syncIndex, 1);
              }
            }
          }
          if (currentProp.type !== 7 || currentProp.name !== "pre") {
            currentOpenTag.props.push(currentProp);
          }
        }
        currentAttrValue = "";
        currentAttrStartIndex = currentAttrEndIndex = -1;
      },
      oncomment(start, end) {
        if (currentOptions.comments) {
          addNode({
            type: 3,
            content: getSlice(start, end),
            loc: getLoc(start - 4, end + 3)
          });
        }
      },
      onend() {
        const end = currentInput.length;
        if (tokenizer.state !== 1) {
          switch (tokenizer.state) {
            case 5:
            case 8:
              emitError(5, end);
              break;
            case 3:
            case 4:
              emitError(
                25,
                tokenizer.sectionStart
              );
              break;
            case 28:
              if (tokenizer.currentSequence === Sequences.CdataEnd) {
                emitError(6, end);
              } else {
                emitError(7, end);
              }
              break;
            case 6:
            case 7:
            case 9:
            case 11:
            case 12:
            case 13:
            case 14:
            case 15:
            case 16:
            case 17:
            case 18:
            case 19:
            case 20:
            case 21:
              emitError(9, end);
              break;
          }
        }
        for (let index2 = 0; index2 < stack.length; index2++) {
          onCloseTag(stack[index2], end - 1);
          emitError(24, stack[index2].loc.start.offset);
        }
      },
      oncdata(start, end) {
        if (stack[0].ns !== 0) {
          onText(getSlice(start, end), start, end);
        } else {
          emitError(1, start - 9);
        }
      },
      onprocessinginstruction(start) {
        if ((stack[0] ? stack[0].ns : currentOptions.ns) === 0) {
          emitError(
            21,
            start - 1
          );
        }
      }
    });
    forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
    stripParensRE = /^\(|\)$/g;
    specialTemplateDir = /* @__PURE__ */ new Set(["if", "else", "else-if", "for", "slot"]);
    windowsNewlineRE = /\r\n/g;
    allowHoistedHelperSet = /* @__PURE__ */ new Set([
      NORMALIZE_CLASS,
      NORMALIZE_STYLE,
      NORMALIZE_PROPS,
      GUARD_REACTIVE_PROPS
    ]);
    PURE_ANNOTATION = `/*#__PURE__*/`;
    aliasHelper = (s) => `${helperNameMap[s]}: _${helperNameMap[s]}`;
    prohibitedKeywordRE = new RegExp(
      "\\b" + "arguments,await,break,case,catch,class,const,continue,debugger,default,delete,do,else,export,extends,finally,for,function,if,import,let,new,return,super,switch,throw,try,var,void,while,with,yield".split(",").join("\\b|\\b") + "\\b"
    );
    stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g;
    transformExpression = (node, context2) => {
      if (node.type === 5) {
        node.content = processExpression(
          node.content,
          context2
        );
      } else if (node.type === 1) {
        for (let i = 0; i < node.props.length; i++) {
          const dir = node.props[i];
          if (dir.type === 7 && dir.name !== "for") {
            const exp = dir.exp;
            const arg = dir.arg;
            if (exp && exp.type === 4 && !(dir.name === "on" && arg)) {
              dir.exp = processExpression(
                exp,
                context2,
                // slot args must be processed as function params
                dir.name === "slot"
              );
            }
            if (arg && arg.type === 4 && !arg.isStatic) {
              dir.arg = processExpression(arg, context2);
            }
          }
        }
      }
    };
    transformIf = createStructuralDirectiveTransform(
      /^(if|else|else-if)$/,
      (node, dir, context2) => {
        return processIf(node, dir, context2, (ifNode, branch, isRoot) => {
          const siblings = context2.parent.children;
          let i = siblings.indexOf(ifNode);
          let key = 0;
          while (i-- >= 0) {
            const sibling = siblings[i];
            if (sibling && sibling.type === 9) {
              key += sibling.branches.length;
            }
          }
          return () => {
            if (isRoot) {
              ifNode.codegenNode = createCodegenNodeForBranch(
                branch,
                key,
                context2
              );
            } else {
              const parentCondition = getParentCondition(ifNode.codegenNode);
              parentCondition.alternate = createCodegenNodeForBranch(
                branch,
                key + ifNode.branches.length - 1,
                context2
              );
            }
          };
        });
      }
    );
    transformFor = createStructuralDirectiveTransform(
      "for",
      (node, dir, context2) => {
        const { helper, removeHelper } = context2;
        return processFor(node, dir, context2, (forNode) => {
          const renderExp = createCallExpression(helper(RENDER_LIST), [
            forNode.source
          ]);
          const isTemplate = isTemplateNode(node);
          const memo = findDir(node, "memo");
          const keyProp = findProp(node, `key`);
          const keyExp = keyProp && (keyProp.type === 6 ? createSimpleExpression(keyProp.value.content, true) : keyProp.exp);
          const keyProperty = keyProp ? createObjectProperty(`key`, keyExp) : null;
          const isStableFragment = forNode.source.type === 4 && forNode.source.constType > 0;
          const fragmentFlag = isStableFragment ? 64 : keyProp ? 128 : 256;
          forNode.codegenNode = createVNodeCall(
            context2,
            helper(FRAGMENT),
            void 0,
            renderExp,
            fragmentFlag + (true ? ` /* ${PatchFlagNames[fragmentFlag]} */` : ``),
            void 0,
            void 0,
            true,
            !isStableFragment,
            false,
            node.loc
          );
          return () => {
            let childBlock;
            const { children } = forNode;
            if (isTemplate) {
              node.children.some((c) => {
                if (c.type === 1) {
                  const key = findProp(c, "key");
                  if (key) {
                    context2.onError(
                      createCompilerError(
                        33,
                        key.loc
                      )
                    );
                    return true;
                  }
                }
              });
            }
            const needFragmentWrapper = children.length !== 1 || children[0].type !== 1;
            const slotOutlet = isSlotOutlet(node) ? node : isTemplate && node.children.length === 1 && isSlotOutlet(node.children[0]) ? node.children[0] : null;
            if (slotOutlet) {
              childBlock = slotOutlet.codegenNode;
              if (isTemplate && keyProperty) {
                injectProp(childBlock, keyProperty, context2);
              }
            } else if (needFragmentWrapper) {
              childBlock = createVNodeCall(
                context2,
                helper(FRAGMENT),
                keyProperty ? createObjectExpression([keyProperty]) : void 0,
                node.children,
                64 + (true ? ` /* ${PatchFlagNames[64]} */` : ``),
                void 0,
                void 0,
                true,
                void 0,
                false
              );
            } else {
              childBlock = children[0].codegenNode;
              if (isTemplate && keyProperty) {
                injectProp(childBlock, keyProperty, context2);
              }
              if (childBlock.isBlock !== !isStableFragment) {
                if (childBlock.isBlock) {
                  removeHelper(OPEN_BLOCK);
                  removeHelper(
                    getVNodeBlockHelper(context2.inSSR, childBlock.isComponent)
                  );
                } else {
                  removeHelper(
                    getVNodeHelper(context2.inSSR, childBlock.isComponent)
                  );
                }
              }
              childBlock.isBlock = !isStableFragment;
              if (childBlock.isBlock) {
                helper(OPEN_BLOCK);
                helper(getVNodeBlockHelper(context2.inSSR, childBlock.isComponent));
              } else {
                helper(getVNodeHelper(context2.inSSR, childBlock.isComponent));
              }
            }
            if (memo) {
              const loop = createFunctionExpression(
                createForLoopParams(forNode.parseResult, [
                  createSimpleExpression(`_cached`)
                ])
              );
              loop.body = createBlockStatement([
                createCompoundExpression([`const _memo = (`, memo.exp, `)`]),
                createCompoundExpression([
                  `if (_cached`,
                  ...keyExp ? [` && _cached.key === `, keyExp] : [],
                  ` && ${context2.helperString(
                    IS_MEMO_SAME
                  )}(_cached, _memo)) return _cached`
                ]),
                createCompoundExpression([`const _item = `, childBlock]),
                createSimpleExpression(`_item.memo = _memo`),
                createSimpleExpression(`return _item`)
              ]);
              renderExp.arguments.push(
                loop,
                createSimpleExpression(`_cache`),
                createSimpleExpression(String(context2.cached++))
              );
            } else {
              renderExp.arguments.push(
                createFunctionExpression(
                  createForLoopParams(forNode.parseResult),
                  childBlock,
                  true
                )
              );
            }
          };
        });
      }
    );
    defaultFallback = createSimpleExpression(`undefined`, false);
    trackSlotScopes = (node, context2) => {
      if (node.type === 1 && (node.tagType === 1 || node.tagType === 3)) {
        const vSlot = findDir(node, "slot");
        if (vSlot) {
          vSlot.exp;
          context2.scopes.vSlot++;
          return () => {
            context2.scopes.vSlot--;
          };
        }
      }
    };
    trackVForSlotScopes = (node, context2) => {
      let vFor;
      if (isTemplateNode(node) && node.props.some(isVSlot) && (vFor = findDir(node, "for"))) {
        const result2 = vFor.forParseResult;
        if (result2) {
          finalizeForParseResult(result2, context2);
          const { value: value2, key, index: index2 } = result2;
          const { addIdentifiers, removeIdentifiers } = context2;
          value2 && addIdentifiers(value2);
          key && addIdentifiers(key);
          index2 && addIdentifiers(index2);
          return () => {
            value2 && removeIdentifiers(value2);
            key && removeIdentifiers(key);
            index2 && removeIdentifiers(index2);
          };
        }
      }
    };
    buildClientSlotFn = (props, _vForExp, children, loc) => createFunctionExpression(
      props,
      children,
      false,
      true,
      children.length ? children[0].loc : loc
    );
    directiveImportMap = /* @__PURE__ */ new WeakMap();
    transformElement = (node, context2) => {
      return function postTransformElement() {
        node = context2.currentNode;
        if (!(node.type === 1 && (node.tagType === 0 || node.tagType === 1))) {
          return;
        }
        const { tag, props } = node;
        const isComponent2 = node.tagType === 1;
        let vnodeTag = isComponent2 ? resolveComponentType(node, context2) : `"${tag}"`;
        const isDynamicComponent = isObject(vnodeTag) && vnodeTag.callee === RESOLVE_DYNAMIC_COMPONENT;
        let vnodeProps;
        let vnodeChildren;
        let vnodePatchFlag;
        let patchFlag = 0;
        let vnodeDynamicProps;
        let dynamicPropNames;
        let vnodeDirectives;
        let shouldUseBlock = (
          // dynamic component may resolve to plain elements
          isDynamicComponent || vnodeTag === TELEPORT || vnodeTag === SUSPENSE || !isComponent2 && // <svg> and <foreignObject> must be forced into blocks so that block
          // updates inside get proper isSVG flag at runtime. (#639, #643)
          // This is technically web-specific, but splitting the logic out of core
          // leads to too much unnecessary complexity.
          (tag === "svg" || tag === "foreignObject")
        );
        if (props.length > 0) {
          const propsBuildResult = buildProps(
            node,
            context2,
            void 0,
            isComponent2,
            isDynamicComponent
          );
          vnodeProps = propsBuildResult.props;
          patchFlag = propsBuildResult.patchFlag;
          dynamicPropNames = propsBuildResult.dynamicPropNames;
          const directives = propsBuildResult.directives;
          vnodeDirectives = directives && directives.length ? createArrayExpression(
            directives.map((dir) => buildDirectiveArgs(dir, context2))
          ) : void 0;
          if (propsBuildResult.shouldUseBlock) {
            shouldUseBlock = true;
          }
        }
        if (node.children.length > 0) {
          if (vnodeTag === KEEP_ALIVE) {
            shouldUseBlock = true;
            patchFlag |= 1024;
            if (node.children.length > 1) {
              context2.onError(
                createCompilerError(46, {
                  start: node.children[0].loc.start,
                  end: node.children[node.children.length - 1].loc.end,
                  source: ""
                })
              );
            }
          }
          const shouldBuildAsSlots = isComponent2 && // Teleport is not a real component and has dedicated runtime handling
          vnodeTag !== TELEPORT && // explained above.
          vnodeTag !== KEEP_ALIVE;
          if (shouldBuildAsSlots) {
            const { slots, hasDynamicSlots } = buildSlots(node, context2);
            vnodeChildren = slots;
            if (hasDynamicSlots) {
              patchFlag |= 1024;
            }
          } else if (node.children.length === 1 && vnodeTag !== TELEPORT) {
            const child = node.children[0];
            const type2 = child.type;
            const hasDynamicTextChild = type2 === 5 || type2 === 8;
            if (hasDynamicTextChild && getConstantType(child, context2) === 0) {
              patchFlag |= 1;
            }
            if (hasDynamicTextChild || type2 === 2) {
              vnodeChildren = child;
            } else {
              vnodeChildren = node.children;
            }
          } else {
            vnodeChildren = node.children;
          }
        }
        if (patchFlag !== 0) {
          if (true) {
            if (patchFlag < 0) {
              vnodePatchFlag = patchFlag + ` /* ${PatchFlagNames[patchFlag]} */`;
            } else {
              const flagNames = Object.keys(PatchFlagNames).map(Number).filter((n) => n > 0 && patchFlag & n).map((n) => PatchFlagNames[n]).join(`, `);
              vnodePatchFlag = patchFlag + ` /* ${flagNames} */`;
            }
          } else {
            vnodePatchFlag = String(patchFlag);
          }
          if (dynamicPropNames && dynamicPropNames.length) {
            vnodeDynamicProps = stringifyDynamicPropNames(dynamicPropNames);
          }
        }
        node.codegenNode = createVNodeCall(
          context2,
          vnodeTag,
          vnodeProps,
          vnodeChildren,
          vnodePatchFlag,
          vnodeDynamicProps,
          vnodeDirectives,
          !!shouldUseBlock,
          false,
          isComponent2,
          node.loc
        );
      };
    };
    transformSlotOutlet = (node, context2) => {
      if (isSlotOutlet(node)) {
        const { children, loc } = node;
        const { slotName, slotProps } = processSlotOutlet(node, context2);
        const slotArgs = [
          context2.prefixIdentifiers ? `_ctx.$slots` : `$slots`,
          slotName,
          "{}",
          "undefined",
          "true"
        ];
        let expectedLen = 2;
        if (slotProps) {
          slotArgs[2] = slotProps;
          expectedLen = 3;
        }
        if (children.length) {
          slotArgs[3] = createFunctionExpression([], children, false, false, loc);
          expectedLen = 4;
        }
        if (context2.scopeId && !context2.slotted) {
          expectedLen = 5;
        }
        slotArgs.splice(expectedLen);
        node.codegenNode = createCallExpression(
          context2.helper(RENDER_SLOT),
          slotArgs,
          loc
        );
      }
    };
    fnExpRE = /^\s*([\w$_]+|(async\s*)?\([^)]*?\))\s*(:[^=]+)?=>|^\s*(async\s+)?function(?:\s+[\w$]+)?\s*\(/;
    transformOn = (dir, node, context2, augmentor) => {
      const { loc, modifiers, arg } = dir;
      if (!dir.exp && !modifiers.length) {
        context2.onError(createCompilerError(35, loc));
      }
      let eventName;
      if (arg.type === 4) {
        if (arg.isStatic) {
          let rawName = arg.content;
          if (rawName.startsWith("vnode")) {
            context2.onError(createCompilerError(51, arg.loc));
          }
          if (rawName.startsWith("vue:")) {
            rawName = `vnode-${rawName.slice(4)}`;
          }
          const eventString = node.tagType !== 0 || rawName.startsWith("vnode") || !/[A-Z]/.test(rawName) ? (
            // for non-element and vnode lifecycle event listeners, auto convert
            // it to camelCase. See issue #2249
            toHandlerKey(camelize(rawName))
          ) : (
            // preserve case for plain element listeners that have uppercase
            // letters, as these may be custom elements' custom events
            `on:${rawName}`
          );
          eventName = createSimpleExpression(eventString, true, arg.loc);
        } else {
          eventName = createCompoundExpression([
            `${context2.helperString(TO_HANDLER_KEY)}(`,
            arg,
            `)`
          ]);
        }
      } else {
        eventName = arg;
        eventName.children.unshift(`${context2.helperString(TO_HANDLER_KEY)}(`);
        eventName.children.push(`)`);
      }
      let exp = dir.exp;
      if (exp && !exp.content.trim()) {
        exp = void 0;
      }
      let shouldCache = context2.cacheHandlers && !exp && !context2.inVOnce;
      if (exp) {
        const isMemberExp = isMemberExpression(exp.content);
        const isInlineStatement = !(isMemberExp || fnExpRE.test(exp.content));
        const hasMultipleStatements = exp.content.includes(`;`);
        if (true) {
          validateBrowserExpression(
            exp,
            context2,
            false,
            hasMultipleStatements
          );
        }
        if (isInlineStatement || shouldCache && isMemberExp) {
          exp = createCompoundExpression([
            `${isInlineStatement ? `$event` : `${``}(...args)`} => ${hasMultipleStatements ? `{` : `(`}`,
            exp,
            hasMultipleStatements ? `}` : `)`
          ]);
        }
      }
      let ret = {
        props: [
          createObjectProperty(
            eventName,
            exp || createSimpleExpression(`() => {}`, false, loc)
          )
        ]
      };
      if (augmentor) {
        ret = augmentor(ret);
      }
      if (shouldCache) {
        ret.props[0].value = context2.cache(ret.props[0].value);
      }
      ret.props.forEach((p2) => p2.key.isHandlerKey = true);
      return ret;
    };
    transformBind = (dir, _node, context2) => {
      const { modifiers, loc } = dir;
      const arg = dir.arg;
      let { exp } = dir;
      if (!exp && arg.type === 4) {
        const propName = camelize(arg.content);
        exp = dir.exp = createSimpleExpression(propName, false, arg.loc);
      }
      if (arg.type !== 4) {
        arg.children.unshift(`(`);
        arg.children.push(`) || ""`);
      } else if (!arg.isStatic) {
        arg.content = `${arg.content} || ""`;
      }
      if (modifiers.includes("camel")) {
        if (arg.type === 4) {
          if (arg.isStatic) {
            arg.content = camelize(arg.content);
          } else {
            arg.content = `${context2.helperString(CAMELIZE)}(${arg.content})`;
          }
        } else {
          arg.children.unshift(`${context2.helperString(CAMELIZE)}(`);
          arg.children.push(`)`);
        }
      }
      if (!context2.inSSR) {
        if (modifiers.includes("prop")) {
          injectPrefix(arg, ".");
        }
        if (modifiers.includes("attr")) {
          injectPrefix(arg, "^");
        }
      }
      if (!exp || exp.type === 4 && !exp.content.trim()) {
        context2.onError(createCompilerError(34, loc));
        return {
          props: [createObjectProperty(arg, createSimpleExpression("", true, loc))]
        };
      }
      return {
        props: [createObjectProperty(arg, exp)]
      };
    };
    injectPrefix = (arg, prefix) => {
      if (arg.type === 4) {
        if (arg.isStatic) {
          arg.content = prefix + arg.content;
        } else {
          arg.content = `\`${prefix}\${${arg.content}}\``;
        }
      } else {
        arg.children.unshift(`'${prefix}' + (`);
        arg.children.push(`)`);
      }
    };
    transformText = (node, context2) => {
      if (node.type === 0 || node.type === 1 || node.type === 11 || node.type === 10) {
        return () => {
          const children = node.children;
          let currentContainer = void 0;
          let hasText = false;
          for (let i = 0; i < children.length; i++) {
            const child = children[i];
            if (isText$1(child)) {
              hasText = true;
              for (let j = i + 1; j < children.length; j++) {
                const next = children[j];
                if (isText$1(next)) {
                  if (!currentContainer) {
                    currentContainer = children[i] = createCompoundExpression(
                      [child],
                      child.loc
                    );
                  }
                  currentContainer.children.push(` + `, next);
                  children.splice(j, 1);
                  j--;
                } else {
                  currentContainer = void 0;
                  break;
                }
              }
            }
          }
          if (!hasText || // if this is a plain element with a single text child, leave it
          // as-is since the runtime has dedicated fast path for this by directly
          // setting textContent of the element.
          // for component root it's always normalized anyway.
          children.length === 1 && (node.type === 0 || node.type === 1 && node.tagType === 0 && // #3756
          // custom directives can potentially add DOM elements arbitrarily,
          // we need to avoid setting textContent of the element at runtime
          // to avoid accidentally overwriting the DOM elements added
          // by the user through custom directives.
          !node.props.find(
            (p2) => p2.type === 7 && !context2.directiveTransforms[p2.name]
          ) && // in compat mode, <template> tags with no special directives
          // will be rendered as a fragment so its children must be
          // converted into vnodes.
          !(node.tag === "template"))) {
            return;
          }
          for (let i = 0; i < children.length; i++) {
            const child = children[i];
            if (isText$1(child) || child.type === 8) {
              const callArgs = [];
              if (child.type !== 2 || child.content !== " ") {
                callArgs.push(child);
              }
              if (!context2.ssr && getConstantType(child, context2) === 0) {
                callArgs.push(
                  1 + (true ? ` /* ${PatchFlagNames[1]} */` : ``)
                );
              }
              children[i] = {
                type: 12,
                content: child,
                loc: child.loc,
                codegenNode: createCallExpression(
                  context2.helper(CREATE_TEXT),
                  callArgs
                )
              };
            }
          }
        };
      }
    };
    seen$1 = /* @__PURE__ */ new WeakSet();
    transformOnce = (node, context2) => {
      if (node.type === 1 && findDir(node, "once", true)) {
        if (seen$1.has(node) || context2.inVOnce || context2.inSSR) {
          return;
        }
        seen$1.add(node);
        context2.inVOnce = true;
        context2.helper(SET_BLOCK_TRACKING);
        return () => {
          context2.inVOnce = false;
          const cur = context2.currentNode;
          if (cur.codegenNode) {
            cur.codegenNode = context2.cache(
              cur.codegenNode,
              true
              /* isVNode */
            );
          }
        };
      }
    };
    transformModel = (dir, node, context2) => {
      const { exp, arg } = dir;
      if (!exp) {
        context2.onError(
          createCompilerError(41, dir.loc)
        );
        return createTransformProps();
      }
      const rawExp = exp.loc.source;
      const expString = exp.type === 4 ? exp.content : rawExp;
      const bindingType = context2.bindingMetadata[rawExp];
      if (bindingType === "props" || bindingType === "props-aliased") {
        context2.onError(createCompilerError(44, exp.loc));
        return createTransformProps();
      }
      const maybeRef = false;
      if (!expString.trim() || !isMemberExpression(expString) && !maybeRef) {
        context2.onError(
          createCompilerError(42, exp.loc)
        );
        return createTransformProps();
      }
      const propName = arg ? arg : createSimpleExpression("modelValue", true);
      const eventName = arg ? isStaticExp(arg) ? `onUpdate:${camelize(arg.content)}` : createCompoundExpression(['"onUpdate:" + ', arg]) : `onUpdate:modelValue`;
      let assignmentExp;
      const eventArg = context2.isTS ? `($event: any)` : `$event`;
      {
        assignmentExp = createCompoundExpression([
          `${eventArg} => ((`,
          exp,
          `) = $event)`
        ]);
      }
      const props = [
        // modelValue: foo
        createObjectProperty(propName, dir.exp),
        // "onUpdate:modelValue": $event => (foo = $event)
        createObjectProperty(eventName, assignmentExp)
      ];
      if (dir.modifiers.length && node.tagType === 1) {
        const modifiers = dir.modifiers.map((m) => (isSimpleIdentifier(m) ? m : JSON.stringify(m)) + `: true`).join(`, `);
        const modifiersKey = arg ? isStaticExp(arg) ? `${arg.content}Modifiers` : createCompoundExpression([arg, ' + "Modifiers"']) : `modelModifiers`;
        props.push(
          createObjectProperty(
            modifiersKey,
            createSimpleExpression(
              `{ ${modifiers} }`,
              false,
              dir.loc,
              2
            )
          )
        );
      }
      return createTransformProps(props);
    };
    validDivisionCharRE = /[\w).+\-_$\]]/;
    transformFilter = (node, context2) => {
      if (!isCompatEnabled("COMPILER_FILTERS", context2)) {
        return;
      }
      if (node.type === 5) {
        rewriteFilter(node.content, context2);
      }
      if (node.type === 1) {
        node.props.forEach((prop) => {
          if (prop.type === 7 && prop.name !== "for" && prop.exp) {
            rewriteFilter(prop.exp, context2);
          }
        });
      }
    };
    seen = /* @__PURE__ */ new WeakSet();
    transformMemo = (node, context2) => {
      if (node.type === 1) {
        const dir = findDir(node, "memo");
        if (!dir || seen.has(node)) {
          return;
        }
        seen.add(node);
        return () => {
          const codegenNode = node.codegenNode || context2.currentNode.codegenNode;
          if (codegenNode && codegenNode.type === 13) {
            if (node.tagType !== 1) {
              convertToBlock(codegenNode, context2);
            }
            node.codegenNode = createCallExpression(context2.helper(WITH_MEMO), [
              dir.exp,
              createFunctionExpression(void 0, codegenNode),
              `_cache`,
              String(context2.cached++)
            ]);
          }
        };
      }
    };
    BindingTypes = {
      "DATA": "data",
      "PROPS": "props",
      "PROPS_ALIASED": "props-aliased",
      "SETUP_LET": "setup-let",
      "SETUP_CONST": "setup-const",
      "SETUP_REACTIVE_CONST": "setup-reactive-const",
      "SETUP_MAYBE_REF": "setup-maybe-ref",
      "SETUP_REF": "setup-ref",
      "OPTIONS": "options",
      "LITERAL_CONST": "literal-const"
    };
    noopDirectiveTransform = () => ({ props: [] });
  }
});

// node_modules/@vue/compiler-dom/dist/compiler-dom.esm-bundler.js
var compiler_dom_esm_bundler_exports = {};
__export(compiler_dom_esm_bundler_exports, {
  BASE_TRANSITION: () => BASE_TRANSITION,
  BindingTypes: () => BindingTypes,
  CAMELIZE: () => CAMELIZE,
  CAPITALIZE: () => CAPITALIZE,
  CREATE_BLOCK: () => CREATE_BLOCK,
  CREATE_COMMENT: () => CREATE_COMMENT,
  CREATE_ELEMENT_BLOCK: () => CREATE_ELEMENT_BLOCK,
  CREATE_ELEMENT_VNODE: () => CREATE_ELEMENT_VNODE,
  CREATE_SLOTS: () => CREATE_SLOTS,
  CREATE_STATIC: () => CREATE_STATIC,
  CREATE_TEXT: () => CREATE_TEXT,
  CREATE_VNODE: () => CREATE_VNODE,
  CompilerDeprecationTypes: () => CompilerDeprecationTypes,
  ConstantTypes: () => ConstantTypes,
  DOMDirectiveTransforms: () => DOMDirectiveTransforms,
  DOMErrorCodes: () => DOMErrorCodes,
  DOMErrorMessages: () => DOMErrorMessages,
  DOMNodeTransforms: () => DOMNodeTransforms,
  ElementTypes: () => ElementTypes,
  ErrorCodes: () => ErrorCodes,
  FRAGMENT: () => FRAGMENT,
  GUARD_REACTIVE_PROPS: () => GUARD_REACTIVE_PROPS,
  IS_MEMO_SAME: () => IS_MEMO_SAME,
  IS_REF: () => IS_REF,
  KEEP_ALIVE: () => KEEP_ALIVE,
  MERGE_PROPS: () => MERGE_PROPS,
  NORMALIZE_CLASS: () => NORMALIZE_CLASS,
  NORMALIZE_PROPS: () => NORMALIZE_PROPS,
  NORMALIZE_STYLE: () => NORMALIZE_STYLE,
  Namespaces: () => Namespaces,
  NodeTypes: () => NodeTypes,
  OPEN_BLOCK: () => OPEN_BLOCK,
  POP_SCOPE_ID: () => POP_SCOPE_ID,
  PUSH_SCOPE_ID: () => PUSH_SCOPE_ID,
  RENDER_LIST: () => RENDER_LIST,
  RENDER_SLOT: () => RENDER_SLOT,
  RESOLVE_COMPONENT: () => RESOLVE_COMPONENT,
  RESOLVE_DIRECTIVE: () => RESOLVE_DIRECTIVE,
  RESOLVE_DYNAMIC_COMPONENT: () => RESOLVE_DYNAMIC_COMPONENT,
  RESOLVE_FILTER: () => RESOLVE_FILTER,
  SET_BLOCK_TRACKING: () => SET_BLOCK_TRACKING,
  SUSPENSE: () => SUSPENSE,
  TELEPORT: () => TELEPORT,
  TO_DISPLAY_STRING: () => TO_DISPLAY_STRING,
  TO_HANDLERS: () => TO_HANDLERS,
  TO_HANDLER_KEY: () => TO_HANDLER_KEY,
  TRANSITION: () => TRANSITION,
  TRANSITION_GROUP: () => TRANSITION_GROUP,
  TS_NODE_TYPES: () => TS_NODE_TYPES,
  UNREF: () => UNREF,
  V_MODEL_CHECKBOX: () => V_MODEL_CHECKBOX,
  V_MODEL_DYNAMIC: () => V_MODEL_DYNAMIC,
  V_MODEL_RADIO: () => V_MODEL_RADIO,
  V_MODEL_SELECT: () => V_MODEL_SELECT,
  V_MODEL_TEXT: () => V_MODEL_TEXT,
  V_ON_WITH_KEYS: () => V_ON_WITH_KEYS,
  V_ON_WITH_MODIFIERS: () => V_ON_WITH_MODIFIERS,
  V_SHOW: () => V_SHOW,
  WITH_CTX: () => WITH_CTX,
  WITH_DIRECTIVES: () => WITH_DIRECTIVES,
  WITH_MEMO: () => WITH_MEMO,
  advancePositionWithClone: () => advancePositionWithClone,
  advancePositionWithMutation: () => advancePositionWithMutation,
  assert: () => assert,
  baseCompile: () => baseCompile,
  baseParse: () => baseParse,
  buildDirectiveArgs: () => buildDirectiveArgs,
  buildProps: () => buildProps,
  buildSlots: () => buildSlots,
  checkCompatEnabled: () => checkCompatEnabled,
  compile: () => compile,
  convertToBlock: () => convertToBlock,
  createArrayExpression: () => createArrayExpression,
  createAssignmentExpression: () => createAssignmentExpression,
  createBlockStatement: () => createBlockStatement,
  createCacheExpression: () => createCacheExpression,
  createCallExpression: () => createCallExpression,
  createCompilerError: () => createCompilerError,
  createCompoundExpression: () => createCompoundExpression,
  createConditionalExpression: () => createConditionalExpression,
  createDOMCompilerError: () => createDOMCompilerError,
  createForLoopParams: () => createForLoopParams,
  createFunctionExpression: () => createFunctionExpression,
  createIfStatement: () => createIfStatement,
  createInterpolation: () => createInterpolation,
  createObjectExpression: () => createObjectExpression,
  createObjectProperty: () => createObjectProperty,
  createReturnStatement: () => createReturnStatement,
  createRoot: () => createRoot,
  createSequenceExpression: () => createSequenceExpression,
  createSimpleExpression: () => createSimpleExpression,
  createStructuralDirectiveTransform: () => createStructuralDirectiveTransform,
  createTemplateLiteral: () => createTemplateLiteral,
  createTransformContext: () => createTransformContext,
  createVNodeCall: () => createVNodeCall,
  errorMessages: () => errorMessages,
  extractIdentifiers: () => extractIdentifiers,
  findDir: () => findDir,
  findProp: () => findProp,
  forAliasRE: () => forAliasRE,
  generate: () => generate,
  generateCodeFrame: () => generateCodeFrame,
  getBaseTransformPreset: () => getBaseTransformPreset,
  getConstantType: () => getConstantType,
  getMemoedVNodeCall: () => getMemoedVNodeCall,
  getVNodeBlockHelper: () => getVNodeBlockHelper,
  getVNodeHelper: () => getVNodeHelper,
  hasDynamicKeyVBind: () => hasDynamicKeyVBind,
  hasScopeRef: () => hasScopeRef,
  helperNameMap: () => helperNameMap,
  injectProp: () => injectProp,
  isCoreComponent: () => isCoreComponent,
  isFunctionType: () => isFunctionType,
  isInDestructureAssignment: () => isInDestructureAssignment,
  isInNewExpression: () => isInNewExpression,
  isMemberExpression: () => isMemberExpression,
  isMemberExpressionBrowser: () => isMemberExpressionBrowser,
  isMemberExpressionNode: () => isMemberExpressionNode,
  isReferencedIdentifier: () => isReferencedIdentifier,
  isSimpleIdentifier: () => isSimpleIdentifier,
  isSlotOutlet: () => isSlotOutlet,
  isStaticArgOf: () => isStaticArgOf,
  isStaticExp: () => isStaticExp,
  isStaticProperty: () => isStaticProperty,
  isStaticPropertyKey: () => isStaticPropertyKey,
  isTemplateNode: () => isTemplateNode,
  isText: () => isText$1,
  isVSlot: () => isVSlot,
  locStub: () => locStub,
  noopDirectiveTransform: () => noopDirectiveTransform,
  parse: () => parse,
  parserOptions: () => parserOptions,
  processExpression: () => processExpression,
  processFor: () => processFor,
  processIf: () => processIf,
  processSlotOutlet: () => processSlotOutlet,
  registerRuntimeHelpers: () => registerRuntimeHelpers,
  resolveComponentType: () => resolveComponentType,
  stringifyExpression: () => stringifyExpression,
  toValidAssetId: () => toValidAssetId,
  trackSlotScopes: () => trackSlotScopes,
  trackVForSlotScopes: () => trackVForSlotScopes,
  transform: () => transform,
  transformBind: () => transformBind,
  transformElement: () => transformElement,
  transformExpression: () => transformExpression,
  transformModel: () => transformModel,
  transformOn: () => transformOn,
  transformStyle: () => transformStyle,
  traverseNode: () => traverseNode,
  unwrapTSNode: () => unwrapTSNode,
  walkBlockDeclarations: () => walkBlockDeclarations,
  walkFunctionParams: () => walkFunctionParams,
  walkIdentifiers: () => walkIdentifiers,
  warnDeprecation: () => warnDeprecation
});
function decodeHtmlBrowser(raw, asAttr = false) {
  if (!decoder) {
    decoder = document.createElement("div");
  }
  if (asAttr) {
    decoder.innerHTML = `<div foo="${raw.replace(/"/g, "&quot;")}">`;
    return decoder.children[0].getAttribute("foo");
  } else {
    decoder.innerHTML = raw;
    return decoder.textContent;
  }
}
function createDOMCompilerError(code, loc) {
  return createCompilerError(
    code,
    loc,
    true ? DOMErrorMessages : void 0
  );
}
function hasMultipleChildren(node) {
  const children = node.children = node.children.filter(
    (c) => c.type !== 3 && !(c.type === 2 && !c.content.trim())
  );
  const child = children[0];
  return children.length !== 1 || child.type === 11 || child.type === 9 && child.branches.some(hasMultipleChildren);
}
function compile(src, options2 = {}) {
  return baseCompile(
    src,
    extend({}, parserOptions, options2, {
      nodeTransforms: [
        // ignore <script> and <tag>
        // this is not put inside DOMNodeTransforms because that list is used
        // by compiler-ssr to generate vnode fallback branches
        ignoreSideEffectTags,
        ...DOMNodeTransforms,
        ...options2.nodeTransforms || []
      ],
      directiveTransforms: extend(
        {},
        DOMDirectiveTransforms,
        options2.directiveTransforms || {}
      ),
      transformHoist: null
    })
  );
}
function parse(template, options2 = {}) {
  return baseParse(template, extend({}, parserOptions, options2));
}
var V_MODEL_RADIO, V_MODEL_CHECKBOX, V_MODEL_TEXT, V_MODEL_SELECT, V_MODEL_DYNAMIC, V_ON_WITH_MODIFIERS, V_ON_WITH_KEYS, V_SHOW, TRANSITION, TRANSITION_GROUP, decoder, parserOptions, transformStyle, parseInlineCSS, DOMErrorCodes, DOMErrorMessages, transformVHtml, transformVText, transformModel2, isEventOptionModifier, isNonKeyModifier, maybeKeyModifier, isKeyboardEvent, resolveModifiers, transformClick, transformOn2, transformShow, transformTransition, ignoreSideEffectTags, DOMNodeTransforms, DOMDirectiveTransforms;
var init_compiler_dom_esm_bundler = __esm({
  "node_modules/@vue/compiler-dom/dist/compiler-dom.esm-bundler.js"() {
    init_compiler_core_esm_bundler();
    init_compiler_core_esm_bundler();
    init_shared_esm_bundler();
    V_MODEL_RADIO = Symbol(true ? `vModelRadio` : ``);
    V_MODEL_CHECKBOX = Symbol(true ? `vModelCheckbox` : ``);
    V_MODEL_TEXT = Symbol(true ? `vModelText` : ``);
    V_MODEL_SELECT = Symbol(true ? `vModelSelect` : ``);
    V_MODEL_DYNAMIC = Symbol(true ? `vModelDynamic` : ``);
    V_ON_WITH_MODIFIERS = Symbol(true ? `vOnModifiersGuard` : ``);
    V_ON_WITH_KEYS = Symbol(true ? `vOnKeysGuard` : ``);
    V_SHOW = Symbol(true ? `vShow` : ``);
    TRANSITION = Symbol(true ? `Transition` : ``);
    TRANSITION_GROUP = Symbol(true ? `TransitionGroup` : ``);
    registerRuntimeHelpers({
      [V_MODEL_RADIO]: `vModelRadio`,
      [V_MODEL_CHECKBOX]: `vModelCheckbox`,
      [V_MODEL_TEXT]: `vModelText`,
      [V_MODEL_SELECT]: `vModelSelect`,
      [V_MODEL_DYNAMIC]: `vModelDynamic`,
      [V_ON_WITH_MODIFIERS]: `withModifiers`,
      [V_ON_WITH_KEYS]: `withKeys`,
      [V_SHOW]: `vShow`,
      [TRANSITION]: `Transition`,
      [TRANSITION_GROUP]: `TransitionGroup`
    });
    parserOptions = {
      parseMode: "html",
      isVoidTag,
      isNativeTag: (tag) => isHTMLTag(tag) || isSVGTag(tag) || isMathMLTag(tag),
      isPreTag: (tag) => tag === "pre",
      decodeEntities: decodeHtmlBrowser,
      isBuiltInComponent: (tag) => {
        if (tag === "Transition" || tag === "transition") {
          return TRANSITION;
        } else if (tag === "TransitionGroup" || tag === "transition-group") {
          return TRANSITION_GROUP;
        }
      },
      // https://html.spec.whatwg.org/multipage/parsing.html#tree-construction-dispatcher
      getNamespace(tag, parent, rootNamespace) {
        let ns = parent ? parent.ns : rootNamespace;
        if (parent && ns === 2) {
          if (parent.tag === "annotation-xml") {
            if (tag === "svg") {
              return 1;
            }
            if (parent.props.some(
              (a) => a.type === 6 && a.name === "encoding" && a.value != null && (a.value.content === "text/html" || a.value.content === "application/xhtml+xml")
            )) {
              ns = 0;
            }
          } else if (/^m(?:[ions]|text)$/.test(parent.tag) && tag !== "mglyph" && tag !== "malignmark") {
            ns = 0;
          }
        } else if (parent && ns === 1) {
          if (parent.tag === "foreignObject" || parent.tag === "desc" || parent.tag === "title") {
            ns = 0;
          }
        }
        if (ns === 0) {
          if (tag === "svg") {
            return 1;
          }
          if (tag === "math") {
            return 2;
          }
        }
        return ns;
      }
    };
    transformStyle = (node) => {
      if (node.type === 1) {
        node.props.forEach((p2, i) => {
          if (p2.type === 6 && p2.name === "style" && p2.value) {
            node.props[i] = {
              type: 7,
              name: `bind`,
              arg: createSimpleExpression(`style`, true, p2.loc),
              exp: parseInlineCSS(p2.value.content, p2.loc),
              modifiers: [],
              loc: p2.loc
            };
          }
        });
      }
    };
    parseInlineCSS = (cssText, loc) => {
      const normalized = parseStringStyle(cssText);
      return createSimpleExpression(
        JSON.stringify(normalized),
        false,
        loc,
        3
      );
    };
    DOMErrorCodes = {
      "X_V_HTML_NO_EXPRESSION": 53,
      "53": "X_V_HTML_NO_EXPRESSION",
      "X_V_HTML_WITH_CHILDREN": 54,
      "54": "X_V_HTML_WITH_CHILDREN",
      "X_V_TEXT_NO_EXPRESSION": 55,
      "55": "X_V_TEXT_NO_EXPRESSION",
      "X_V_TEXT_WITH_CHILDREN": 56,
      "56": "X_V_TEXT_WITH_CHILDREN",
      "X_V_MODEL_ON_INVALID_ELEMENT": 57,
      "57": "X_V_MODEL_ON_INVALID_ELEMENT",
      "X_V_MODEL_ARG_ON_ELEMENT": 58,
      "58": "X_V_MODEL_ARG_ON_ELEMENT",
      "X_V_MODEL_ON_FILE_INPUT_ELEMENT": 59,
      "59": "X_V_MODEL_ON_FILE_INPUT_ELEMENT",
      "X_V_MODEL_UNNECESSARY_VALUE": 60,
      "60": "X_V_MODEL_UNNECESSARY_VALUE",
      "X_V_SHOW_NO_EXPRESSION": 61,
      "61": "X_V_SHOW_NO_EXPRESSION",
      "X_TRANSITION_INVALID_CHILDREN": 62,
      "62": "X_TRANSITION_INVALID_CHILDREN",
      "X_IGNORED_SIDE_EFFECT_TAG": 63,
      "63": "X_IGNORED_SIDE_EFFECT_TAG",
      "__EXTEND_POINT__": 64,
      "64": "__EXTEND_POINT__"
    };
    DOMErrorMessages = {
      [53]: `v-html is missing expression.`,
      [54]: `v-html will override element children.`,
      [55]: `v-text is missing expression.`,
      [56]: `v-text will override element children.`,
      [57]: `v-model can only be used on <input>, <textarea> and <select> elements.`,
      [58]: `v-model argument is not supported on plain elements.`,
      [59]: `v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead.`,
      [60]: `Unnecessary value binding used alongside v-model. It will interfere with v-model's behavior.`,
      [61]: `v-show is missing expression.`,
      [62]: `<Transition> expects exactly one child element or component.`,
      [63]: `Tags with side effect (<script> and <style>) are ignored in client component templates.`
    };
    transformVHtml = (dir, node, context2) => {
      const { exp, loc } = dir;
      if (!exp) {
        context2.onError(
          createDOMCompilerError(53, loc)
        );
      }
      if (node.children.length) {
        context2.onError(
          createDOMCompilerError(54, loc)
        );
        node.children.length = 0;
      }
      return {
        props: [
          createObjectProperty(
            createSimpleExpression(`innerHTML`, true, loc),
            exp || createSimpleExpression("", true)
          )
        ]
      };
    };
    transformVText = (dir, node, context2) => {
      const { exp, loc } = dir;
      if (!exp) {
        context2.onError(
          createDOMCompilerError(55, loc)
        );
      }
      if (node.children.length) {
        context2.onError(
          createDOMCompilerError(56, loc)
        );
        node.children.length = 0;
      }
      return {
        props: [
          createObjectProperty(
            createSimpleExpression(`textContent`, true),
            exp ? getConstantType(exp, context2) > 0 ? exp : createCallExpression(
              context2.helperString(TO_DISPLAY_STRING),
              [exp],
              loc
            ) : createSimpleExpression("", true)
          )
        ]
      };
    };
    transformModel2 = (dir, node, context2) => {
      const baseResult = transformModel(dir, node, context2);
      if (!baseResult.props.length || node.tagType === 1) {
        return baseResult;
      }
      if (dir.arg) {
        context2.onError(
          createDOMCompilerError(
            58,
            dir.arg.loc
          )
        );
      }
      function checkDuplicatedValue() {
        const value2 = findDir(node, "bind");
        if (value2 && isStaticArgOf(value2.arg, "value")) {
          context2.onError(
            createDOMCompilerError(
              60,
              value2.loc
            )
          );
        }
      }
      const { tag } = node;
      const isCustomElement = context2.isCustomElement(tag);
      if (tag === "input" || tag === "textarea" || tag === "select" || isCustomElement) {
        let directiveToUse = V_MODEL_TEXT;
        let isInvalidType = false;
        if (tag === "input" || isCustomElement) {
          const type2 = findProp(node, `type`);
          if (type2) {
            if (type2.type === 7) {
              directiveToUse = V_MODEL_DYNAMIC;
            } else if (type2.value) {
              switch (type2.value.content) {
                case "radio":
                  directiveToUse = V_MODEL_RADIO;
                  break;
                case "checkbox":
                  directiveToUse = V_MODEL_CHECKBOX;
                  break;
                case "file":
                  isInvalidType = true;
                  context2.onError(
                    createDOMCompilerError(
                      59,
                      dir.loc
                    )
                  );
                  break;
                default:
                  checkDuplicatedValue();
                  break;
              }
            }
          } else if (hasDynamicKeyVBind(node)) {
            directiveToUse = V_MODEL_DYNAMIC;
          } else {
            checkDuplicatedValue();
          }
        } else if (tag === "select") {
          directiveToUse = V_MODEL_SELECT;
        } else {
          checkDuplicatedValue();
        }
        if (!isInvalidType) {
          baseResult.needRuntime = context2.helper(directiveToUse);
        }
      } else {
        context2.onError(
          createDOMCompilerError(
            57,
            dir.loc
          )
        );
      }
      baseResult.props = baseResult.props.filter(
        (p2) => !(p2.key.type === 4 && p2.key.content === "modelValue")
      );
      return baseResult;
    };
    isEventOptionModifier = makeMap(`passive,once,capture`);
    isNonKeyModifier = makeMap(
      // event propagation management
      `stop,prevent,self,ctrl,shift,alt,meta,exact,middle`
    );
    maybeKeyModifier = makeMap("left,right");
    isKeyboardEvent = makeMap(
      `onkeyup,onkeydown,onkeypress`,
      true
    );
    resolveModifiers = (key, modifiers, context2, loc) => {
      const keyModifiers = [];
      const nonKeyModifiers = [];
      const eventOptionModifiers = [];
      for (let i = 0; i < modifiers.length; i++) {
        const modifier = modifiers[i];
        if (modifier === "native" && checkCompatEnabled(
          "COMPILER_V_ON_NATIVE",
          context2,
          loc
        )) {
          eventOptionModifiers.push(modifier);
        } else if (isEventOptionModifier(modifier)) {
          eventOptionModifiers.push(modifier);
        } else {
          if (maybeKeyModifier(modifier)) {
            if (isStaticExp(key)) {
              if (isKeyboardEvent(key.content)) {
                keyModifiers.push(modifier);
              } else {
                nonKeyModifiers.push(modifier);
              }
            } else {
              keyModifiers.push(modifier);
              nonKeyModifiers.push(modifier);
            }
          } else {
            if (isNonKeyModifier(modifier)) {
              nonKeyModifiers.push(modifier);
            } else {
              keyModifiers.push(modifier);
            }
          }
        }
      }
      return {
        keyModifiers,
        nonKeyModifiers,
        eventOptionModifiers
      };
    };
    transformClick = (key, event) => {
      const isStaticClick = isStaticExp(key) && key.content.toLowerCase() === "onclick";
      return isStaticClick ? createSimpleExpression(event, true) : key.type !== 4 ? createCompoundExpression([
        `(`,
        key,
        `) === "onClick" ? "${event}" : (`,
        key,
        `)`
      ]) : key;
    };
    transformOn2 = (dir, node, context2) => {
      return transformOn(dir, node, context2, (baseResult) => {
        const { modifiers } = dir;
        if (!modifiers.length)
          return baseResult;
        let { key, value: handlerExp } = baseResult.props[0];
        const { keyModifiers, nonKeyModifiers, eventOptionModifiers } = resolveModifiers(key, modifiers, context2, dir.loc);
        if (nonKeyModifiers.includes("right")) {
          key = transformClick(key, `onContextmenu`);
        }
        if (nonKeyModifiers.includes("middle")) {
          key = transformClick(key, `onMouseup`);
        }
        if (nonKeyModifiers.length) {
          handlerExp = createCallExpression(context2.helper(V_ON_WITH_MODIFIERS), [
            handlerExp,
            JSON.stringify(nonKeyModifiers)
          ]);
        }
        if (keyModifiers.length && // if event name is dynamic, always wrap with keys guard
        (!isStaticExp(key) || isKeyboardEvent(key.content))) {
          handlerExp = createCallExpression(context2.helper(V_ON_WITH_KEYS), [
            handlerExp,
            JSON.stringify(keyModifiers)
          ]);
        }
        if (eventOptionModifiers.length) {
          const modifierPostfix = eventOptionModifiers.map(capitalize).join("");
          key = isStaticExp(key) ? createSimpleExpression(`${key.content}${modifierPostfix}`, true) : createCompoundExpression([`(`, key, `) + "${modifierPostfix}"`]);
        }
        return {
          props: [createObjectProperty(key, handlerExp)]
        };
      });
    };
    transformShow = (dir, node, context2) => {
      const { exp, loc } = dir;
      if (!exp) {
        context2.onError(
          createDOMCompilerError(61, loc)
        );
      }
      return {
        props: [],
        needRuntime: context2.helper(V_SHOW)
      };
    };
    transformTransition = (node, context2) => {
      if (node.type === 1 && node.tagType === 1) {
        const component = context2.isBuiltInComponent(node.tag);
        if (component === TRANSITION) {
          return () => {
            if (!node.children.length) {
              return;
            }
            if (hasMultipleChildren(node)) {
              context2.onError(
                createDOMCompilerError(
                  62,
                  {
                    start: node.children[0].loc.start,
                    end: node.children[node.children.length - 1].loc.end,
                    source: ""
                  }
                )
              );
            }
            const child = node.children[0];
            if (child.type === 1) {
              for (const p2 of child.props) {
                if (p2.type === 7 && p2.name === "show") {
                  node.props.push({
                    type: 6,
                    name: "persisted",
                    nameLoc: node.loc,
                    value: void 0,
                    loc: node.loc
                  });
                }
              }
            }
          };
        }
      }
    };
    ignoreSideEffectTags = (node, context2) => {
      if (node.type === 1 && node.tagType === 0 && (node.tag === "script" || node.tag === "style")) {
        context2.onError(
          createDOMCompilerError(
            63,
            node.loc
          )
        );
        context2.removeNode();
      }
    };
    DOMNodeTransforms = [
      transformStyle,
      ...true ? [transformTransition] : []
    ];
    DOMDirectiveTransforms = {
      cloak: noopDirectiveTransform,
      html: transformVHtml,
      text: transformVText,
      model: transformModel2,
      // override compiler-core
      on: transformOn2,
      // override compiler-core
      show: transformShow
    };
  }
});

// node_modules/vue/dist/vue.cjs.js
var require_vue_cjs = __commonJS({
  "node_modules/vue/dist/vue.cjs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var compilerDom = (init_compiler_dom_esm_bundler(), __toCommonJS(compiler_dom_esm_bundler_exports));
    var runtimeDom = (init_runtime_dom_esm_bundler(), __toCommonJS(runtime_dom_esm_bundler_exports));
    var shared = (init_shared_esm_bundler(), __toCommonJS(shared_esm_bundler_exports));
    function _interopNamespaceDefault(e) {
      var n = /* @__PURE__ */ Object.create(null);
      if (e) {
        for (var k in e) {
          n[k] = e[k];
        }
      }
      n.default = e;
      return Object.freeze(n);
    }
    var runtimeDom__namespace = _interopNamespaceDefault(runtimeDom);
    var compileCache = /* @__PURE__ */ new WeakMap();
    function getCache(options2) {
      let c = compileCache.get(options2 != null ? options2 : shared.EMPTY_OBJ);
      if (!c) {
        c = /* @__PURE__ */ Object.create(null);
        compileCache.set(options2 != null ? options2 : shared.EMPTY_OBJ, c);
      }
      return c;
    }
    function compileToFunction(template, options2) {
      if (!shared.isString(template)) {
        if (template.nodeType) {
          template = template.innerHTML;
        } else {
          runtimeDom.warn(`invalid template option: `, template);
          return shared.NOOP;
        }
      }
      const key = template;
      const cache = getCache(options2);
      const cached = cache[key];
      if (cached) {
        return cached;
      }
      if (template[0] === "#") {
        const el = document.querySelector(template);
        if (!el) {
          runtimeDom.warn(`Template element not found or is empty: ${template}`);
        }
        template = el ? el.innerHTML : ``;
      }
      const opts = shared.extend(
        {
          hoistStatic: true,
          onError,
          onWarn: (e) => onError(e, true)
        },
        options2
      );
      if (!opts.isCustomElement && typeof customElements !== "undefined") {
        opts.isCustomElement = (tag) => !!customElements.get(tag);
      }
      const { code } = compilerDom.compile(template, opts);
      function onError(err, asWarning = false) {
        const message = asWarning ? err.message : `Template compilation error: ${err.message}`;
        const codeFrame = err.loc && shared.generateCodeFrame(
          template,
          err.loc.start.offset,
          err.loc.end.offset
        );
        runtimeDom.warn(codeFrame ? `${message}
${codeFrame}` : message);
      }
      const render4 = new Function("Vue", code)(runtimeDom__namespace);
      render4._rc = true;
      return cache[key] = render4;
    }
    runtimeDom.registerRuntimeCompiler(compileToFunction);
    exports.compile = compileToFunction;
    Object.keys(runtimeDom).forEach(function(k) {
      if (k !== "default" && !Object.prototype.hasOwnProperty.call(exports, k))
        exports[k] = runtimeDom[k];
    });
  }
});

// node_modules/vue/index.js
var require_vue = __commonJS({
  "node_modules/vue/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_vue_cjs();
    }
  }
});

// node_modules/@babel/runtime/helpers/esm/extends.js
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
var init_extends = __esm({
  "node_modules/@babel/runtime/helpers/esm/extends.js"() {
  }
});

// node_modules/devextreme/esm/core/utils/iterator.js
var map, each;
var init_iterator = __esm({
  "node_modules/devextreme/esm/core/utils/iterator.js"() {
    map = (values, callback) => {
      if (Array.isArray(values)) {
        return values.map(callback);
      }
      var result2 = [];
      for (var key in values) {
        result2.push(callback(values[key], key));
      }
      return result2;
    };
    each = (values, callback) => {
      if (!values) {
        return;
      }
      if ("length" in values) {
        for (var i = 0; i < values.length; i++) {
          if (false === callback.call(values[i], i, values[i])) {
            break;
          }
        }
      } else {
        for (var key in values) {
          if (false === callback.call(values[key], key, values[key])) {
            break;
          }
        }
      }
      return values;
    };
  }
});

// node_modules/devextreme/esm/core/utils/callbacks.js
var callbacks_exports = {};
__export(callbacks_exports, {
  default: () => callbacks_default
});
var Callback, Callbacks, callbacks_default;
var init_callbacks = __esm({
  "node_modules/devextreme/esm/core/utils/callbacks.js"() {
    Callback = function(options2) {
      this._options = options2 || {};
      this._list = [];
      this._queue = [];
      this._firing = false;
      this._fired = false;
      this._firingIndexes = [];
    };
    Callback.prototype._fireCore = function(context2, args) {
      var firingIndexes = this._firingIndexes;
      var list = this._list;
      var stopOnFalse = this._options.stopOnFalse;
      var step = firingIndexes.length;
      for (firingIndexes[step] = 0; firingIndexes[step] < list.length; firingIndexes[step]++) {
        var result2 = list[firingIndexes[step]].apply(context2, args);
        if (false === result2 && stopOnFalse) {
          break;
        }
      }
      firingIndexes.pop();
    };
    Callback.prototype.add = function(fn) {
      if ("function" === typeof fn && (!this._options.unique || !this.has(fn))) {
        this._list.push(fn);
      }
      return this;
    };
    Callback.prototype.remove = function(fn) {
      var list = this._list;
      var firingIndexes = this._firingIndexes;
      var index2 = list.indexOf(fn);
      if (index2 > -1) {
        list.splice(index2, 1);
        if (this._firing && firingIndexes.length) {
          for (var step = 0; step < firingIndexes.length; step++) {
            if (index2 <= firingIndexes[step]) {
              firingIndexes[step]--;
            }
          }
        }
      }
      return this;
    };
    Callback.prototype.has = function(fn) {
      var list = this._list;
      return fn ? list.indexOf(fn) > -1 : !!list.length;
    };
    Callback.prototype.empty = function(fn) {
      this._list = [];
      return this;
    };
    Callback.prototype.fireWith = function(context2, args) {
      var queue = this._queue;
      args = args || [];
      args = args.slice ? args.slice() : args;
      if (this._options.syncStrategy) {
        this._firing = true;
        this._fireCore(context2, args);
      } else {
        queue.push([context2, args]);
        if (this._firing) {
          return;
        }
        this._firing = true;
        while (queue.length) {
          var memory = queue.shift();
          this._fireCore(memory[0], memory[1]);
        }
      }
      this._firing = false;
      this._fired = true;
      return this;
    };
    Callback.prototype.fire = function() {
      this.fireWith(this, arguments);
    };
    Callback.prototype.fired = function() {
      return this._fired;
    };
    Callbacks = function(options2) {
      return new Callback(options2);
    };
    callbacks_default = Callbacks;
  }
});

// node_modules/devextreme/esm/core/memorized_callbacks.js
var MemorizedCallbacks;
var init_memorized_callbacks = __esm({
  "node_modules/devextreme/esm/core/memorized_callbacks.js"() {
    init_iterator();
    init_callbacks();
    MemorizedCallbacks = class {
      constructor() {
        this.memory = [];
        this.callbacks = callbacks_default();
      }
      add(fn) {
        each(this.memory, (_2, item) => fn.apply(fn, item));
        this.callbacks.add(fn);
      }
      remove(fn) {
        this.callbacks.remove(fn);
      }
      fire() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        this.memory.push(args);
        this.callbacks.fire.apply(this.callbacks, args);
      }
    };
  }
});

// node_modules/devextreme/esm/events/core/event_registrator_callbacks.js
var event_registrator_callbacks_default;
var init_event_registrator_callbacks = __esm({
  "node_modules/devextreme/esm/events/core/event_registrator_callbacks.js"() {
    init_memorized_callbacks();
    event_registrator_callbacks_default = new MemorizedCallbacks();
  }
});

// node_modules/devextreme/esm/core/utils/type.js
var types, type, isBoolean, isExponential, isDate, isDefined, isFunction, isString2, isNumeric, isObject2, isEmptyObject, isPlainObject, isPrimitive, isWindow, isRenderer, isPromise, isDeferred, isEvent;
var init_type = __esm({
  "node_modules/devextreme/esm/core/utils/type.js"() {
    types = {
      "[object Array]": "array",
      "[object Date]": "date",
      "[object Object]": "object",
      "[object String]": "string",
      "[object Null]": "null"
    };
    type = function(object) {
      var typeOfObject = Object.prototype.toString.call(object);
      return "object" === typeof object ? types[typeOfObject] || "object" : typeof object;
    };
    isBoolean = function(object) {
      return "boolean" === typeof object;
    };
    isExponential = function(value2) {
      return isNumeric(value2) && -1 !== value2.toString().indexOf("e");
    };
    isDate = function(object) {
      return "date" === type(object);
    };
    isDefined = function(object) {
      return null !== object && void 0 !== object;
    };
    isFunction = function(object) {
      return "function" === typeof object;
    };
    isString2 = function(object) {
      return "string" === typeof object;
    };
    isNumeric = function(object) {
      return "number" === typeof object && isFinite(object) || !isNaN(object - parseFloat(object));
    };
    isObject2 = function(object) {
      return "object" === type(object);
    };
    isEmptyObject = function(object) {
      var property;
      for (property in object) {
        return false;
      }
      return true;
    };
    isPlainObject = function(object) {
      if (!object || "[object Object]" !== Object.prototype.toString.call(object)) {
        return false;
      }
      var proto = Object.getPrototypeOf(object);
      var ctor = Object.hasOwnProperty.call(proto, "constructor") && proto.constructor;
      return "function" === typeof ctor && Object.toString.call(ctor) === Object.toString.call(Object);
    };
    isPrimitive = function(value2) {
      return -1 === ["object", "array", "function"].indexOf(type(value2));
    };
    isWindow = function(object) {
      return null != object && object === object.window;
    };
    isRenderer = function(object) {
      return !!(object.jquery || object.dxRenderer);
    };
    isPromise = function(object) {
      return object && isFunction(object.then);
    };
    isDeferred = function(object) {
      return object && isFunction(object.done) && isFunction(object.fail);
    };
    isEvent = function(object) {
      return !!(object && object.preventDefault);
    };
  }
});

// node_modules/devextreme/esm/core/utils/extend.js
var extendFromObject, extend2;
var init_extend = __esm({
  "node_modules/devextreme/esm/core/utils/extend.js"() {
    init_type();
    extendFromObject = function(target, source, overrideExistingValues) {
      target = target || {};
      for (var prop in source) {
        if (Object.prototype.hasOwnProperty.call(source, prop)) {
          var value2 = source[prop];
          if (!(prop in target) || overrideExistingValues) {
            target[prop] = value2;
          }
        }
      }
      return target;
    };
    extend2 = function extend3(target) {
      target = target || {};
      var i = 1;
      var deep = false;
      if ("boolean" === typeof target) {
        deep = target;
        target = arguments[1] || {};
        i++;
      }
      for (; i < arguments.length; i++) {
        var source = arguments[i];
        if (null == source) {
          continue;
        }
        for (var key in source) {
          var targetValue = target[key];
          var sourceValue = source[key];
          var sourceValueIsArray = false;
          var clone = void 0;
          if ("__proto__" === key || "constructor" === key || target === sourceValue) {
            continue;
          }
          if (deep && sourceValue && (isPlainObject(sourceValue) || (sourceValueIsArray = Array.isArray(sourceValue)))) {
            if (sourceValueIsArray) {
              clone = targetValue && Array.isArray(targetValue) ? targetValue : [];
            } else {
              clone = targetValue && isPlainObject(targetValue) ? targetValue : {};
            }
            target[key] = extend3(deep, clone, sourceValue);
          } else if (void 0 !== sourceValue) {
            target[key] = sourceValue;
          }
        }
      }
      return target;
    };
  }
});

// node_modules/devextreme/esm/core/utils/console.js
var noop, getConsoleMethod, logger;
var init_console = __esm({
  "node_modules/devextreme/esm/core/utils/console.js"() {
    init_type();
    noop = function() {
    };
    getConsoleMethod = function(method) {
      if ("undefined" === typeof console || !isFunction(console[method])) {
        return noop;
      }
      return console[method].bind(console);
    };
    logger = {
      info: getConsoleMethod("info"),
      warn: getConsoleMethod("warn"),
      error: getConsoleMethod("error")
    };
  }
});

// node_modules/devextreme/esm/core/utils/string.js
function format(template) {
  for (var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    values[_key - 1] = arguments[_key];
  }
  if (isFunction(template)) {
    return template(...values);
  }
  values.forEach((value2, index2) => {
    if (isString2(value2)) {
      value2 = value2.replace(/\$/g, "$$$$");
    }
    var placeholderReg = new RegExp("\\{" + index2 + "\\}", "gm");
    template = template.replace(placeholderReg, value2);
  });
  return template;
}
var encodeHtml, splitQuad, quadToObject, isEmpty;
var init_string = __esm({
  "node_modules/devextreme/esm/core/utils/string.js"() {
    init_type();
    encodeHtml = function() {
      var encodeRegExp = [new RegExp("&", "g"), new RegExp('"', "g"), new RegExp("'", "g"), new RegExp("<", "g"), new RegExp(">", "g")];
      return function(str) {
        return String(str).replace(encodeRegExp[0], "&amp;").replace(encodeRegExp[1], "&quot;").replace(encodeRegExp[2], "&#39;").replace(encodeRegExp[3], "&lt;").replace(encodeRegExp[4], "&gt;");
      };
    }();
    splitQuad = function(raw) {
      switch (typeof raw) {
        case "string":
          return raw.split(/\s+/, 4);
        case "object":
          return [raw.x || raw.h || raw.left, raw.y || raw.v || raw.top, raw.x || raw.h || raw.right, raw.y || raw.v || raw.bottom];
        case "number":
          return [raw];
        default:
          return raw;
      }
    };
    quadToObject = function(raw) {
      var quad = splitQuad(raw);
      var left = parseInt(quad && quad[0], 10);
      var top = parseInt(quad && quad[1], 10);
      var right = parseInt(quad && quad[2], 10);
      var bottom = parseInt(quad && quad[3], 10);
      if (!isFinite(left)) {
        left = 0;
      }
      if (!isFinite(top)) {
        top = left;
      }
      if (!isFinite(right)) {
        right = left;
      }
      if (!isFinite(bottom)) {
        bottom = top;
      }
      return {
        top,
        right,
        bottom,
        left
      };
    };
    isEmpty = /* @__PURE__ */ function() {
      var SPACE_REGEXP = /\s/g;
      return function(text) {
        return !text || !text.replace(SPACE_REGEXP, "");
      };
    }();
  }
});

// node_modules/devextreme/esm/core/version.js
var version;
var init_version = __esm({
  "node_modules/devextreme/esm/core/version.js"() {
    version = "21.1.12";
  }
});

// node_modules/devextreme/esm/core/utils/error.js
function error_default(baseErrors, errors2) {
  var exports = {
    ERROR_MESSAGES: extend2(errors2, baseErrors),
    Error: function() {
      return makeError([].slice.call(arguments));
    },
    log: function(id) {
      var method = "log";
      if (/^E\d+$/.test(id)) {
        method = "error";
      } else if (/^W\d+$/.test(id)) {
        method = "warn";
      }
      logger[method]("log" === method ? id : combineMessage([].slice.call(arguments)));
    }
  };
  function combineMessage(args) {
    var id = args[0];
    args = args.slice(1);
    return formatMessage(id, formatDetails(id, args));
  }
  function formatDetails(id, args) {
    args = [exports.ERROR_MESSAGES[id]].concat(args);
    return format.apply(this, args).replace(/\.*\s*?$/, "");
  }
  function formatMessage(id, details) {
    return format.apply(this, ["{0} - {1}. See:\n{2}", id, details, getErrorUrl(id)]);
  }
  function makeError(args) {
    var id = args[0];
    args = args.slice(1);
    var details = formatDetails(id, args);
    var url = getErrorUrl(id);
    var message = formatMessage(id, details);
    return extend2(new Error(message), {
      __id: id,
      __details: details,
      url
    });
  }
  function getErrorUrl(id) {
    return ERROR_URL + id;
  }
  return exports;
}
var ERROR_URL;
var init_error = __esm({
  "node_modules/devextreme/esm/core/utils/error.js"() {
    init_extend();
    init_console();
    init_string();
    init_version();
    ERROR_URL = "http://js.devexpress.com/error/" + version.split(".").slice(0, 2).join("_") + "/";
  }
});

// node_modules/devextreme/esm/core/errors.js
var errors_default;
var init_errors = __esm({
  "node_modules/devextreme/esm/core/errors.js"() {
    init_error();
    errors_default = error_default({
      E0001: "Method is not implemented",
      E0002: "Member name collision: {0}",
      E0003: "A class must be instantiated using the 'new' keyword",
      E0004: "The NAME property of the component is not specified",
      E0005: "Unknown device",
      E0006: "Unknown endpoint key is requested",
      E0007: "'Invalidate' method is called outside the update transaction",
      E0008: "Type of the option name is not appropriate to create an action",
      E0009: "Component '{0}' has not been initialized for an element",
      E0010: "Animation configuration with the '{0}' type requires '{1}' configuration as {2}",
      E0011: "Unknown animation type '{0}'",
      E0012: "jQuery version is too old. Please upgrade jQuery to 1.10.0 or later",
      E0013: "KnockoutJS version is too old. Please upgrade KnockoutJS to 2.3.0 or later",
      E0014: "The 'release' method shouldn't be called for an unlocked Lock object",
      E0015: "Queued task returned an unexpected result",
      E0017: "Event namespace is not defined",
      E0018: "DevExpress.ui.DevExpressPopup widget is required",
      E0020: "Template engine '{0}' is not supported",
      E0021: "Unknown theme is set: {0}",
      E0022: "LINK[rel=DevExpress-theme] tags must go before DevExpress included scripts",
      E0023: "Template name is not specified",
      E0024: "DevExtreme bundle already included",
      E0025: "Unexpected argument type",
      E0100: "Unknown validation type is detected",
      E0101: "Misconfigured range validation rule is detected",
      E0102: "Misconfigured comparison validation rule is detected",
      E0103: "validationCallback of an asynchronous rule should return a jQuery or a native promise",
      E0110: "Unknown validation group is detected",
      E0120: "Adapter for a DevExpressValidator component cannot be configured",
      E0121: "The 'customItem' parameter of the 'onCustomItemCreating' function is empty or contains invalid data. Assign a custom object or a Promise that is resolved after the item is created.",
      W0000: "'{0}' is deprecated in {1}. {2}",
      W0001: "{0} - '{1}' option is deprecated in {2}. {3}",
      W0002: "{0} - '{1}' method is deprecated in {2}. {3}",
      W0003: "{0} - '{1}' property is deprecated in {2}. {3}",
      W0004: "Timeout for theme loading is over: {0}",
      W0005: "'{0}' event is deprecated in {1}. {2}",
      W0006: "Invalid recurrence rule: '{0}'",
      W0007: "'{0}' Globalize culture is not defined",
      W0008: "Invalid view name: '{0}'",
      W0009: "Invalid time zone name: '{0}'",
      W0010: "{0} is deprecated in {1}. {2}",
      W0011: "Number parsing is invoked while the parser is not defined",
      W0012: "Date parsing is invoked while the parser is not defined",
      W0013: "'{0}' file is deprecated in {1}. {2}",
      W0014: "{0} - '{1}' type is deprecated in {2}. {3}",
      W0015: "Instead of returning a value from the '{0}' function, write it into the '{1}' field of the function's parameter.",
      W0016: 'The "{0}" option does not accept the "{1}" value since v.{2}. {3}.'
    });
  }
});

// node_modules/devextreme/esm/core/class.js
var wrapOverridden, clonePrototype, redefine, include, subclassOf, abstract, copyStatic, classImpl, class_default;
var init_class = __esm({
  "node_modules/devextreme/esm/core/class.js"() {
    init_errors();
    init_type();
    wrapOverridden = function(baseProto, methodName, method) {
      return function() {
        var prevCallBase = this.callBase;
        this.callBase = baseProto[methodName];
        try {
          return method.apply(this, arguments);
        } finally {
          this.callBase = prevCallBase;
        }
      };
    };
    clonePrototype = function(obj) {
      var func = function() {
      };
      func.prototype = obj.prototype;
      return new func();
    };
    redefine = function(members) {
      var overridden;
      var memberName;
      var member;
      if (!members) {
        return this;
      }
      for (memberName in members) {
        member = members[memberName];
        overridden = "function" === typeof this.prototype[memberName] && "function" === typeof member;
        this.prototype[memberName] = overridden ? wrapOverridden(this.parent.prototype, memberName, member) : member;
      }
      return this;
    };
    include = function() {
      var classObj = this;
      var argument;
      var name2;
      var i;
      var hasClassObjOwnProperty = Object.prototype.hasOwnProperty.bind(classObj);
      var isES6Class = !hasClassObjOwnProperty("_includedCtors") && !hasClassObjOwnProperty("_includedPostCtors");
      if (isES6Class) {
        classObj._includedCtors = classObj._includedCtors.slice(0);
        classObj._includedPostCtors = classObj._includedPostCtors.slice(0);
      }
      for (i = 0; i < arguments.length; i++) {
        argument = arguments[i];
        if (argument.ctor) {
          classObj._includedCtors.push(argument.ctor);
        }
        if (argument.postCtor) {
          classObj._includedPostCtors.push(argument.postCtor);
        }
        for (name2 in argument) {
          if ("ctor" === name2 || "postCtor" === name2 || "default" === name2) {
            continue;
          }
          classObj.prototype[name2] = argument[name2];
        }
      }
      return classObj;
    };
    subclassOf = function(parentClass) {
      var hasParentProperty = Object.prototype.hasOwnProperty.bind(this)("parent");
      var isES6Class = !hasParentProperty && this.parent;
      if (isES6Class) {
        var baseClass = Object.getPrototypeOf(this);
        return baseClass === parentClass || baseClass.subclassOf(parentClass);
      } else {
        if (this.parent === parentClass) {
          return true;
        }
        if (!this.parent || !this.parent.subclassOf) {
          return false;
        }
        return this.parent.subclassOf(parentClass);
      }
    };
    abstract = function() {
      throw errors_default.Error("E0001");
    };
    copyStatic = /* @__PURE__ */ function() {
      var hasOwn = Object.prototype.hasOwnProperty;
      return function(source, destination) {
        for (var key in source) {
          if (!hasOwn.call(source, key)) {
            return;
          }
          destination[key] = source[key];
        }
      };
    }();
    classImpl = function() {
    };
    classImpl.inherit = function(members) {
      var inheritor = function() {
        if (!this || isWindow(this) || "function" !== typeof this.constructor) {
          throw errors_default.Error("E0003");
        }
        var instance = this;
        var ctor = instance.ctor;
        var includedCtors = instance.constructor._includedCtors;
        var includedPostCtors = instance.constructor._includedPostCtors;
        var i;
        for (i = 0; i < includedCtors.length; i++) {
          includedCtors[i].call(instance);
        }
        if (ctor) {
          ctor.apply(instance, arguments);
        }
        for (i = 0; i < includedPostCtors.length; i++) {
          includedPostCtors[i].call(instance);
        }
      };
      inheritor.prototype = clonePrototype(this);
      copyStatic(this, inheritor);
      inheritor.inherit = this.inherit;
      inheritor.abstract = abstract;
      inheritor.redefine = redefine;
      inheritor.include = include;
      inheritor.subclassOf = subclassOf;
      inheritor.parent = this;
      inheritor._includedCtors = this._includedCtors ? this._includedCtors.slice(0) : [];
      inheritor._includedPostCtors = this._includedPostCtors ? this._includedPostCtors.slice(0) : [];
      inheritor.prototype.constructor = inheritor;
      inheritor.redefine(members);
      return inheritor;
    };
    classImpl.abstract = abstract;
    class_default = classImpl;
  }
});

// node_modules/devextreme/esm/core/utils/dependency_injector.js
function dependency_injector_default(object) {
  var BaseClass = class_default.inherit(object);
  var InjectedClass = BaseClass;
  var instance = new InjectedClass(object);
  var initialFields = {};
  var injectFields = function(injectionObject, initial) {
    each(injectionObject, function(key) {
      if (isFunction(instance[key])) {
        if (initial || !object[key]) {
          object[key] = function() {
            return instance[key].apply(object, arguments);
          };
        }
      } else {
        if (initial) {
          initialFields[key] = object[key];
        }
        object[key] = instance[key];
      }
    });
  };
  injectFields(object, true);
  object.inject = function(injectionObject) {
    InjectedClass = InjectedClass.inherit(injectionObject);
    instance = new InjectedClass();
    injectFields(injectionObject);
  };
  object.resetInjection = function() {
    extend2(object, initialFields);
    InjectedClass = BaseClass;
    instance = new BaseClass();
  };
  return object;
}
var init_dependency_injector = __esm({
  "node_modules/devextreme/esm/core/utils/dependency_injector.js"() {
    init_extend();
    init_type();
    init_iterator();
    init_class();
  }
});

// node_modules/devextreme/esm/core/config.js
var config, deprecatedFields, configMethod, config_default;
var init_config = __esm({
  "node_modules/devextreme/esm/core/config.js"() {
    init_extend();
    init_errors();
    config = {
      rtlEnabled: false,
      defaultCurrency: "USD",
      oDataFilterToLower: true,
      serverDecimalSeparator: ".",
      decimalSeparator: ".",
      thousandsSeparator: ",",
      forceIsoDateParsing: true,
      wrapActionsBeforeExecute: true,
      useLegacyStoreResult: false,
      useJQuery: void 0,
      editorStylingMode: void 0,
      useLegacyVisibleIndex: false,
      floatingActionButtonConfig: {
        icon: "add",
        closeIcon: "close",
        label: "",
        position: {
          at: "right bottom",
          my: "right bottom",
          offset: {
            x: -16,
            y: -16
          }
        },
        maxSpeedDialActionCount: 5,
        shading: false,
        direction: "auto"
      },
      optionsParser: (optionsString) => {
        if ("{" !== optionsString.trim().charAt(0)) {
          optionsString = "{" + optionsString + "}";
        }
        try {
          return new Function("return " + optionsString)();
        } catch (ex) {
          throw errors_default.Error("E3018", ex, optionsString);
        }
      }
    };
    deprecatedFields = ["decimalSeparator", "thousandsSeparator"];
    configMethod = function() {
      if (!arguments.length) {
        return config;
      }
      var newConfig = arguments.length <= 0 ? void 0 : arguments[0];
      deprecatedFields.forEach((deprecatedField) => {
        if (newConfig[deprecatedField]) {
          var message = "Now, the ".concat(deprecatedField, " is selected based on the specified locale.");
          errors_default.log("W0003", "config", deprecatedField, "19.2", message);
        }
      });
      extend2(config, newConfig);
    };
    if ("undefined" !== typeof DevExpress && DevExpress.config) {
      configMethod(DevExpress.config);
    }
    config_default = configMethod;
  }
});

// node_modules/devextreme/esm/core/guid.js
var Guid, guid_default;
var init_guid = __esm({
  "node_modules/devextreme/esm/core/guid.js"() {
    init_class();
    Guid = class_default.inherit({
      ctor: function(value2) {
        if (value2) {
          value2 = String(value2);
        }
        this._value = this._normalize(value2 || this._generate());
      },
      _normalize: function(value2) {
        value2 = value2.replace(/[^a-f0-9]/gi, "").toLowerCase();
        while (value2.length < 32) {
          value2 += "0";
        }
        return [value2.substr(0, 8), value2.substr(8, 4), value2.substr(12, 4), value2.substr(16, 4), value2.substr(20, 12)].join("-");
      },
      _generate: function() {
        var value2 = "";
        for (var i = 0; i < 32; i++) {
          value2 += Math.round(15 * Math.random()).toString(16);
        }
        return value2;
      },
      toString: function() {
        return this._value;
      },
      valueOf: function() {
        return this._value;
      },
      toJSON: function() {
        return this._value;
      }
    });
    guid_default = Guid;
  }
});

// node_modules/devextreme/esm/core/utils/deferred.js
function fromPromise(promise2, context2) {
  if (isDeferred(promise2)) {
    return promise2;
  } else if (isPromise(promise2)) {
    var d = new _DeferredObj();
    promise2.then(function() {
      d.resolveWith.apply(d, [context2].concat([
        [].slice.call(arguments)
      ]));
    }, function() {
      d.rejectWith.apply(d, [context2].concat([
        [].slice.call(arguments)
      ]));
    });
    return d;
  }
  return new _DeferredObj().resolveWith(context2, [promise2]);
}
function Deferred() {
  return new _DeferredObj();
}
function when() {
  return whenFunc.apply(this, arguments);
}
var deferredConfig, _DeferredObj, whenFunc;
var init_deferred = __esm({
  "node_modules/devextreme/esm/core/utils/deferred.js"() {
    init_type();
    init_extend();
    init_callbacks();
    deferredConfig = [{
      method: "resolve",
      handler: "done",
      state: "resolved"
    }, {
      method: "reject",
      handler: "fail",
      state: "rejected"
    }, {
      method: "notify",
      handler: "progress"
    }];
    _DeferredObj = function() {
      var that = this;
      this._state = "pending";
      this._promise = {};
      deferredConfig.forEach((function(config2) {
        var methodName = config2.method;
        this[methodName + "Callbacks"] = new callbacks_default();
        this[methodName] = (function() {
          return this[methodName + "With"](this._promise, arguments);
        }).bind(this);
        this._promise[config2.handler] = function(handler) {
          if (!handler) {
            return this;
          }
          var callbacks2 = that[methodName + "Callbacks"];
          if (callbacks2.fired()) {
            handler.apply(that[methodName + "Context"], that[methodName + "Args"]);
          } else {
            callbacks2.add((function(context2, args) {
              handler.apply(context2, args);
            }).bind(this));
          }
          return this;
        };
      }).bind(this));
      this._promise.always = function(handler) {
        return this.done(handler).fail(handler);
      };
      this._promise.catch = function(handler) {
        return this.then(null, handler);
      };
      this._promise.then = function(resolve, reject) {
        var result2 = new _DeferredObj();
        ["done", "fail"].forEach((function(method) {
          var callback = "done" === method ? resolve : reject;
          this[method](function() {
            if (!callback) {
              result2["done" === method ? "resolve" : "reject"].apply(this, arguments);
              return;
            }
            var callbackResult = callback && callback.apply(this, arguments);
            if (isDeferred(callbackResult)) {
              callbackResult.done(result2.resolve).fail(result2.reject);
            } else if (isPromise(callbackResult)) {
              callbackResult.then(result2.resolve, result2.reject);
            } else {
              result2.resolve.apply(this, isDefined(callbackResult) ? [callbackResult] : arguments);
            }
          });
        }).bind(this));
        return result2.promise();
      };
      this._promise.state = function() {
        return that._state;
      };
      this._promise.promise = function(args) {
        return args ? extend2(args, that._promise) : that._promise;
      };
      this._promise.promise(this);
    };
    deferredConfig.forEach(function(config2) {
      var methodName = config2.method;
      var state = config2.state;
      _DeferredObj.prototype[methodName + "With"] = function(context2, args) {
        var callbacks2 = this[methodName + "Callbacks"];
        if ("pending" === this.state()) {
          this[methodName + "Args"] = args;
          this[methodName + "Context"] = context2;
          if (state) {
            this._state = state;
          }
          callbacks2.fire(context2, args);
        }
        return this;
      };
    });
    whenFunc = function() {
      if (1 === arguments.length) {
        return fromPromise(arguments[0]);
      }
      var values = [].slice.call(arguments);
      var contexts = [];
      var resolvedCount = 0;
      var deferred = new _DeferredObj();
      var updateState = function(i2) {
        return function(value2) {
          contexts[i2] = this;
          values[i2] = arguments.length > 1 ? [].slice.call(arguments) : value2;
          resolvedCount++;
          if (resolvedCount === values.length) {
            deferred.resolveWith(contexts, values);
          }
        };
      };
      for (var i = 0; i < values.length; i++) {
        if (isDeferred(values[i])) {
          values[i].promise().done(updateState(i)).fail(deferred.reject);
        } else {
          resolvedCount++;
        }
      }
      if (resolvedCount === values.length) {
        deferred.resolveWith(contexts, values);
      }
      return deferred.promise();
    };
  }
});

// node_modules/devextreme/esm/core/utils/variable_wrapper.js
var variable_wrapper_default;
var init_variable_wrapper = __esm({
  "node_modules/devextreme/esm/core/utils/variable_wrapper.js"() {
    init_console();
    init_dependency_injector();
    variable_wrapper_default = dependency_injector_default({
      isWrapped: function() {
        return false;
      },
      isWritableWrapped: function() {
        return false;
      },
      wrap: function(value2) {
        return value2;
      },
      unwrap: function(value2) {
        return value2;
      },
      assign: function() {
        logger.error("Method 'assign' should not be used for not wrapped variables. Use 'isWrapped' method for ensuring.");
      }
    });
  }
});

// node_modules/devextreme/esm/core/utils/object.js
var orderEach, assignValueToProperty, deepExtendArraySafe;
var init_object = __esm({
  "node_modules/devextreme/esm/core/utils/object.js"() {
    init_type();
    init_variable_wrapper();
    orderEach = function(map2, func) {
      var keys = [];
      var key;
      var i;
      for (key in map2) {
        if (Object.prototype.hasOwnProperty.call(map2, key)) {
          keys.push(key);
        }
      }
      keys.sort(function(x, y) {
        var isNumberX = isNumeric(x);
        var isNumberY = isNumeric(y);
        if (isNumberX && isNumberY) {
          return x - y;
        }
        if (isNumberX && !isNumberY) {
          return -1;
        }
        if (!isNumberX && isNumberY) {
          return 1;
        }
        if (x < y) {
          return -1;
        }
        if (x > y) {
          return 1;
        }
        return 0;
      });
      for (i = 0; i < keys.length; i++) {
        key = keys[i];
        func(key, map2[key]);
      }
    };
    assignValueToProperty = function(target, property, value2, assignByReference) {
      if (!assignByReference && variable_wrapper_default.isWrapped(target[property])) {
        variable_wrapper_default.assign(target[property], value2);
      } else {
        target[property] = value2;
      }
    };
    deepExtendArraySafe = function deepExtendArraySafe2(target, changes, extendComplexObject, assignByReference) {
      var prevValue;
      var newValue;
      for (var name2 in changes) {
        prevValue = target[name2];
        newValue = changes[name2];
        if ("__proto__" === name2 || "constructor" === name2 || target === newValue) {
          continue;
        }
        if (isPlainObject(newValue)) {
          var goDeeper = extendComplexObject ? isObject2(prevValue) : isPlainObject(prevValue);
          newValue = deepExtendArraySafe2(goDeeper ? prevValue : {}, newValue, extendComplexObject, assignByReference);
        }
        if (void 0 !== newValue && prevValue !== newValue) {
          assignValueToProperty(target, name2, newValue, assignByReference);
        }
      }
      return target;
    };
  }
});

// node_modules/devextreme/esm/core/utils/data.js
function unwrap(value2, options2) {
  return options2.unwrapObservables ? unwrapVariable(value2) : value2;
}
function combineGetters(getters) {
  var compiledGetters = {};
  for (var i = 0, l = getters.length; i < l; i++) {
    var getter = getters[i];
    compiledGetters[getter] = compileGetter(getter);
  }
  return function(obj, options2) {
    var result2;
    each(compiledGetters, function(name2) {
      var value2 = this(obj, options2);
      if (void 0 === value2) {
        return;
      }
      var current2 = result2 || (result2 = {});
      var path = name2.split(".");
      var last = path.length - 1;
      for (var _i = 0; _i < last; _i++) {
        var pathItem = path[_i];
        if (!(pathItem in current2)) {
          current2[pathItem] = {};
        }
        current2 = current2[pathItem];
      }
      current2[path[last]] = value2;
    });
    return result2;
  };
}
var unwrapVariable, isWrapped, assign, bracketsToDots, readPropValue, assignPropValue, prepareOptions, compileGetter, ensurePropValueDefined, compileSetter, toComparable;
var init_data = __esm({
  "node_modules/devextreme/esm/core/utils/data.js"() {
    init_errors();
    init_class();
    init_object();
    init_type();
    init_iterator();
    init_variable_wrapper();
    unwrapVariable = variable_wrapper_default.unwrap;
    isWrapped = variable_wrapper_default.isWrapped;
    assign = variable_wrapper_default.assign;
    bracketsToDots = function(expr) {
      return expr.replace(/\[/g, ".").replace(/\]/g, "");
    };
    readPropValue = function(obj, propName, options2) {
      options2 = options2 || {};
      if ("this" === propName) {
        return unwrap(obj, options2);
      }
      return unwrap(obj[propName], options2);
    };
    assignPropValue = function(obj, propName, value2, options2) {
      if ("this" === propName) {
        throw new errors_default.Error("E4016");
      }
      var propValue = obj[propName];
      if (options2.unwrapObservables && isWrapped(propValue)) {
        assign(propValue, value2);
      } else {
        obj[propName] = value2;
      }
    };
    prepareOptions = function(options2) {
      options2 = options2 || {};
      options2.unwrapObservables = void 0 !== options2.unwrapObservables ? options2.unwrapObservables : true;
      return options2;
    };
    compileGetter = function(expr) {
      if (arguments.length > 1) {
        expr = [].slice.call(arguments);
      }
      if (!expr || "this" === expr) {
        return function(obj) {
          return obj;
        };
      }
      if ("string" === typeof expr) {
        expr = bracketsToDots(expr);
        var path = expr.split(".");
        return function(obj, options2) {
          options2 = prepareOptions(options2);
          var functionAsIs = options2.functionsAsIs;
          var hasDefaultValue = "defaultValue" in options2;
          var current2 = unwrap(obj, options2);
          for (var i = 0; i < path.length; i++) {
            if (!current2) {
              if (null == current2 && hasDefaultValue) {
                return options2.defaultValue;
              }
              break;
            }
            var pathPart = path[i];
            if (hasDefaultValue && isObject2(current2) && !(pathPart in current2)) {
              return options2.defaultValue;
            }
            var next = unwrap(current2[pathPart], options2);
            if (!functionAsIs && isFunction(next)) {
              next = next.call(current2);
            }
            current2 = next;
          }
          return current2;
        };
      }
      if (Array.isArray(expr)) {
        return combineGetters(expr);
      }
      if (isFunction(expr)) {
        return expr;
      }
    };
    ensurePropValueDefined = function(obj, propName, value2, options2) {
      if (isDefined(value2)) {
        return value2;
      }
      var newValue = {};
      assignPropValue(obj, propName, newValue, options2);
      return newValue;
    };
    compileSetter = function(expr) {
      expr = bracketsToDots(expr || "this").split(".");
      var lastLevelIndex = expr.length - 1;
      return function(obj, value2, options2) {
        options2 = prepareOptions(options2);
        var currentValue = unwrap(obj, options2);
        expr.forEach(function(propertyName, levelIndex) {
          var propertyValue = readPropValue(currentValue, propertyName, options2);
          var isPropertyFunc = !options2.functionsAsIs && isFunction(propertyValue) && !isWrapped(propertyValue);
          if (levelIndex === lastLevelIndex) {
            if (options2.merge && isPlainObject(value2) && (!isDefined(propertyValue) || isPlainObject(propertyValue))) {
              propertyValue = ensurePropValueDefined(currentValue, propertyName, propertyValue, options2);
              deepExtendArraySafe(propertyValue, value2, false, true);
            } else if (isPropertyFunc) {
              currentValue[propertyName](value2);
            } else {
              assignPropValue(currentValue, propertyName, value2, options2);
            }
          } else {
            propertyValue = ensurePropValueDefined(currentValue, propertyName, propertyValue, options2);
            if (isPropertyFunc) {
              propertyValue = propertyValue.call(currentValue);
            }
            currentValue = propertyValue;
          }
        });
      };
    };
    toComparable = function(value2, caseSensitive) {
      if (value2 instanceof Date) {
        return value2.getTime();
      }
      if (value2 && value2 instanceof class_default && value2.valueOf) {
        return value2.valueOf();
      }
      if (!caseSensitive && "string" === typeof value2) {
        return value2.toLowerCase();
      }
      return value2;
    };
  }
});

// node_modules/devextreme/esm/core/utils/common.js
var ensureDefined, executeAsync, delayedFuncs, delayedNames, delayedDeferreds, executingName, deferExecute, deferRender, deferUpdate, deferRenderer, deferUpdater, findBestMatches, match, splitPair, pairToObject, getKeyHash, escapeRegExp, applyServerDecimalSeparator, noop2, asyncNoop, grep, arraysEqualByValue, objectsEqualByValue, maxEqualityDepth, equalByValue;
var init_common = __esm({
  "node_modules/devextreme/esm/core/utils/common.js"() {
    init_config();
    init_guid();
    init_deferred();
    init_data();
    init_iterator();
    init_type();
    ensureDefined = function(value2, defaultValue) {
      return isDefined(value2) ? value2 : defaultValue;
    };
    executeAsync = function(action, context2) {
      var deferred = new Deferred();
      var normalizedContext = context2 || this;
      var task = {
        promise: deferred.promise(),
        abort: function() {
          clearTimeout(timerId);
          deferred.rejectWith(normalizedContext);
        }
      };
      var callback = function() {
        var result2 = action.call(normalizedContext);
        if (result2 && result2.done && isFunction(result2.done)) {
          result2.done(function() {
            deferred.resolveWith(normalizedContext);
          });
        } else {
          deferred.resolveWith(normalizedContext);
        }
      };
      var timerId = (arguments[2] || setTimeout)(callback, "number" === typeof context2 ? context2 : 0);
      return task;
    };
    delayedFuncs = [];
    delayedNames = [];
    delayedDeferreds = [];
    deferExecute = function(name2, func, deferred) {
      if (executingName && executingName !== name2) {
        delayedFuncs.push(func);
        delayedNames.push(name2);
        deferred = deferred || new Deferred();
        delayedDeferreds.push(deferred);
        return deferred;
      } else {
        var oldExecutingName = executingName;
        var currentDelayedCount = delayedDeferreds.length;
        executingName = name2;
        var result2 = func();
        if (!result2) {
          if (delayedDeferreds.length > currentDelayedCount) {
            result2 = when.apply(this, delayedDeferreds.slice(currentDelayedCount));
          } else if (deferred) {
            deferred.resolve();
          }
        }
        executingName = oldExecutingName;
        if (deferred && result2 && result2.done) {
          result2.done(deferred.resolve).fail(deferred.reject);
        }
        if (!executingName && delayedFuncs.length) {
          ("render" === delayedNames.shift() ? deferRender : deferUpdate)(delayedFuncs.shift(), delayedDeferreds.shift());
        }
        return result2 || when();
      }
    };
    deferRender = function(func, deferred) {
      return deferExecute("render", func, deferred);
    };
    deferUpdate = function(func, deferred) {
      return deferExecute("update", func, deferred);
    };
    deferRenderer = function(func) {
      return function() {
        var that = this;
        return deferExecute("render", function() {
          return func.call(that);
        });
      };
    };
    deferUpdater = function(func) {
      return function() {
        var that = this;
        return deferExecute("update", function() {
          return func.call(that);
        });
      };
    };
    findBestMatches = function(targetFilter, items, mapFn) {
      var bestMatches = [];
      var maxMatchCount = 0;
      each(items, (index2, itemSrc) => {
        var matchCount = 0;
        var item = mapFn ? mapFn(itemSrc) : itemSrc;
        each(targetFilter, (paramName, targetValue) => {
          var value2 = item[paramName];
          if (void 0 === value2) {
            return;
          }
          if (match(value2, targetValue)) {
            matchCount++;
            return;
          }
          matchCount = -1;
          return false;
        });
        if (matchCount < maxMatchCount) {
          return;
        }
        if (matchCount > maxMatchCount) {
          bestMatches.length = 0;
          maxMatchCount = matchCount;
        }
        bestMatches.push(itemSrc);
      });
      return bestMatches;
    };
    match = function(value2, targetValue) {
      if (Array.isArray(value2) && Array.isArray(targetValue)) {
        var mismatch = false;
        each(value2, (index2, valueItem) => {
          if (valueItem !== targetValue[index2]) {
            mismatch = true;
            return false;
          }
        });
        if (mismatch) {
          return false;
        }
        return true;
      }
      if (value2 === targetValue) {
        return true;
      }
      return false;
    };
    splitPair = function(raw) {
      var _raw$x, _raw$y;
      switch (type(raw)) {
        case "string":
          return raw.split(/\s+/, 2);
        case "object":
          return [null !== (_raw$x = raw.x) && void 0 !== _raw$x ? _raw$x : raw.h, null !== (_raw$y = raw.y) && void 0 !== _raw$y ? _raw$y : raw.v];
        case "number":
          return [raw];
        case "array":
          return raw;
        default:
          return null;
      }
    };
    pairToObject = function(raw, preventRound) {
      var pair = splitPair(raw);
      var h = preventRound ? parseFloat(pair && pair[0]) : parseInt(pair && pair[0], 10);
      var v = preventRound ? parseFloat(pair && pair[1]) : parseInt(pair && pair[1], 10);
      if (!isFinite(h)) {
        h = 0;
      }
      if (!isFinite(v)) {
        v = h;
      }
      return {
        h,
        v
      };
    };
    getKeyHash = function(key) {
      if (key instanceof guid_default) {
        return key.toString();
      } else if (isObject2(key) || Array.isArray(key)) {
        try {
          var keyHash = JSON.stringify(key);
          return "{}" === keyHash ? key : keyHash;
        } catch (e) {
          return key;
        }
      }
      return key;
    };
    escapeRegExp = function(string) {
      return string.replace(/[[\]{}\-()*+?.\\^$|\s]/g, "\\$&");
    };
    applyServerDecimalSeparator = function(value2) {
      var separator = config_default().serverDecimalSeparator;
      if (isDefined(value2)) {
        value2 = value2.toString().replace(".", separator);
      }
      return value2;
    };
    noop2 = function() {
    };
    asyncNoop = function() {
      return new Deferred().resolve().promise();
    };
    grep = function(elements, checkFunction, invert) {
      var result2 = [];
      var check;
      var expectedCheck = !invert;
      for (var i = 0; i < elements.length; i++) {
        check = !!checkFunction(elements[i], i);
        if (check === expectedCheck) {
          result2.push(elements[i]);
        }
      }
      return result2;
    };
    arraysEqualByValue = function(array1, array2, depth) {
      if (array1.length !== array2.length) {
        return false;
      }
      for (var i = 0; i < array1.length; i++) {
        if (!equalByValue(array1[i], array2[i], depth + 1)) {
          return false;
        }
      }
      return true;
    };
    objectsEqualByValue = function(object1, object2, depth, strict) {
      for (var propertyName in object1) {
        if (Object.prototype.hasOwnProperty.call(object1, propertyName) && !equalByValue(object1[propertyName], object2[propertyName], depth + 1, strict)) {
          return false;
        }
      }
      for (var _propertyName in object2) {
        if (!(_propertyName in object1)) {
          return false;
        }
      }
      return true;
    };
    maxEqualityDepth = 3;
    equalByValue = function(object1, object2) {
      var depth = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
      var strict = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : true;
      object1 = toComparable(object1, true);
      object2 = toComparable(object2, true);
      var comparisonResult = strict ? object1 === object2 : object1 == object2;
      if (comparisonResult || depth >= maxEqualityDepth) {
        return true;
      }
      if (isObject2(object1) && isObject2(object2)) {
        return objectsEqualByValue(object1, object2, depth, strict);
      } else if (Array.isArray(object1) && Array.isArray(object2)) {
        return arraysEqualByValue(object1, object2, depth);
      }
      return false;
    };
  }
});

// node_modules/devextreme/esm/core/dom_adapter.js
var dom_adapter_exports = {};
__export(dom_adapter_exports, {
  default: () => dom_adapter_default
});
var ELEMENT_NODE, TEXT_NODE, DOCUMENT_NODE, nativeDOMAdapterStrategy, dom_adapter_default;
var init_dom_adapter = __esm({
  "node_modules/devextreme/esm/core/dom_adapter.js"() {
    init_dependency_injector();
    init_common();
    ELEMENT_NODE = 1;
    TEXT_NODE = 3;
    DOCUMENT_NODE = 9;
    nativeDOMAdapterStrategy = {
      querySelectorAll: (element, selector) => element.querySelectorAll(selector),
      elementMatches(element, selector) {
        var matches = element.matches || element.matchesSelector || element.mozMatchesSelector || element.msMatchesSelector || element.oMatchesSelector || element.webkitMatchesSelector || ((selector2) => {
          var doc = element.document || element.ownerDocument;
          if (!doc) {
            return false;
          }
          var items = this.querySelectorAll(doc, selector2);
          for (var i = 0; i < items.length; i++) {
            if (items[i] === element) {
              return true;
            }
          }
        });
        return matches.call(element, selector);
      },
      createElement(tagName, context2) {
        context2 = context2 || this._document;
        return context2.createElement(tagName);
      },
      createElementNS(ns, tagName, context2) {
        context2 = context2 || this._document;
        return context2.createElementNS(ns, tagName);
      },
      createTextNode(text, context2) {
        context2 = context2 || this._document;
        return context2.createTextNode(text);
      },
      isNode: (element) => element && "object" === typeof element && "nodeType" in element && "nodeName" in element,
      isElementNode: (element) => element && element.nodeType === ELEMENT_NODE,
      isTextNode: (element) => element && element.nodeType === TEXT_NODE,
      isDocument: (element) => element && element.nodeType === DOCUMENT_NODE,
      removeElement(element) {
        var parentNode = element && element.parentNode;
        if (parentNode) {
          parentNode.removeChild(element);
        }
      },
      insertElement(parentElement, newElement, nextSiblingElement) {
        if (parentElement && newElement && parentElement !== newElement) {
          if (nextSiblingElement) {
            parentElement.insertBefore(newElement, nextSiblingElement);
          } else {
            parentElement.appendChild(newElement);
          }
        }
      },
      getAttribute: (element, name2) => element.getAttribute(name2),
      setAttribute(element, name2, value2) {
        element.setAttribute(name2, value2);
      },
      removeAttribute(element, name2) {
        element.removeAttribute(name2);
      },
      setProperty(element, name2, value2) {
        element[name2] = value2;
      },
      setText(element, text) {
        if (element) {
          element.textContent = text;
        }
      },
      setClass(element, className, isAdd) {
        if (1 === element.nodeType && className) {
          if (element.classList) {
            if (isAdd) {
              element.classList.add(className);
            } else {
              element.classList.remove(className);
            }
          } else {
            var classNameSupported = "string" === typeof element.className;
            var elementClass = classNameSupported ? element.className : this.getAttribute(element, "class") || "";
            var classNames = elementClass.split(" ");
            var classIndex = classNames.indexOf(className);
            var resultClassName;
            if (isAdd && classIndex < 0) {
              resultClassName = elementClass ? elementClass + " " + className : className;
            }
            if (!isAdd && classIndex >= 0) {
              classNames.splice(classIndex, 1);
              resultClassName = classNames.join(" ");
            }
            if (void 0 !== resultClassName) {
              if (classNameSupported) {
                element.className = resultClassName;
              } else {
                this.setAttribute(element, "class", resultClassName);
              }
            }
          }
        }
      },
      setStyle(element, name2, value2) {
        element.style[name2] = value2 || "";
      },
      _document: "undefined" === typeof document ? void 0 : document,
      getDocument() {
        return this._document;
      },
      getActiveElement() {
        return this._document.activeElement;
      },
      getBody() {
        return this._document.body;
      },
      createDocumentFragment() {
        return this._document.createDocumentFragment();
      },
      getDocumentElement() {
        return this._document.documentElement;
      },
      getLocation() {
        return this._document.location;
      },
      getSelection() {
        return this._document.selection;
      },
      getReadyState() {
        return this._document.readyState;
      },
      getHead() {
        return this._document.head;
      },
      hasDocumentProperty(property) {
        return property in this._document;
      },
      listen(element, event, callback, options2) {
        if (!element || !("addEventListener" in element)) {
          return noop2;
        }
        element.addEventListener(event, callback, options2);
        return () => {
          element.removeEventListener(event, callback);
        };
      }
    };
    dom_adapter_default = dependency_injector_default(nativeDOMAdapterStrategy);
  }
});

// node_modules/devextreme/esm/core/utils/window.js
var hasWindowValue, hasWindow, windowObject, getWindow, hasProperty, defaultScreenFactorFunc, getCurrentScreenFactor, getNavigator;
var init_window = __esm({
  "node_modules/devextreme/esm/core/utils/window.js"() {
    init_dom_adapter();
    hasWindowValue = "undefined" !== typeof window;
    hasWindow = () => hasWindowValue;
    windowObject = hasWindow() ? window : void 0;
    if (!windowObject) {
      windowObject = {};
      windowObject.window = windowObject;
    }
    getWindow = () => windowObject;
    hasProperty = (prop) => hasWindow() && prop in windowObject;
    defaultScreenFactorFunc = (width) => {
      if (width < 768) {
        return "xs";
      } else if (width < 992) {
        return "sm";
      } else if (width < 1200) {
        return "md";
      } else {
        return "lg";
      }
    };
    getCurrentScreenFactor = (screenFactorCallback) => {
      var screenFactorFunc = screenFactorCallback || defaultScreenFactorFunc;
      var windowWidth = dom_adapter_default.getDocumentElement().clientWidth;
      return screenFactorFunc(windowWidth);
    };
    getNavigator = () => hasWindow() ? windowObject.navigator : {
      userAgent: ""
    };
  }
});

// node_modules/devextreme/esm/core/utils/browser.js
var navigator, webkitRegExp, ieRegExp, ie11RegExp, msEdge, mozillaRegExp, browserFromUA, browser_default;
var init_browser = __esm({
  "node_modules/devextreme/esm/core/utils/browser.js"() {
    init_extend();
    init_window();
    navigator = getNavigator();
    webkitRegExp = /(webkit)[ /]([\w.]+)/;
    ieRegExp = /(msie) (\d{1,2}\.\d)/;
    ie11RegExp = /(trident).*rv:(\d{1,2}\.\d)/;
    msEdge = /(edge)\/((\d+)?[\w.]+)/;
    mozillaRegExp = /(mozilla)(?:.*? rv:([\w.]+))/;
    browserFromUA = function(ua2) {
      ua2 = ua2.toLowerCase();
      var result2 = {};
      var matches = ieRegExp.exec(ua2) || ie11RegExp.exec(ua2) || msEdge.exec(ua2) || ua2.indexOf("compatible") < 0 && mozillaRegExp.exec(ua2) || webkitRegExp.exec(ua2) || [];
      var browserName = matches[1];
      var browserVersion = matches[2];
      if ("webkit" === browserName) {
        result2.webkit = true;
        if (ua2.indexOf("chrome") >= 0 || ua2.indexOf("crios") >= 0) {
          browserName = "chrome";
          browserVersion = /(?:chrome|crios)\/(\d+\.\d+)/.exec(ua2);
          browserVersion = browserVersion && browserVersion[1];
        } else if (ua2.indexOf("fxios") >= 0) {
          browserName = "mozilla";
          browserVersion = /fxios\/(\d+\.\d+)/.exec(ua2);
          browserVersion = browserVersion && browserVersion[1];
        } else if (ua2.indexOf("safari") >= 0 && /version|phantomjs/.test(ua2)) {
          browserName = "safari";
          browserVersion = /(?:version|phantomjs)\/([0-9.]+)/.exec(ua2);
          browserVersion = browserVersion && browserVersion[1];
        } else {
          browserName = "unknown";
          browserVersion = /applewebkit\/([0-9.]+)/.exec(ua2);
          browserVersion = browserVersion && browserVersion[1];
        }
      }
      if ("trident" === browserName || "edge" === browserName) {
        browserName = "msie";
      }
      if (browserName) {
        result2[browserName] = true;
        result2.version = browserVersion;
      }
      return result2;
    };
    browser_default = extend2({
      _fromUA: browserFromUA
    }, browserFromUA(navigator.userAgent));
  }
});

// node_modules/devextreme/esm/core/utils/array.js
var isIE11, isEmpty2, wrapToArray, inArray, uniqueValues, removeDuplicates, normalizeIndexes, merge, find, groupBy;
var init_array = __esm({
  "node_modules/devextreme/esm/core/utils/array.js"() {
    init_extends();
    init_type();
    init_iterator();
    init_object();
    init_config();
    init_browser();
    isIE11 = browser_default.msie && parseInt(browser_default.version) <= 11;
    isEmpty2 = function(entity) {
      return Array.isArray(entity) && !entity.length;
    };
    wrapToArray = function(entity) {
      return Array.isArray(entity) ? entity : [entity];
    };
    inArray = function(value2, object) {
      if (!object) {
        return -1;
      }
      var array = Array.isArray(object) ? object : object.toArray();
      return array.indexOf(value2);
    };
    uniqueValues = function(data2) {
      if (isIE11) {
        return data2.filter(function(item, position3) {
          return data2.indexOf(item) === position3;
        });
      }
      return [...new Set(data2)];
    };
    removeDuplicates = function(from, what) {
      if (!Array.isArray(from) || 0 === from.length) {
        return [];
      }
      var result2 = from.slice();
      if (!Array.isArray(what) || 0 === what.length) {
        return result2;
      }
      each(what, function(_2, value2) {
        var index2 = inArray(value2, result2);
        result2.splice(index2, 1);
      });
      return result2;
    };
    normalizeIndexes = function(items, indexParameterName, currentItem, needIndexCallback) {
      var indexedItems = {};
      var parameterIndex = 0;
      var useLegacyVisibleIndex = config_default().useLegacyVisibleIndex;
      each(items, function(index2, item) {
        index2 = item[indexParameterName];
        if (index2 >= 0) {
          indexedItems[index2] = indexedItems[index2] || [];
          if (item === currentItem) {
            indexedItems[index2].unshift(item);
          } else {
            indexedItems[index2].push(item);
          }
        } else {
          item[indexParameterName] = void 0;
        }
      });
      if (!useLegacyVisibleIndex) {
        each(items, function() {
          if (!isDefined(this[indexParameterName]) && (!needIndexCallback || needIndexCallback(this))) {
            while (indexedItems[parameterIndex]) {
              parameterIndex++;
            }
            indexedItems[parameterIndex] = [this];
            parameterIndex++;
          }
        });
      }
      parameterIndex = 0;
      orderEach(indexedItems, function(index2, items2) {
        each(items2, function() {
          if (index2 >= 0) {
            this[indexParameterName] = parameterIndex++;
          }
        });
      });
      if (useLegacyVisibleIndex) {
        each(items, function() {
          if (!isDefined(this[indexParameterName]) && (!needIndexCallback || needIndexCallback(this))) {
            this[indexParameterName] = parameterIndex++;
          }
        });
      }
      return parameterIndex;
    };
    merge = function(array1, array2) {
      for (var i = 0; i < array2.length; i++) {
        array1[array1.length] = array2[i];
      }
      return array1;
    };
    find = function(array, condition) {
      for (var i = 0; i < array.length; i++) {
        if (condition(array[i])) {
          return array[i];
        }
      }
    };
    groupBy = (array, cb) => array.reduce((result2, item) => _extends({}, result2, {
      [cb(item)]: [...result2[cb(item)] || [], item]
    }), {});
  }
});

// node_modules/devextreme/esm/core/polyfills/weak_map.js
var weakMap, weak_map_default;
var init_weak_map = __esm({
  "node_modules/devextreme/esm/core/polyfills/weak_map.js"() {
    init_array();
    init_window();
    weakMap = hasWindow() ? getWindow().WeakMap : WeakMap;
    if (!weakMap) {
      weakMap = function() {
        var keys = [];
        var values = [];
        this.set = function(key, value2) {
          var index2 = inArray(key, keys);
          if (-1 === index2) {
            keys.push(key);
            values.push(value2);
          } else {
            values[index2] = value2;
          }
        };
        this.get = function(key) {
          var index2 = inArray(key, keys);
          if (-1 === index2) {
            return;
          }
          return values[index2];
        };
        this.has = function(key) {
          var index2 = inArray(key, keys);
          if (-1 === index2) {
            return false;
          }
          return true;
        };
        this.delete = function(key) {
          var index2 = inArray(key, keys);
          if (-1 === index2) {
            return;
          }
          keys.splice(index2, 1);
          values.splice(index2, 1);
        };
      };
    }
    weak_map_default = weakMap;
  }
});

// node_modules/devextreme/esm/events/core/hook_touch_props.js
function hook_touch_props_default(callback) {
  touchPropsToHook.forEach(function(name2) {
    callback(name2, function(event) {
      return touchPropHook(name2, event);
    });
  }, this);
}
var touchPropsToHook, touchPropHook;
var init_hook_touch_props = __esm({
  "node_modules/devextreme/esm/events/core/hook_touch_props.js"() {
    touchPropsToHook = ["pageX", "pageY", "screenX", "screenY", "clientX", "clientY"];
    touchPropHook = function(name2, event) {
      if (event[name2] && !event.touches || !event.touches) {
        return event[name2];
      }
      var touches = event.touches.length ? event.touches : event.changedTouches;
      if (!touches.length) {
        return;
      }
      return touches[0][name2];
    };
  }
});

// node_modules/devextreme/esm/core/utils/call_once.js
var callOnce, call_once_default;
var init_call_once = __esm({
  "node_modules/devextreme/esm/core/utils/call_once.js"() {
    callOnce = function(handler) {
      var result2;
      var _wrappedHandler = function() {
        result2 = handler.apply(this, arguments);
        _wrappedHandler = function() {
          return result2;
        };
        return result2;
      };
      return function() {
        return _wrappedHandler.apply(this, arguments);
      };
    };
    call_once_default = callOnce;
  }
});

// node_modules/devextreme/esm/events/core/events_engine.js
function matchesSafe(target, selector) {
  return !isWindow(target) && "#document" !== target.nodeName && dom_adapter_default.elementMatches(target, selector);
}
function applyForEach(args, method) {
  var element = args[0];
  if (!element) {
    return;
  }
  if (dom_adapter_default.isNode(element) || isWindow(element)) {
    method.apply(eventsEngine, args);
  } else if (!isString2(element) && "length" in element) {
    var itemArgs = Array.prototype.slice.call(args, 0);
    Array.prototype.forEach.call(element, function(itemElement) {
      itemArgs[0] = itemElement;
      applyForEach(itemArgs, method);
    });
  } else {
    throw errors_default.Error("E0025");
  }
}
function getHandler(method) {
  return function() {
    applyForEach(arguments, method);
  };
}
function detectPassiveEventHandlersSupport() {
  var isSupported = false;
  try {
    var options2 = Object.defineProperty({}, "passive", {
      get: function() {
        isSupported = true;
        return true;
      }
    });
    window2.addEventListener("test", null, options2);
  } catch (e) {
  }
  return isSupported;
}
function getHandlersController(element, eventName) {
  var elementData = elementDataMap.get(element);
  eventName = eventName || "";
  var eventNameParts = eventName.split(".");
  var namespaces2 = eventNameParts.slice(1);
  var eventNameIsDefined = !!eventNameParts[0];
  eventName = eventNameParts[0] || EMPTY_EVENT_NAME;
  if (!elementData) {
    elementData = {};
    elementDataMap.set(element, elementData);
  }
  if (!elementData[eventName]) {
    elementData[eventName] = {
      handleObjects: [],
      nativeHandler: null
    };
  }
  var eventData2 = elementData[eventName];
  return {
    addHandler: function(handler, selector, data2) {
      var callHandler = function(e, extraParameters) {
        var handlerArgs = [e];
        var target = e.currentTarget;
        var relatedTarget = e.relatedTarget;
        var secondaryTargetIsInside;
        var result2;
        if (eventName in NATIVE_EVENTS_TO_SUBSCRIBE) {
          secondaryTargetIsInside = relatedTarget && target && (relatedTarget === target || contains(target, relatedTarget));
        }
        if (void 0 !== extraParameters) {
          handlerArgs.push(extraParameters);
        }
        special.callMethod(eventName, "handle", element, [e, data2]);
        if (!secondaryTargetIsInside) {
          result2 = handler.apply(target, handlerArgs);
        }
        if (false === result2) {
          e.preventDefault();
          e.stopPropagation();
        }
      };
      var handleObject = {
        handler,
        wrappedHandler: function(e, extraParameters) {
          if (skipEvent && e.type === skipEvent) {
            return;
          }
          e.data = data2;
          e.delegateTarget = element;
          if (selector) {
            var currentTarget = e.target;
            while (currentTarget && currentTarget !== element) {
              if (matchesSafe(currentTarget, selector)) {
                e.currentTarget = currentTarget;
                callHandler(e, extraParameters);
              }
              currentTarget = currentTarget.parentNode;
            }
          } else {
            e.currentTarget = e.delegateTarget || e.target;
            callHandler(e, extraParameters);
          }
        },
        selector,
        type: eventName,
        data: data2,
        namespace: namespaces2.join("."),
        namespaces: namespaces2,
        guid: ++guid
      };
      eventData2.handleObjects.push(handleObject);
      var firstHandlerForTheType = 1 === eventData2.handleObjects.length;
      var shouldAddNativeListener = firstHandlerForTheType && eventNameIsDefined;
      var nativeListenerOptions;
      if (shouldAddNativeListener) {
        shouldAddNativeListener = !special.callMethod(eventName, "setup", element, [data2, namespaces2, handler]);
      }
      if (shouldAddNativeListener) {
        eventData2.nativeHandler = getNativeHandler(eventName);
        if (passiveEventHandlersSupported() && forcePassiveFalseEventNames.indexOf(eventName) > -1) {
          nativeListenerOptions = {
            passive: false
          };
        }
        eventData2.removeListener = dom_adapter_default.listen(element, NATIVE_EVENTS_TO_SUBSCRIBE[eventName] || eventName, eventData2.nativeHandler, nativeListenerOptions);
      }
      special.callMethod(eventName, "add", element, [handleObject]);
    },
    removeHandler: function(handler, selector) {
      var removeByEventName = function(eventName2) {
        var eventData3 = elementData[eventName2];
        if (!eventData3.handleObjects.length) {
          delete elementData[eventName2];
          return;
        }
        var removedHandler;
        eventData3.handleObjects = eventData3.handleObjects.filter(function(handleObject) {
          var skip = namespaces2.length && !isSubset(handleObject.namespaces, namespaces2) || handler && handleObject.handler !== handler || selector && handleObject.selector !== selector;
          if (!skip) {
            removedHandler = handleObject.handler;
            special.callMethod(eventName2, "remove", element, [handleObject]);
          }
          return skip;
        });
        var lastHandlerForTheType = !eventData3.handleObjects.length;
        var shouldRemoveNativeListener = lastHandlerForTheType && eventName2 !== EMPTY_EVENT_NAME;
        if (shouldRemoveNativeListener) {
          special.callMethod(eventName2, "teardown", element, [namespaces2, removedHandler]);
          if (eventData3.nativeHandler) {
            eventData3.removeListener();
          }
          delete elementData[eventName2];
        }
      };
      if (eventNameIsDefined) {
        removeByEventName(eventName);
      } else {
        for (var name2 in elementData) {
          removeByEventName(name2);
        }
      }
      var elementDataIsEmpty = 0 === Object.keys(elementData).length;
      if (elementDataIsEmpty) {
        elementDataMap.delete(element);
      }
    },
    callHandlers: function(event, extraParameters) {
      var forceStop = false;
      var handleCallback = function(handleObject) {
        if (forceStop) {
          return;
        }
        if (!namespaces2.length || isSubset(handleObject.namespaces, namespaces2)) {
          handleObject.wrappedHandler(event, extraParameters);
          forceStop = event.isImmediatePropagationStopped();
        }
      };
      eventData2.handleObjects.forEach(handleCallback);
      if (namespaces2.length && elementData[EMPTY_EVENT_NAME]) {
        elementData[EMPTY_EVENT_NAME].handleObjects.forEach(handleCallback);
      }
    }
  };
}
function getNativeHandler(subscribeName) {
  return function(event, extraParameters) {
    var handlersController = getHandlersController(this, subscribeName);
    event = eventsEngine.Event(event);
    handlersController.callHandlers(event, extraParameters);
  };
}
function isSubset(original, checked) {
  for (var i = 0; i < checked.length; i++) {
    if (original.indexOf(checked[i]) < 0) {
      return false;
    }
  }
  return true;
}
function normalizeOnArguments(callback) {
  return function(element, eventName, selector, data2, handler) {
    if (!handler) {
      handler = data2;
      data2 = void 0;
    }
    if ("string" !== typeof selector) {
      data2 = selector;
      selector = void 0;
    }
    if (!handler && "string" === typeof eventName) {
      handler = data2 || selector;
      selector = void 0;
      data2 = void 0;
    }
    callback(element, eventName, selector, data2, handler);
  };
}
function normalizeOffArguments(callback) {
  return function(element, eventName, selector, handler) {
    if ("function" === typeof selector) {
      handler = selector;
      selector = void 0;
    }
    callback(element, eventName, selector, handler);
  };
}
function normalizeTriggerArguments(callback) {
  return function(element, src, extraParameters) {
    if ("string" === typeof src) {
      src = {
        type: src
      };
    }
    if (!src.target) {
      src.target = element;
    }
    src.currentTarget = element;
    if (!src.delegateTarget) {
      src.delegateTarget = element;
    }
    if (!src.type && src.originalEvent) {
      src.type = src.originalEvent.type;
    }
    callback(element, src instanceof eventsEngine.Event ? src : eventsEngine.Event(src), extraParameters);
  };
}
function normalizeEventArguments(callback) {
  eventsEngine.Event = function(src, config2) {
    if (!(this instanceof eventsEngine.Event)) {
      return new eventsEngine.Event(src, config2);
    }
    if (!src) {
      src = {};
    }
    if ("string" === typeof src) {
      src = {
        type: src
      };
    }
    if (!config2) {
      config2 = {};
    }
    callback.call(this, src, config2);
  };
  _extends(eventsEngine.Event.prototype, {
    _propagationStopped: false,
    _immediatePropagationStopped: false,
    _defaultPrevented: false,
    isPropagationStopped: function() {
      return !!(this._propagationStopped || this.originalEvent && this.originalEvent.propagationStopped);
    },
    stopPropagation: function() {
      this._propagationStopped = true;
      this.originalEvent && this.originalEvent.stopPropagation();
    },
    isImmediatePropagationStopped: function() {
      return this._immediatePropagationStopped;
    },
    stopImmediatePropagation: function() {
      this.stopPropagation();
      this._immediatePropagationStopped = true;
      this.originalEvent && this.originalEvent.stopImmediatePropagation();
    },
    isDefaultPrevented: function() {
      return !!(this._defaultPrevented || this.originalEvent && this.originalEvent.defaultPrevented);
    },
    preventDefault: function() {
      this._defaultPrevented = true;
      this.originalEvent && this.originalEvent.preventDefault();
    }
  });
  return eventsEngine.Event;
}
function iterate(callback) {
  var iterateEventNames = function(element, eventName) {
    if (eventName && eventName.indexOf(" ") > -1) {
      var args = Array.prototype.slice.call(arguments, 0);
      eventName.split(" ").forEach(function(eventName2) {
        args[1] = eventName2;
        callback.apply(this, args);
      });
    } else {
      callback.apply(this, arguments);
    }
  };
  return function(element, eventName) {
    if ("object" === typeof eventName) {
      var args = Array.prototype.slice.call(arguments, 0);
      for (var name2 in eventName) {
        args[1] = name2;
        args[args.length - 1] = eventName[name2];
        iterateEventNames.apply(this, args);
      }
    } else {
      iterateEventNames.apply(this, arguments);
    }
  };
}
function callNativeMethod(eventName, element) {
  var nativeMethodName = NATIVE_EVENTS_TO_TRIGGER[eventName] || eventName;
  if (function(eventName2, element2) {
    return "click" === eventName2 && "a" === element2.localName;
  }(eventName, element)) {
    return;
  }
  if (isFunction(element[nativeMethodName])) {
    skipEvent = eventName;
    element[nativeMethodName]();
    skipEvent = void 0;
  }
}
function calculateWhich(event) {
  if (function(event2) {
    return null == event2.which && 0 === event2.type.indexOf("key");
  }(event)) {
    return null != event.charCode ? event.charCode : event.keyCode;
  }
  if (function(event2) {
    return !event2.which && void 0 !== event2.button && /^(?:mouse|pointer|contextmenu|drag|drop)|click/.test(event2.type);
  }(event)) {
    return {
      1: 1,
      2: 3,
      3: 1,
      4: 2
    }[event.button];
  }
  return event.which;
}
function initEvent(EventClass) {
  if (EventClass) {
    eventsEngine.Event = EventClass;
    eventsEngine.Event.prototype = EventClass.prototype;
  }
}
function addProperty(propName, hook, eventInstance) {
  Object.defineProperty(eventInstance || eventsEngine.Event.prototype, propName, {
    enumerable: true,
    configurable: true,
    get: function() {
      return this.originalEvent && hook(this.originalEvent);
    },
    set: function(value2) {
      Object.defineProperty(this, propName, {
        enumerable: true,
        configurable: true,
        writable: true,
        value: value2
      });
    }
  });
}
var window2, EMPTY_EVENT_NAME, NATIVE_EVENTS_TO_SUBSCRIBE, NATIVE_EVENTS_TO_TRIGGER, NO_BUBBLE_EVENTS, forcePassiveFalseEventNames, EVENT_PROPERTIES, elementDataMap, guid, skipEvent, special, eventsEngine, passiveEventHandlersSupported, contains, beforeSetStrategy, afterSetStrategy, events_engine_default;
var init_events_engine = __esm({
  "node_modules/devextreme/esm/events/core/events_engine.js"() {
    init_extends();
    init_event_registrator_callbacks();
    init_extend();
    init_dom_adapter();
    init_window();
    init_dependency_injector();
    init_type();
    init_callbacks();
    init_errors();
    init_weak_map();
    init_hook_touch_props();
    init_call_once();
    window2 = getWindow();
    EMPTY_EVENT_NAME = "dxEmptyEventType";
    NATIVE_EVENTS_TO_SUBSCRIBE = {
      mouseenter: "mouseover",
      mouseleave: "mouseout",
      pointerenter: "pointerover",
      pointerleave: "pointerout"
    };
    NATIVE_EVENTS_TO_TRIGGER = {
      focusin: "focus",
      focusout: "blur"
    };
    NO_BUBBLE_EVENTS = ["blur", "focus", "load"];
    forcePassiveFalseEventNames = ["touchmove", "wheel", "mousewheel", "touchstart"];
    EVENT_PROPERTIES = ["target", "relatedTarget", "delegateTarget", "altKey", "bubbles", "cancelable", "changedTouches", "ctrlKey", "detail", "eventPhase", "metaKey", "shiftKey", "view", "char", "code", "charCode", "key", "keyCode", "button", "buttons", "offsetX", "offsetY", "pointerId", "pointerType", "targetTouches", "toElement", "touches"];
    elementDataMap = new weak_map_default();
    guid = 0;
    special = function() {
      var specialData = {};
      event_registrator_callbacks_default.add(function(eventName, eventObject) {
        specialData[eventName] = eventObject;
      });
      return {
        getField: function(eventName, field) {
          return specialData[eventName] && specialData[eventName][field];
        },
        callMethod: function(eventName, methodName, context2, args) {
          return specialData[eventName] && specialData[eventName][methodName] && specialData[eventName][methodName].apply(context2, args);
        }
      };
    }();
    eventsEngine = dependency_injector_default({
      on: getHandler(normalizeOnArguments(iterate(function(element, eventName, selector, data2, handler) {
        var handlersController = getHandlersController(element, eventName);
        handlersController.addHandler(handler, selector, data2);
      }))),
      one: getHandler(normalizeOnArguments(function(element, eventName, selector, data2, handler) {
        eventsEngine.on(element, eventName, selector, data2, function oneTimeHandler() {
          eventsEngine.off(element, eventName, selector, oneTimeHandler);
          handler.apply(this, arguments);
        });
      })),
      off: getHandler(normalizeOffArguments(iterate(function(element, eventName, selector, handler) {
        var handlersController = getHandlersController(element, eventName);
        handlersController.removeHandler(handler, selector);
      }))),
      trigger: getHandler(normalizeTriggerArguments(function(element, event, extraParameters) {
        var eventName = event.type;
        var handlersController = getHandlersController(element, event.type);
        special.callMethod(eventName, "trigger", element, [event, extraParameters]);
        handlersController.callHandlers(event, extraParameters);
        var noBubble = special.getField(eventName, "noBubble") || event.isPropagationStopped() || -1 !== NO_BUBBLE_EVENTS.indexOf(eventName);
        if (!noBubble) {
          var parents = [];
          !function getParents(element2) {
            var parent = element2.parentNode;
            if (parent) {
              parents.push(parent);
              getParents(parent);
            }
          }(element);
          parents.push(window2);
          var i = 0;
          while (parents[i] && !event.isPropagationStopped()) {
            var parentDataByEvent = getHandlersController(parents[i], event.type);
            parentDataByEvent.callHandlers(extend2(event, {
              currentTarget: parents[i]
            }), extraParameters);
            i++;
          }
        }
        if (element.nodeType || isWindow(element)) {
          special.callMethod(eventName, "_default", element, [event, extraParameters]);
          callNativeMethod(eventName, element);
        }
      })),
      triggerHandler: getHandler(normalizeTriggerArguments(function(element, event, extraParameters) {
        var handlersController = getHandlersController(element, event.type);
        handlersController.callHandlers(event, extraParameters);
      }))
    });
    passiveEventHandlersSupported = call_once_default(detectPassiveEventHandlersSupport);
    contains = (container, element) => {
      if (isWindow(container)) {
        return contains(container.document, element);
      }
      return container.contains ? container.contains(element) : !!(element.compareDocumentPosition(container) & element.DOCUMENT_POSITION_CONTAINS);
    };
    initEvent(normalizeEventArguments(function(src, config2) {
      var _src$view;
      var srcIsEvent = src instanceof eventsEngine.Event || hasWindow() && src instanceof window2.Event || (null === (_src$view = src.view) || void 0 === _src$view ? void 0 : _src$view.Event) && src instanceof src.view.Event;
      if (srcIsEvent) {
        this.originalEvent = src;
        this.type = src.type;
        this.currentTarget = void 0;
        if (Object.prototype.hasOwnProperty.call(src, "isTrusted")) {
          this.isTrusted = src.isTrusted;
        }
        this.timeStamp = src.timeStamp || Date.now();
      } else {
        _extends(this, src);
      }
      addProperty("which", calculateWhich, this);
      if (0 === src.type.indexOf("touch")) {
        delete config2.pageX;
        delete config2.pageY;
      }
      _extends(this, config2);
      this.guid = ++guid;
    }));
    EVENT_PROPERTIES.forEach((prop) => addProperty(prop, (event) => event[prop]));
    hook_touch_props_default(addProperty);
    beforeSetStrategy = callbacks_default();
    afterSetStrategy = callbacks_default();
    eventsEngine.set = function(engine) {
      beforeSetStrategy.fire();
      eventsEngine.inject(engine);
      initEvent(engine.Event);
      afterSetStrategy.fire();
    };
    eventsEngine.subscribeGlobal = function() {
      applyForEach(arguments, normalizeOnArguments(function() {
        var args = arguments;
        eventsEngine.on.apply(this, args);
        beforeSetStrategy.add(function() {
          var offArgs = Array.prototype.slice.call(args, 0);
          offArgs.splice(3, 1);
          eventsEngine.off.apply(this, offArgs);
        });
        afterSetStrategy.add(function() {
          eventsEngine.on.apply(this, args);
        });
      }));
    };
    eventsEngine.forcePassiveFalseEventNames = forcePassiveFalseEventNames;
    eventsEngine.passiveEventHandlersSupported = passiveEventHandlersSupported;
    events_engine_default = eventsEngine;
  }
});

// node_modules/devextreme/esm/events/index.js
var events_exports = {};
__export(events_exports, {
  Event: () => Event,
  off: () => off,
  on: () => on,
  one: () => one,
  trigger: () => trigger,
  triggerHandler: () => triggerHandler
});
var on, one, off, trigger, triggerHandler, Event;
var init_events = __esm({
  "node_modules/devextreme/esm/events/index.js"() {
    init_events_engine();
    on = events_engine_default.on;
    one = events_engine_default.one;
    off = events_engine_default.off;
    trigger = events_engine_default.trigger;
    triggerHandler = events_engine_default.triggerHandler;
    Event = events_engine_default.Event;
  }
});

// node_modules/devextreme-vue/core/strategy/vue2/children-processing.js
var require_children_processing = __commonJS({
  "node_modules/devextreme-vue/core/strategy/vue2/children-processing.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p2 in s)
            if (Object.prototype.hasOwnProperty.call(s, p2))
              t[p2] = s[p2];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.pullAllChildren = void 0;
    function pullAllChildren(directChildren, allChildren, config2) {
      if (!directChildren || directChildren.length === 0) {
        return;
      }
      pullConfigComponents(directChildren, allChildren, config2);
    }
    exports.pullAllChildren = pullAllChildren;
    function pullConfigComponents(children, nodes, ownerConfig) {
      children.forEach(function(node) {
        nodes.push(node);
        if (!node.componentOptions) {
          return;
        }
        var configComponent = node.componentOptions.Ctor;
        if (!configComponent.$_optionName) {
          return;
        }
        var initialValues = __assign(__assign({}, configComponent.$_predefinedProps), node.componentOptions.propsData);
        var config2 = ownerConfig.createNested(configComponent.$_optionName, initialValues, configComponent.$_isCollectionItem, configComponent.$_expectedChildren);
        node.componentOptions.$_config = config2;
        node.componentOptions.$_innerChanges = {};
        if (node.componentOptions.children) {
          pullConfigComponents(node.componentOptions.children, nodes, config2);
        }
      });
    }
  }
});

// node_modules/devextreme-vue/core/strategy/vue2/helpers.js
var require_helpers = __commonJS({
  "node_modules/devextreme-vue/core/strategy/vue2/helpers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getOptionInfo = exports.getOptionValue = exports.allKeysAreEqual = exports.forEachChildNode = exports.isEqual = exports.toComparable = exports.camelize = exports.lowercaseFirst = exports.uppercaseFirst = void 0;
    function uppercaseFirst(value2) {
      return value2[0].toUpperCase() + value2.substr(1);
    }
    exports.uppercaseFirst = uppercaseFirst;
    function lowercaseFirst(value2) {
      return value2[0].toLowerCase() + value2.substr(1);
    }
    exports.lowercaseFirst = lowercaseFirst;
    function camelize3(value2) {
      return lowercaseFirst(value2.split("-").map(function(v) {
        return uppercaseFirst(v);
      }).join(""));
    }
    exports.camelize = camelize3;
    function toComparable2(value2) {
      return value2 instanceof Date ? value2.getTime() : value2;
    }
    exports.toComparable = toComparable2;
    function isEqual(value1, value2) {
      if (toComparable2(value1) === toComparable2(value2)) {
        return true;
      }
      if (Array.isArray(value1) && Array.isArray(value2)) {
        return value1.length === 0 && value2.length === 0;
      }
      return false;
    }
    exports.isEqual = isEqual;
    function forEachChildNode(el, callback) {
      Array.prototype.slice.call(el.childNodes).forEach(callback);
    }
    exports.forEachChildNode = forEachChildNode;
    function allKeysAreEqual(obj1, obj2) {
      var obj1Keys = Object.keys(obj1);
      if (obj1Keys.length !== Object.keys(obj2).length) {
        return false;
      }
      for (var _i = 0, obj1Keys_1 = obj1Keys; _i < obj1Keys_1.length; _i++) {
        var key = obj1Keys_1[_i];
        if (!obj2.hasOwnProperty(key)) {
          return false;
        }
      }
      return true;
    }
    exports.allKeysAreEqual = allKeysAreEqual;
    function getOptionValue(options2, optionPath) {
      var value2 = options2;
      optionPath.split(".").forEach(function(p2) {
        var optionInfo = getOptionInfo(p2);
        if (value2) {
          value2 = optionInfo.isCollection ? value2[optionInfo.name] && value2[optionInfo.name][optionInfo.index] : value2[optionInfo.name];
        }
      });
      return value2;
    }
    exports.getOptionValue = getOptionValue;
    function getOptionInfo(name2) {
      var parts = name2.split("[");
      if (parts.length === 1) {
        return {
          isCollection: false,
          name: name2,
          fullName: name2
        };
      }
      return {
        isCollection: true,
        name: parts[0],
        fullName: name2,
        index: Number(parts[1].slice(0, -1))
      };
    }
    exports.getOptionInfo = getOptionInfo;
  }
});

// node_modules/devextreme-vue/core/strategy/vue2/configuration.js
var require_configuration = __commonJS({
  "node_modules/devextreme-vue/core/strategy/vue2/configuration.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p2 in s)
            if (Object.prototype.hasOwnProperty.call(s, p2))
              t[p2] = s[p2];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setEmitOptionChangedFunc = exports.bindOptionWatchers = void 0;
    var helpers_1 = require_helpers();
    var Configuration = (
      /** @class */
      function() {
        function Configuration2(updateFunc, name2, initialValues, expectedChildren, isCollectionItem, collectionItemIndex, ownerConfig) {
          this._updateFunc = updateFunc;
          this._name = name2;
          this._initialValues = initialValues ? initialValues : {};
          this._nestedConfigurations = [];
          this._isCollectionItem = !!isCollectionItem;
          this._collectionItemIndex = collectionItemIndex;
          this._expectedChildren = expectedChildren || {};
          this._ownerConfig = ownerConfig;
          this._componentChanges = [];
          this.updateValue = this.updateValue.bind(this);
        }
        Object.defineProperty(Configuration2.prototype, "name", {
          get: function() {
            return this._name;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Configuration2.prototype, "fullName", {
          get: function() {
            return this._name && this._isCollectionItem ? this._name + "[" + this._collectionItemIndex + "]" : this._name;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Configuration2.prototype, "componentsCountChanged", {
          get: function() {
            return this._componentChanges;
          },
          enumerable: false,
          configurable: true
        });
        Configuration2.prototype.cleanComponentsCountChanged = function() {
          this._componentChanges = [];
        };
        Object.defineProperty(Configuration2.prototype, "fullPath", {
          get: function() {
            return this._ownerConfig && this._ownerConfig.fullPath ? this._ownerConfig.fullPath + "." + this.fullName : this.fullName;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Configuration2.prototype, "ownerConfig", {
          get: function() {
            return this._ownerConfig;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Configuration2.prototype, "options", {
          get: function() {
            return this._options;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Configuration2.prototype, "initialValues", {
          get: function() {
            return this._initialValues;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Configuration2.prototype, "expectedChildren", {
          get: function() {
            return this._expectedChildren;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Configuration2.prototype, "nested", {
          get: function() {
            return this._nestedConfigurations;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Configuration2.prototype, "prevNestedOptions", {
          get: function() {
            return this._prevNestedConfigOptions;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Configuration2.prototype, "collectionItemIndex", {
          get: function() {
            return this._collectionItemIndex;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Configuration2.prototype, "isCollectionItem", {
          get: function() {
            return this._isCollectionItem;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Configuration2.prototype, "updateFunc", {
          get: function() {
            return this._updateFunc;
          },
          enumerable: false,
          configurable: true
        });
        Configuration2.prototype.init = function(options2) {
          this._options = options2 ? options2 : [];
        };
        Object.defineProperty(Configuration2.prototype, "emitOptionChanged", {
          set: function(handler) {
            this._emitOptionChanged = handler;
          },
          enumerable: false,
          configurable: true
        });
        Configuration2.prototype.setPrevNestedOptions = function(value2) {
          this._prevNestedConfigOptions = value2;
        };
        Configuration2.prototype.onOptionChanged = function(args) {
          if (helpers_1.isEqual(args.value, args.previousValue)) {
            return;
          }
          this._onOptionChanged(args.fullName.split("."), args);
        };
        Configuration2.prototype.cleanNested = function() {
          this._nestedConfigurations = [];
        };
        Configuration2.prototype.createNested = function(name2, initialValues, isCollectionItem, expectedChildren) {
          var expected = this._expectedChildren[name2];
          var actualName = name2;
          var actualIsCollectionItem = isCollectionItem;
          if (expected) {
            actualIsCollectionItem = expected.isCollectionItem;
            if (expected.optionName) {
              actualName = expected.optionName;
            }
          }
          var collectionItemIndex = -1;
          if (actualIsCollectionItem && actualName) {
            collectionItemIndex = this._nestedConfigurations.filter(function(c) {
              return c._name && c._name === actualName;
            }).length;
          }
          var configuration = new Configuration2(this._updateFunc, actualName, initialValues, expectedChildren, actualIsCollectionItem, collectionItemIndex, this);
          this._nestedConfigurations.push(configuration);
          return configuration;
        };
        Configuration2.prototype.updateValue = function(nestedName, value2) {
          var fullName = [this.fullPath, nestedName].filter(function(n) {
            return n;
          }).join(".");
          this._updateFunc(fullName, value2);
        };
        Configuration2.prototype.getNestedOptionValues = function() {
          var values = {};
          this._nestedConfigurations.forEach(function(o) {
            if (!o._name) {
              return;
            }
            var nestedValue = __assign(__assign({}, o.initialValues), o.getNestedOptionValues());
            if (!nestedValue) {
              return;
            }
            if (!o._isCollectionItem) {
              values[o._name] = nestedValue;
            } else {
              var arr = values[o._name];
              if (!arr || !Array.isArray(arr)) {
                arr = [];
                values[o._name] = arr;
              }
              arr.push(nestedValue);
            }
          });
          return values;
        };
        Configuration2.prototype.getOptionsToWatch = function() {
          var blackList = {};
          this._nestedConfigurations.forEach(function(c) {
            return c._name && (blackList[c._name] = true);
          });
          return this._options.filter(function(o) {
            return !blackList[o];
          });
        };
        Configuration2.prototype._onOptionChanged = function(optionRelPath, args) {
          if (optionRelPath.length === 0) {
            return;
          }
          var optionInfo = helpers_1.getOptionInfo(optionRelPath[0]);
          if (optionInfo.isCollection || optionRelPath.length > 1) {
            var nestedConfig = this._getNestedConfig(optionInfo.fullName);
            if (nestedConfig) {
              nestedConfig._onOptionChanged(optionRelPath.slice(1), args);
              return;
            }
            this._tryEmitOptionChanged(optionInfo.name, args.component.option(this.fullPath ? this.fullPath + "." + optionInfo.name : optionInfo.name));
          } else {
            this._tryEmitOptionChanged(optionInfo.name, args.value);
          }
        };
        Configuration2.prototype._getNestedConfig = function(fullName) {
          for (var _i = 0, _a = this._nestedConfigurations; _i < _a.length; _i++) {
            var nestedConfig = _a[_i];
            if (nestedConfig.fullName === fullName) {
              return nestedConfig;
            }
          }
          return void 0;
        };
        Configuration2.prototype._tryEmitOptionChanged = function(name2, value2) {
          if (this._emitOptionChanged) {
            this._emitOptionChanged(name2, value2);
          }
        };
        return Configuration2;
      }()
    );
    function bindOptionWatchers(config2, vueInstance, innerChanges) {
      var targets = config2 && config2.getOptionsToWatch();
      if (targets) {
        targets.forEach(function(optionName) {
          vueInstance.$watch(optionName, function(value2) {
            if (!innerChanges.hasOwnProperty(optionName) || innerChanges[optionName] !== value2) {
              config2.updateValue(optionName, value2);
            }
            delete innerChanges[optionName];
          });
        });
      }
    }
    exports.bindOptionWatchers = bindOptionWatchers;
    function setEmitOptionChangedFunc(config2, vueInstance, innerChanges) {
      config2.emitOptionChanged = function(name2, value2) {
        if (!helpers_1.isEqual(value2, vueInstance.$props[name2])) {
          innerChanges[name2] = value2;
          vueInstance.$emit("update:" + name2, value2);
        }
      };
    }
    exports.setEmitOptionChangedFunc = setEmitOptionChangedFunc;
    exports.default = Configuration;
  }
});

// node_modules/devextreme-vue/core/strategy/vue2/configuration-component.js
var require_configuration_component = __commonJS({
  "node_modules/devextreme-vue/core/strategy/vue2/configuration-component.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result2 = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result2, mod, k);
      }
      __setModuleDefault(result2, mod);
      return result2;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getInnerChanges = exports.getConfig = exports.initOptionChangedFunc = exports.DxConfiguration = void 0;
    var VueType = __importStar(require_vue());
    var Vue = VueType.default || VueType;
    var configuration_1 = require_configuration();
    function getConfig2(vueInstance) {
      if (!vueInstance.$vnode) {
        return;
      }
      var componentOptions = vueInstance.$vnode.componentOptions;
      return componentOptions && componentOptions.$_config;
    }
    exports.getConfig = getConfig2;
    function getInnerChanges(vueInstance) {
      if (!vueInstance.$vnode) {
        return;
      }
      var componentOptions = vueInstance.$vnode.componentOptions;
      return componentOptions && componentOptions.$_innerChanges;
    }
    exports.getInnerChanges = getInnerChanges;
    function initOptionChangedFunc(config2, vueInstance, innerChanges) {
      if (!config2) {
        return;
      }
      config2.init(Object.keys(vueInstance.$props));
      configuration_1.setEmitOptionChangedFunc(config2, vueInstance, innerChanges);
    }
    exports.initOptionChangedFunc = initOptionChangedFunc;
    function getComponentInfo(_a, removed) {
      var name2 = _a.name, isCollectionItem = _a.isCollectionItem, ownerConfig = _a.ownerConfig;
      var parentPath = ownerConfig && ownerConfig.fullPath;
      var optionPath = name2 && parentPath ? parentPath + "." + name2 : name2 || "";
      return {
        optionPath,
        isCollection: isCollectionItem,
        removed
      };
    }
    var DxConfiguration = function() {
      return Vue.extend({
        beforeMount: function() {
          var config2 = getConfig2(this);
          var innerChanges = getInnerChanges(this);
          initOptionChangedFunc(config2, this, innerChanges);
          configuration_1.bindOptionWatchers(config2, this, innerChanges);
        },
        mounted: function() {
          if (this.$parent.$_instance) {
            this.$parent.$_config.componentsCountChanged.push(getComponentInfo(getConfig2(this)));
          }
        },
        beforeDestroy: function() {
          this.$parent.$_config.componentsCountChanged.push(getComponentInfo(getConfig2(this), true));
        },
        render: function(createElement2) {
          return createElement2();
        }
      });
    };
    exports.DxConfiguration = DxConfiguration;
  }
});

// node_modules/devextreme-vue/core/strategy/vue2/constants.js
var require_constants = __commonJS({
  "node_modules/devextreme-vue/core/strategy/vue2/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DX_REMOVE_EVENT = exports.DX_TEMPLATE_WRAPPER_CLASS = void 0;
    var DX_TEMPLATE_WRAPPER_CLASS = "dx-template-wrapper";
    exports.DX_TEMPLATE_WRAPPER_CLASS = DX_TEMPLATE_WRAPPER_CLASS;
    var DX_REMOVE_EVENT = "dxremove";
    exports.DX_REMOVE_EVENT = DX_REMOVE_EVENT;
  }
});

// node_modules/devextreme-vue/core/strategy/vue2/config.js
var require_config = __commonJS({
  "node_modules/devextreme-vue/core/strategy/vue2/config.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p2 in s)
            if (Object.prototype.hasOwnProperty.call(s, p2))
              t[p2] = s[p2];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getOption = void 0;
    var config2 = {
      useLegacyTemplateEngine: false
    };
    function setOptions(options2) {
      config2 = __assign(__assign({}, config2), options2);
    }
    function getOption(optionName) {
      return config2[optionName];
    }
    exports.getOption = getOption;
    exports.default = setOptions;
  }
});

// node_modules/devextreme-vue/core/strategy/vue2/errors.js
var require_errors = __commonJS({
  "node_modules/devextreme-vue/core/strategy/vue2/errors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TEMPLATE_MULTIPLE_ROOTS_ERROR = void 0;
    exports.TEMPLATE_MULTIPLE_ROOTS_ERROR = "Template must have a single root node.";
  }
});

// node_modules/devextreme-vue/core/strategy/vue2/templates-discovering.js
var require_templates_discovering = __commonJS({
  "node_modules/devextreme-vue/core/strategy/vue2/templates-discovering.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result2 = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result2, mod, k);
      }
      __setModuleDefault(result2, mod);
      return result2;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.discover = exports.mountTemplate = void 0;
    var VueType = __importStar(require_vue());
    var errors_1 = require_errors();
    var TEMPLATE_PROP = "template";
    var Vue = VueType.default || VueType;
    function asConfigurable(component) {
      if (!component.$vnode) {
        return void 0;
      }
      var configurable = component.$vnode.componentOptions;
      if (!configurable.$_config || !configurable.$_config.name) {
        return void 0;
      }
      return configurable;
    }
    function hasTemplate(component) {
      return TEMPLATE_PROP in component.$props && (component.$vnode.data && component.$vnode.data.scopedSlots);
    }
    function discover(component) {
      var templates = {};
      for (var slotName in component.$scopedSlots) {
        if (slotName === "default" && component.$slots.default) {
          continue;
        }
        var slot = component.$scopedSlots[slotName];
        if (!slot) {
          continue;
        }
        templates[slotName] = slot;
      }
      for (var _i = 0, _a = component.$children; _i < _a.length; _i++) {
        var childComponent = _a[_i];
        var configurable = asConfigurable(childComponent);
        if (!configurable) {
          continue;
        }
        var defaultSlot = childComponent.$scopedSlots.default;
        if (!defaultSlot || !hasTemplate(childComponent)) {
          continue;
        }
        var templateName = configurable.$_config.fullPath + "." + TEMPLATE_PROP;
        templates[templateName] = defaultSlot;
      }
      return templates;
    }
    exports.discover = discover;
    function mountTemplate(getSlot, parent, data2, name2, placeholder) {
      return new Vue({
        el: placeholder,
        name: name2,
        inject: ["eventBus"],
        parent,
        created: function() {
          var _this = this;
          this.eventBus.$on("updated", function() {
            _this.$forceUpdate();
          });
        },
        render: function(createElement2) {
          var content = getSlot()(data2);
          if (!content) {
            return createElement2("div");
          }
          if (content.length > 1) {
            throw new Error(errors_1.TEMPLATE_MULTIPLE_ROOTS_ERROR);
          }
          return content[0];
        },
        destroyed: function() {
          this.eventBus.$off("updated");
        }
      });
    }
    exports.mountTemplate = mountTemplate;
  }
});

// node_modules/devextreme-vue/core/strategy/vue2/templates-manager.js
var require_templates_manager = __commonJS({
  "node_modules/devextreme-vue/core/strategy/vue2/templates-manager.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p2 in s)
            if (Object.prototype.hasOwnProperty.call(s, p2))
              t[p2] = s[p2];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TemplatesManager = void 0;
    var config_1 = require_config();
    var templates_discovering_1 = require_templates_discovering();
    var dom_adapter_1 = __importDefault((init_dom_adapter(), __toCommonJS(dom_adapter_exports)));
    var events_1 = (init_events(), __toCommonJS(events_exports));
    var constants_1 = require_constants();
    var helpers_1 = require_helpers();
    var TemplatesManager = (
      /** @class */
      function() {
        function TemplatesManager2(component) {
          this._slots = {};
          this._templates = {};
          this._isDirty = false;
          this._component = component;
          this.discover();
        }
        TemplatesManager2.prototype.discover = function() {
          var slots = templates_discovering_1.discover(this._component);
          this._slots = __assign(__assign({}, this._slots), slots);
          if (!helpers_1.allKeysAreEqual(this._templates, slots)) {
            this._prepareTemplates();
          }
        };
        Object.defineProperty(TemplatesManager2.prototype, "templates", {
          get: function() {
            return this._templates;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(TemplatesManager2.prototype, "isDirty", {
          get: function() {
            return this._isDirty;
          },
          enumerable: false,
          configurable: true
        });
        TemplatesManager2.prototype.resetDirtyFlag = function() {
          this._isDirty = false;
        };
        TemplatesManager2.prototype._prepareTemplates = function() {
          this._templates = {};
          for (var _i = 0, _a = Object.keys(this._slots); _i < _a.length; _i++) {
            var name_1 = _a[_i];
            this._templates[name_1] = this.createDxTemplate(name_1);
          }
          this._isDirty = true;
        };
        TemplatesManager2.prototype.createDxTemplate = function(name2) {
          var _this = this;
          return {
            render: function(data2) {
              var scopeData = config_1.getOption("useLegacyTemplateEngine") ? data2.model : { data: data2.model, index: data2.index };
              var container = data2.container.get ? data2.container.get(0) : data2.container;
              var placeholder = document.createElement("div");
              container.appendChild(placeholder);
              var mountedTemplate = templates_discovering_1.mountTemplate(function() {
                return _this._slots[name2];
              }, _this._component, scopeData, name2, placeholder);
              var element = mountedTemplate.$el;
              dom_adapter_1.default.setClass(element, constants_1.DX_TEMPLATE_WRAPPER_CLASS, true);
              if (element.nodeType === Node.TEXT_NODE) {
                var removalListener = document.createElement(container.nodeName === "TABLE" ? "tbody" : "span");
                removalListener.style.display = "none";
                container.appendChild(removalListener);
                events_1.one(removalListener, constants_1.DX_REMOVE_EVENT, mountedTemplate.$destroy.bind(mountedTemplate));
              } else {
                events_1.one(element, constants_1.DX_REMOVE_EVENT, mountedTemplate.$destroy.bind(mountedTemplate));
              }
              return element;
            }
          };
        };
        return TemplatesManager2;
      }()
    );
    exports.TemplatesManager = TemplatesManager;
  }
});

// node_modules/devextreme-vue/core/strategy/vue2/component.js
var require_component = __commonJS({
  "node_modules/devextreme-vue/core/strategy/vue2/component.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p2 in s)
            if (Object.prototype.hasOwnProperty.call(s, p2))
              t[p2] = s[p2];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result2 = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result2, mod, k);
      }
      __setModuleDefault(result2, mod);
      return result2;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BaseComponent = exports.DxComponent = void 0;
    var VueType = __importStar(require_vue());
    var events_1 = (init_events(), __toCommonJS(events_exports));
    var children_processing_1 = require_children_processing();
    var configuration_1 = __importStar(require_configuration());
    var configuration_component_1 = require_configuration_component();
    var constants_1 = require_constants();
    var helpers_1 = require_helpers();
    var templates_manager_1 = require_templates_manager();
    var Vue = VueType.default || VueType;
    var BaseComponent = function() {
      return Vue.extend({
        inheritAttrs: false,
        data: function() {
          return {
            eventBus: new Vue()
          };
        },
        provide: function() {
          return {
            eventBus: this.eventBus
          };
        },
        render: function(createElement2) {
          var children = [];
          if (this.$_config.cleanNested) {
            this.$_config.cleanNested();
          }
          children_processing_1.pullAllChildren(this.$slots.default, children, this.$_config);
          this.$_processChildren(children);
          return createElement2("div", {
            attrs: { id: this.$attrs.id }
          }, children);
        },
        beforeUpdate: function() {
          this.$_config.setPrevNestedOptions(this.$_config.getNestedOptionValues());
        },
        updated: function() {
          this.$children.forEach(function(child) {
            return configuration_component_1.initOptionChangedFunc(configuration_component_1.getConfig(child), child, configuration_component_1.getInnerChanges(child));
          });
          this.$_templatesManager.discover();
          this.$_instance.beginUpdate();
          if (this.$_templatesManager.isDirty) {
            this.$_instance.option("integrationOptions.templates", this.$_templatesManager.templates);
            for (var _i = 0, _a = Object.keys(this.$_templatesManager.templates); _i < _a.length; _i++) {
              var name_1 = _a[_i];
              this.$_instance.option(name_1, name_1);
            }
            this.$_templatesManager.resetDirtyFlag();
          }
          for (var _b = 0, _c = Object.keys(this.$_pendingOptions); _b < _c.length; _b++) {
            var name_2 = _c[_b];
            this.$_instance.option(name_2, this.$_pendingOptions[name_2]);
          }
          this.$_pendingOptions = {};
          this.$_applyConfigurationChanges();
          this.$_instance.endUpdate();
          this.eventBus.$emit("updated");
        },
        beforeDestroy: function() {
          var instance = this.$_instance;
          if (instance) {
            events_1.triggerHandler(this.$el, constants_1.DX_REMOVE_EVENT);
            instance.dispose();
          }
        },
        created: function() {
          var _this = this;
          this.$_config = new configuration_1.default(function(n, v) {
            return _this.$_pendingOptions[n] = v;
          }, null, this.$options.propsData && __assign({}, this.$options.propsData), this.$_expectedChildren);
          this.$_innerChanges = {};
          this.$_config.init(this.$props && Object.keys(this.$props));
        },
        methods: {
          $_applyConfigurationChanges: function() {
            var _this = this;
            this.$_config.componentsCountChanged.forEach(function(_a) {
              var optionPath = _a.optionPath, isCollection = _a.isCollection, removed = _a.removed;
              var options2 = _this.$_config.getNestedOptionValues();
              if (!isCollection && removed) {
                _this.$_instance.resetOption(optionPath);
              } else {
                _this.$_instance.option(optionPath, helpers_1.getOptionValue(options2, optionPath));
              }
            });
            this.$_config.cleanComponentsCountChanged();
          },
          $_createWidget: function(element) {
            var thisComponent = this;
            thisComponent.$_pendingOptions = {};
            thisComponent.$_templatesManager = new templates_manager_1.TemplatesManager(this);
            var config2 = this.$_config;
            var options2 = __assign(__assign(__assign(__assign({}, this.$options.propsData), config2.initialValues), config2.getNestedOptionValues()), this.$_getIntegrationOptions());
            var instance = new this.$_WidgetClass(element, options2);
            thisComponent.$_instance = instance;
            instance.on("optionChanged", function(args) {
              return config2.onOptionChanged(args);
            });
            configuration_1.setEmitOptionChangedFunc(config2, this, this.$_innerChanges);
            configuration_1.bindOptionWatchers(config2, this, this.$_innerChanges);
            this.$_createEmitters(instance);
          },
          $_getIntegrationOptions: function() {
            var result2 = __assign({ integrationOptions: {
              watchMethod: this.$_getWatchMethod()
            } }, this.$_getExtraIntegrationOptions());
            if (this.$_templatesManager.isDirty) {
              var templates = this.$_templatesManager.templates;
              result2.integrationOptions.templates = templates;
              for (var _i = 0, _a = Object.keys(templates); _i < _a.length; _i++) {
                var name_3 = _a[_i];
                result2[name_3] = name_3;
              }
              this.$_templatesManager.resetDirtyFlag();
            }
            return result2;
          },
          $_getWatchMethod: function() {
            var _this = this;
            return function(valueGetter, valueChangeCallback, options2) {
              options2 = options2 || {};
              if (!options2.skipImmediate) {
                valueChangeCallback(valueGetter());
              }
              return _this.$watch(function() {
                return valueGetter();
              }, function(newValue, oldValue) {
                if (helpers_1.toComparable(oldValue) !== helpers_1.toComparable(newValue) || options2.deep) {
                  valueChangeCallback(newValue);
                }
              }, {
                deep: options2.deep
              });
            };
          },
          $_getExtraIntegrationOptions: function() {
            return {};
          },
          $_processChildren: function(_children) {
            return;
          },
          $_createEmitters: function(instance) {
            var _this = this;
            Object.keys(this.$listeners).forEach(function(listenerName) {
              var eventName = helpers_1.camelize(listenerName);
              instance.on(eventName, function(e) {
                _this.$emit(listenerName, e);
              });
            });
          }
        }
      });
    };
    exports.BaseComponent = BaseComponent;
    function cleanWidgetNode(node) {
      var removedNodes = [];
      helpers_1.forEachChildNode(node, function(childNode) {
        var parent = childNode.parentNode;
        var isExtension = childNode.hasAttribute && childNode.hasAttribute("isExtension");
        if ((childNode.nodeName === "#comment" || isExtension) && parent) {
          removedNodes.push(childNode);
          parent.removeChild(childNode);
        }
      });
      return removedNodes;
    }
    function restoreNodes(el, nodes) {
      nodes.forEach(function(node) {
        el.appendChild(node);
      });
    }
    var DxComponent = function() {
      return BaseComponent().extend({
        methods: {
          $_getExtraIntegrationOptions: function() {
            return {
              onInitializing: function() {
                this.beginUpdate();
              }
            };
          },
          $_processChildren: function(children) {
            children.forEach(function(childNode) {
              if (!childNode.componentOptions) {
                return;
              }
              childNode.componentOptions.$_hasOwner = true;
            });
          }
        },
        mounted: function() {
          var _this = this;
          var nodes = cleanWidgetNode(this.$el);
          this.$_createWidget(this.$el);
          this.$_instance.endUpdate();
          restoreNodes(this.$el, nodes);
          if (this.$slots && this.$slots.default) {
            this.$slots.default.forEach(function(child) {
              var childExtension = child.componentInstance;
              if (childExtension && childExtension.$_isExtension) {
                childExtension.attachTo(_this.$el);
              }
            });
          }
        }
      });
    };
    exports.DxComponent = DxComponent;
  }
});

// node_modules/devextreme-vue/core/strategy/vue2/extension-component.js
var require_extension_component = __commonJS({
  "node_modules/devextreme-vue/core/strategy/vue2/extension-component.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DxExtensionComponent = void 0;
    var component_1 = require_component();
    var DxExtensionComponent = function() {
      return component_1.BaseComponent().extend({
        created: function() {
          this.$_isExtension = true;
        },
        mounted: function() {
          this.$el.setAttribute("isExtension", "true");
          if (this.$vnode && this.$vnode.componentOptions.$_hasOwner) {
            return;
          }
          this.attachTo(this.$el);
        },
        methods: {
          attachTo: function(element) {
            this.$_createWidget(element);
          }
        }
      });
    };
    exports.DxExtensionComponent = DxExtensionComponent;
  }
});

// node_modules/devextreme-vue/core/strategy/vue2/index.js
var require_vue2 = __commonJS({
  "node_modules/devextreme-vue/core/strategy/vue2/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result2 = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result2, mod, k);
      }
      __setModuleDefault(result2, mod);
      return result2;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createExtensionComponent = exports.createConfigurationComponent = exports.createComponent = void 0;
    var VueType = __importStar(require_vue());
    var Vue = VueType.default || VueType;
    var component_1 = require_component();
    var configuration_component_1 = require_configuration_component();
    var extension_component_1 = require_extension_component();
    function createComponent(config2) {
      config2.extends = component_1.DxComponent();
      return Vue.extend(config2);
    }
    exports.createComponent = createComponent;
    function createConfigurationComponent(config2) {
      config2.extends = configuration_component_1.DxConfiguration();
      return Vue.extend(config2);
    }
    exports.createConfigurationComponent = createConfigurationComponent;
    function createExtensionComponent(config2) {
      config2.extends = extension_component_1.DxExtensionComponent();
      return Vue.extend(config2);
    }
    exports.createExtensionComponent = createExtensionComponent;
  }
});

// node_modules/devextreme-vue/core/helpers.js
var require_helpers2 = __commonJS({
  "node_modules/devextreme-vue/core/helpers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getOptionInfo = exports.getOptionValue = exports.allKeysAreEqual = exports.forEachChildNode = exports.isEqual = exports.toComparable = exports.camelize = exports.lowercaseFirst = exports.uppercaseFirst = void 0;
    function uppercaseFirst(value2) {
      return value2[0].toUpperCase() + value2.substr(1);
    }
    exports.uppercaseFirst = uppercaseFirst;
    function lowercaseFirst(value2) {
      return value2[0].toLowerCase() + value2.substr(1);
    }
    exports.lowercaseFirst = lowercaseFirst;
    function camelize3(value2) {
      return lowercaseFirst(value2.split("-").map(function(v) {
        return uppercaseFirst(v);
      }).join(""));
    }
    exports.camelize = camelize3;
    function toComparable2(value2) {
      return value2 instanceof Date ? value2.getTime() : value2;
    }
    exports.toComparable = toComparable2;
    function isEqual(value1, value2) {
      if (toComparable2(value1) === toComparable2(value2)) {
        return true;
      }
      if (Array.isArray(value1) && Array.isArray(value2)) {
        return value1.length === 0 && value2.length === 0;
      }
      return false;
    }
    exports.isEqual = isEqual;
    function forEachChildNode(el, callback) {
      Array.prototype.slice.call(el.childNodes).forEach(callback);
    }
    exports.forEachChildNode = forEachChildNode;
    function allKeysAreEqual(obj1, obj2) {
      var obj1Keys = Object.keys(obj1);
      if (obj1Keys.length !== Object.keys(obj2).length) {
        return false;
      }
      for (var _i = 0, obj1Keys_1 = obj1Keys; _i < obj1Keys_1.length; _i++) {
        var key = obj1Keys_1[_i];
        if (!obj2.hasOwnProperty(key)) {
          return false;
        }
      }
      return true;
    }
    exports.allKeysAreEqual = allKeysAreEqual;
    function getOptionValue(options2, optionPath) {
      var value2 = options2;
      optionPath.split(".").forEach(function(p2) {
        var optionInfo = getOptionInfo(p2);
        if (value2) {
          value2 = optionInfo.isCollection ? value2[optionInfo.name] && value2[optionInfo.name][optionInfo.index] : value2[optionInfo.name];
        }
      });
      return value2;
    }
    exports.getOptionValue = getOptionValue;
    function getOptionInfo(name2) {
      var parts = name2.split("[");
      if (parts.length === 1) {
        return {
          isCollection: false,
          name: name2,
          fullName: name2
        };
      }
      return {
        isCollection: true,
        name: parts[0],
        fullName: name2,
        index: Number(parts[1].slice(0, -1))
      };
    }
    exports.getOptionInfo = getOptionInfo;
  }
});

// node_modules/devextreme-vue/core/children-processing.js
var require_children_processing2 = __commonJS({
  "node_modules/devextreme-vue/core/children-processing.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p2 in s)
            if (Object.prototype.hasOwnProperty.call(s, p2))
              t[p2] = s[p2];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.pullAllChildren = exports.pullConfigComponents = exports.isFragment = void 0;
    var vue_helper_1 = require_vue_helper();
    function pullAllChildren(directChildren, allChildren, config2) {
      if (!directChildren || directChildren.length === 0) {
        return;
      }
      pullConfigComponents(directChildren, allChildren, config2);
    }
    exports.pullAllChildren = pullAllChildren;
    function isFragment(node) {
      var patchFlag = node.patchFlag;
      return patchFlag === 128 || patchFlag === 256 || patchFlag === 64 || patchFlag === -2;
    }
    exports.isFragment = isFragment;
    function pullConfigComponents(children, nodes, ownerConfig) {
      children.forEach(function(node) {
        if (isFragment(node) && Array.isArray(node.children)) {
          pullConfigComponents(node.children, nodes, ownerConfig);
        }
        if (!isFragment(node)) {
          nodes.push(node);
        }
        if (!node) {
          return;
        }
        var componentInfo = vue_helper_1.getComponentInfo(node);
        if (!componentInfo || !componentInfo.$_optionName) {
          return;
        }
        var componentChildren = vue_helper_1.configurationChildren(node);
        var initialValues = __assign(__assign({}, componentInfo.$_predefinedProps), vue_helper_1.getNormalizedProps(node.props || {}));
        var config2 = ownerConfig.createNested(componentInfo.$_optionName, initialValues, componentInfo.$_isCollectionItem, componentInfo.$_expectedChildren);
        node.$_config = config2;
        node.$_innerChanges = {};
        if (componentChildren) {
          pullConfigComponents(componentChildren, nodes, config2);
        }
      });
    }
    exports.pullConfigComponents = pullConfigComponents;
  }
});

// node_modules/devextreme-vue/core/vue-helper.js
var require_vue_helper = __commonJS({
  "node_modules/devextreme-vue/core/vue-helper.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p2 in s)
            if (Object.prototype.hasOwnProperty.call(s, p2))
              t[p2] = s[p2];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getConfigurationOptions = exports.setVModel = exports.setCompatOptions = exports.getVModelValue = exports.getNodeTypeOfComponent = exports.getNodeOptions = exports.usedConfigurationProps = exports.getComponentProps = exports.mount = exports.defaultSlots = exports.declaredTemplates = exports.configurationTemplate = exports.configurationDefaultTemplate = exports.configurationChildren = exports.getNormalizedProps = exports.getComponentInfo = exports.getChildren = exports.VMODEL_NAME = void 0;
    var vue_1 = require_vue();
    var helpers_1 = require_helpers2();
    var children_processing_1 = require_children_processing2();
    exports.VMODEL_NAME = "modelValue";
    function getChildren(component) {
      if (!hasChildren(component) || !component.$_config) {
        return [];
      }
      var children = component.$.subTree && component.$.subTree.children;
      if (!Array.isArray(children)) {
        return [];
      }
      return children.filter(function(child) {
        if (!children_processing_1.isFragment(child)) {
          return child;
        }
        return;
      });
    }
    exports.getChildren = getChildren;
    function getComponentInfo(component) {
      return getConfigurationOptions(component);
    }
    exports.getComponentInfo = getComponentInfo;
    function getNormalizedProps(props) {
      var result2 = {};
      for (var propName in props) {
        if (props.hasOwnProperty(propName)) {
          result2[helpers_1.camelize(propName)] = props[propName];
        }
      }
      return result2;
    }
    exports.getNormalizedProps = getNormalizedProps;
    function configurationChildren(component) {
      if (!component.children || !component.children.default) {
        return [];
      }
      return findConfigurationComponents(component.children.default());
    }
    exports.configurationChildren = configurationChildren;
    function configurationDefaultTemplate(node) {
      if (!node.children || node.children === "object" || !node.children.default) {
        return;
      }
      return hasInlineTemplate(node.children.default()) ? node.children.default : void 0;
    }
    exports.configurationDefaultTemplate = configurationDefaultTemplate;
    function configurationTemplate(node) {
      return configurationDefaultTemplate(node);
    }
    exports.configurationTemplate = configurationTemplate;
    function declaredTemplates(component) {
      return component.$slots;
    }
    exports.declaredTemplates = declaredTemplates;
    function defaultSlots(component) {
      var templates = declaredTemplates(component);
      if (!templates.default) {
        return [];
      }
      return templates.default();
    }
    exports.defaultSlots = defaultSlots;
    function mount2(options2, parent, el) {
      var template = vue_1.createApp(options2);
      template.provide("eventBus", parent.eventBus);
      setAppContext(template, parent);
      return template.mount(el);
    }
    exports.mount = mount2;
    function getComponentProps(component) {
      var props = component.$.vnode.props || {};
      return getNormalizedProps(props);
    }
    exports.getComponentProps = getComponentProps;
    function usedConfigurationProps(node) {
      return node.props;
    }
    exports.usedConfigurationProps = usedConfigurationProps;
    function getNodeOptions(component) {
      if (component.$) {
        return component.$.vnode;
      }
      return component;
    }
    exports.getNodeOptions = getNodeOptions;
    function getNodeTypeOfComponent(component) {
      return component.$.vnode.type;
    }
    exports.getNodeTypeOfComponent = getNodeTypeOfComponent;
    function getVModelValue(options2) {
      return options2[exports.VMODEL_NAME];
    }
    exports.getVModelValue = getVModelValue;
    function setCompatOptions(component) {
      component.compatConfig = {
        MODE: 3
      };
    }
    exports.setCompatOptions = setCompatOptions;
    function setVModel(config2) {
      var _a;
      var eventName = "update:" + exports.VMODEL_NAME;
      config2.model.prop = exports.VMODEL_NAME;
      config2.model.event = eventName;
      config2.props.modelValue = {};
      config2.emits = __assign(__assign({}, config2.emits), (_a = {}, _a["" + eventName] = null, _a));
    }
    exports.setVModel = setVModel;
    function setCustomPluginsData(appContext, parentAppContext) {
      for (var prop in parentAppContext) {
        if (!appContext.hasOwnProperty(prop) && parentAppContext.hasOwnProperty(prop)) {
          appContext[prop] = parentAppContext[prop];
        }
      }
    }
    function setAppContext(template, parent) {
      template._context.components = Object.assign(parent.$.appContext.components, template._context.components);
      Object.setPrototypeOf(template._context.provides, Object.getPrototypeOf(parent.$.provides));
      Object.assign(template._context.provides, parent.$.appContext.provides);
      template._context.config = parent.$.appContext.config;
      template._context.directives = parent.$.appContext.directives;
      template._context.mixins = parent.$.appContext.mixins;
      setCustomPluginsData(template._context.app, parent.$.appContext.app);
    }
    function findConfigurationComponents(children) {
      return children.filter(function(child) {
        if (children_processing_1.isFragment(child)) {
          return findConfigurationComponents(child.children || []);
        }
        var childType = child.type;
        if (childType && typeof childType === "object" && childType.$_optionName) {
          delete child.$_config;
          delete child.$_innerChanges;
          return child;
        }
        return;
      });
    }
    function hasInlineTemplate(children) {
      var hasTemplate = false;
      children.forEach(function(child) {
        if (!isConfiguration(child) && !children_processing_1.isFragment(child) && !isComment(child)) {
          hasTemplate = true;
        }
      });
      return hasTemplate;
    }
    function isComment(node) {
      var nodeType = node.type;
      var type2 = typeof nodeType === "symbol" ? nodeType.toString() : nodeType;
      return type2 === "Symbol(Comment)" || type2 === "Symbol()" && !node.children;
    }
    function isConfiguration(child) {
      return child.type && typeof child.type === "object" && child.type.$_optionName;
    }
    function getConfigurationOptions(node) {
      return node.type;
    }
    exports.getConfigurationOptions = getConfigurationOptions;
    function hasChildren(component) {
      return component.$.vnode && component.$.vnode.children && component.$.vnode.children.default;
    }
  }
});

// node_modules/devextreme-vue/core/config.js
var require_config2 = __commonJS({
  "node_modules/devextreme-vue/core/config.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p2 in s)
            if (Object.prototype.hasOwnProperty.call(s, p2))
              t[p2] = s[p2];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getOption = void 0;
    var config2 = {
      deepWatch: false
    };
    function setOptions(options2) {
      config2 = __assign(__assign({}, config2), options2);
    }
    function getOption(optionName) {
      return config2[optionName];
    }
    exports.getOption = getOption;
    exports.default = setOptions;
  }
});

// node_modules/devextreme-vue/core/configuration.js
var require_configuration2 = __commonJS({
  "node_modules/devextreme-vue/core/configuration.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p2 in s)
            if (Object.prototype.hasOwnProperty.call(s, p2))
              t[p2] = s[p2];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setEmitOptionChangedFunc = exports.bindOptionWatchers = void 0;
    var vue_1 = require_vue();
    var config_1 = require_config2();
    var helpers_1 = require_helpers2();
    var vue_helper_1 = require_vue_helper();
    var Configuration = (
      /** @class */
      function() {
        function Configuration2(updateFunc, name2, initialValues, expectedChildren, isCollectionItem, collectionItemIndex, ownerConfig) {
          this._updateFunc = updateFunc;
          this._name = name2;
          this._initialValues = initialValues ? initialValues : {};
          this._nestedConfigurations = [];
          this._isCollectionItem = !!isCollectionItem;
          this._collectionItemIndex = collectionItemIndex;
          this._expectedChildren = expectedChildren || {};
          this._ownerConfig = ownerConfig;
          this._componentChanges = [];
          this.updateValue = this.updateValue.bind(this);
        }
        Object.defineProperty(Configuration2.prototype, "name", {
          get: function() {
            return this._name;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Configuration2.prototype, "fullName", {
          get: function() {
            return this._name && this._isCollectionItem ? this._name + "[" + this._collectionItemIndex + "]" : this._name;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Configuration2.prototype, "componentsCountChanged", {
          get: function() {
            return this._componentChanges;
          },
          enumerable: false,
          configurable: true
        });
        Configuration2.prototype.cleanComponentsCountChanged = function() {
          this._componentChanges = [];
        };
        Object.defineProperty(Configuration2.prototype, "fullPath", {
          get: function() {
            return this._ownerConfig && this._ownerConfig.fullPath ? this._ownerConfig.fullPath + "." + this.fullName : this.fullName;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Configuration2.prototype, "ownerConfig", {
          get: function() {
            return this._ownerConfig;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Configuration2.prototype, "options", {
          get: function() {
            return this._options;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Configuration2.prototype, "initialValues", {
          get: function() {
            return this._initialValues;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Configuration2.prototype, "expectedChildren", {
          get: function() {
            return this._expectedChildren;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Configuration2.prototype, "nested", {
          get: function() {
            return this._nestedConfigurations;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Configuration2.prototype, "prevNestedOptions", {
          get: function() {
            return this._prevNestedConfigOptions;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Configuration2.prototype, "collectionItemIndex", {
          get: function() {
            return this._collectionItemIndex;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Configuration2.prototype, "isCollectionItem", {
          get: function() {
            return this._isCollectionItem;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Configuration2.prototype, "updateFunc", {
          get: function() {
            return this._updateFunc;
          },
          enumerable: false,
          configurable: true
        });
        Configuration2.prototype.init = function(options2) {
          this._options = options2 ? options2 : [];
        };
        Object.defineProperty(Configuration2.prototype, "emitOptionChanged", {
          set: function(handler) {
            this._emitOptionChanged = handler;
          },
          enumerable: false,
          configurable: true
        });
        Configuration2.prototype.setPrevNestedOptions = function(value2) {
          this._prevNestedConfigOptions = value2;
        };
        Configuration2.prototype.onOptionChanged = function(args) {
          if (helpers_1.isEqual(args.value, args.previousValue)) {
            return;
          }
          this._onOptionChanged(args.fullName.split("."), args);
        };
        Configuration2.prototype.cleanNested = function() {
          this._nestedConfigurations = [];
        };
        Configuration2.prototype.createNested = function(name2, initialValues, isCollectionItem, expectedChildren) {
          var expected = this._expectedChildren[name2];
          var actualName = name2;
          var actualIsCollectionItem = isCollectionItem;
          if (expected) {
            actualIsCollectionItem = expected.isCollectionItem;
            if (expected.optionName) {
              actualName = expected.optionName;
            }
          }
          var collectionItemIndex = -1;
          if (actualIsCollectionItem && actualName) {
            collectionItemIndex = this._nestedConfigurations.filter(function(c) {
              return c._name && c._name === actualName;
            }).length;
          }
          var configuration = new Configuration2(this._updateFunc, actualName, initialValues, expectedChildren, actualIsCollectionItem, collectionItemIndex, this);
          this._nestedConfigurations.push(configuration);
          return configuration;
        };
        Configuration2.prototype.updateValue = function(nestedName, value2) {
          var fullName = [this.fullPath, nestedName].filter(function(n) {
            return n;
          }).join(".");
          this._updateFunc(fullName, value2);
        };
        Configuration2.prototype.getNestedOptionValues = function() {
          var values = {};
          this._nestedConfigurations.forEach(function(o) {
            if (!o._name) {
              return;
            }
            var nestedValue = __assign(__assign({}, o.initialValues), o.getNestedOptionValues());
            if (!nestedValue) {
              return;
            }
            if (!o._isCollectionItem) {
              values[o._name] = nestedValue;
            } else {
              var arr = values[o._name];
              if (!arr || !Array.isArray(arr)) {
                arr = [];
                values[o._name] = arr;
              }
              arr.push(nestedValue);
            }
          });
          return values;
        };
        Configuration2.prototype.getOptionsToWatch = function() {
          var blackList = {};
          this._nestedConfigurations.forEach(function(c) {
            return c._name && (blackList[c._name] = true);
          });
          return this._options.filter(function(o) {
            return !blackList[o];
          });
        };
        Configuration2.prototype._onOptionChanged = function(optionRelPath, args) {
          if (optionRelPath.length === 0) {
            return;
          }
          var optionInfo = helpers_1.getOptionInfo(optionRelPath[0]);
          if (optionInfo.isCollection || optionRelPath.length > 1) {
            var nestedConfig = this._getNestedConfig(optionInfo.fullName);
            if (nestedConfig) {
              nestedConfig._onOptionChanged(optionRelPath.slice(1), args);
              return;
            }
            this._tryEmitOptionChanged(optionInfo.name, args.component.option(this.fullPath ? this.fullPath + "." + optionInfo.name : optionInfo.name));
          } else {
            this._tryEmitOptionChanged(optionInfo.name, args.value);
          }
        };
        Configuration2.prototype._getNestedConfig = function(fullName) {
          for (var _i = 0, _a = this._nestedConfigurations; _i < _a.length; _i++) {
            var nestedConfig = _a[_i];
            if (nestedConfig.fullName === fullName) {
              return nestedConfig;
            }
          }
          return void 0;
        };
        Configuration2.prototype._tryEmitOptionChanged = function(name2, value2) {
          if (this._emitOptionChanged) {
            this._emitOptionChanged(name2, value2);
          }
        };
        return Configuration2;
      }()
    );
    function bindOptionWatchers(config2, vueInstance, innerChanges) {
      var targets = config2 && config2.getOptionsToWatch();
      if (targets) {
        targets.forEach(function(optionName) {
          vueInstance.$watch(optionName, function(value2) {
            var rawValue = vue_1.toRaw(value2);
            if (!innerChanges.hasOwnProperty(optionName) || innerChanges[optionName] !== rawValue) {
              config2.updateValue(optionName, value2);
            }
            delete innerChanges[optionName];
          }, { deep: config_1.getOption("deepWatch") });
        });
      }
    }
    exports.bindOptionWatchers = bindOptionWatchers;
    function hasProp2(vueInstance, propName) {
      var props = vueInstance.$options.props;
      return props && props.hasOwnProperty(propName);
    }
    function hasVModelValue(options2, props, vnode) {
      var _a;
      return options2.model && props.hasOwnProperty(vue_helper_1.VMODEL_NAME) && ((_a = vnode === null || vnode === void 0 ? void 0 : vnode.props) === null || _a === void 0 ? void 0 : _a.hasOwnProperty(vue_helper_1.VMODEL_NAME));
    }
    function setEmitOptionChangedFunc(config2, vueInstance, innerChanges) {
      config2.emitOptionChanged = function(name2, value2) {
        var _a;
        var props = vueInstance.$props;
        var vnode = (_a = vueInstance === null || vueInstance === void 0 ? void 0 : vueInstance.$) === null || _a === void 0 ? void 0 : _a.vnode;
        if (hasProp2(vueInstance, name2) && !helpers_1.isEqual(value2, props[name2]) && vueInstance.$emit) {
          innerChanges[name2] = vue_1.toRaw(value2);
          var eventName = name2 === "value" && hasVModelValue(vueInstance.$options, props, vnode) ? "update:" + vue_helper_1.VMODEL_NAME : "update:" + name2;
          vueInstance.$emit(eventName, value2);
        }
      };
    }
    exports.setEmitOptionChangedFunc = setEmitOptionChangedFunc;
    exports.default = Configuration;
  }
});

// node_modules/devextreme-vue/core/configuration-component.js
var require_configuration_component2 = __commonJS({
  "node_modules/devextreme-vue/core/configuration-component.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getInnerChanges = exports.getConfig = exports.initOptionChangedFunc = exports.initDxConfiguration = void 0;
    var vue_1 = require_vue();
    var vue_helper_1 = require_vue_helper();
    var configuration_1 = require_configuration2();
    function getConfig2(vueInstance) {
      var componentOptions = vue_helper_1.getNodeOptions(vueInstance);
      if (!componentOptions) {
        return;
      }
      return componentOptions.$_config || vueInstance.$_config;
    }
    exports.getConfig = getConfig2;
    function getInnerChanges(vueInstance) {
      var componentOptions = vue_helper_1.getNodeOptions(vueInstance);
      if (!componentOptions) {
        return;
      }
      return componentOptions.$_innerChanges || vueInstance.$_innerChanges;
    }
    exports.getInnerChanges = getInnerChanges;
    function initOptionChangedFunc(config2, props, vueInstance, innerChanges) {
      if (!config2) {
        return;
      }
      config2.init(Object.keys(props));
      if (vueInstance) {
        configuration_1.setEmitOptionChangedFunc(config2, vueInstance, innerChanges);
      }
    }
    exports.initOptionChangedFunc = initOptionChangedFunc;
    function getComponentInfo(_a, removed) {
      var name2 = _a.name, isCollectionItem = _a.isCollectionItem, ownerConfig = _a.ownerConfig;
      var parentPath = ownerConfig && ownerConfig.fullPath;
      var optionPath = name2 && parentPath ? parentPath + "." + name2 : name2 || "";
      return {
        optionPath,
        isCollection: isCollectionItem,
        removed
      };
    }
    function initDxConfiguration() {
      return vue_1.defineComponent({
        beforeMount: function() {
          var thisComponent = this;
          var config2 = getConfig2(thisComponent);
          var innerChanges = getInnerChanges(thisComponent);
          initOptionChangedFunc(config2, vue_helper_1.getNodeTypeOfComponent(thisComponent).props, thisComponent, innerChanges);
          configuration_1.bindOptionWatchers(config2, this, innerChanges);
        },
        mounted: function() {
          if (this.$parent.$_instance) {
            this.$parent.$_config.componentsCountChanged.push(getComponentInfo(getConfig2(this)));
          }
        },
        beforeUnmount: function() {
          var config2 = getConfig2(this);
          if (config2) {
            this.$parent.$_config.componentsCountChanged.push(getComponentInfo(config2, true));
          }
        },
        render: function() {
          return null;
        }
      });
    }
    exports.initDxConfiguration = initDxConfiguration;
  }
});

// node_modules/devextreme-vue/core/constants.js
var require_constants2 = __commonJS({
  "node_modules/devextreme-vue/core/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DX_REMOVE_EVENT = exports.DX_TEMPLATE_WRAPPER_CLASS = void 0;
    var DX_TEMPLATE_WRAPPER_CLASS = "dx-template-wrapper";
    exports.DX_TEMPLATE_WRAPPER_CLASS = DX_TEMPLATE_WRAPPER_CLASS;
    var DX_REMOVE_EVENT = "dxremove";
    exports.DX_REMOVE_EVENT = DX_REMOVE_EVENT;
  }
});

// node_modules/devextreme-vue/core/templates-discovering.js
var require_templates_discovering2 = __commonJS({
  "node_modules/devextreme-vue/core/templates-discovering.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.discover = exports.mountTemplate = void 0;
    var vue_helper_1 = require_vue_helper();
    var vue_1 = require_vue();
    var TEMPLATE_PROP = "template";
    function asConfigurable(component) {
      var componentOptions = component;
      if (!componentOptions) {
        return;
      }
      if (!componentOptions.$_config || !componentOptions.$_config.name) {
        return void 0;
      }
      return componentOptions;
    }
    function hasTemplate(component) {
      return TEMPLATE_PROP in component.type.props && vue_helper_1.configurationTemplate(component);
    }
    function discover(component) {
      var templates = {};
      var namedTeplates = vue_helper_1.declaredTemplates(component);
      for (var slotName in namedTeplates) {
        if (slotName === "default" && component.$slots.default) {
          continue;
        }
        var slot = namedTeplates[slotName];
        if (!slot) {
          continue;
        }
        templates[slotName] = slot;
      }
      var componentChildren = vue_helper_1.getChildren(component);
      for (var _i = 0, componentChildren_1 = componentChildren; _i < componentChildren_1.length; _i++) {
        var childComponent = componentChildren_1[_i];
        var configurable = asConfigurable(childComponent);
        if (!configurable) {
          continue;
        }
        var defaultSlot = vue_helper_1.configurationDefaultTemplate(childComponent);
        if (!defaultSlot || !hasTemplate(childComponent)) {
          continue;
        }
        var templateName = configurable.$_config.fullPath + "." + TEMPLATE_PROP;
        templates[templateName] = defaultSlot;
      }
      return templates;
    }
    exports.discover = discover;
    function clearConfiguration(content) {
      var newContent = [];
      content.forEach(function(item) {
        var configurable = vue_helper_1.getConfigurationOptions(item);
        if (!configurable || !configurable.$_optionName) {
          newContent.push(item);
        }
      });
      return newContent;
    }
    function mountTemplate(getSlot, parent, data2, name2, placeholder) {
      return vue_helper_1.mount({
        name: name2,
        inject: ["eventBus"],
        created: function() {
          this.eventBus.add(this.$_updatedHandler);
        },
        mounted: function() {
          data2.onRendered();
        },
        unmounted: function() {
          this.eventBus.remove(this.$_updatedHandler);
        },
        methods: {
          $_updatedHandler: function() {
            this.$forceUpdate();
          }
        },
        render: function() {
          var content = clearConfiguration(getSlot()(data2));
          if (!content) {
            return vue_1.h("div");
          }
          return content[0];
        }
      }, parent, placeholder);
    }
    exports.mountTemplate = mountTemplate;
  }
});

// node_modules/devextreme-vue/core/templates-manager.js
var require_templates_manager2 = __commonJS({
  "node_modules/devextreme-vue/core/templates-manager.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p2 in s)
            if (Object.prototype.hasOwnProperty.call(s, p2))
              t[p2] = s[p2];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TemplatesManager = void 0;
    var templates_discovering_1 = require_templates_discovering2();
    var dom_adapter_1 = __importDefault((init_dom_adapter(), __toCommonJS(dom_adapter_exports)));
    var events_1 = (init_events(), __toCommonJS(events_exports));
    var constants_1 = require_constants2();
    var helpers_1 = require_helpers2();
    var TemplatesManager = (
      /** @class */
      function() {
        function TemplatesManager2(component) {
          this._slots = {};
          this._templates = {};
          this._isDirty = false;
          this._component = component;
          this.discover();
        }
        TemplatesManager2.prototype.discover = function() {
          var slots = templates_discovering_1.discover(this._component);
          this._slots = __assign(__assign({}, this._slots), slots);
          if (!helpers_1.allKeysAreEqual(this._templates, slots)) {
            this._prepareTemplates();
          }
        };
        Object.defineProperty(TemplatesManager2.prototype, "templates", {
          get: function() {
            return this._templates;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(TemplatesManager2.prototype, "isDirty", {
          get: function() {
            return this._isDirty;
          },
          enumerable: false,
          configurable: true
        });
        TemplatesManager2.prototype.resetDirtyFlag = function() {
          this._isDirty = false;
        };
        TemplatesManager2.prototype._prepareTemplates = function() {
          this._templates = {};
          for (var _i = 0, _a = Object.keys(this._slots); _i < _a.length; _i++) {
            var name_1 = _a[_i];
            this._templates[name_1] = this.createDxTemplate(name_1);
          }
          this._isDirty = true;
        };
        TemplatesManager2.prototype.createDxTemplate = function(name2) {
          var _this = this;
          return {
            render: function(data2) {
              var rendered = function(onRendered, counter) {
                if (counter === void 0) {
                  counter = 0;
                }
                return function() {
                  if (counter === 1 && onRendered) {
                    onRendered();
                  }
                  counter++;
                };
              }(data2.onRendered);
              var scopeData = { data: data2.model, index: data2.index, onRendered: rendered };
              var placeholder = document.createElement("div");
              var container = data2.container.get ? data2.container.get(0) : data2.container;
              container.appendChild(placeholder);
              var mountedTemplate = templates_discovering_1.mountTemplate(function() {
                return _this._slots[name2];
              }, _this._component, scopeData, name2, placeholder);
              var element = mountedTemplate.$el;
              container.removeChild(placeholder);
              container.appendChild(element);
              dom_adapter_1.default.setClass(element, constants_1.DX_TEMPLATE_WRAPPER_CLASS, true);
              if (element.nodeType === Node.TEXT_NODE) {
                var removalListener = document.createElement(container.nodeName === "TABLE" ? "tbody" : "span");
                removalListener.style.display = "none";
                container.appendChild(removalListener);
                events_1.one(removalListener, constants_1.DX_REMOVE_EVENT, mountedTemplate.$.appContext.app.unmount.bind(mountedTemplate));
              } else {
                events_1.one(element, constants_1.DX_REMOVE_EVENT, mountedTemplate.$.appContext.app.unmount.bind(mountedTemplate));
              }
              rendered();
              return element;
            }
          };
        };
        return TemplatesManager2;
      }()
    );
    exports.TemplatesManager = TemplatesManager;
  }
});

// node_modules/devextreme-vue/core/component.js
var require_component2 = __commonJS({
  "node_modules/devextreme-vue/core/component.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p2 in s)
            if (Object.prototype.hasOwnProperty.call(s, p2))
              t[p2] = s[p2];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result2 = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result2, mod, k);
      }
      __setModuleDefault(result2, mod);
      return result2;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.initBaseComponent = exports.initDxComponent = void 0;
    var vue_1 = require_vue();
    var callbacks_1 = __importDefault((init_callbacks(), __toCommonJS(callbacks_exports)));
    var events_1 = (init_events(), __toCommonJS(events_exports));
    var vue_helper_1 = require_vue_helper();
    var children_processing_1 = require_children_processing2();
    var configuration_1 = __importStar(require_configuration2());
    var configuration_component_1 = require_configuration_component2();
    var constants_1 = require_constants2();
    var helpers_1 = require_helpers2();
    var templates_manager_1 = require_templates_manager2();
    var includeAttrs = ["id", "class", "style"];
    function getAttrs(attrs) {
      var attributes = {};
      includeAttrs.forEach(function(attr) {
        var attrValue = attrs[attr];
        if (attrValue) {
          attributes[attr] = attrValue;
        }
      });
      return attributes;
    }
    function initBaseComponent() {
      return vue_1.defineComponent({
        inheritAttrs: false,
        data: function() {
          return {
            eventBus: callbacks_1.default()
          };
        },
        provide: function() {
          return {
            eventBus: this.eventBus
          };
        },
        render: function() {
          var thisComponent = this;
          var children = [];
          if (thisComponent.$_config.cleanNested) {
            thisComponent.$_config.cleanNested();
          }
          children_processing_1.pullAllChildren(vue_helper_1.defaultSlots(this), children, thisComponent.$_config);
          this.$_processChildren(children);
          return vue_1.h("div", __assign({}, getAttrs(this.$attrs)), children);
        },
        beforeUpdate: function() {
          var thisComponent = this;
          thisComponent.$_config.setPrevNestedOptions(thisComponent.$_config.getNestedOptionValues());
        },
        updated: function() {
          var thisComponent = this;
          var nodes = cleanWidgetNode(this.$el);
          vue_helper_1.getChildren(thisComponent).forEach(function(child) {
            var _a2;
            configuration_component_1.initOptionChangedFunc(child.$_config, child.type.props || {}, (_a2 = child === null || child === void 0 ? void 0 : child.component) === null || _a2 === void 0 ? void 0 : _a2.proxy, child.$_innerChanges);
          });
          thisComponent.$_templatesManager.discover();
          thisComponent.$_instance.beginUpdate();
          if (thisComponent.$_templatesManager.isDirty) {
            thisComponent.$_instance.option("integrationOptions.templates", thisComponent.$_templatesManager.templates);
            for (var _i = 0, _a = Object.keys(thisComponent.$_templatesManager.templates); _i < _a.length; _i++) {
              var name_1 = _a[_i];
              thisComponent.$_instance.option(name_1, name_1);
            }
            thisComponent.$_templatesManager.resetDirtyFlag();
          }
          for (var _b = 0, _c = Object.keys(thisComponent.$_pendingOptions); _b < _c.length; _b++) {
            var name_2 = _c[_b];
            thisComponent.$_instance.option(name_2, thisComponent.$_pendingOptions[name_2]);
          }
          thisComponent.$_pendingOptions = {};
          this.$_applyConfigurationChanges();
          thisComponent.$_instance.endUpdate();
          restoreNodes(this.$el, nodes);
          this.eventBus.fire();
        },
        beforeUnmount: function() {
          var thisComponent = this;
          var instance = thisComponent.$_instance;
          if (instance) {
            events_1.triggerHandler(this.$el, constants_1.DX_REMOVE_EVENT);
            instance.dispose();
          }
        },
        created: function() {
          var thisComponent = this;
          var props = vue_helper_1.getComponentProps(this);
          thisComponent.$_config = new configuration_1.default(function(n, v) {
            if (Array.isArray(v)) {
              thisComponent.$_instance.option(n, v);
            } else {
              thisComponent.$_pendingOptions[n === vue_helper_1.VMODEL_NAME ? "value" : n] = v;
            }
          }, null, props && __assign({}, props), thisComponent.$_expectedChildren);
          thisComponent.$_innerChanges = {};
          thisComponent.$_config.init(this.$props && Object.keys(this.$props));
        },
        methods: {
          $_applyConfigurationChanges: function() {
            var thisComponent = this;
            thisComponent.$_config.componentsCountChanged.forEach(function(_a) {
              var optionPath = _a.optionPath, isCollection = _a.isCollection, removed = _a.removed;
              var options2 = thisComponent.$_config.getNestedOptionValues();
              if (!isCollection && removed) {
                thisComponent.$_instance.resetOption(optionPath);
              } else {
                thisComponent.$_instance.option(optionPath, helpers_1.getOptionValue(options2, optionPath));
              }
            });
            thisComponent.$_config.cleanComponentsCountChanged();
          },
          $_createWidget: function(element) {
            var thisComponent = this;
            thisComponent.$_pendingOptions = {};
            thisComponent.$_templatesManager = new templates_manager_1.TemplatesManager(this);
            var config2 = thisComponent.$_config;
            if (config2.initialValues.hasOwnProperty(vue_helper_1.VMODEL_NAME)) {
              config2.initialValues.value = vue_helper_1.getVModelValue(config2.initialValues);
            }
            var options2 = __assign(__assign(__assign(__assign({ templatesRenderAsynchronously: thisComponent.$_hasAsyncTemplate }, vue_helper_1.getComponentProps(thisComponent)), config2.initialValues), config2.getNestedOptionValues()), this.$_getIntegrationOptions());
            var instance = new thisComponent.$_WidgetClass(element, options2);
            thisComponent.$_instance = instance;
            instance.on("optionChanged", function(args) {
              return config2.onOptionChanged(args);
            });
            configuration_1.setEmitOptionChangedFunc(config2, thisComponent, thisComponent.$_innerChanges);
            configuration_1.bindOptionWatchers(config2, thisComponent, thisComponent.$_innerChanges);
            this.$_createEmitters(instance);
          },
          $_getIntegrationOptions: function() {
            var thisComponent = this;
            var result2 = __assign({ integrationOptions: {
              watchMethod: this.$_getWatchMethod()
            } }, this.$_getExtraIntegrationOptions());
            if (thisComponent.$_templatesManager.isDirty) {
              var templates = thisComponent.$_templatesManager.templates;
              result2.integrationOptions.templates = templates;
              for (var _i = 0, _a = Object.keys(templates); _i < _a.length; _i++) {
                var name_3 = _a[_i];
                result2[name_3] = name_3;
              }
              thisComponent.$_templatesManager.resetDirtyFlag();
            }
            return result2;
          },
          $_getWatchMethod: function() {
            var _this = this;
            return function(valueGetter, valueChangeCallback, options2) {
              options2 = options2 || {};
              if (!options2.skipImmediate) {
                valueChangeCallback(valueGetter());
              }
              return _this.$watch(function() {
                return valueGetter();
              }, function(newValue, oldValue) {
                if (helpers_1.toComparable(oldValue) !== helpers_1.toComparable(newValue) || options2.deep) {
                  valueChangeCallback(newValue);
                }
              }, {
                deep: options2.deep
              });
            };
          },
          $_getExtraIntegrationOptions: function() {
            return {};
          },
          $_processChildren: function(_children) {
            return;
          },
          $_createEmitters: function(instance) {
            var _this = this;
            if (this.$attrs) {
              Object.keys(this.$attrs).forEach(function(listenerName) {
                var eventName = helpers_1.camelize(listenerName);
                instance.on(eventName, function(e) {
                  _this.$emit(listenerName, e);
                });
              });
            }
          }
        }
      });
    }
    exports.initBaseComponent = initBaseComponent;
    function cleanWidgetNode(node) {
      var removedNodes = [];
      helpers_1.forEachChildNode(node, function(childNode) {
        var parent = childNode.parentNode;
        var isExtension = childNode.hasAttribute && childNode.hasAttribute("isExtension");
        if ((childNode.nodeName === "#comment" || isExtension) && parent) {
          removedNodes.push(childNode);
          parent.removeChild(childNode);
        }
      });
      return removedNodes;
    }
    function restoreNodes(el, nodes) {
      nodes.forEach(function(node) {
        el.appendChild(node);
      });
    }
    function initDxComponent() {
      return vue_1.defineComponent({
        extends: initBaseComponent(),
        methods: {
          $_getExtraIntegrationOptions: function() {
            return {
              onInitializing: function() {
                this.beginUpdate();
              }
            };
          },
          $_processChildren: function(children) {
            children.forEach(function(childNode) {
              if (!childNode || typeof childNode !== "object") {
                return;
              }
              childNode.$_hasOwner = true;
            });
          }
        },
        mounted: function() {
          var _this = this;
          var nodes = cleanWidgetNode(this.$el);
          var thisComponent = this;
          this.$_createWidget(this.$el);
          thisComponent.$_instance.endUpdate();
          restoreNodes(this.$el, nodes);
          if (this.$slots && this.$slots.default) {
            vue_helper_1.getChildren(thisComponent).forEach(function(child) {
              var childExtenton = child;
              if (childExtenton && childExtenton.$_isExtension) {
                childExtenton.$_attachTo(_this.$el);
              }
            });
          }
        }
      });
    }
    exports.initDxComponent = initDxComponent;
  }
});

// node_modules/devextreme-vue/core/extension-component.js
var require_extension_component2 = __commonJS({
  "node_modules/devextreme-vue/core/extension-component.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.initDxExtensionComponent = void 0;
    var vue_1 = require_vue();
    var component_1 = require_component2();
    var vue_helper_1 = require_vue_helper();
    function initDxExtensionComponent() {
      return vue_1.defineComponent({
        extends: component_1.initBaseComponent(),
        mounted: function() {
          this.$el.setAttribute("isExtension", "true");
          var nodeOptions = vue_helper_1.getNodeOptions(this);
          nodeOptions.$_isExtension = true;
          nodeOptions.$_attachTo = this.attachTo.bind(this);
          if (nodeOptions && nodeOptions.$_hasOwner) {
            return;
          }
          this.attachTo(this.$el);
        },
        methods: {
          attachTo: function(element) {
            this.$_createWidget(element);
          }
        }
      });
    }
    exports.initDxExtensionComponent = initDxExtensionComponent;
  }
});

// node_modules/devextreme-vue/core/strategy/vue3/index.js
var require_vue3 = __commonJS({
  "node_modules/devextreme-vue/core/strategy/vue3/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createExtensionComponent = exports.createConfigurationComponent = exports.createComponent = void 0;
    var vue_1 = require_vue();
    var component_1 = require_component2();
    var configuration_component_1 = require_configuration_component2();
    var extension_component_1 = require_extension_component2();
    var vue_helper_1 = require_vue_helper();
    function createComponent(config2) {
      config2.extends = component_1.initDxComponent();
      vue_helper_1.setCompatOptions(config2);
      if (config2.model) {
        vue_helper_1.setVModel(config2);
      }
      return vue_1.defineComponent(config2);
    }
    exports.createComponent = createComponent;
    function createConfigurationComponent(config2) {
      config2.extends = configuration_component_1.initDxConfiguration();
      vue_helper_1.setCompatOptions(config2);
      return vue_1.defineComponent(config2);
    }
    exports.createConfigurationComponent = createConfigurationComponent;
    function createExtensionComponent(config2) {
      config2.extends = extension_component_1.initDxExtensionComponent();
      vue_helper_1.setCompatOptions(config2);
      return vue_1.defineComponent(config2);
    }
    exports.createExtensionComponent = createExtensionComponent;
  }
});

// node_modules/devextreme-vue/core/version.js
var require_version = __commonJS({
  "node_modules/devextreme-vue/core/version.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result2 = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result2, mod, k);
      }
      __setModuleDefault(result2, mod);
      return result2;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isVue3 = exports.getVueVersion = void 0;
    var VueType = __importStar(require_vue());
    var Vue = VueType.default || VueType;
    function getVueVersion() {
      var currentVersion = Vue.version;
      return Number(currentVersion.split(".")[0]);
    }
    exports.getVueVersion = getVueVersion;
    function isVue3() {
      return getVueVersion() === 3;
    }
    exports.isVue3 = isVue3;
  }
});

// node_modules/devextreme-vue/core/index.js
var require_core = __commonJS({
  "node_modules/devextreme-vue/core/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result2 = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result2, mod, k);
      }
      __setModuleDefault(result2, mod);
      return result2;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createExtensionComponent = exports.createConfigurationComponent = exports.createComponent = void 0;
    var vue2Stategy = __importStar(require_vue2());
    var vue3Stategy = __importStar(require_vue3());
    var version_1 = require_version();
    var strategy3 = version_1.isVue3() ? vue3Stategy : vue2Stategy;
    exports.createComponent = strategy3.createComponent;
    exports.createConfigurationComponent = strategy3.createConfigurationComponent;
    exports.createExtensionComponent = strategy3.createExtensionComponent;
  }
});

// node_modules/devextreme/esm/core/element_data.js
function data() {
  return strategy.data.apply(this, arguments);
}
function beforeCleanData(callback) {
  beforeCleanDataFunc = callback;
}
function removeData(element, key) {
  return strategy.removeData.call(this, element, key);
}
function cleanDataRecursive(element, cleanSelf) {
  if (!dom_adapter_default.isElementNode(element)) {
    return;
  }
  var childElements = element.getElementsByTagName("*");
  strategy.cleanData(childElements);
  if (cleanSelf) {
    strategy.cleanData([element]);
  }
}
var dataMap, strategy, strategyChanging, beforeCleanDataFunc, afterCleanDataFunc, setDataStrategy;
var init_element_data = __esm({
  "node_modules/devextreme/esm/core/element_data.js"() {
    init_weak_map();
    init_dom_adapter();
    init_events_engine();
    init_memorized_callbacks();
    dataMap = new weak_map_default();
    strategyChanging = new MemorizedCallbacks();
    beforeCleanDataFunc = function() {
    };
    afterCleanDataFunc = function() {
    };
    setDataStrategy = function(value2) {
      strategyChanging.fire(value2);
      strategy = value2;
      var cleanData = strategy.cleanData;
      strategy.cleanData = function(nodes) {
        beforeCleanDataFunc(nodes);
        var result2 = cleanData.call(this, nodes);
        afterCleanDataFunc(nodes);
        return result2;
      };
    };
    setDataStrategy({
      data: function() {
        var element = arguments[0];
        var key = arguments[1];
        var value2 = arguments[2];
        if (!element) {
          return;
        }
        var elementData = dataMap.get(element);
        if (!elementData) {
          elementData = {};
          dataMap.set(element, elementData);
        }
        if (void 0 === key) {
          return elementData;
        }
        if (2 === arguments.length) {
          return elementData[key];
        }
        elementData[key] = value2;
        return value2;
      },
      removeData: function(element, key) {
        if (!element) {
          return;
        }
        if (void 0 === key) {
          dataMap.delete(element);
        } else {
          var elementData = dataMap.get(element);
          if (elementData) {
            delete elementData[key];
          }
        }
      },
      cleanData: function(elements) {
        for (var i = 0; i < elements.length; i++) {
          events_engine_default.off(elements[i]);
          dataMap.delete(elements[i]);
        }
      }
    });
  }
});

// node_modules/devextreme/esm/core/utils/inflector.js
var _normalize, _upperCaseFirst, _chop, dasherize, camelize2, humanize, titleize, DIGIT_CHARS, captionize;
var init_inflector = __esm({
  "node_modules/devextreme/esm/core/utils/inflector.js"() {
    init_iterator();
    _normalize = function(text) {
      if (void 0 === text || null === text) {
        return "";
      }
      return String(text);
    };
    _upperCaseFirst = function(text) {
      return _normalize(text).charAt(0).toUpperCase() + text.substr(1);
    };
    _chop = function(text) {
      return _normalize(text).replace(/([a-z\d])([A-Z])/g, "$1 $2").split(/[\s_-]+/);
    };
    dasherize = function(text) {
      return map(_chop(text), function(p2) {
        return p2.toLowerCase();
      }).join("-");
    };
    camelize2 = function(text, upperFirst) {
      return map(_chop(text), function(p2, i) {
        p2 = p2.toLowerCase();
        if (upperFirst || i > 0) {
          p2 = _upperCaseFirst(p2);
        }
        return p2;
      }).join("");
    };
    humanize = function(text) {
      return _upperCaseFirst(dasherize(text).replace(/-/g, " "));
    };
    titleize = function(text) {
      return map(_chop(text), function(p2) {
        return _upperCaseFirst(p2.toLowerCase());
      }).join(" ");
    };
    DIGIT_CHARS = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"];
    captionize = function(name2) {
      var captionList = [];
      var i;
      var char;
      var isPrevCharNewWord = false;
      var isNewWord = false;
      for (i = 0; i < name2.length; i++) {
        char = name2.charAt(i);
        isNewWord = char === char.toUpperCase() && "-" !== char && ")" !== char && "/" !== char || char in DIGIT_CHARS;
        if ("_" === char || "." === char) {
          char = " ";
          isNewWord = true;
        } else if (0 === i) {
          char = char.toUpperCase();
          isNewWord = true;
        } else if (!isPrevCharNewWord && isNewWord) {
          if (captionList.length > 0) {
            captionList.push(" ");
          }
        }
        captionList.push(char);
        isPrevCharNewWord = isNewWord;
      }
      return captionList.join("");
    };
  }
});

// node_modules/devextreme/esm/core/utils/style.js
var jsPrefixes, cssPrefixes, getStyles, forEachPrefixes, styleProp, stylePropPrefix, pxExceptions, normalizeStyleProp, setDimensionProperty, setWidth, setHeight;
var init_style = __esm({
  "node_modules/devextreme/esm/core/utils/style.js"() {
    init_inflector();
    init_call_once();
    init_type();
    init_dom_adapter();
    jsPrefixes = ["", "Webkit", "Moz", "O", "Ms"];
    cssPrefixes = {
      "": "",
      Webkit: "-webkit-",
      Moz: "-moz-",
      O: "-o-",
      ms: "-ms-"
    };
    getStyles = call_once_default(function() {
      return dom_adapter_default.createElement("dx").style;
    });
    forEachPrefixes = function(prop, callBack) {
      prop = camelize2(prop, true);
      var result2;
      for (var i = 0, cssPrefixesCount = jsPrefixes.length; i < cssPrefixesCount; i++) {
        var jsPrefix = jsPrefixes[i];
        var prefixedProp = jsPrefix + prop;
        var lowerPrefixedProp = camelize2(prefixedProp);
        result2 = callBack(lowerPrefixedProp, jsPrefix);
        if (void 0 === result2) {
          result2 = callBack(prefixedProp, jsPrefix);
        }
        if (void 0 !== result2) {
          break;
        }
      }
      return result2 || "";
    };
    styleProp = function(name2) {
      if (name2 in getStyles()) {
        return name2;
      }
      var originalName = name2;
      name2 = name2.charAt(0).toUpperCase() + name2.substr(1);
      for (var i = 1; i < jsPrefixes.length; i++) {
        var prefixedProp = jsPrefixes[i].toLowerCase() + name2;
        if (prefixedProp in getStyles()) {
          return prefixedProp;
        }
      }
      return originalName;
    };
    stylePropPrefix = function(prop) {
      return forEachPrefixes(prop, function(specific, jsPrefix) {
        if (specific in getStyles()) {
          return cssPrefixes[jsPrefix];
        }
      });
    };
    pxExceptions = ["fillOpacity", "columnCount", "flexGrow", "flexShrink", "fontWeight", "lineHeight", "opacity", "zIndex", "zoom"];
    normalizeStyleProp = function(prop, value2) {
      if (isNumeric(value2) && -1 === pxExceptions.indexOf(prop)) {
        value2 += "px";
      }
      return value2;
    };
    setDimensionProperty = function(elements, propertyName, value2) {
      if (elements) {
        value2 = isNumeric(value2) ? value2 += "px" : value2;
        for (var i = 0; i < elements.length; ++i) {
          elements[i].style[propertyName] = value2;
        }
      }
    };
    setWidth = function(elements, value2) {
      setDimensionProperty(elements, "width", value2);
    };
    setHeight = function(elements, value2) {
      setDimensionProperty(elements, "height", value2);
    };
  }
});

// node_modules/devextreme/esm/core/utils/size.js
var window3, SPECIAL_HEIGHT_VALUES, getSizeByStyles, getElementBoxParams, getBoxSizingOffset, getSize, getContainerHeight, parseHeight, getHeightWithOffset, addOffsetToMaxHeight, addOffsetToMinHeight, getVerticalOffsets, getVisibleHeight;
var init_size = __esm({
  "node_modules/devextreme/esm/core/utils/size.js"() {
    init_window();
    init_type();
    window3 = getWindow();
    SPECIAL_HEIGHT_VALUES = ["auto", "none", "inherit", "initial"];
    getSizeByStyles = function(elementStyles, styles) {
      var result2 = 0;
      styles.forEach(function(style) {
        result2 += parseFloat(elementStyles[style]) || 0;
      });
      return result2;
    };
    getElementBoxParams = function(name2, elementStyles) {
      var beforeName = "width" === name2 ? "Left" : "Top";
      var afterName = "width" === name2 ? "Right" : "Bottom";
      return {
        padding: getSizeByStyles(elementStyles, ["padding" + beforeName, "padding" + afterName]),
        border: getSizeByStyles(elementStyles, ["border" + beforeName + "Width", "border" + afterName + "Width"]),
        margin: getSizeByStyles(elementStyles, ["margin" + beforeName, "margin" + afterName])
      };
    };
    getBoxSizingOffset = function(name2, elementStyles, boxParams) {
      var size = elementStyles[name2];
      if ("border-box" === elementStyles.boxSizing && size.length && "%" !== size[size.length - 1]) {
        return boxParams.border + boxParams.padding;
      }
      return 0;
    };
    getSize = function(element, name2, include2) {
      var elementStyles = window3.getComputedStyle(element);
      var boxParams = getElementBoxParams(name2, elementStyles);
      var clientRect = element.getClientRects().length;
      var boundingClientRect = element.getBoundingClientRect()[name2];
      var result2 = clientRect ? boundingClientRect : 0;
      if (result2 <= 0) {
        result2 = parseFloat(elementStyles[name2] || element.style[name2]) || 0;
        result2 -= getBoxSizingOffset(name2, elementStyles, boxParams);
      } else {
        result2 -= boxParams.padding + boxParams.border;
      }
      if (include2.paddings) {
        result2 += boxParams.padding;
      }
      if (include2.borders) {
        result2 += boxParams.border;
      }
      if (include2.margins) {
        result2 += boxParams.margin;
      }
      return result2;
    };
    getContainerHeight = function(container) {
      return isWindow(container) ? container.innerHeight : container.offsetHeight;
    };
    parseHeight = function(value2, container) {
      if (value2.indexOf("px") > 0) {
        value2 = parseInt(value2.replace("px", ""));
      } else if (value2.indexOf("%") > 0) {
        value2 = parseInt(value2.replace("%", "")) * getContainerHeight(container) / 100;
      } else if (!isNaN(value2)) {
        value2 = parseInt(value2);
      } else if (value2.indexOf("vh") > 0) {
        value2 = window3.innerHeight / 100 * parseInt(value2.replace("vh", ""));
      }
      return value2;
    };
    getHeightWithOffset = function(value2, offset2, container) {
      if (!value2) {
        return null;
      }
      if (SPECIAL_HEIGHT_VALUES.indexOf(value2) > -1) {
        return offset2 ? null : value2;
      }
      if (isString2(value2)) {
        value2 = parseHeight(value2, container);
      }
      if (isNumeric(value2)) {
        return Math.max(0, value2 + offset2);
      }
      var operationString = offset2 < 0 ? " - " : " ";
      return "calc(" + value2 + operationString + Math.abs(offset2) + "px)";
    };
    addOffsetToMaxHeight = function(value2, offset2, container) {
      var maxHeight = getHeightWithOffset(value2, offset2, container);
      return null !== maxHeight ? maxHeight : "none";
    };
    addOffsetToMinHeight = function(value2, offset2, container) {
      var minHeight = getHeightWithOffset(value2, offset2, container);
      return null !== minHeight ? minHeight : 0;
    };
    getVerticalOffsets = function(element, withMargins) {
      if (!element) {
        return 0;
      }
      var boxParams = getElementBoxParams("height", window3.getComputedStyle(element));
      return boxParams.padding + boxParams.border + (withMargins ? boxParams.margin : 0);
    };
    getVisibleHeight = function(element) {
      if (element) {
        var boundingClientRect = element.getBoundingClientRect();
        if (boundingClientRect.height) {
          return boundingClientRect.height;
        }
      }
      return 0;
    };
  }
});

// node_modules/devextreme/esm/core/utils/html_parser.js
var isTagName, tagWrappers, parseHTML, isTablePart;
var init_html_parser = __esm({
  "node_modules/devextreme/esm/core/utils/html_parser.js"() {
    init_array();
    init_dom_adapter();
    isTagName = /<([a-z][^/\0>\x20\t\r\n\f]+)/i;
    tagWrappers = {
      default: {
        tagsCount: 0,
        startTags: "",
        endTags: ""
      },
      thead: {
        tagsCount: 1,
        startTags: "<table>",
        endTags: "</table>"
      },
      td: {
        tagsCount: 3,
        startTags: "<table><tbody><tr>",
        endTags: "</tr></tbody></table>"
      },
      col: {
        tagsCount: 2,
        startTags: "<table><colgroup>",
        endTags: "</colgroup></table>"
      },
      tr: {
        tagsCount: 2,
        startTags: "<table><tbody>",
        endTags: "</tbody></table>"
      }
    };
    tagWrappers.tbody = tagWrappers.colgroup = tagWrappers.caption = tagWrappers.tfoot = tagWrappers.thead;
    tagWrappers.th = tagWrappers.td;
    parseHTML = function(html) {
      if ("string" !== typeof html) {
        return null;
      }
      var fragment = dom_adapter_default.createDocumentFragment();
      var container = fragment.appendChild(dom_adapter_default.createElement("div"));
      var tags = isTagName.exec(html);
      var firstRootTag = tags && tags[1].toLowerCase();
      var tagWrapper = tagWrappers[firstRootTag] || tagWrappers.default;
      container.innerHTML = tagWrapper.startTags + html + tagWrapper.endTags;
      for (var i = 0; i < tagWrapper.tagsCount; i++) {
        container = container.lastChild;
      }
      return merge([], container.childNodes);
    };
    isTablePart = function(html) {
      var tags = isTagName.exec(html);
      return tags && tags[1] in tagWrappers;
    };
  }
});

// node_modules/devextreme/esm/core/renderer_base.js
var window4, renderer, initRender, repeatMethod, setAttributeValue, appendElements, setCss, isVisible, emptyArray, getWindowByElement, rendererWrapper, renderer_base_default;
var init_renderer_base = __esm({
  "node_modules/devextreme/esm/core/renderer_base.js"() {
    init_element_data();
    init_dom_adapter();
    init_window();
    init_type();
    init_style();
    init_size();
    init_html_parser();
    window4 = getWindow();
    initRender = function(selector, context2) {
      if (!selector) {
        this.length = 0;
        return this;
      }
      if ("string" === typeof selector) {
        if ("body" === selector) {
          this[0] = context2 ? context2.body : dom_adapter_default.getBody();
          this.length = 1;
          return this;
        }
        context2 = context2 || dom_adapter_default.getDocument();
        if ("<" === selector[0]) {
          this[0] = dom_adapter_default.createElement(selector.slice(1, -1), context2);
          this.length = 1;
          return this;
        }
        [].push.apply(this, dom_adapter_default.querySelectorAll(context2, selector));
        return this;
      } else if (dom_adapter_default.isNode(selector) || isWindow(selector)) {
        this[0] = selector;
        this.length = 1;
        return this;
      } else if (Array.isArray(selector)) {
        [].push.apply(this, selector);
        return this;
      }
      return renderer(selector.toArray ? selector.toArray() : [selector]);
    };
    renderer = function(selector, context2) {
      return new initRender(selector, context2);
    };
    renderer.fn = {
      dxRenderer: true
    };
    initRender.prototype = renderer.fn;
    repeatMethod = function(methodName, args) {
      for (var i = 0; i < this.length; i++) {
        var item = renderer(this[i]);
        item[methodName].apply(item, args);
      }
      return this;
    };
    setAttributeValue = function(element, attrName, value2) {
      if (void 0 !== value2 && null !== value2) {
        dom_adapter_default.setAttribute(element, attrName, value2);
      } else {
        dom_adapter_default.removeAttribute(element, attrName);
      }
    };
    initRender.prototype.show = function() {
      return this.toggle(true);
    };
    initRender.prototype.hide = function() {
      return this.toggle(false);
    };
    initRender.prototype.toggle = function(value2) {
      if (this[0]) {
        this.toggleClass("dx-state-invisible", !value2);
      }
      return this;
    };
    initRender.prototype.attr = function(attrName, value2) {
      if (this.length > 1 && arguments.length > 1) {
        return repeatMethod.call(this, "attr", arguments);
      }
      if (!this[0]) {
        if (isObject2(attrName) || void 0 !== value2) {
          return this;
        } else {
          return;
        }
      }
      if (!this[0].getAttribute) {
        return this.prop(attrName, value2);
      }
      if ("string" === typeof attrName && 1 === arguments.length) {
        var result2 = this[0].getAttribute(attrName);
        return null == result2 ? void 0 : result2;
      } else if (isPlainObject(attrName)) {
        for (var key in attrName) {
          this.attr(key, attrName[key]);
        }
      } else {
        setAttributeValue(this[0], attrName, value2);
      }
      return this;
    };
    initRender.prototype.removeAttr = function(attrName) {
      this[0] && dom_adapter_default.removeAttribute(this[0], attrName);
      return this;
    };
    initRender.prototype.prop = function(propName, value2) {
      if (!this[0]) {
        return this;
      }
      if ("string" === typeof propName && 1 === arguments.length) {
        return this[0][propName];
      } else if (isPlainObject(propName)) {
        for (var key in propName) {
          this.prop(key, propName[key]);
        }
      } else {
        dom_adapter_default.setProperty(this[0], propName, value2);
      }
      return this;
    };
    initRender.prototype.addClass = function(className) {
      return this.toggleClass(className, true);
    };
    initRender.prototype.removeClass = function(className) {
      return this.toggleClass(className, false);
    };
    initRender.prototype.hasClass = function(className) {
      if (!this[0] || void 0 === this[0].className) {
        return false;
      }
      var classNames = className.split(" ");
      for (var i = 0; i < classNames.length; i++) {
        if (this[0].classList) {
          if (this[0].classList.contains(classNames[i])) {
            return true;
          }
        } else {
          var _className = isString2(this[0].className) ? this[0].className : dom_adapter_default.getAttribute(this[0], "class");
          if ((_className || "").split(" ").indexOf(classNames[i]) >= 0) {
            return true;
          }
        }
      }
      return false;
    };
    initRender.prototype.toggleClass = function(className, value2) {
      if (this.length > 1) {
        return repeatMethod.call(this, "toggleClass", arguments);
      }
      if (!this[0] || !className) {
        return this;
      }
      value2 = void 0 === value2 ? !this.hasClass(className) : value2;
      var classNames = className.split(" ");
      for (var i = 0; i < classNames.length; i++) {
        dom_adapter_default.setClass(this[0], classNames[i], value2);
      }
      return this;
    };
    ["width", "height", "outerWidth", "outerHeight", "innerWidth", "innerHeight"].forEach(function(methodName) {
      var partialName = methodName.toLowerCase().indexOf("width") >= 0 ? "Width" : "Height";
      var propName = partialName.toLowerCase();
      var isOuter = 0 === methodName.indexOf("outer");
      var isInner = 0 === methodName.indexOf("inner");
      initRender.prototype[methodName] = function(value2) {
        if (this.length > 1 && arguments.length > 0) {
          return repeatMethod.call(this, methodName, arguments);
        }
        var element = this[0];
        if (!element) {
          return;
        }
        if (isWindow(element)) {
          return isOuter ? element["inner" + partialName] : dom_adapter_default.getDocumentElement()["client" + partialName];
        }
        if (dom_adapter_default.isDocument(element)) {
          var documentElement = dom_adapter_default.getDocumentElement();
          var body = dom_adapter_default.getBody();
          return Math.max(body["scroll" + partialName], body["offset" + partialName], documentElement["scroll" + partialName], documentElement["offset" + partialName], documentElement["client" + partialName]);
        }
        if (0 === arguments.length || "boolean" === typeof value2) {
          var include2 = {
            paddings: isInner || isOuter,
            borders: isOuter,
            margins: value2
          };
          return getSize(element, propName, include2);
        }
        if (void 0 === value2 || null === value2) {
          return this;
        }
        if (isNumeric(value2)) {
          var elementStyles = window4.getComputedStyle(element);
          var sizeAdjustment = getElementBoxParams(propName, elementStyles);
          var isBorderBox = "border-box" === elementStyles.boxSizing;
          value2 = Number(value2);
          if (isOuter) {
            value2 -= isBorderBox ? 0 : sizeAdjustment.border + sizeAdjustment.padding;
          } else if (isInner) {
            value2 += isBorderBox ? sizeAdjustment.border : -sizeAdjustment.padding;
          } else if (isBorderBox) {
            value2 += sizeAdjustment.border + sizeAdjustment.padding;
          }
        }
        value2 += isNumeric(value2) ? "px" : "";
        dom_adapter_default.setStyle(element, propName, value2);
        return this;
      };
    });
    initRender.prototype.html = function(value2) {
      if (!arguments.length) {
        return this[0].innerHTML;
      }
      this.empty();
      if ("string" === typeof value2 && !isTablePart(value2) || "number" === typeof value2) {
        this[0].innerHTML = value2;
        return this;
      }
      return this.append(parseHTML(value2));
    };
    appendElements = function(element, nextSibling) {
      if (!this[0] || !element) {
        return;
      }
      if ("string" === typeof element) {
        element = parseHTML(element);
      } else if (element.nodeType) {
        element = [element];
      } else if (isNumeric(element)) {
        element = [dom_adapter_default.createTextNode(element)];
      }
      for (var i = 0; i < element.length; i++) {
        var item = element[i];
        var container = this[0];
        var wrapTR = "TABLE" === container.tagName && "TR" === item.tagName;
        if (wrapTR && container.tBodies && container.tBodies.length) {
          container = container.tBodies[0];
        }
        dom_adapter_default.insertElement(container, item.nodeType ? item : item[0], nextSibling);
      }
    };
    setCss = function(name2, value2) {
      if (!this[0] || !this[0].style) {
        return;
      }
      if (null === value2 || "number" === typeof value2 && isNaN(value2)) {
        return;
      }
      name2 = styleProp(name2);
      for (var i = 0; i < this.length; i++) {
        this[i].style[name2] = normalizeStyleProp(name2, value2);
      }
    };
    initRender.prototype.css = function(name2, value2) {
      if (isString2(name2)) {
        if (2 === arguments.length) {
          setCss.call(this, name2, value2);
        } else {
          if (!this[0]) {
            return;
          }
          name2 = styleProp(name2);
          var result2 = window4.getComputedStyle(this[0])[name2] || this[0].style[name2];
          return isNumeric(result2) ? result2.toString() : result2;
        }
      } else if (isPlainObject(name2)) {
        for (var key in name2) {
          setCss.call(this, key, name2[key]);
        }
      }
      return this;
    };
    initRender.prototype.prepend = function(element) {
      if (arguments.length > 1) {
        for (var i = 0; i < arguments.length; i++) {
          this.prepend(arguments[i]);
        }
        return this;
      }
      appendElements.apply(this, [element, this[0].firstChild]);
      return this;
    };
    initRender.prototype.append = function(element) {
      if (arguments.length > 1) {
        for (var i = 0; i < arguments.length; i++) {
          this.append(arguments[i]);
        }
        return this;
      }
      appendElements.apply(this, [element]);
      return this;
    };
    initRender.prototype.prependTo = function(element) {
      if (this.length > 1) {
        for (var i = this.length - 1; i >= 0; i--) {
          renderer(this[i]).prependTo(element);
        }
        return this;
      }
      element = renderer(element);
      if (element[0]) {
        dom_adapter_default.insertElement(element[0], this[0], element[0].firstChild);
      }
      return this;
    };
    initRender.prototype.appendTo = function(element) {
      if (this.length > 1) {
        return repeatMethod.call(this, "appendTo", arguments);
      }
      dom_adapter_default.insertElement(renderer(element)[0], this[0]);
      return this;
    };
    initRender.prototype.insertBefore = function(element) {
      if (element && element[0]) {
        dom_adapter_default.insertElement(element[0].parentNode, this[0], element[0]);
      }
      return this;
    };
    initRender.prototype.insertAfter = function(element) {
      if (element && element[0]) {
        dom_adapter_default.insertElement(element[0].parentNode, this[0], element[0].nextSibling);
      }
      return this;
    };
    initRender.prototype.before = function(element) {
      if (this[0]) {
        dom_adapter_default.insertElement(this[0].parentNode, element[0], this[0]);
      }
      return this;
    };
    initRender.prototype.after = function(element) {
      if (this[0]) {
        dom_adapter_default.insertElement(this[0].parentNode, element[0], this[0].nextSibling);
      }
      return this;
    };
    initRender.prototype.wrap = function(wrapper) {
      if (this[0]) {
        var wrap = renderer(wrapper);
        wrap.insertBefore(this);
        wrap.append(this);
      }
      return this;
    };
    initRender.prototype.wrapInner = function(wrapper) {
      var contents = this.contents();
      if (contents.length) {
        contents.wrap(wrapper);
      } else {
        this.append(wrapper);
      }
      return this;
    };
    initRender.prototype.replaceWith = function(element) {
      if (!(element && element[0])) {
        return;
      }
      if (element.is(this)) {
        return this;
      }
      element.insertBefore(this);
      this.remove();
      return element;
    };
    initRender.prototype.remove = function() {
      if (this.length > 1) {
        return repeatMethod.call(this, "remove", arguments);
      }
      cleanDataRecursive(this[0], true);
      dom_adapter_default.removeElement(this[0]);
      return this;
    };
    initRender.prototype.detach = function() {
      if (this.length > 1) {
        return repeatMethod.call(this, "detach", arguments);
      }
      dom_adapter_default.removeElement(this[0]);
      return this;
    };
    initRender.prototype.empty = function() {
      if (this.length > 1) {
        return repeatMethod.call(this, "empty", arguments);
      }
      cleanDataRecursive(this[0]);
      dom_adapter_default.setText(this[0], "");
      return this;
    };
    initRender.prototype.clone = function() {
      var result2 = [];
      for (var i = 0; i < this.length; i++) {
        result2.push(this[i].cloneNode(true));
      }
      return renderer(result2);
    };
    initRender.prototype.text = function(value2) {
      if (!arguments.length) {
        var result2 = "";
        for (var i = 0; i < this.length; i++) {
          result2 += this[i] && this[i].textContent || "";
        }
        return result2;
      }
      var text = isFunction(value2) ? value2() : value2;
      cleanDataRecursive(this[0], false);
      dom_adapter_default.setText(this[0], isDefined(text) ? text : "");
      return this;
    };
    initRender.prototype.val = function(value2) {
      if (1 === arguments.length) {
        return this.prop("value", isDefined(value2) ? value2 : "");
      }
      return this.prop("value");
    };
    initRender.prototype.contents = function() {
      if (!this[0]) {
        return renderer();
      }
      var result2 = [];
      result2.push.apply(result2, this[0].childNodes);
      return renderer(result2);
    };
    initRender.prototype.find = function(selector) {
      var result2 = renderer();
      if (!selector) {
        return result2;
      }
      var nodes = [];
      var i;
      if ("string" === typeof selector) {
        selector = selector.trim();
        for (i = 0; i < this.length; i++) {
          var element = this[i];
          if (dom_adapter_default.isElementNode(element)) {
            var elementId = element.getAttribute("id");
            var queryId = elementId || "dx-query-children";
            if (!elementId) {
              setAttributeValue(element, "id", queryId);
            }
            queryId = "[id='" + queryId + "'] ";
            var querySelector = queryId + selector.replace(/([^\\])(,)/g, "$1, " + queryId);
            nodes.push.apply(nodes, dom_adapter_default.querySelectorAll(element, querySelector));
            setAttributeValue(element, "id", elementId);
          } else if (dom_adapter_default.isDocument(element)) {
            nodes.push.apply(nodes, dom_adapter_default.querySelectorAll(element, selector));
          }
        }
      } else {
        for (i = 0; i < this.length; i++) {
          selector = dom_adapter_default.isNode(selector) ? selector : selector[0];
          if (this[i] !== selector && this[i].contains(selector)) {
            nodes.push(selector);
          }
        }
      }
      return result2.add(nodes);
    };
    isVisible = function(_2, element) {
      if (!element.nodeType) {
        return true;
      }
      return !!(element.offsetWidth || element.offsetHeight || element.getClientRects().length);
    };
    initRender.prototype.filter = function(selector) {
      if (!selector) {
        return renderer();
      }
      if (":visible" === selector) {
        return this.filter(isVisible);
      } else if (":hidden" === selector) {
        return this.filter(function(_2, element) {
          return !isVisible(_2, element);
        });
      }
      var result2 = [];
      for (var i = 0; i < this.length; i++) {
        var item = this[i];
        if (dom_adapter_default.isElementNode(item) && "string" === type(selector)) {
          dom_adapter_default.elementMatches(item, selector) && result2.push(item);
        } else if (dom_adapter_default.isNode(selector) || isWindow(selector)) {
          selector === item && result2.push(item);
        } else if (isFunction(selector)) {
          selector.call(item, i, item) && result2.push(item);
        } else {
          for (var j = 0; j < selector.length; j++) {
            selector[j] === item && result2.push(item);
          }
        }
      }
      return renderer(result2);
    };
    initRender.prototype.not = function(selector) {
      var result2 = [];
      var nodes = this.filter(selector).toArray();
      for (var i = 0; i < this.length; i++) {
        if (-1 === nodes.indexOf(this[i])) {
          result2.push(this[i]);
        }
      }
      return renderer(result2);
    };
    initRender.prototype.is = function(selector) {
      return !!this.filter(selector).length;
    };
    initRender.prototype.children = function(selector) {
      var result2 = [];
      for (var i = 0; i < this.length; i++) {
        var nodes = this[i] ? this[i].childNodes : [];
        for (var j = 0; j < nodes.length; j++) {
          if (dom_adapter_default.isElementNode(nodes[j])) {
            result2.push(nodes[j]);
          }
        }
      }
      result2 = renderer(result2);
      return selector ? result2.filter(selector) : result2;
    };
    initRender.prototype.siblings = function() {
      var element = this[0];
      if (!element || !element.parentNode) {
        return renderer();
      }
      var result2 = [];
      var parentChildNodes = element.parentNode.childNodes || [];
      for (var i = 0; i < parentChildNodes.length; i++) {
        var node = parentChildNodes[i];
        if (dom_adapter_default.isElementNode(node) && node !== element) {
          result2.push(node);
        }
      }
      return renderer(result2);
    };
    initRender.prototype.each = function(callback) {
      for (var i = 0; i < this.length; i++) {
        if (false === callback.call(this[i], i, this[i])) {
          break;
        }
      }
    };
    initRender.prototype.index = function(element) {
      if (!element) {
        return this.parent().children().index(this);
      }
      element = renderer(element);
      return this.toArray().indexOf(element[0]);
    };
    initRender.prototype.get = function(index2) {
      return this[index2 < 0 ? this.length + index2 : index2];
    };
    initRender.prototype.eq = function(index2) {
      index2 = index2 < 0 ? this.length + index2 : index2;
      return renderer(this[index2]);
    };
    initRender.prototype.first = function() {
      return this.eq(0);
    };
    initRender.prototype.last = function() {
      return this.eq(-1);
    };
    initRender.prototype.parent = function(selector) {
      if (!this[0]) {
        return renderer();
      }
      var result2 = renderer(this[0].parentNode);
      return !selector || result2.is(selector) ? result2 : renderer();
    };
    initRender.prototype.parents = function(selector) {
      var result2 = [];
      var parent = this.parent();
      while (parent && parent[0] && !dom_adapter_default.isDocument(parent[0])) {
        if (dom_adapter_default.isElementNode(parent[0])) {
          if (!selector || parent.is(selector)) {
            result2.push(parent.get(0));
          }
        }
        parent = parent.parent();
      }
      return renderer(result2);
    };
    initRender.prototype.closest = function(selector) {
      if (this.is(selector)) {
        return this;
      }
      var parent = this.parent();
      while (parent && parent.length) {
        if (parent.is(selector)) {
          return parent;
        }
        parent = parent.parent();
      }
      return renderer();
    };
    initRender.prototype.next = function(selector) {
      if (!this[0]) {
        return renderer();
      }
      var next = renderer(this[0].nextSibling);
      if (!arguments.length) {
        return next;
      }
      while (next && next.length) {
        if (next.is(selector)) {
          return next;
        }
        next = next.next();
      }
      return renderer();
    };
    initRender.prototype.prev = function() {
      if (!this[0]) {
        return renderer();
      }
      return renderer(this[0].previousSibling);
    };
    initRender.prototype.add = function(selector) {
      var targets = renderer(selector);
      var result2 = this.toArray();
      for (var i = 0; i < targets.length; i++) {
        var target = targets[i];
        if (-1 === result2.indexOf(target)) {
          result2.push(target);
        }
      }
      return renderer(result2);
    };
    emptyArray = [];
    initRender.prototype.splice = function() {
      return renderer(emptyArray.splice.apply(this, arguments));
    };
    initRender.prototype.slice = function() {
      return renderer(emptyArray.slice.apply(this, arguments));
    };
    initRender.prototype.toArray = function() {
      return emptyArray.slice.call(this);
    };
    getWindowByElement = function(element) {
      return isWindow(element) ? element : element.defaultView;
    };
    initRender.prototype.offset = function() {
      if (!this[0]) {
        return;
      }
      if (!this[0].getClientRects().length) {
        return {
          top: 0,
          left: 0
        };
      }
      var rect = this[0].getBoundingClientRect();
      var win = getWindowByElement(this[0].ownerDocument);
      var docElem = this[0].ownerDocument.documentElement;
      return {
        top: rect.top + win.pageYOffset - docElem.clientTop,
        left: rect.left + win.pageXOffset - docElem.clientLeft
      };
    };
    initRender.prototype.offsetParent = function() {
      if (!this[0]) {
        return renderer();
      }
      var offsetParent = renderer(this[0].offsetParent);
      while (offsetParent[0] && "static" === offsetParent.css("position")) {
        offsetParent = renderer(offsetParent[0].offsetParent);
      }
      offsetParent = offsetParent[0] ? offsetParent : renderer(dom_adapter_default.getDocumentElement());
      return offsetParent;
    };
    initRender.prototype.position = function() {
      if (!this[0]) {
        return;
      }
      var offset2;
      var marginTop = parseFloat(this.css("marginTop"));
      var marginLeft = parseFloat(this.css("marginLeft"));
      if ("fixed" === this.css("position")) {
        offset2 = this[0].getBoundingClientRect();
        return {
          top: offset2.top - marginTop,
          left: offset2.left - marginLeft
        };
      }
      offset2 = this.offset();
      var offsetParent = this.offsetParent();
      var parentOffset = {
        top: 0,
        left: 0
      };
      if ("HTML" !== offsetParent[0].nodeName) {
        parentOffset = offsetParent.offset();
      }
      parentOffset = {
        top: parentOffset.top + parseFloat(offsetParent.css("borderTopWidth")),
        left: parentOffset.left + parseFloat(offsetParent.css("borderLeftWidth"))
      };
      return {
        top: offset2.top - parentOffset.top - marginTop,
        left: offset2.left - parentOffset.left - marginLeft
      };
    };
    [{
      name: "scrollLeft",
      offsetProp: "pageXOffset",
      scrollWindow: function(win, value2) {
        win.scrollTo(value2, win.pageYOffset);
      }
    }, {
      name: "scrollTop",
      offsetProp: "pageYOffset",
      scrollWindow: function(win, value2) {
        win.scrollTo(win.pageXOffset, value2);
      }
    }].forEach(function(directionStrategy) {
      var propName = directionStrategy.name;
      initRender.prototype[propName] = function(value2) {
        if (!this[0]) {
          return;
        }
        var window29 = getWindowByElement(this[0]);
        if (void 0 === value2) {
          return window29 ? window29[directionStrategy.offsetProp] : this[0][propName];
        }
        if (window29) {
          directionStrategy.scrollWindow(window29, value2);
        } else {
          this[0][propName] = value2;
        }
        return this;
      };
    });
    initRender.prototype.data = function(key, value2) {
      if (!this[0]) {
        return;
      }
      if (arguments.length < 2) {
        return data.call(renderer, this[0], key);
      }
      data.call(renderer, this[0], key, value2);
      return this;
    };
    initRender.prototype.removeData = function(key) {
      this[0] && removeData(this[0], key);
      return this;
    };
    rendererWrapper = function() {
      return renderer.apply(this, arguments);
    };
    Object.defineProperty(rendererWrapper, "fn", {
      enumerable: true,
      configurable: true,
      get: function() {
        return renderer.fn;
      },
      set: function(value2) {
        renderer.fn = value2;
      }
    });
    renderer_base_default = {
      set: function(strategy3) {
        renderer = strategy3;
      },
      get: function() {
        return rendererWrapper;
      }
    };
  }
});

// node_modules/devextreme/esm/core/renderer.js
var renderer_default;
var init_renderer = __esm({
  "node_modules/devextreme/esm/core/renderer.js"() {
    init_renderer_base();
    renderer_default = renderer_base_default.get();
  }
});

// node_modules/devextreme/esm/core/component_registrator_callbacks.js
var component_registrator_callbacks_default;
var init_component_registrator_callbacks = __esm({
  "node_modules/devextreme/esm/core/component_registrator_callbacks.js"() {
    init_memorized_callbacks();
    component_registrator_callbacks_default = new MemorizedCallbacks();
  }
});

// node_modules/devextreme/esm/events/core/event_registrator.js
var registerEvent, event_registrator_default;
var init_event_registrator = __esm({
  "node_modules/devextreme/esm/events/core/event_registrator.js"() {
    init_iterator();
    init_event_registrator_callbacks();
    registerEvent = function(name2, eventObject) {
      var strategy3 = {};
      if ("noBubble" in eventObject) {
        strategy3.noBubble = eventObject.noBubble;
      }
      if ("bindType" in eventObject) {
        strategy3.bindType = eventObject.bindType;
      }
      if ("delegateType" in eventObject) {
        strategy3.delegateType = eventObject.delegateType;
      }
      each(["setup", "teardown", "add", "remove", "trigger", "handle", "_default", "dispose"], function(_2, methodName) {
        if (!eventObject[methodName]) {
          return;
        }
        strategy3[methodName] = function() {
          var args = [].slice.call(arguments);
          args.unshift(this);
          return eventObject[methodName].apply(eventObject, args);
        };
      });
      event_registrator_callbacks_default.fire(name2, strategy3);
    };
    registerEvent.callbacks = event_registrator_callbacks_default;
    event_registrator_default = registerEvent;
  }
});

// node_modules/devextreme/esm/events/remove.js
var removeEvent, eventPropName;
var init_remove = __esm({
  "node_modules/devextreme/esm/events/remove.js"() {
    init_renderer();
    init_element_data();
    init_events_engine();
    init_event_registrator();
    removeEvent = "dxremove";
    eventPropName = "dxRemoveEvent";
    beforeCleanData(function(elements) {
      elements = [].slice.call(elements);
      for (var i = 0; i < elements.length; i++) {
        var $element = renderer_default(elements[i]);
        if ($element.prop(eventPropName)) {
          $element[0][eventPropName] = null;
          events_engine_default.triggerHandler($element, removeEvent);
        }
      }
    });
    event_registrator_default(removeEvent, {
      noBubble: true,
      setup: function(element) {
        renderer_default(element).prop(eventPropName, true);
      }
    });
  }
});

// node_modules/devextreme/esm/core/utils/public_component.js
function attachInstanceToElement($element, componentInstance, disposeFn) {
  var data2 = data($element.get(0));
  var name2 = getName(componentInstance.constructor);
  data2[name2] = componentInstance;
  if (disposeFn) {
    events_engine_default.one($element, removeEvent, function() {
      disposeFn.call(componentInstance);
    });
  }
  if (!data2[COMPONENT_NAMES_DATA_KEY]) {
    data2[COMPONENT_NAMES_DATA_KEY] = [];
  }
  data2[COMPONENT_NAMES_DATA_KEY].push(name2);
}
function getInstanceByElement($element, componentClass) {
  var name2 = getName(componentClass);
  return data($element.get(0), name2);
}
var COMPONENT_NAMES_DATA_KEY, ANONYMOUS_COMPONENT_DATA_KEY, componentNames, nextAnonymousComponent, getName;
var init_public_component = __esm({
  "node_modules/devextreme/esm/core/utils/public_component.js"() {
    init_element_data();
    init_events_engine();
    init_weak_map();
    init_type();
    init_remove();
    COMPONENT_NAMES_DATA_KEY = "dxComponents";
    ANONYMOUS_COMPONENT_DATA_KEY = "dxPrivateComponent";
    componentNames = new weak_map_default();
    nextAnonymousComponent = 0;
    getName = function(componentClass, newName) {
      if (isDefined(newName)) {
        componentNames.set(componentClass, newName);
        return;
      }
      if (!componentNames.has(componentClass)) {
        var generatedName = ANONYMOUS_COMPONENT_DATA_KEY + nextAnonymousComponent++;
        componentNames.set(componentClass, generatedName);
        return generatedName;
      }
      return componentNames.get(componentClass);
    };
  }
});

// node_modules/devextreme/esm/core/component_registrator.js
var registerComponent, registerRendererComponent, component_registrator_default;
var init_component_registrator = __esm({
  "node_modules/devextreme/esm/core/component_registrator.js"() {
    init_renderer();
    init_component_registrator_callbacks();
    init_errors();
    init_public_component();
    registerComponent = function(name2, namespace, componentClass) {
      if (!componentClass) {
        componentClass = namespace;
      } else {
        namespace[name2] = componentClass;
      }
      getName(componentClass, name2);
      component_registrator_callbacks_default.fire(name2, componentClass);
    };
    registerRendererComponent = function(name2, componentClass) {
      renderer_default.fn[name2] = function(options2) {
        var isMemberInvoke = "string" === typeof options2;
        var result2;
        if (isMemberInvoke) {
          var memberName = options2;
          var memberArgs = [].slice.call(arguments).slice(1);
          this.each(function() {
            var instance = componentClass.getInstance(this);
            if (!instance) {
              throw errors_default.Error("E0009", name2);
            }
            var member = instance[memberName];
            var memberValue = member.apply(instance, memberArgs);
            if (void 0 === result2) {
              result2 = memberValue;
            }
          });
        } else {
          this.each(function() {
            var instance = componentClass.getInstance(this);
            if (instance) {
              instance.option(options2);
            } else {
              new componentClass(this, options2);
            }
          });
          result2 = this;
        }
        return result2;
      };
    };
    component_registrator_callbacks_default.add(registerRendererComponent);
    component_registrator_default = registerComponent;
  }
});

// node_modules/devextreme/esm/core/utils/ready_callbacks.js
var callbacks, isReady, subscribeReady, readyCallbacks, ready_callbacks_default;
var init_ready_callbacks = __esm({
  "node_modules/devextreme/esm/core/utils/ready_callbacks.js"() {
    init_dom_adapter();
    init_dependency_injector();
    init_window();
    init_call_once();
    callbacks = [];
    isReady = () => "complete" === dom_adapter_default.getReadyState() || "loading" !== dom_adapter_default.getReadyState() && !dom_adapter_default.getDocumentElement().doScroll;
    subscribeReady = call_once_default(() => {
      var removeListener = dom_adapter_default.listen(dom_adapter_default.getDocument(), "DOMContentLoaded", () => {
        readyCallbacks.fire();
        removeListener();
      });
    });
    readyCallbacks = {
      add: (callback) => {
        var windowExists = hasWindow();
        if (windowExists && isReady()) {
          callback();
        } else {
          callbacks.push(callback);
          windowExists && subscribeReady();
        }
      },
      fire: () => {
        callbacks.forEach((callback) => callback());
        callbacks = [];
      }
    };
    ready_callbacks_default = dependency_injector_default(readyCallbacks);
  }
});

// node_modules/devextreme/esm/core/utils/resize_callbacks.js
var resizeCallbacks, resize_callbacks_default;
var init_resize_callbacks = __esm({
  "node_modules/devextreme/esm/core/utils/resize_callbacks.js"() {
    init_window();
    init_dom_adapter();
    init_callbacks();
    init_ready_callbacks();
    init_call_once();
    resizeCallbacks = function() {
      var prevSize;
      var callbacks2 = callbacks_default();
      var originalCallbacksAdd = callbacks2.add;
      var originalCallbacksRemove = callbacks2.remove;
      if (!hasWindow()) {
        return callbacks2;
      }
      var formatSize = function() {
        var window29 = getWindow();
        return {
          width: window29.innerWidth,
          height: window29.innerHeight
        };
      };
      var handleResize = function() {
        var now = formatSize();
        if (now.width === prevSize.width && now.height === prevSize.height) {
          return;
        }
        var changedDimension;
        if (now.width === prevSize.width) {
          changedDimension = "height";
        }
        if (now.height === prevSize.height) {
          changedDimension = "width";
        }
        prevSize = now;
        callbacks2.fire(changedDimension);
      };
      var setPrevSize = call_once_default(function() {
        prevSize = formatSize();
      });
      var removeListener;
      callbacks2.add = function() {
        var result2 = originalCallbacksAdd.apply(callbacks2, arguments);
        setPrevSize();
        ready_callbacks_default.add(function() {
          if (!removeListener && callbacks2.has()) {
            removeListener = dom_adapter_default.listen(getWindow(), "resize", handleResize);
          }
        });
        return result2;
      };
      callbacks2.remove = function() {
        var result2 = originalCallbacksRemove.apply(callbacks2, arguments);
        if (!callbacks2.has() && removeListener) {
          removeListener();
          removeListener = void 0;
        }
        return result2;
      };
      return callbacks2;
    }();
    resize_callbacks_default = resizeCallbacks;
  }
});

// node_modules/devextreme/esm/core/events_strategy.js
var EventsStrategy;
var init_events_strategy = __esm({
  "node_modules/devextreme/esm/core/events_strategy.js"() {
    init_callbacks();
    init_iterator();
    init_type();
    EventsStrategy = class _EventsStrategy {
      constructor(owner) {
        var options2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        this._events = {};
        this._owner = owner;
        this._options = options2;
      }
      static create(owner, strategy3) {
        if (strategy3) {
          return isFunction(strategy3) ? strategy3(owner) : strategy3;
        } else {
          return new _EventsStrategy(owner);
        }
      }
      hasEvent(eventName) {
        var callbacks2 = this._events[eventName];
        return callbacks2 ? callbacks2.has() : false;
      }
      fireEvent(eventName, eventArgs) {
        var callbacks2 = this._events[eventName];
        if (callbacks2) {
          callbacks2.fireWith(this._owner, eventArgs);
        }
        return this._owner;
      }
      on(eventName, eventHandler) {
        if (isPlainObject(eventName)) {
          each(eventName, (e, h) => {
            this.on(e, h);
          });
        } else {
          var callbacks2 = this._events[eventName];
          if (!callbacks2) {
            callbacks2 = callbacks_default({
              syncStrategy: this._options.syncStrategy
            });
            this._events[eventName] = callbacks2;
          }
          var addFn = callbacks2.originalAdd || callbacks2.add;
          addFn.call(callbacks2, eventHandler);
        }
      }
      off(eventName, eventHandler) {
        var callbacks2 = this._events[eventName];
        if (callbacks2) {
          if (isFunction(eventHandler)) {
            callbacks2.remove(eventHandler);
          } else {
            callbacks2.empty();
          }
        }
      }
      dispose() {
        each(this._events, (eventName, event) => {
          event.empty();
        });
      }
    };
  }
});

// node_modules/devextreme/esm/core/utils/storage.js
var window5, getSessionStorage;
var init_storage = __esm({
  "node_modules/devextreme/esm/core/utils/storage.js"() {
    init_window();
    window5 = getWindow();
    getSessionStorage = function() {
      var sessionStorage;
      try {
        sessionStorage = window5.sessionStorage;
      } catch (e) {
      }
      return sessionStorage;
    };
  }
});

// node_modules/devextreme/esm/core/utils/view_port.js
function originalViewPort() {
  return $originalViewPort;
}
var ready, changeCallback, $originalViewPort, value;
var init_view_port = __esm({
  "node_modules/devextreme/esm/core/utils/view_port.js"() {
    init_renderer();
    init_ready_callbacks();
    init_callbacks();
    ready = ready_callbacks_default.add;
    changeCallback = callbacks_default();
    $originalViewPort = renderer_default();
    value = /* @__PURE__ */ function() {
      var $current;
      return function(element) {
        if (!arguments.length) {
          return $current;
        }
        var $element = renderer_default(element);
        $originalViewPort = $element;
        var isNewViewportFound = !!$element.length;
        var prevViewPort = value();
        $current = isNewViewportFound ? $element : renderer_default("body");
        changeCallback.fire(isNewViewportFound ? value() : renderer_default(), prevViewPort);
      };
    }();
    ready(function() {
      value(".dx-viewport");
    });
  }
});

// node_modules/devextreme/esm/core/devices.js
var navigator2, window6, KNOWN_UA_TABLE, DEFAULT_DEVICE, uaParsers, Devices, devices, viewPortElement, devices_default;
var init_devices = __esm({
  "node_modules/devextreme/esm/core/devices.js"() {
    init_renderer();
    init_window();
    init_extend();
    init_type();
    init_iterator();
    init_errors();
    init_callbacks();
    init_ready_callbacks();
    init_resize_callbacks();
    init_events_strategy();
    init_storage();
    init_view_port();
    init_config();
    navigator2 = getNavigator();
    window6 = getWindow();
    KNOWN_UA_TABLE = {
      iPhone: "iPhone",
      iPhone5: "iPhone",
      iPhone6: "iPhone",
      iPhone6plus: "iPhone",
      iPad: "iPad",
      iPadMini: "iPad Mini",
      androidPhone: "Android Mobile",
      androidTablet: "Android",
      msSurface: "Windows ARM Tablet PC",
      desktop: "desktop"
    };
    DEFAULT_DEVICE = {
      deviceType: "desktop",
      platform: "generic",
      version: [],
      phone: false,
      tablet: false,
      android: false,
      ios: false,
      generic: true,
      grade: "A",
      mac: false
    };
    uaParsers = {
      generic(userAgent) {
        var isPhone = /windows phone/i.test(userAgent) || userAgent.match(/WPDesktop/);
        var isTablet = !isPhone && /Windows(.*)arm(.*)Tablet PC/i.test(userAgent);
        var isDesktop = !isPhone && !isTablet && /msapphost/i.test(userAgent);
        var isMac = /((intel|ppc) mac os x)/.test(userAgent.toLowerCase());
        if (!(isPhone || isTablet || isDesktop || isMac)) {
          return;
        }
        return {
          deviceType: isPhone ? "phone" : isTablet ? "tablet" : "desktop",
          platform: "generic",
          version: [],
          grade: "A",
          mac: isMac
        };
      },
      ios(userAgent) {
        if (!/ip(hone|od|ad)/i.test(userAgent)) {
          return;
        }
        var isPhone = /ip(hone|od)/i.test(userAgent);
        var matches = userAgent.match(/os (\d+)_(\d+)_?(\d+)?/i);
        var version2 = matches ? [parseInt(matches[1], 10), parseInt(matches[2], 10), parseInt(matches[3] || 0, 10)] : [];
        var isIPhone4 = 480 === window6.screen.height;
        var grade = isIPhone4 ? "B" : "A";
        return {
          deviceType: isPhone ? "phone" : "tablet",
          platform: "ios",
          version: version2,
          grade
        };
      },
      android(userAgent) {
        if (!/android|htc_|silk/i.test(userAgent)) {
          return;
        }
        var isPhone = /mobile/i.test(userAgent);
        var matches = userAgent.match(/android (\d+)\.?(\d+)?\.?(\d+)?/i);
        var version2 = matches ? [parseInt(matches[1], 10), parseInt(matches[2] || 0, 10), parseInt(matches[3] || 0, 10)] : [];
        var worseThan4_4 = version2.length > 1 && (version2[0] < 4 || 4 === version2[0] && version2[1] < 4);
        var grade = worseThan4_4 ? "B" : "A";
        return {
          deviceType: isPhone ? "phone" : "tablet",
          platform: "android",
          version: version2,
          grade
        };
      }
    };
    Devices = class {
      constructor(options2) {
        this._window = (null === options2 || void 0 === options2 ? void 0 : options2.window) || window6;
        this._realDevice = this._getDevice();
        this._currentDevice = void 0;
        this._currentOrientation = void 0;
        this._eventsStrategy = new EventsStrategy(this);
        this.changed = callbacks_default();
        if (hasWindow()) {
          ready_callbacks_default.add(this._recalculateOrientation.bind(this));
          resize_callbacks_default.add(this._recalculateOrientation.bind(this));
        }
      }
      current(deviceOrName) {
        if (deviceOrName) {
          this._currentDevice = this._getDevice(deviceOrName);
          this._forced = true;
          this.changed.fire();
          return;
        }
        if (!this._currentDevice) {
          deviceOrName = void 0;
          try {
            deviceOrName = this._getDeviceOrNameFromWindowScope();
          } catch (e) {
            deviceOrName = this._getDeviceNameFromSessionStorage();
          } finally {
            if (!deviceOrName) {
              deviceOrName = this._getDeviceNameFromSessionStorage();
            }
            if (deviceOrName) {
              this._forced = true;
            }
          }
          this._currentDevice = this._getDevice(deviceOrName);
        }
        return this._currentDevice;
      }
      real(forceDevice) {
        return extend2({}, this._realDevice);
      }
      orientation() {
        return this._currentOrientation;
      }
      isForced() {
        return this._forced;
      }
      isRippleEmulator() {
        return !!this._window.tinyHippos;
      }
      _getCssClasses(device) {
        var result2 = [];
        var realDevice4 = this._realDevice;
        device = device || this.current();
        if (device.deviceType) {
          result2.push("dx-device-".concat(device.deviceType));
          if ("desktop" !== device.deviceType) {
            result2.push("dx-device-mobile");
          }
        }
        result2.push("dx-device-".concat(realDevice4.platform));
        if (realDevice4.version && realDevice4.version.length) {
          result2.push("dx-device-".concat(realDevice4.platform, "-").concat(realDevice4.version[0]));
        }
        if (this.isSimulator()) {
          result2.push("dx-simulator");
        }
        if (config_default().rtlEnabled) {
          result2.push("dx-rtl");
        }
        return result2;
      }
      attachCssClasses(element, device) {
        this._deviceClasses = this._getCssClasses(device).join(" ");
        renderer_default(element).addClass(this._deviceClasses);
      }
      detachCssClasses(element) {
        renderer_default(element).removeClass(this._deviceClasses);
      }
      isSimulator() {
        try {
          return this._isSimulator || hasWindow() && this._window.top !== this._window.self && this._window.top["dx-force-device"] || this.isRippleEmulator();
        } catch (e) {
          return false;
        }
      }
      forceSimulator() {
        this._isSimulator = true;
      }
      _getDevice(deviceName) {
        if ("genericPhone" === deviceName) {
          deviceName = {
            deviceType: "phone",
            platform: "generic",
            generic: true
          };
        }
        if (isPlainObject(deviceName)) {
          return this._fromConfig(deviceName);
        } else {
          var ua2;
          if (deviceName) {
            ua2 = KNOWN_UA_TABLE[deviceName];
            if (!ua2) {
              throw errors_default.Error("E0005");
            }
          } else {
            ua2 = navigator2.userAgent;
          }
          return this._fromUA(ua2);
        }
      }
      _getDeviceOrNameFromWindowScope() {
        var result2;
        if (hasWindow() && (this._window.top["dx-force-device-object"] || this._window.top["dx-force-device"])) {
          result2 = this._window.top["dx-force-device-object"] || this._window.top["dx-force-device"];
        }
        return result2;
      }
      _getDeviceNameFromSessionStorage() {
        var sessionStorage = getSessionStorage();
        if (!sessionStorage) {
          return;
        }
        var deviceOrName = sessionStorage.getItem("dx-force-device");
        try {
          return JSON.parse(deviceOrName);
        } catch (ex) {
          return deviceOrName;
        }
      }
      _fromConfig(config2) {
        var result2 = extend2({}, DEFAULT_DEVICE, this._currentDevice, config2);
        var shortcuts = {
          phone: "phone" === result2.deviceType,
          tablet: "tablet" === result2.deviceType,
          android: "android" === result2.platform,
          ios: "ios" === result2.platform,
          generic: "generic" === result2.platform
        };
        return extend2(result2, shortcuts);
      }
      _fromUA(ua2) {
        var config2;
        each(uaParsers, (platform, parser) => {
          config2 = parser(ua2);
          return !config2;
        });
        if (config2) {
          return this._fromConfig(config2);
        }
        return DEFAULT_DEVICE;
      }
      _changeOrientation() {
        var $window = renderer_default(this._window);
        var orientation = $window.height() > $window.width() ? "portrait" : "landscape";
        if (this._currentOrientation === orientation) {
          return;
        }
        this._currentOrientation = orientation;
        this._eventsStrategy.fireEvent("orientationChanged", [{
          orientation
        }]);
      }
      _recalculateOrientation() {
        var windowWidth = renderer_default(this._window).width();
        if (this._currentWidth === windowWidth) {
          return;
        }
        this._currentWidth = windowWidth;
        this._changeOrientation();
      }
      on(eventName, eventHandler) {
        this._eventsStrategy.on(eventName, eventHandler);
        return this;
      }
      off(eventName, eventHandler) {
        this._eventsStrategy.off(eventName, eventHandler);
        return this;
      }
    };
    devices = new Devices();
    viewPortElement = value();
    if (viewPortElement) {
      devices.attachCssClasses(viewPortElement);
    }
    changeCallback.add((viewPort2, prevViewport) => {
      devices.detachCssClasses(prevViewport);
      devices.attachCssClasses(viewPort2);
    });
    devices_default = devices;
  }
});

// node_modules/devextreme/esm/core/action.js
var Action, createValidatorByTargetElement;
var init_action = __esm({
  "node_modules/devextreme/esm/core/action.js"() {
    init_renderer();
    init_window();
    init_type();
    init_iterator();
    Action = class _Action {
      constructor(action, config2) {
        config2 = config2 || {};
        this._action = action;
        this._context = config2.context || getWindow();
        this._beforeExecute = config2.beforeExecute;
        this._afterExecute = config2.afterExecute;
        this._component = config2.component;
        this._validatingTargetName = config2.validatingTargetName;
        var excludeValidators = this._excludeValidators = {};
        if (config2.excludeValidators) {
          for (var i = 0; i < config2.excludeValidators.length; i++) {
            excludeValidators[config2.excludeValidators[i]] = true;
          }
        }
      }
      execute() {
        var e = {
          action: this._action,
          args: Array.prototype.slice.call(arguments),
          context: this._context,
          component: this._component,
          validatingTargetName: this._validatingTargetName,
          cancel: false,
          handled: false
        };
        var beforeExecute = this._beforeExecute;
        var afterExecute = this._afterExecute;
        var argsBag = e.args[0] || {};
        if (!this._validateAction(e)) {
          return;
        }
        null === beforeExecute || void 0 === beforeExecute ? void 0 : beforeExecute.call(this._context, e);
        if (e.cancel) {
          return;
        }
        var result2 = this._executeAction(e);
        if (argsBag.cancel) {
          return;
        }
        null === afterExecute || void 0 === afterExecute ? void 0 : afterExecute.call(this._context, e);
        return result2;
      }
      _validateAction(e) {
        var excludeValidators = this._excludeValidators;
        var {
          executors
        } = _Action;
        for (var name2 in executors) {
          if (!excludeValidators[name2]) {
            var _executor$validate;
            var executor = executors[name2];
            null === (_executor$validate = executor.validate) || void 0 === _executor$validate ? void 0 : _executor$validate.call(executor, e);
            if (e.cancel) {
              return false;
            }
          }
        }
        return true;
      }
      _executeAction(e) {
        var result2;
        var {
          executors
        } = _Action;
        for (var name2 in executors) {
          var _executor$execute;
          var executor = executors[name2];
          null === (_executor$execute = executor.execute) || void 0 === _executor$execute ? void 0 : _executor$execute.call(executor, e);
          if (e.handled) {
            result2 = e.result;
            break;
          }
        }
        return result2;
      }
      static registerExecutor(name2, executor) {
        if (isPlainObject(name2)) {
          each(name2, _Action.registerExecutor);
          return;
        }
        _Action.executors[name2] = executor;
      }
      static unregisterExecutor() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        each(args, function() {
          delete _Action.executors[this];
        });
      }
    };
    Action.executors = {};
    createValidatorByTargetElement = (condition) => (e) => {
      if (!e.args.length) {
        return;
      }
      var args = e.args[0];
      var element = args[e.validatingTargetName] || args.element;
      if (element && condition(renderer_default(element))) {
        e.cancel = true;
      }
    };
    Action.registerExecutor({
      disabled: {
        validate: createValidatorByTargetElement(($target) => $target.is(".dx-state-disabled, .dx-state-disabled *"))
      },
      readOnly: {
        validate: createValidatorByTargetElement(($target) => $target.is(".dx-state-readonly, .dx-state-readonly *:not(.dx-state-independent)"))
      },
      undefined: {
        execute: (e) => {
          if (!e.action) {
            e.result = void 0;
            e.handled = true;
          }
        }
      },
      func: {
        execute: (e) => {
          if (isFunction(e.action)) {
            e.result = e.action.call(e.context, e.args[0]);
            e.handled = true;
          }
        }
      }
    });
  }
});

// node_modules/devextreme/esm/core/utils/comparator.js
var hasNegation, equals;
var init_comparator = __esm({
  "node_modules/devextreme/esm/core/utils/comparator.js"() {
    init_dom_adapter();
    init_data();
    init_type();
    hasNegation = function(oldValue, newValue) {
      return 1 / oldValue === 1 / newValue;
    };
    equals = function(oldValue, newValue) {
      oldValue = toComparable(oldValue, true);
      newValue = toComparable(newValue, true);
      if (oldValue && newValue && isRenderer(oldValue) && isRenderer(newValue)) {
        return newValue.is(oldValue);
      }
      var oldValueIsNaN = oldValue !== oldValue;
      var newValueIsNaN = newValue !== newValue;
      if (oldValueIsNaN && newValueIsNaN) {
        return true;
      }
      if (0 === oldValue && 0 === newValue) {
        return hasNegation(oldValue, newValue);
      }
      if (null === oldValue || "object" !== typeof oldValue || dom_adapter_default.isElementNode(oldValue)) {
        return oldValue === newValue;
      }
      return false;
    };
  }
});

// node_modules/devextreme/esm/core/options/utils.js
var cachedGetters, convertRulesToOptions, normalizeOptions, deviceMatch, getFieldName, getParentName, getNestedOptionValue;
var init_utils = __esm({
  "node_modules/devextreme/esm/core/options/utils.js"() {
    init_devices();
    init_type();
    init_common();
    init_extend();
    init_data();
    cachedGetters = {};
    convertRulesToOptions = (rules) => {
      var currentDevice = devices_default.current();
      return rules.reduce((options2, _ref) => {
        var {
          device,
          options: ruleOptions
        } = _ref;
        var deviceFilter = device || {};
        var match2 = isFunction(deviceFilter) ? deviceFilter(currentDevice) : deviceMatch(currentDevice, deviceFilter);
        if (match2) {
          extend2(true, options2, ruleOptions);
        }
        return options2;
      }, {});
    };
    normalizeOptions = (options2, value2) => "string" !== typeof options2 ? options2 : {
      [options2]: value2
    };
    deviceMatch = (device, filter) => isEmptyObject(filter) || findBestMatches(device, [filter]).length > 0;
    getFieldName = (fullName) => fullName.substr(fullName.lastIndexOf(".") + 1);
    getParentName = (fullName) => fullName.substr(0, fullName.lastIndexOf("."));
    getNestedOptionValue = function(optionsObject, name2) {
      cachedGetters[name2] = cachedGetters[name2] || compileGetter(name2);
      return cachedGetters[name2](optionsObject, {
        functionsAsIs: true
      });
    };
  }
});

// node_modules/devextreme/esm/core/options/option_manager.js
var cachedGetters2, cachedSetters, OptionManager;
var init_option_manager = __esm({
  "node_modules/devextreme/esm/core/options/option_manager.js"() {
    init_data();
    init_common();
    init_comparator();
    init_extend();
    init_type();
    init_utils();
    cachedGetters2 = {};
    cachedSetters = {};
    OptionManager = class {
      constructor(options2, optionsByReference) {
        this._options = options2;
        this._optionsByReference = optionsByReference;
        this._changingCallback;
        this._changedCallback;
        this._namePreparedCallbacks;
      }
      _setByReference(options2, rulesOptions) {
        extend2(true, options2, rulesOptions);
        for (var fieldName in this._optionsByReference) {
          if (Object.prototype.hasOwnProperty.call(rulesOptions, fieldName)) {
            options2[fieldName] = rulesOptions[fieldName];
          }
        }
      }
      _setPreparedValue(name2, value2, merge2, silent) {
        var previousValue = this.get(this._options, name2, false);
        if (!equals(previousValue, value2)) {
          var path = name2.split(/[.[]/);
          !silent && this._changingCallback(name2, previousValue, value2);
          cachedSetters[name2] = cachedSetters[name2] || compileSetter(name2);
          cachedSetters[name2](this._options, value2, {
            functionsAsIs: true,
            merge: isDefined(merge2) ? merge2 : !this._optionsByReference[name2],
            unwrapObservables: path.length > 1 && !!this._optionsByReference[path[0]]
          });
          !silent && this._changedCallback(name2, value2, previousValue);
        }
      }
      _prepareRelevantNames(options2, name2, value2, silent) {
        if (isPlainObject(value2)) {
          for (var valueName in value2) {
            this._prepareRelevantNames(options2, "".concat(name2, ".").concat(valueName), value2[valueName]);
          }
        }
        this._namePreparedCallbacks(options2, name2, value2, silent);
      }
      get() {
        var options2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this._options;
        var name2 = arguments.length > 1 ? arguments[1] : void 0;
        var unwrapObservables = arguments.length > 2 ? arguments[2] : void 0;
        cachedGetters2[name2] = cachedGetters2[name2] || compileGetter(name2);
        return cachedGetters2[name2](options2, {
          functionsAsIs: true,
          unwrapObservables
        });
      }
      set(options2, value2, merge2, silent) {
        options2 = normalizeOptions(options2, value2);
        for (var name2 in options2) {
          this._prepareRelevantNames(options2, name2, options2[name2], silent);
        }
        for (var _name in options2) {
          this._setPreparedValue(_name, options2[_name], merge2, silent);
        }
      }
      onRelevantNamesPrepared(callBack) {
        this._namePreparedCallbacks = callBack;
      }
      onChanging(callBack) {
        this._changingCallback = callBack;
      }
      onChanged(callBack) {
        this._changedCallback = callBack;
      }
      dispose() {
        this._changingCallback = noop2;
        this._changedCallback = noop2;
      }
    };
  }
});

// node_modules/devextreme/esm/core/options/index.js
var Options;
var init_options = __esm({
  "node_modules/devextreme/esm/core/options/index.js"() {
    init_extends();
    init_type();
    init_common();
    init_option_manager();
    init_utils();
    init_extend();
    Options = class {
      constructor(options2, defaultOptions, optionsByReference, deprecatedOptions) {
        this._deprecatedCallback;
        this._startChangeCallback;
        this._endChangeCallback;
        this._default = defaultOptions;
        this._deprecated = deprecatedOptions;
        this._deprecatedNames = [];
        this._initDeprecatedNames();
        this._optionManager = new OptionManager(options2, optionsByReference);
        this._optionManager.onRelevantNamesPrepared((options3, name2, value2, silent) => this._setRelevantNames(options3, name2, value2, silent));
        this._cachedOptions = {};
        this._rules = [];
      }
      set _initial(value2) {
        this._initialOptions = value2;
      }
      get _initial() {
        if (!this._initialOptions) {
          var rulesOptions = this._getByRules(this.silent("defaultOptionsRules"));
          this._initialOptions = this._default;
          this._optionManager._setByReference(this._initialOptions, rulesOptions);
        }
        return this._initialOptions;
      }
      _initDeprecatedNames() {
        for (var optionName in this._deprecated) {
          this._deprecatedNames.push(optionName);
        }
      }
      _getByRules(rules) {
        rules = Array.isArray(rules) ? this._rules.concat(rules) : this._rules;
        return convertRulesToOptions(rules);
      }
      _notifyDeprecated(option) {
        var info = this._deprecated[option];
        if (info) {
          this._deprecatedCallback(option, info);
        }
      }
      _setRelevantNames(options2, name2, value2, silent) {
        if (name2) {
          var normalizedName = this._normalizeName(name2, silent);
          if (normalizedName && normalizedName !== name2) {
            this._setField(options2, normalizedName, value2);
            this._clearField(options2, name2);
          }
        }
      }
      _setField(options2, fullName, value2) {
        var fieldName = "";
        var fieldObject = null;
        do {
          fieldName = fieldName ? ".".concat(fieldName) : "";
          fieldName = getFieldName(fullName) + fieldName;
          fullName = getParentName(fullName);
          fieldObject = fullName ? this._optionManager.get(options2, fullName, false) : options2;
        } while (!fieldObject);
        fieldObject[fieldName] = value2;
      }
      _clearField(options2, name2) {
        delete options2[name2];
        var previousFieldName = getParentName(name2);
        var fieldObject = previousFieldName ? this._optionManager.get(options2, previousFieldName, false) : options2;
        if (fieldObject) {
          delete fieldObject[getFieldName(name2)];
        }
      }
      _normalizeName(name2, silent) {
        if (this._deprecatedNames.length && name2) {
          for (var i = 0; i < this._deprecatedNames.length; i++) {
            if (this._deprecatedNames[i] === name2) {
              var deprecate = this._deprecated[name2];
              if (deprecate) {
                !silent && this._notifyDeprecated(name2);
                return deprecate.alias || name2;
              }
            }
          }
        }
        return name2;
      }
      addRules(rules) {
        this._rules = rules.concat(this._rules);
      }
      applyRules(rules) {
        var options2 = this._getByRules(rules);
        this.silent(options2);
      }
      dispose() {
        this._deprecatedCallback = noop2;
        this._startChangeCallback = noop2;
        this._endChangeCallback = noop2;
        this._optionManager.dispose();
      }
      onChanging(callBack) {
        this._optionManager.onChanging(callBack);
      }
      onChanged(callBack) {
        this._optionManager.onChanged(callBack);
      }
      onDeprecated(callBack) {
        this._deprecatedCallback = callBack;
      }
      onStartChange(callBack) {
        this._startChangeCallback = callBack;
      }
      onEndChange(callBack) {
        this._endChangeCallback = callBack;
      }
      isInitial(name2) {
        var value2 = this.silent(name2);
        var initialValue = this.initial(name2);
        var areFunctions = isFunction(value2) && isFunction(initialValue);
        return areFunctions ? value2.toString() === initialValue.toString() : equalByValue(value2, initialValue);
      }
      initial(name2) {
        return getNestedOptionValue(this._initial, name2);
      }
      option(options2, value2) {
        var isGetter = arguments.length < 2 && "object" !== type(options2);
        if (isGetter) {
          return this._optionManager.get(void 0, this._normalizeName(options2));
        } else {
          this._startChangeCallback();
          try {
            this._optionManager.set(options2, value2);
          } finally {
            this._endChangeCallback();
          }
        }
      }
      silent(options2, value2) {
        var isGetter = arguments.length < 2 && "object" !== type(options2);
        if (isGetter) {
          return this._optionManager.get(void 0, options2, void 0, true);
        } else {
          this._optionManager.set(options2, value2, void 0, true);
        }
      }
      reset(name2) {
        if (name2) {
          var fullPath = name2.replace(/\[([^\]])\]/g, ".$1").split(".");
          var value2 = fullPath.reduce((value3, field) => value3 ? value3[field] : this.initial(field), null);
          var defaultValue = isObject2(value2) ? _extends({}, value2) : value2;
          this._optionManager.set(name2, defaultValue, false);
        }
      }
      getAliasesByName(name2) {
        return Object.keys(this._deprecated).filter((aliasName) => name2 === this._deprecated[aliasName].alias);
      }
      isDeprecated(name2) {
        return Object.prototype.hasOwnProperty.call(this._deprecated, name2);
      }
      cache(name2, options2) {
        var isGetter = arguments.length < 2;
        if (isGetter) {
          return this._cachedOptions[name2];
        } else {
          this._cachedOptions[name2] = extend2(this._cachedOptions[name2], options2);
        }
      }
    };
  }
});

// node_modules/devextreme/esm/core/postponed_operations.js
var PostponedOperations;
var init_postponed_operations = __esm({
  "node_modules/devextreme/esm/core/postponed_operations.js"() {
    init_deferred();
    init_type();
    PostponedOperations = class {
      constructor() {
        this._postponedOperations = {};
      }
      add(key, fn, postponedPromise) {
        if (key in this._postponedOperations) {
          postponedPromise && this._postponedOperations[key].promises.push(postponedPromise);
        } else {
          var completePromise = new Deferred();
          this._postponedOperations[key] = {
            fn,
            completePromise,
            promises: postponedPromise ? [postponedPromise] : []
          };
        }
        return this._postponedOperations[key].completePromise.promise();
      }
      callPostponedOperations() {
        for (var key in this._postponedOperations) {
          var operation = this._postponedOperations[key];
          if (isDefined(operation)) {
            if (operation.promises && operation.promises.length) {
              when(...operation.promises).done(operation.fn).then(operation.completePromise.resolve);
            } else {
              operation.fn().done(operation.completePromise.resolve);
            }
          }
        }
        this._postponedOperations = {};
      }
    };
  }
});

// node_modules/devextreme/esm/core/component.js
var getEventName, isInnerOption, Component;
var init_component = __esm({
  "node_modules/devextreme/esm/core/component.js"() {
    init_config();
    init_extend();
    init_options();
    init_utils();
    init_class();
    init_action();
    init_errors();
    init_callbacks();
    init_events_strategy();
    init_public_component();
    init_postponed_operations();
    init_type();
    init_common();
    getEventName = (actionName) => actionName.charAt(2).toLowerCase() + actionName.substr(3);
    isInnerOption = (optionName) => 0 === optionName.indexOf("_", 0);
    Component = class_default.inherit({
      _setDeprecatedOptions() {
        this._deprecatedOptions = {};
      },
      _getDeprecatedOptions() {
        return this._deprecatedOptions;
      },
      _getDefaultOptions: () => ({
        onInitialized: null,
        onOptionChanged: null,
        onDisposing: null,
        defaultOptionsRules: null
      }),
      _defaultOptionsRules: () => [],
      _setOptionsByDevice(rules) {
        this._options.applyRules(rules);
      },
      _convertRulesToOptions: (rules) => convertRulesToOptions(rules),
      _isInitialOptionValue(name2) {
        return this._options.isInitial(name2);
      },
      _setOptionsByReference() {
        this._optionsByReference = {};
      },
      _getOptionsByReference() {
        return this._optionsByReference;
      },
      ctor() {
        var options2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
        var {
          _optionChangedCallbacks,
          _disposingCallbacks
        } = options2;
        this.NAME = getName(this.constructor);
        this._eventsStrategy = EventsStrategy.create(this, options2.eventsStrategy);
        this._updateLockCount = 0;
        this._optionChangedCallbacks = _optionChangedCallbacks || callbacks_default();
        this._disposingCallbacks = _disposingCallbacks || callbacks_default();
        this.postponedOperations = new PostponedOperations();
        this._createOptions(options2);
      },
      _createOptions(options2) {
        this.beginUpdate();
        try {
          this._setOptionsByReference();
          this._setDeprecatedOptions();
          this._options = new Options(this._getDefaultOptions(), this._getDefaultOptions(), this._getOptionsByReference(), this._getDeprecatedOptions());
          this._options.onChanging((name2, previousValue, value2) => this._initialized && this._optionChanging(name2, previousValue, value2));
          this._options.onDeprecated((option, info) => this._logDeprecatedOptionWarning(option, info));
          this._options.onChanged((name2, value2, previousValue) => this._notifyOptionChanged(name2, value2, previousValue));
          this._options.onStartChange(() => this.beginUpdate());
          this._options.onEndChange(() => this.endUpdate());
          this._options.addRules(this._defaultOptionsRules());
          if (options2 && options2.onInitializing) {
            options2.onInitializing.apply(this, [options2]);
          }
          this._setOptionsByDevice(options2.defaultOptionsRules);
          this._initOptions(options2);
        } finally {
          this.endUpdate();
        }
      },
      _initOptions(options2) {
        this.option(options2);
      },
      _init() {
        this._createOptionChangedAction();
        this.on("disposing", (args) => {
          this._disposingCallbacks.fireWith(this, [args]);
        });
      },
      _logDeprecatedOptionWarning(option, info) {
        var message = info.message || "Use the '".concat(info.alias, "' option instead");
        errors_default.log("W0001", this.NAME, option, info.since, message);
      },
      _logDeprecatedComponentWarning(since, alias) {
        errors_default.log("W0000", this.NAME, since, "Use the '".concat(alias, "' widget instead"));
      },
      _createOptionChangedAction() {
        this._optionChangedAction = this._createActionByOption("onOptionChanged", {
          excludeValidators: ["disabled", "readOnly"]
        });
      },
      _createDisposingAction() {
        this._disposingAction = this._createActionByOption("onDisposing", {
          excludeValidators: ["disabled", "readOnly"]
        });
      },
      _optionChanged(args) {
        switch (args.name) {
          case "onDisposing":
          case "onInitialized":
            break;
          case "onOptionChanged":
            this._createOptionChangedAction();
        }
      },
      _dispose() {
        this._optionChangedCallbacks.empty();
        this._createDisposingAction();
        this._disposingAction();
        this._eventsStrategy.dispose();
        this._options.dispose();
        this._disposed = true;
      },
      _lockUpdate() {
        this._updateLockCount++;
      },
      _unlockUpdate() {
        this._updateLockCount = Math.max(this._updateLockCount - 1, 0);
      },
      _isUpdateAllowed() {
        return 0 === this._updateLockCount;
      },
      _isInitializingRequired() {
        return !this._initializing && !this._initialized;
      },
      isInitialized() {
        return this._initialized;
      },
      _commitUpdate() {
        this.postponedOperations.callPostponedOperations();
        this._isInitializingRequired() && this._initializeComponent();
      },
      _initializeComponent() {
        this._initializing = true;
        try {
          this._init();
        } finally {
          this._initializing = false;
          this._lockUpdate();
          this._createActionByOption("onInitialized", {
            excludeValidators: ["disabled", "readOnly"]
          })();
          this._unlockUpdate();
          this._initialized = true;
        }
      },
      instance() {
        return this;
      },
      beginUpdate: function() {
        this._lockUpdate();
      },
      endUpdate: function() {
        this._unlockUpdate();
        this._isUpdateAllowed() && this._commitUpdate();
      },
      _optionChanging: noop2,
      _notifyOptionChanged(option, value2, previousValue) {
        if (this._initialized) {
          var optionNames = [option].concat(this._options.getAliasesByName(option));
          for (var i = 0; i < optionNames.length; i++) {
            var name2 = optionNames[i];
            var args = {
              name: name2.split(/[.[]/)[0],
              fullName: name2,
              value: value2,
              previousValue
            };
            if (!isInnerOption(name2)) {
              this._optionChangedCallbacks.fireWith(this, [extend2(this._defaultActionArgs(), args)]);
              this._optionChangedAction(extend2({}, args));
            }
            if (!this._disposed && this._cancelOptionChange !== name2) {
              this._optionChanged(args);
            }
          }
        }
      },
      initialOption(name2) {
        return this._options.initial(name2);
      },
      _defaultActionConfig() {
        return {
          context: this,
          component: this
        };
      },
      _defaultActionArgs() {
        return {
          component: this
        };
      },
      _createAction(actionSource, config2) {
        var action;
        return (e) => {
          if (!isDefined(e)) {
            e = {};
          }
          if (!isPlainObject(e)) {
            e = {
              actionValue: e
            };
          }
          action = action || new Action(actionSource, extend2(config2, this._defaultActionConfig()));
          return action.execute.call(action, extend2(e, this._defaultActionArgs()));
        };
      },
      _createActionByOption(optionName, config2) {
        var _this = this;
        var action;
        var eventName;
        var actionFunc;
        var result2 = function() {
          if (!eventName) {
            config2 = config2 || {};
            if ("string" !== typeof optionName) {
              throw errors_default.Error("E0008");
            }
            if (0 === optionName.indexOf("on")) {
              eventName = getEventName(optionName);
            }
            actionFunc = _this.option(optionName);
          }
          if (!action && !actionFunc && !config2.beforeExecute && !config2.afterExecute && !_this._eventsStrategy.hasEvent(eventName)) {
            return;
          }
          if (!action) {
            var beforeExecute = config2.beforeExecute;
            config2.beforeExecute = function() {
              for (var _len2 = arguments.length, props = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                props[_key2] = arguments[_key2];
              }
              beforeExecute && beforeExecute.apply(_this, props);
              _this._eventsStrategy.fireEvent(eventName, props[0].args);
            };
            action = _this._createAction(actionFunc, config2);
          }
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          if (config_default().wrapActionsBeforeExecute) {
            var beforeActionExecute = _this.option("beforeActionExecute") || noop2;
            var wrappedAction = beforeActionExecute(_this, action, config2) || action;
            return wrappedAction.apply(_this, args);
          }
          return action.apply(_this, args);
        };
        if (config_default().wrapActionsBeforeExecute) {
          return result2;
        }
        var onActionCreated = this.option("onActionCreated") || noop2;
        return onActionCreated(this, result2, config2) || result2;
      },
      on(eventName, eventHandler) {
        this._eventsStrategy.on(eventName, eventHandler);
        return this;
      },
      off(eventName, eventHandler) {
        this._eventsStrategy.off(eventName, eventHandler);
        return this;
      },
      hasActionSubscription: function(actionName) {
        return !!this._options.silent(actionName) || this._eventsStrategy.hasEvent(getEventName(actionName));
      },
      isOptionDeprecated(name2) {
        return this._options.isDeprecated(name2);
      },
      _setOptionWithoutOptionChange(name2, value2) {
        this._cancelOptionChange = name2;
        this.option(name2, value2);
        this._cancelOptionChange = false;
      },
      _getOptionValue(name2, context2) {
        var value2 = this.option(name2);
        if (isFunction(value2)) {
          return value2.bind(context2)();
        }
        return value2;
      },
      option() {
        return this._options.option(...arguments);
      },
      resetOption(name2) {
        this.beginUpdate();
        this._options.reset(name2);
        this.endUpdate();
      }
    });
  }
});

// node_modules/devextreme/esm/core/utils/dom.js
var window7, resetActiveElement, clearSelection, closestCommonParent, extractTemplateMarkup, normalizeTemplateElement, clipboardText, contains2, createTextElementHiddenCopy;
var init_dom = __esm({
  "node_modules/devextreme/esm/core/utils/dom.js"() {
    init_dom_adapter();
    init_renderer();
    init_type();
    init_window();
    window7 = getWindow();
    resetActiveElement = function() {
      var activeElement = dom_adapter_default.getActiveElement();
      var body = dom_adapter_default.getBody();
      if (activeElement && activeElement !== body && activeElement.blur) {
        try {
          activeElement.blur();
        } catch (e) {
          body.blur();
        }
      }
    };
    clearSelection = function() {
      var selection = window7.getSelection();
      if (!selection) {
        return;
      }
      if ("Caret" === selection.type) {
        return;
      }
      if (selection.empty) {
        selection.empty();
      } else if (selection.removeAllRanges) {
        try {
          selection.removeAllRanges();
        } catch (e) {
        }
      }
    };
    closestCommonParent = function(startTarget, endTarget) {
      var $startTarget = renderer_default(startTarget);
      var $endTarget = renderer_default(endTarget);
      if ($startTarget[0] === $endTarget[0]) {
        return $startTarget[0];
      }
      var $startParents = $startTarget.parents();
      var $endParents = $endTarget.parents();
      var startingParent = Math.min($startParents.length, $endParents.length);
      for (var i = -startingParent; i < 0; i++) {
        if ($startParents.get(i) === $endParents.get(i)) {
          return $startParents.get(i);
        }
      }
    };
    extractTemplateMarkup = function(element) {
      element = renderer_default(element);
      var templateTag = element.length && element.filter(function() {
        var $node = renderer_default(this);
        return $node.is("script[type]") && $node.attr("type").indexOf("script") < 0;
      });
      if (templateTag.length) {
        return templateTag.eq(0).html();
      } else {
        element = renderer_default("<div>").append(element);
        return element.html();
      }
    };
    normalizeTemplateElement = function normalizeTemplateElement2(element) {
      var $element = isDefined(element) && (element.nodeType || isRenderer(element)) ? renderer_default(element) : renderer_default("<div>").html(element).contents();
      if (1 === $element.length) {
        if ($element.is("script")) {
          $element = normalizeTemplateElement2($element.html().trim());
        } else if ($element.is("table")) {
          $element = $element.children("tbody").contents();
        }
      }
      return $element;
    };
    clipboardText = function(event, text) {
      var clipboard = event.originalEvent && event.originalEvent.clipboardData || window7.clipboardData;
      if (1 === arguments.length) {
        return clipboard && clipboard.getData("Text");
      }
      clipboard && clipboard.setData("Text", text);
    };
    contains2 = function contains3(container, element) {
      if (!element) {
        return false;
      }
      if (dom_adapter_default.isTextNode(element)) {
        element = element.parentNode;
      }
      if (dom_adapter_default.isDocument(container)) {
        return container.documentElement.contains(element);
      }
      if (isWindow(container)) {
        return contains3(container.document, element);
      }
      return container.contains ? container.contains(element) : !!(element.compareDocumentPosition(container) & element.DOCUMENT_POSITION_CONTAINS);
    };
    createTextElementHiddenCopy = function(element, text, options2) {
      var elementStyles = window7.getComputedStyle(renderer_default(element).get(0));
      var includePaddings = options2 && options2.includePaddings;
      return renderer_default("<div>").text(text).css({
        fontStyle: elementStyles.fontStyle,
        fontVariant: elementStyles.fontVariant,
        fontWeight: elementStyles.fontWeight,
        fontSize: elementStyles.fontSize,
        fontFamily: elementStyles.fontFamily,
        letterSpacing: elementStyles.letterSpacing,
        border: elementStyles.border,
        paddingTop: includePaddings ? elementStyles.paddingTop : "",
        paddingRight: includePaddings ? elementStyles.paddingRight : "",
        paddingBottom: includePaddings ? elementStyles.paddingBottom : "",
        paddingLeft: includePaddings ? elementStyles.paddingLeft : "",
        visibility: "hidden",
        whiteSpace: "pre",
        position: "absolute",
        float: "left"
      });
    };
  }
});

// node_modules/devextreme/esm/events/visibility_change.js
var triggerVisibilityChangeEvent, triggerShownEvent, triggerHidingEvent, triggerResizeEvent;
var init_visibility_change = __esm({
  "node_modules/devextreme/esm/events/visibility_change.js"() {
    init_renderer();
    init_events_engine();
    triggerVisibilityChangeEvent = function(eventName) {
      return function(element) {
        var $element = renderer_default(element || "body");
        var changeHandlers = $element.filter(".dx-visibility-change-handler").add($element.find(".dx-visibility-change-handler"));
        for (var i = 0; i < changeHandlers.length; i++) {
          events_engine_default.triggerHandler(changeHandlers[i], eventName);
        }
      };
    };
    triggerShownEvent = triggerVisibilityChangeEvent("dxshown");
    triggerHidingEvent = triggerVisibilityChangeEvent("dxhiding");
    triggerResizeEvent = triggerVisibilityChangeEvent("dxresize");
  }
});

// node_modules/devextreme/esm/core/templates/template_base.js
var renderedCallbacks, TemplateBase;
var init_template_base = __esm({
  "node_modules/devextreme/esm/core/templates/template_base.js"() {
    init_renderer();
    init_dom_adapter();
    init_callbacks();
    init_dom();
    init_visibility_change();
    init_errors();
    renderedCallbacks = callbacks_default({
      syncStrategy: true
    });
    TemplateBase = class {
      render(options2) {
        options2 = options2 || {};
        var onRendered = options2.onRendered;
        delete options2.onRendered;
        var $result = this._renderCore(options2);
        this._ensureResultInContainer($result, options2.container);
        renderedCallbacks.fire($result, options2.container);
        onRendered && onRendered();
        return $result;
      }
      _ensureResultInContainer($result, container) {
        if (!container) {
          return;
        }
        var $container = renderer_default(container);
        var resultInContainer = contains2($container.get(0), $result.get(0));
        $container.append($result);
        if (resultInContainer) {
          return;
        }
        var resultInBody = dom_adapter_default.getBody().contains($container.get(0));
        if (!resultInBody) {
          return;
        }
        triggerShownEvent($result);
      }
      _renderCore() {
        throw errors_default.Error("E0001");
      }
    };
  }
});

// node_modules/devextreme/esm/core/templates/function_template.js
var FunctionTemplate;
var init_function_template = __esm({
  "node_modules/devextreme/esm/core/templates/function_template.js"() {
    init_template_base();
    init_dom();
    FunctionTemplate = class extends TemplateBase {
      constructor(render4) {
        super();
        this._render = render4;
      }
      _renderCore(options2) {
        return normalizeTemplateElement(this._render(options2));
      }
    };
  }
});

// node_modules/devextreme/esm/core/templates/empty_template.js
var EmptyTemplate;
var init_empty_template = __esm({
  "node_modules/devextreme/esm/core/templates/empty_template.js"() {
    init_renderer();
    init_template_base();
    EmptyTemplate = class extends TemplateBase {
      _renderCore() {
        return renderer_default();
      }
    };
  }
});

// node_modules/devextreme/esm/core/templates/child_default_template.js
var ChildDefaultTemplate;
var init_child_default_template = __esm({
  "node_modules/devextreme/esm/core/templates/child_default_template.js"() {
    init_template_base();
    ChildDefaultTemplate = class extends TemplateBase {
      constructor(name2) {
        super();
        this.name = name2;
      }
    };
  }
});

// node_modules/devextreme/esm/core/templates/template_engine_registry.js
function registerTemplateEngine(name2, templateEngine) {
  templateEngines[name2] = templateEngine;
}
function setTemplateEngine(templateEngine) {
  if (isString2(templateEngine)) {
    currentTemplateEngine = templateEngines[templateEngine];
    if (!currentTemplateEngine) {
      throw errors_default.Error("E0020", templateEngine);
    }
  } else {
    currentTemplateEngine = templateEngine;
  }
}
function getCurrentTemplateEngine() {
  return currentTemplateEngine;
}
var templateEngines, currentTemplateEngine;
var init_template_engine_registry = __esm({
  "node_modules/devextreme/esm/core/templates/template_engine_registry.js"() {
    init_type();
    init_errors();
    templateEngines = {};
  }
});

// node_modules/devextreme/esm/core/templates/template_engines.js
var init_template_engines = __esm({
  "node_modules/devextreme/esm/core/templates/template_engines.js"() {
    init_dom();
    init_template_engine_registry();
    registerTemplateEngine("jquery-tmpl", {
      compile: (element) => extractTemplateMarkup(element),
      render: (template, data2) => jQuery.tmpl(template, data2)
    });
    registerTemplateEngine("jsrender", {
      compile: (element) => (jQuery ? jQuery : jsrender).templates(extractTemplateMarkup(element)),
      render: (template, data2) => template.render(data2)
    });
    registerTemplateEngine("mustache", {
      compile: (element) => extractTemplateMarkup(element),
      render: (template, data2) => Mustache.render(template, data2)
    });
    registerTemplateEngine("hogan", {
      compile: (element) => Hogan.compile(extractTemplateMarkup(element)),
      render: (template, data2) => template.render(data2)
    });
    registerTemplateEngine("underscore", {
      compile: (element) => _.template(extractTemplateMarkup(element)),
      render: (template, data2) => template(data2)
    });
    registerTemplateEngine("handlebars", {
      compile: (element) => Handlebars.compile(extractTemplateMarkup(element)),
      render: (template, data2) => template(data2)
    });
    registerTemplateEngine("doT", {
      compile: (element) => doT.template(extractTemplateMarkup(element)),
      render: (template, data2) => template(data2)
    });
  }
});

// node_modules/devextreme/esm/core/templates/template.js
var Template;
var init_template = __esm({
  "node_modules/devextreme/esm/core/templates/template.js"() {
    init_renderer();
    init_template_base();
    init_dom();
    init_template_engine_registry();
    init_template_engines();
    registerTemplateEngine("default", {
      compile: (element) => normalizeTemplateElement(element),
      render: (template, model, index2) => template.clone()
    });
    setTemplateEngine("default");
    Template = class extends TemplateBase {
      constructor(element) {
        super();
        this._element = element;
      }
      _renderCore(options2) {
        var transclude = options2.transclude;
        if (!transclude && !this._compiledTemplate) {
          this._compiledTemplate = getCurrentTemplateEngine().compile(this._element);
        }
        return renderer_default("<div>").append(transclude ? this._element : getCurrentTemplateEngine().render(this._compiledTemplate, options2.model, options2.index)).contents();
      }
      source() {
        return renderer_default(this._element).clone();
      }
    };
  }
});

// node_modules/devextreme/esm/core/utils/template_manager.js
var findTemplates, suitableTemplatesByName, addOneRenderedCall, getNormalizedTemplateArgs, validateTemplateSource, templateKey, defaultCreateElement, acquireIntegrationTemplate, acquireTemplate;
var init_template_manager = __esm({
  "node_modules/devextreme/esm/core/utils/template_manager.js"() {
    init_config();
    init_devices();
    init_errors();
    init_renderer();
    init_child_default_template();
    init_empty_template();
    init_template();
    init_template_base();
    init_array();
    init_common();
    init_dom();
    init_extend();
    init_type();
    findTemplates = (element, name2) => {
      var templates = renderer_default(element).contents().filter("[".concat("data-options", '*="').concat(name2, '"]'));
      return [].slice.call(templates).map((element2) => {
        var optionsString = renderer_default(element2).attr("data-options") || "";
        return {
          element: element2,
          options: config_default().optionsParser(optionsString)[name2]
        };
      }).filter((template) => !!template.options);
    };
    suitableTemplatesByName = (rawTemplates) => {
      var templatesMap = groupBy(rawTemplates, (template) => template.options.name);
      if (templatesMap[void 0]) {
        throw errors_default.Error("E0023");
      }
      var result2 = {};
      Object.keys(templatesMap).forEach((name2) => {
        var _findBestMatches$;
        var suitableTemplate = null === (_findBestMatches$ = findBestMatches(devices_default.current(), templatesMap[name2], (template) => template.options)[0]) || void 0 === _findBestMatches$ ? void 0 : _findBestMatches$.element;
        if (suitableTemplate) {
          result2[name2] = suitableTemplate;
        }
      });
      return result2;
    };
    addOneRenderedCall = (template) => {
      var render4 = template.render.bind(template);
      return extend2({}, template, {
        render(options2) {
          var templateResult = render4(options2);
          options2 && options2.onRendered && options2.onRendered();
          return templateResult;
        }
      });
    };
    getNormalizedTemplateArgs = (options2) => {
      var args = [];
      if ("model" in options2) {
        args.push(options2.model);
      }
      if ("index" in options2) {
        args.push(options2.index);
      }
      args.push(options2.container);
      return args;
    };
    validateTemplateSource = (templateSource) => "string" === typeof templateSource ? normalizeTemplateElement(templateSource) : templateSource;
    templateKey = (templateSource) => isRenderer(templateSource) && templateSource[0] || templateSource;
    defaultCreateElement = (element) => new Template(element);
    acquireIntegrationTemplate = (templateSource, templates, isAsyncTemplate, skipTemplates) => {
      var integrationTemplate = null;
      if (!skipTemplates || -1 === skipTemplates.indexOf(templateSource)) {
        integrationTemplate = templates[templateSource];
        if (integrationTemplate && !(integrationTemplate instanceof TemplateBase) && !isAsyncTemplate) {
          integrationTemplate = addOneRenderedCall(integrationTemplate);
        }
      }
      return integrationTemplate;
    };
    acquireTemplate = (templateSource, createTemplate, templates, isAsyncTemplate, skipTemplates, defaultTemplates) => {
      if (null == templateSource) {
        return new EmptyTemplate();
      }
      if (templateSource instanceof ChildDefaultTemplate) {
        return defaultTemplates[templateSource.name];
      }
      if (templateSource instanceof TemplateBase) {
        return templateSource;
      }
      if (isFunction(templateSource.render) && !isRenderer(templateSource)) {
        return isAsyncTemplate ? templateSource : addOneRenderedCall(templateSource);
      }
      if (templateSource.nodeType || isRenderer(templateSource)) {
        return createTemplate(renderer_default(templateSource));
      }
      return acquireIntegrationTemplate(templateSource, templates, isAsyncTemplate, skipTemplates) || defaultTemplates[templateSource] || createTemplate(templateSource);
    };
  }
});

// node_modules/devextreme/esm/core/template_manager.js
var TEXT_NODE2, ANONYMOUS_TEMPLATE_NAME, TEMPLATE_OPTIONS_NAME, TEMPLATE_WRAPPER_CLASS, DX_POLYMORPH_WIDGET_TEMPLATE, TemplateManager;
var init_template_manager2 = __esm({
  "node_modules/devextreme/esm/core/template_manager.js"() {
    init_renderer();
    init_type();
    init_common();
    init_extend();
    init_function_template();
    init_empty_template();
    init_template_manager();
    TEXT_NODE2 = 3;
    ANONYMOUS_TEMPLATE_NAME = "template";
    TEMPLATE_OPTIONS_NAME = "dxTemplate";
    TEMPLATE_WRAPPER_CLASS = "dx-template-wrapper";
    DX_POLYMORPH_WIDGET_TEMPLATE = new FunctionTemplate((_ref) => {
      var {
        model,
        parent
      } = _ref;
      var widgetName = model.widget;
      if (!widgetName) {
        return renderer_default();
      }
      var widgetElement = renderer_default("<div>");
      var widgetOptions = model.options || {};
      if (parent) {
        parent._createComponent(widgetElement, widgetName, widgetOptions);
      } else {
        widgetElement[widgetName](widgetOptions);
      }
      return widgetElement;
    });
    TemplateManager = class {
      constructor(createElement2, anonymousTemplateName) {
        this._tempTemplates = [];
        this._defaultTemplates = {};
        this._anonymousTemplateName = anonymousTemplateName || ANONYMOUS_TEMPLATE_NAME;
        this._createElement = createElement2 || defaultCreateElement;
        this._createTemplateIfNeeded = this._createTemplateIfNeeded.bind(this);
      }
      static createDefaultOptions() {
        return {
          integrationOptions: {
            watchMethod: function(fn, callback) {
              var options2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
              if (!options2.skipImmediate) {
                callback(fn());
              }
              return noop2;
            },
            templates: {
              "dx-polymorph-widget": DX_POLYMORPH_WIDGET_TEMPLATE
            },
            useDeferUpdateForTemplates: true
          }
        };
      }
      get anonymousTemplateName() {
        return this._anonymousTemplateName;
      }
      addDefaultTemplates(templates) {
        this._defaultTemplates = extend2({}, this._defaultTemplates, templates);
      }
      dispose() {
        this._tempTemplates.forEach((tempTemplate) => {
          tempTemplate.template.dispose && tempTemplate.template.dispose();
        });
        this._tempTemplates = [];
      }
      extractTemplates($el) {
        var templates = this._extractTemplates($el);
        var anonymousTemplateMeta = this._extractAnonymousTemplate($el);
        return {
          templates,
          anonymousTemplateMeta
        };
      }
      _extractTemplates($el) {
        var templates = findTemplates($el, TEMPLATE_OPTIONS_NAME);
        var suitableTemplates = suitableTemplatesByName(templates);
        templates.forEach((_ref2) => {
          var {
            element,
            options: {
              name: name2
            }
          } = _ref2;
          if (element === suitableTemplates[name2]) {
            renderer_default(element).addClass(TEMPLATE_WRAPPER_CLASS).detach();
          } else {
            renderer_default(element).remove();
          }
        });
        return Object.keys(suitableTemplates).map((name2) => ({
          name: name2,
          template: this._createTemplate(suitableTemplates[name2])
        }));
      }
      _extractAnonymousTemplate($el) {
        var $anonymousTemplate = $el.contents().detach();
        var $notJunkTemplateContent = $anonymousTemplate.filter((_2, element) => {
          var isTextNode = element.nodeType === TEXT_NODE2;
          var isEmptyText = renderer_default(element).text().trim().length < 1;
          return !(isTextNode && isEmptyText);
        });
        return $notJunkTemplateContent.length > 0 ? {
          template: this._createTemplate($anonymousTemplate),
          name: this._anonymousTemplateName
        } : {};
      }
      _createTemplateIfNeeded(templateSource) {
        var cachedTemplate = this._tempTemplates.filter((tempTemplate) => tempTemplate.source === templateKey(templateSource))[0];
        if (cachedTemplate) {
          return cachedTemplate.template;
        }
        var template = this._createTemplate(templateSource);
        this._tempTemplates.push({
          template,
          source: templateKey(templateSource)
        });
        return template;
      }
      _createTemplate(templateSource) {
        return this._createElement(validateTemplateSource(templateSource));
      }
      getTemplate(templateSource, templates, _ref3, context2) {
        var {
          isAsyncTemplate,
          skipTemplates
        } = _ref3;
        if (!isFunction(templateSource)) {
          return acquireTemplate(templateSource, this._createTemplateIfNeeded, templates, isAsyncTemplate, skipTemplates, this._defaultTemplates);
        }
        return new FunctionTemplate((options2) => {
          var templateSourceResult = templateSource.apply(context2, getNormalizedTemplateArgs(options2));
          if (!isDefined(templateSourceResult)) {
            return new EmptyTemplate();
          }
          var dispose = false;
          var template = acquireTemplate(templateSourceResult, (templateSource2) => {
            if (templateSource2.nodeType || isRenderer(templateSource2) && !renderer_default(templateSource2).is("script")) {
              return new FunctionTemplate(() => templateSource2);
            }
            dispose = true;
            return this._createTemplate(templateSource2);
          }, templates, isAsyncTemplate, skipTemplates, this._defaultTemplates);
          var result2 = template.render(options2);
          dispose && template.dispose && template.dispose();
          return result2;
        });
      }
    };
  }
});

// node_modules/devextreme/esm/core/element.js
function getPublicElement(element) {
  return strategy2(element);
}
var strategy2;
var init_element = __esm({
  "node_modules/devextreme/esm/core/element.js"() {
    strategy2 = function(element) {
      return element && element.get(0);
    };
  }
});

// node_modules/devextreme/esm/events/utils/add_namespace.js
var addNamespace, add_namespace_default;
var init_add_namespace = __esm({
  "node_modules/devextreme/esm/events/utils/add_namespace.js"() {
    init_errors();
    addNamespace = (eventNames, namespace) => {
      if (!namespace) {
        throw errors_default.Error("E0017");
      }
      if (Array.isArray(eventNames)) {
        return eventNames.map((eventName) => addNamespace(eventName, namespace)).join(" ");
      }
      if (-1 !== eventNames.indexOf(" ")) {
        return addNamespace(eventNames.split(/\s+/g), namespace);
      }
      return "".concat(eventNames, ".").concat(namespace);
    };
    add_namespace_default = addNamespace;
  }
});

// node_modules/devextreme/esm/ui/widget/selectors.js
function visible(element) {
  var $element = renderer_default(element);
  return $element.is(":visible") && "hidden" !== $element.css("visibility") && "hidden" !== $element.parents().css("visibility");
}
var focusableFn, focusable, tabbable, focused;
var init_selectors = __esm({
  "node_modules/devextreme/esm/ui/widget/selectors.js"() {
    init_renderer();
    init_dom_adapter();
    focusableFn = function(element, tabIndex) {
      if (!visible(element)) {
        return false;
      }
      var nodeName = element.nodeName.toLowerCase();
      var isTabIndexNotNaN = !isNaN(tabIndex);
      var isDisabled = element.disabled;
      var isDefaultFocus = /^(input|select|textarea|button|object|iframe)$/.test(nodeName);
      var isHyperlink = "a" === nodeName;
      var isFocusable = true;
      var isContentEditable = element.isContentEditable;
      if (isDefaultFocus || isContentEditable) {
        isFocusable = !isDisabled;
      } else if (isHyperlink) {
        isFocusable = element.href || isTabIndexNotNaN;
      } else {
        isFocusable = isTabIndexNotNaN;
      }
      return isFocusable;
    };
    focusable = function(index2, element) {
      return focusableFn(element, renderer_default(element).attr("tabIndex"));
    };
    tabbable = function(index2, element) {
      var tabIndex = renderer_default(element).attr("tabIndex");
      return (isNaN(tabIndex) || tabIndex >= 0) && focusableFn(element, tabIndex);
    };
    focused = function($element) {
      var element = renderer_default($element).get(0);
      return dom_adapter_default.getActiveElement() === element;
    };
  }
});

// node_modules/devextreme/esm/events/utils/index.js
var KEY_MAP, LEGACY_KEY_CODES, EVENT_SOURCES_REGEX, fixMethod, copyEvent, isDxEvent, isNativeMouseEvent, isNativeTouchEvent, eventSource, isPointerEvent, isMouseEvent, isDxMouseWheelEvent, isTouchEvent, eventData, eventDelta, hasTouches, skipEvents, needSkipEvent, createEvent, fireEvent, normalizeKeyName, getChar, addNamespace2, isCommandKeyPressed;
var init_utils2 = __esm({
  "node_modules/devextreme/esm/events/utils/index.js"() {
    init_renderer();
    init_add_namespace();
    init_events_engine();
    init_iterator();
    init_extend();
    init_selectors();
    KEY_MAP = {
      backspace: "backspace",
      tab: "tab",
      enter: "enter",
      escape: "escape",
      pageup: "pageUp",
      pagedown: "pageDown",
      end: "end",
      home: "home",
      arrowleft: "leftArrow",
      arrowup: "upArrow",
      arrowright: "rightArrow",
      arrowdown: "downArrow",
      delete: "del",
      " ": "space",
      f: "F",
      a: "A",
      "*": "asterisk",
      "-": "minus",
      alt: "alt",
      control: "control",
      shift: "shift",
      left: "leftArrow",
      up: "upArrow",
      right: "rightArrow",
      down: "downArrow",
      multiply: "asterisk",
      spacebar: "space",
      del: "del",
      subtract: "minus",
      esc: "escape"
    };
    LEGACY_KEY_CODES = {
      8: "backspace",
      9: "tab",
      13: "enter",
      27: "escape",
      33: "pageUp",
      34: "pageDown",
      35: "end",
      36: "home",
      37: "leftArrow",
      38: "upArrow",
      39: "rightArrow",
      40: "downArrow",
      46: "del",
      32: "space",
      70: "F",
      65: "A",
      106: "asterisk",
      109: "minus",
      189: "minus",
      173: "minus",
      16: "shift",
      17: "control",
      18: "alt"
    };
    EVENT_SOURCES_REGEX = {
      dx: /^dx/i,
      mouse: /(mouse|wheel)/i,
      touch: /^touch/i,
      keyboard: /^key/i,
      pointer: /^(ms)?pointer/i
    };
    fixMethod = (e) => e;
    copyEvent = (originalEvent) => fixMethod(events_engine_default.Event(originalEvent, originalEvent), originalEvent);
    isDxEvent = (e) => "dx" === eventSource(e);
    isNativeMouseEvent = (e) => "mouse" === eventSource(e);
    isNativeTouchEvent = (e) => "touch" === eventSource(e);
    eventSource = (_ref) => {
      var {
        type: type2
      } = _ref;
      var result2 = "other";
      each(EVENT_SOURCES_REGEX, function(key) {
        if (this.test(type2)) {
          result2 = key;
          return false;
        }
      });
      return result2;
    };
    isPointerEvent = (e) => "pointer" === eventSource(e);
    isMouseEvent = (e) => isNativeMouseEvent(e) || (isPointerEvent(e) || isDxEvent(e)) && "mouse" === e.pointerType;
    isDxMouseWheelEvent = (e) => e && "dxmousewheel" === e.type;
    isTouchEvent = (e) => isNativeTouchEvent(e) || (isPointerEvent(e) || isDxEvent(e)) && "touch" === e.pointerType;
    eventData = (_ref3) => {
      var {
        pageX,
        pageY,
        timeStamp
      } = _ref3;
      return {
        x: pageX,
        y: pageY,
        time: timeStamp
      };
    };
    eventDelta = (from, to) => ({
      x: to.x - from.x,
      y: to.y - from.y,
      time: to.time - from.time || 1
    });
    hasTouches = (e) => {
      var {
        originalEvent,
        pointers
      } = e;
      if (isNativeTouchEvent(e)) {
        return (originalEvent.touches || []).length;
      }
      if (isDxEvent(e)) {
        return (pointers || []).length;
      }
      return 0;
    };
    skipEvents = false;
    needSkipEvent = (e) => {
      if (skipEvents) {
        return true;
      }
      var {
        target
      } = e;
      var $target = renderer_default(target);
      var isContentEditable = (null === target || void 0 === target ? void 0 : target.isContentEditable) || (null === target || void 0 === target ? void 0 : target.hasAttribute("contenteditable"));
      var touchInEditable = $target.is("input, textarea, select") || isContentEditable;
      if ($target.is(".dx-skip-gesture-event *, .dx-skip-gesture-event")) {
        return true;
      }
      if (isDxMouseWheelEvent(e)) {
        var isTextArea = $target.is("textarea") && $target.hasClass("dx-texteditor-input");
        if (isTextArea || isContentEditable) {
          return false;
        }
        var isInputFocused = $target.is("input[type='number'], textarea, select") && $target.is(":focus");
        return isInputFocused;
      }
      if (isMouseEvent(e)) {
        return touchInEditable || e.which > 1;
      }
      if (isTouchEvent(e)) {
        return touchInEditable && focused($target);
      }
    };
    createEvent = (originalEvent, args) => {
      var event = copyEvent(originalEvent);
      args && extend2(event, args);
      return event;
    };
    fireEvent = (props) => {
      var {
        originalEvent,
        delegateTarget
      } = props;
      var event = createEvent(originalEvent, props);
      events_engine_default.trigger(delegateTarget || event.target, event);
      return event;
    };
    normalizeKeyName = (_ref4) => {
      var {
        key,
        which
      } = _ref4;
      var originalKey = key;
      var isKeySupported = !!key;
      if (key || which) {
        if (isKeySupported) {
          key = KEY_MAP[key.toLowerCase()];
        }
        if (!isKeySupported || !key && which) {
          key = LEGACY_KEY_CODES[which] || String.fromCharCode(which);
        }
        return key || originalKey;
      }
    };
    getChar = (_ref5) => {
      var {
        key,
        which
      } = _ref5;
      return key || String.fromCharCode(which);
    };
    addNamespace2 = add_namespace_default;
    isCommandKeyPressed = (_ref6) => {
      var {
        ctrlKey,
        metaKey
      } = _ref6;
      return ctrlKey || metaKey;
    };
  }
});

// node_modules/devextreme/esm/events/core/keyboard_processor.js
var COMPOSITION_START_EVENT, COMPOSITION_END_EVENT, KEYDOWN_EVENT, NAMESPACE, KeyboardProcessor, keyboard_processor_default;
var init_keyboard_processor = __esm({
  "node_modules/devextreme/esm/events/core/keyboard_processor.js"() {
    init_renderer();
    init_events_engine();
    init_class();
    init_array();
    init_utils2();
    COMPOSITION_START_EVENT = "compositionstart";
    COMPOSITION_END_EVENT = "compositionend";
    KEYDOWN_EVENT = "keydown";
    NAMESPACE = "KeyboardProcessor";
    KeyboardProcessor = class_default.inherit({
      _keydown: addNamespace2(KEYDOWN_EVENT, NAMESPACE),
      _compositionStart: addNamespace2(COMPOSITION_START_EVENT, NAMESPACE),
      _compositionEnd: addNamespace2(COMPOSITION_END_EVENT, NAMESPACE),
      ctor: function(options2) {
        options2 = options2 || {};
        if (options2.element) {
          this._element = renderer_default(options2.element);
        }
        if (options2.focusTarget) {
          this._focusTarget = options2.focusTarget;
        }
        this._handler = options2.handler;
        if (this._element) {
          this._processFunction = (e) => {
            var isNotFocusTarget = this._focusTarget && this._focusTarget !== e.target && inArray(e.target, renderer_default(this._focusTarget)) < 0;
            var shouldSkipProcessing = this._isComposingJustFinished && 229 === e.which || this._isComposing || isNotFocusTarget;
            this._isComposingJustFinished = false;
            if (!shouldSkipProcessing) {
              this.process(e);
            }
          };
          this._toggleProcessingWithContext = this.toggleProcessing.bind(this);
          events_engine_default.on(this._element, this._keydown, this._processFunction);
          events_engine_default.on(this._element, this._compositionStart, this._toggleProcessingWithContext);
          events_engine_default.on(this._element, this._compositionEnd, this._toggleProcessingWithContext);
        }
      },
      dispose: function() {
        if (this._element) {
          events_engine_default.off(this._element, this._keydown, this._processFunction);
          events_engine_default.off(this._element, this._compositionStart, this._toggleProcessingWithContext);
          events_engine_default.off(this._element, this._compositionEnd, this._toggleProcessingWithContext);
        }
        this._element = void 0;
        this._handler = void 0;
      },
      process: function(e) {
        this._handler({
          keyName: normalizeKeyName(e),
          key: e.key,
          code: e.code,
          ctrl: e.ctrlKey,
          location: e.location,
          metaKey: e.metaKey,
          shift: e.shiftKey,
          alt: e.altKey,
          which: e.which,
          originalEvent: e
        });
      },
      toggleProcessing: function(_ref) {
        var {
          type: type2
        } = _ref;
        this._isComposing = type2 === COMPOSITION_START_EVENT;
        this._isComposingJustFinished = !this._isComposing;
      }
    });
    keyboard_processor_default = KeyboardProcessor;
  }
});

// node_modules/devextreme/esm/core/utils/support.js
var support_exports = {};
__export(support_exports, {
  animation: () => animation,
  inputType: () => inputType,
  nativeScrolling: () => nativeScrolling,
  pointerEvents: () => pointerEvents,
  styleProp: () => styleProp,
  stylePropPrefix: () => stylePropPrefix,
  supportProp: () => supportProp,
  touch: () => touch,
  touchEvents: () => touchEvents,
  transition: () => transition,
  transitionEndEventName: () => transitionEndEventName
});
var maxTouchPoints, msMaxTouchPoints, pointerEnabled, transitionEndEventNames, supportProp, isNativeScrollingSupported, inputType, detectTouchEvents, detectPointerEvent, touchEvents, pointerEvents, touchPointersPresent, touch, transition, transitionEndEventName, animation, nativeScrolling;
var init_support = __esm({
  "node_modules/devextreme/esm/core/utils/support.js"() {
    init_array();
    init_dom_adapter();
    init_common();
    init_call_once();
    init_window();
    init_devices();
    init_style();
    ({
      maxTouchPoints,
      msMaxTouchPoints,
      pointerEnabled
    } = getNavigator());
    transitionEndEventNames = {
      webkitTransition: "webkitTransitionEnd",
      MozTransition: "transitionend",
      OTransition: "oTransitionEnd",
      msTransition: "MsTransitionEnd",
      transition: "transitionend"
    };
    supportProp = function(prop) {
      return !!styleProp(prop);
    };
    isNativeScrollingSupported = function() {
      var {
        platform,
        version: version2,
        mac: isMac
      } = devices_default.real();
      var isObsoleteAndroid = version2 && version2[0] < 4 && "android" === platform;
      var isNativeScrollDevice = !isObsoleteAndroid && inArray(platform, ["ios", "android"]) > -1 || isMac;
      return isNativeScrollDevice;
    };
    inputType = function(type2) {
      if ("text" === type2) {
        return true;
      }
      var input = dom_adapter_default.createElement("input");
      try {
        input.setAttribute("type", type2);
        input.value = "wrongValue";
        return !input.value;
      } catch (e) {
        return false;
      }
    };
    detectTouchEvents = function(hasWindowProperty, maxTouchPoints2) {
      return (hasWindowProperty("ontouchstart") || !!maxTouchPoints2) && !hasWindowProperty("callPhantom");
    };
    detectPointerEvent = function(hasWindowProperty, pointerEnabled2) {
      var isPointerEnabled = ensureDefined(pointerEnabled2, true);
      var canUsePointerEvent = ensureDefined(pointerEnabled2, false);
      return hasWindowProperty("PointerEvent") && isPointerEnabled || canUsePointerEvent;
    };
    touchEvents = detectTouchEvents(hasProperty, maxTouchPoints);
    pointerEvents = detectPointerEvent(hasProperty, pointerEnabled);
    touchPointersPresent = !!maxTouchPoints || !!msMaxTouchPoints;
    touch = touchEvents || pointerEvents && touchPointersPresent;
    transition = call_once_default(function() {
      return supportProp("transition");
    });
    transitionEndEventName = call_once_default(function() {
      return transitionEndEventNames[styleProp("transition")];
    });
    animation = call_once_default(function() {
      return supportProp("animation");
    });
    nativeScrolling = isNativeScrollingSupported();
  }
});

// node_modules/devextreme/esm/events/pointer/base.js
var POINTER_EVENTS_NAMESPACE, BaseStrategy, base_default;
var init_base = __esm({
  "node_modules/devextreme/esm/events/pointer/base.js"() {
    init_events_engine();
    init_browser();
    init_dom_adapter();
    init_class();
    init_utils2();
    POINTER_EVENTS_NAMESPACE = "dxPointerEvents";
    BaseStrategy = class_default.inherit({
      ctor: function(eventName, originalEvents) {
        this._eventName = eventName;
        this._originalEvents = addNamespace2(originalEvents, POINTER_EVENTS_NAMESPACE);
        this._handlerCount = 0;
        this.noBubble = this._isNoBubble();
      },
      _isNoBubble: function() {
        var eventName = this._eventName;
        return "dxpointerenter" === eventName || "dxpointerleave" === eventName;
      },
      _handler: function(e) {
        var delegateTarget = this._getDelegateTarget(e);
        return this._fireEvent({
          type: this._eventName,
          pointerType: e.pointerType || eventSource(e),
          originalEvent: e,
          delegateTarget,
          timeStamp: browser_default.mozilla ? (/* @__PURE__ */ new Date()).getTime() : e.timeStamp
        });
      },
      _getDelegateTarget: function(e) {
        var delegateTarget;
        if (this.noBubble) {
          delegateTarget = e.delegateTarget;
        }
        return delegateTarget;
      },
      _fireEvent: function(args) {
        return fireEvent(args);
      },
      _setSelector: function(handleObj) {
        this._selector = this.noBubble && handleObj ? handleObj.selector : null;
      },
      _getSelector: function() {
        return this._selector;
      },
      setup: function() {
        return true;
      },
      add: function(element, handleObj) {
        if (this._handlerCount <= 0 || this.noBubble) {
          element = this.noBubble ? element : dom_adapter_default.getDocument();
          this._setSelector(handleObj);
          var that = this;
          events_engine_default.on(element, this._originalEvents, this._getSelector(), function(e) {
            that._handler(e);
          });
        }
        if (!this.noBubble) {
          this._handlerCount++;
        }
      },
      remove: function(handleObj) {
        this._setSelector(handleObj);
        if (!this.noBubble) {
          this._handlerCount--;
        }
      },
      teardown: function(element) {
        if (this._handlerCount && !this.noBubble) {
          return;
        }
        element = this.noBubble ? element : dom_adapter_default.getDocument();
        if (this._originalEvents !== "." + POINTER_EVENTS_NAMESPACE) {
          events_engine_default.off(element, this._originalEvents, this._getSelector());
        }
      },
      dispose: function(element) {
        element = this.noBubble ? element : dom_adapter_default.getDocument();
        events_engine_default.off(element, this._originalEvents);
      }
    });
    base_default = BaseStrategy;
  }
});

// node_modules/devextreme/esm/events/pointer/touch.js
var eventMap, normalizeTouchEvent, skipTouchWithSameIdentifier, TouchStrategy, touch_default;
var init_touch = __esm({
  "node_modules/devextreme/esm/events/pointer/touch.js"() {
    init_devices();
    init_extend();
    init_iterator();
    init_base();
    eventMap = {
      dxpointerdown: "touchstart",
      dxpointermove: "touchmove",
      dxpointerup: "touchend",
      dxpointercancel: "touchcancel",
      dxpointerover: "",
      dxpointerout: "",
      dxpointerenter: "",
      dxpointerleave: ""
    };
    normalizeTouchEvent = function(e) {
      var pointers = [];
      each(e.touches, function(_2, touch2) {
        pointers.push(extend2({
          pointerId: touch2.identifier
        }, touch2));
      });
      return {
        pointers,
        pointerId: e.changedTouches[0].identifier
      };
    };
    skipTouchWithSameIdentifier = function(pointerEvent) {
      return "ios" === devices_default.real().platform && ("dxpointerdown" === pointerEvent || "dxpointerup" === pointerEvent);
    };
    TouchStrategy = base_default.inherit({
      ctor: function() {
        this.callBase.apply(this, arguments);
        this._pointerId = 0;
      },
      _handler: function(e) {
        if (skipTouchWithSameIdentifier(this._eventName)) {
          var touch2 = e.changedTouches[0];
          if (this._pointerId === touch2.identifier && 0 !== this._pointerId) {
            return;
          }
          this._pointerId = touch2.identifier;
        }
        return this.callBase.apply(this, arguments);
      },
      _fireEvent: function(args) {
        return this.callBase(extend2(normalizeTouchEvent(args.originalEvent), args));
      }
    });
    TouchStrategy.map = eventMap;
    TouchStrategy.normalize = normalizeTouchEvent;
    touch_default = TouchStrategy;
  }
});

// node_modules/devextreme/esm/events/pointer/observer.js
var addEventsListener, Observer, observer_default;
var init_observer = __esm({
  "node_modules/devextreme/esm/events/pointer/observer.js"() {
    init_iterator();
    init_ready_callbacks();
    init_dom_adapter();
    addEventsListener = function(events, handler) {
      ready_callbacks_default.add(function() {
        events.split(" ").forEach(function(event) {
          dom_adapter_default.listen(dom_adapter_default.getDocument(), event, handler, true);
        });
      });
    };
    Observer = function(eventMap5, pointerEquals, onPointerAdding) {
      onPointerAdding = onPointerAdding || function() {
      };
      var pointers = [];
      var getPointerIndex = function(e) {
        var index2 = -1;
        each(pointers, function(i, pointer2) {
          if (!pointerEquals(e, pointer2)) {
            return true;
          }
          index2 = i;
          return false;
        });
        return index2;
      };
      var removePointer = function(e) {
        var index2 = getPointerIndex(e);
        if (index2 > -1) {
          pointers.splice(index2, 1);
        }
      };
      addEventsListener(eventMap5.dxpointerdown, function(e) {
        if (-1 === getPointerIndex(e)) {
          onPointerAdding(e);
          pointers.push(e);
        }
      });
      addEventsListener(eventMap5.dxpointermove, function(e) {
        pointers[getPointerIndex(e)] = e;
      });
      addEventsListener(eventMap5.dxpointerup, removePointer);
      addEventsListener(eventMap5.dxpointercancel, removePointer);
      this.pointers = function() {
        return pointers;
      };
      this.reset = function() {
        pointers = [];
      };
    };
    observer_default = Observer;
  }
});

// node_modules/devextreme/esm/events/pointer/mspointer.js
var eventMap2, observer, activated, activateStrategy, MsPointerStrategy, mspointer_default;
var init_mspointer = __esm({
  "node_modules/devextreme/esm/events/pointer/mspointer.js"() {
    init_base();
    init_observer();
    init_extend();
    eventMap2 = {
      dxpointerdown: "pointerdown",
      dxpointermove: "pointermove",
      dxpointerup: "pointerup",
      dxpointercancel: "pointercancel",
      dxpointerover: "pointerover",
      dxpointerout: "pointerout",
      dxpointerenter: "pointerenter",
      dxpointerleave: "pointerleave"
    };
    activated = false;
    activateStrategy = function() {
      if (activated) {
        return;
      }
      observer = new observer_default(eventMap2, function(a, b) {
        return a.pointerId === b.pointerId;
      }, function(e) {
        if (e.isPrimary) {
          observer.reset();
        }
      });
      activated = true;
    };
    MsPointerStrategy = base_default.inherit({
      ctor: function() {
        this.callBase.apply(this, arguments);
        activateStrategy();
      },
      _fireEvent: function(args) {
        return this.callBase(extend2({
          pointers: observer.pointers(),
          pointerId: args.originalEvent.pointerId
        }, args));
      }
    });
    MsPointerStrategy.map = eventMap2;
    MsPointerStrategy.resetObserver = function() {
      observer.reset();
    };
    mspointer_default = MsPointerStrategy;
  }
});

// node_modules/devextreme/esm/events/pointer/mouse.js
var eventMap3, normalizeMouseEvent, observer2, activated2, activateStrategy2, MouseStrategy, mouse_default;
var init_mouse = __esm({
  "node_modules/devextreme/esm/events/pointer/mouse.js"() {
    init_extend();
    init_base();
    init_observer();
    eventMap3 = {
      dxpointerdown: "mousedown",
      dxpointermove: "mousemove",
      dxpointerup: "mouseup",
      dxpointercancel: "",
      dxpointerover: "mouseover",
      dxpointerout: "mouseout",
      dxpointerenter: "mouseenter",
      dxpointerleave: "mouseleave"
    };
    normalizeMouseEvent = function(e) {
      e.pointerId = 1;
      return {
        pointers: observer2.pointers(),
        pointerId: 1
      };
    };
    activated2 = false;
    activateStrategy2 = function() {
      if (activated2) {
        return;
      }
      observer2 = new observer_default(eventMap3, function() {
        return true;
      });
      activated2 = true;
    };
    MouseStrategy = base_default.inherit({
      ctor: function() {
        this.callBase.apply(this, arguments);
        activateStrategy2();
      },
      _fireEvent: function(args) {
        return this.callBase(extend2(normalizeMouseEvent(args.originalEvent), args));
      }
    });
    MouseStrategy.map = eventMap3;
    MouseStrategy.normalize = normalizeMouseEvent;
    MouseStrategy.activate = activateStrategy2;
    MouseStrategy.resetObserver = function() {
      observer2.reset();
    };
    mouse_default = MouseStrategy;
  }
});

// node_modules/devextreme/esm/events/pointer/mouse_and_touch.js
var eventMap4, activated3, activateStrategy3, MouseAndTouchStrategy, mouse_and_touch_default;
var init_mouse_and_touch = __esm({
  "node_modules/devextreme/esm/events/pointer/mouse_and_touch.js"() {
    init_extend();
    init_base();
    init_mouse();
    init_touch();
    init_utils2();
    eventMap4 = {
      dxpointerdown: "touchstart mousedown",
      dxpointermove: "touchmove mousemove",
      dxpointerup: "touchend mouseup",
      dxpointercancel: "touchcancel",
      dxpointerover: "mouseover",
      dxpointerout: "mouseout",
      dxpointerenter: "mouseenter",
      dxpointerleave: "mouseleave"
    };
    activated3 = false;
    activateStrategy3 = function() {
      if (activated3) {
        return;
      }
      mouse_default.activate();
      activated3 = true;
    };
    MouseAndTouchStrategy = base_default.inherit({
      EVENT_LOCK_TIMEOUT: 100,
      ctor: function() {
        this.callBase.apply(this, arguments);
        activateStrategy3();
      },
      _handler: function(e) {
        var isMouse = isMouseEvent(e);
        if (!isMouse) {
          this._skipNextEvents = true;
        }
        if (isMouse && this._mouseLocked) {
          return;
        }
        if (isMouse && this._skipNextEvents) {
          this._skipNextEvents = false;
          this._mouseLocked = true;
          clearTimeout(this._unlockMouseTimer);
          var that = this;
          this._unlockMouseTimer = setTimeout(function() {
            that._mouseLocked = false;
          }, this.EVENT_LOCK_TIMEOUT);
          return;
        }
        return this.callBase(e);
      },
      _fireEvent: function(args) {
        var normalizer = isMouseEvent(args.originalEvent) ? mouse_default.normalize : touch_default.normalize;
        return this.callBase(extend2(normalizer(args.originalEvent), args));
      },
      dispose: function() {
        this.callBase();
        this._skipNextEvents = false;
        this._mouseLocked = false;
        clearTimeout(this._unlockMouseTimer);
      }
    });
    MouseAndTouchStrategy.map = eventMap4;
    MouseAndTouchStrategy.resetObserver = mouse_default.resetObserver;
    mouse_and_touch_default = MouseAndTouchStrategy;
  }
});

// node_modules/devextreme/esm/events/pointer.js
var getStrategy, EventStrategy, pointer, pointer_default;
var init_pointer = __esm({
  "node_modules/devextreme/esm/events/pointer.js"() {
    init_support();
    init_iterator();
    init_browser();
    init_devices();
    init_event_registrator();
    init_touch();
    init_mspointer();
    init_mouse();
    init_mouse_and_touch();
    getStrategy = (support, device, browser) => {
      if (support.pointerEvents && browser.msie) {
        return mspointer_default;
      }
      var {
        tablet,
        phone
      } = device;
      if (support.touch && !(tablet || phone)) {
        return mouse_and_touch_default;
      }
      if (support.touch) {
        return touch_default;
      }
      return mouse_default;
    };
    EventStrategy = getStrategy(support_exports, devices_default.real(), browser_default);
    each(EventStrategy.map, (pointerEvent, originalEvents) => {
      event_registrator_default(pointerEvent, new EventStrategy(pointerEvent, originalEvents));
    });
    pointer = {
      down: "dxpointerdown",
      up: "dxpointerup",
      move: "dxpointermove",
      cancel: "dxpointercancel",
      enter: "dxpointerenter",
      leave: "dxpointerleave",
      over: "dxpointerover",
      out: "dxpointerout"
    };
    pointer_default = pointer;
  }
});

// node_modules/devextreme/esm/events/short.js
function addNamespace3(event, namespace) {
  return namespace ? addNamespace2(event, namespace) : event;
}
function executeAction(action, args) {
  return "function" === typeof action ? action(args) : action.execute(args);
}
var active, resize, hover, visibility, focus, dxClick, click, index, keyboardProcessors, generateListenerId, keyboard;
var init_short = __esm({
  "node_modules/devextreme/esm/events/short.js"() {
    init_dom_adapter();
    init_events_engine();
    init_keyboard_processor();
    init_utils2();
    init_pointer();
    active = {
      on: ($el, active2, inactive, opts) => {
        var {
          selector,
          showTimeout,
          hideTimeout,
          namespace
        } = opts;
        events_engine_default.on($el, addNamespace3("dxactive", namespace), selector, {
          timeout: showTimeout
        }, (event) => executeAction(active2, {
          event,
          element: event.currentTarget
        }));
        events_engine_default.on($el, addNamespace3("dxinactive", namespace), selector, {
          timeout: hideTimeout
        }, (event) => executeAction(inactive, {
          event,
          element: event.currentTarget
        }));
      },
      off: ($el, _ref) => {
        var {
          namespace,
          selector
        } = _ref;
        events_engine_default.off($el, addNamespace3("dxactive", namespace), selector);
        events_engine_default.off($el, addNamespace3("dxinactive", namespace), selector);
      }
    };
    resize = {
      on: function($el, resize2) {
        var {
          namespace
        } = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
        events_engine_default.on($el, addNamespace3("dxresize", namespace), resize2);
      },
      off: function($el) {
        var {
          namespace
        } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        events_engine_default.off($el, addNamespace3("dxresize", namespace));
      }
    };
    hover = {
      on: ($el, start, end, _ref2) => {
        var {
          selector,
          namespace
        } = _ref2;
        events_engine_default.on($el, addNamespace3("dxhoverend", namespace), selector, (event) => end(event));
        events_engine_default.on($el, addNamespace3("dxhoverstart", namespace), selector, (event) => executeAction(start, {
          element: event.target,
          event
        }));
      },
      off: ($el, _ref3) => {
        var {
          selector,
          namespace
        } = _ref3;
        events_engine_default.off($el, addNamespace3("dxhoverstart", namespace), selector);
        events_engine_default.off($el, addNamespace3("dxhoverend", namespace), selector);
      }
    };
    visibility = {
      on: ($el, shown, hiding, _ref4) => {
        var {
          namespace
        } = _ref4;
        events_engine_default.on($el, addNamespace3("dxhiding", namespace), hiding);
        events_engine_default.on($el, addNamespace3("dxshown", namespace), shown);
      },
      off: ($el, _ref5) => {
        var {
          namespace
        } = _ref5;
        events_engine_default.off($el, addNamespace3("dxhiding", namespace));
        events_engine_default.off($el, addNamespace3("dxshown", namespace));
      }
    };
    focus = {
      on: ($el, focusIn, focusOut, _ref6) => {
        var {
          namespace,
          isFocusable
        } = _ref6;
        events_engine_default.on($el, addNamespace3("focusin", namespace), focusIn);
        events_engine_default.on($el, addNamespace3("focusout", namespace), focusOut);
        if (dom_adapter_default.hasDocumentProperty("onbeforeactivate")) {
          events_engine_default.on($el, addNamespace3("beforeactivate", namespace), (e) => isFocusable(null, e.target) || e.preventDefault());
        }
      },
      off: ($el, _ref7) => {
        var {
          namespace
        } = _ref7;
        events_engine_default.off($el, addNamespace3("focusin", namespace));
        events_engine_default.off($el, addNamespace3("focusout", namespace));
        if (dom_adapter_default.hasDocumentProperty("onbeforeactivate")) {
          events_engine_default.off($el, addNamespace3("beforeactivate", namespace));
        }
      },
      trigger: ($el) => events_engine_default.trigger($el, "focus")
    };
    dxClick = {
      on: function($el, click2) {
        var {
          namespace
        } = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
        events_engine_default.on($el, addNamespace3("dxclick", namespace), click2);
      },
      off: function($el) {
        var {
          namespace
        } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        events_engine_default.off($el, addNamespace3("dxclick", namespace));
      }
    };
    click = {
      on: function($el, click2) {
        var {
          namespace
        } = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
        events_engine_default.on($el, addNamespace3("click", namespace), click2);
      },
      off: function($el) {
        var {
          namespace
        } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        events_engine_default.off($el, addNamespace3("click", namespace));
      }
    };
    index = 0;
    keyboardProcessors = {};
    generateListenerId = () => "keyboardProcessorId".concat(index++);
    keyboard = {
      on: (element, focusTarget, handler) => {
        var listenerId = generateListenerId();
        keyboardProcessors[listenerId] = new keyboard_processor_default({
          element,
          focusTarget,
          handler
        });
        return listenerId;
      },
      off: (listenerId) => {
        if (listenerId && keyboardProcessors[listenerId]) {
          keyboardProcessors[listenerId].dispose();
          delete keyboardProcessors[listenerId];
        }
      },
      _getProcessor: (listenerId) => keyboardProcessors[listenerId]
    };
  }
});

// node_modules/devextreme/esm/core/dom_component.js
var abstract2, DOMComponent, dom_component_default;
var init_dom_component = __esm({
  "node_modules/devextreme/esm/core/dom_component.js"() {
    init_renderer();
    init_config();
    init_errors();
    init_resize_callbacks();
    init_component();
    init_template_manager2();
    init_public_component();
    init_element_data();
    init_iterator();
    init_extend();
    init_element();
    init_common();
    init_array();
    init_type();
    init_window();
    init_short();
    ({
      abstract: abstract2
    } = Component);
    DOMComponent = Component.inherit({
      _getDefaultOptions() {
        return extend2(this.callBase(), {
          width: void 0,
          height: void 0,
          rtlEnabled: config_default().rtlEnabled,
          elementAttr: {},
          disabled: false,
          integrationOptions: {}
        }, this._useTemplates() ? TemplateManager.createDefaultOptions() : {});
      },
      ctor(element, options2) {
        this._customClass = null;
        this._createElement(element);
        attachInstanceToElement(this._$element, this, this._dispose);
        this.callBase(options2);
      },
      _createElement(element) {
        this._$element = renderer_default(element);
      },
      _getSynchronizableOptionsForCreateComponent: () => ["rtlEnabled", "disabled", "templatesRenderAsynchronously"],
      _visibilityChanged: abstract2,
      _dimensionChanged: abstract2,
      _init() {
        this.callBase();
        this._attachWindowResizeCallback();
        this._initTemplateManager();
      },
      _setOptionsByDevice(instanceCustomRules) {
        this.callBase([].concat(this.constructor._classCustomRules || [], instanceCustomRules || []));
      },
      _isInitialOptionValue(name2) {
        var isCustomOption = this.constructor._classCustomRules && Object.prototype.hasOwnProperty.call(this._convertRulesToOptions(this.constructor._classCustomRules), name2);
        return !isCustomOption && this.callBase(name2);
      },
      _attachWindowResizeCallback() {
        if (this._isDimensionChangeSupported()) {
          var windowResizeCallBack = this._windowResizeCallBack = this._dimensionChanged.bind(this);
          resize_callbacks_default.add(windowResizeCallBack);
        }
      },
      _isDimensionChangeSupported() {
        return this._dimensionChanged !== abstract2;
      },
      _renderComponent() {
        this._initMarkup();
        hasWindow() && this._render();
      },
      _initMarkup() {
        var {
          rtlEnabled
        } = this.option() || {};
        this._renderElementAttributes();
        this._toggleRTLDirection(rtlEnabled);
        this._renderVisibilityChange();
        this._renderDimensions();
      },
      _render() {
        this._attachVisibilityChangeHandlers();
      },
      _renderElementAttributes() {
        var {
          elementAttr
        } = this.option() || {};
        var attributes = extend2({}, elementAttr);
        var classNames = attributes.class;
        delete attributes.class;
        this.$element().attr(attributes).removeClass(this._customClass).addClass(classNames);
        this._customClass = classNames;
      },
      _renderVisibilityChange() {
        if (this._isDimensionChangeSupported()) {
          this._attachDimensionChangeHandlers();
        }
        if (this._isVisibilityChangeSupported()) {
          var $element = this.$element();
          $element.addClass("dx-visibility-change-handler");
        }
      },
      _renderDimensions() {
        var $element = this.$element();
        var element = $element.get(0);
        var width = this._getOptionValue("width", element);
        var height = this._getOptionValue("height", element);
        if (this._isCssUpdateRequired(element, height, width)) {
          $element.css({
            width: null === width ? "" : width,
            height: null === height ? "" : height
          });
        }
      },
      _isCssUpdateRequired: (element, height, width) => !!(isDefined(width) || isDefined(height) || element.style.width || element.style.height),
      _attachDimensionChangeHandlers() {
        var $el = this.$element();
        var namespace = "".concat(this.NAME, "VisibilityChange");
        resize.off($el, {
          namespace
        });
        resize.on($el, () => this._dimensionChanged(), {
          namespace
        });
      },
      _attachVisibilityChangeHandlers() {
        if (this._isVisibilityChangeSupported()) {
          var $el = this.$element();
          var namespace = "".concat(this.NAME, "VisibilityChange");
          this._isHidden = !this._isVisible();
          visibility.off($el, {
            namespace
          });
          visibility.on($el, () => this._checkVisibilityChanged("shown"), () => this._checkVisibilityChanged("hiding"), {
            namespace
          });
        }
      },
      _isVisible() {
        var $element = this.$element();
        return $element.is(":visible");
      },
      _checkVisibilityChanged(action) {
        var isVisible2 = this._isVisible();
        if (isVisible2) {
          if ("hiding" === action && !this._isHidden) {
            this._visibilityChanged(false);
            this._isHidden = true;
          } else if ("shown" === action && this._isHidden) {
            this._isHidden = false;
            this._visibilityChanged(true);
          }
        }
      },
      _isVisibilityChangeSupported() {
        return this._visibilityChanged !== abstract2 && hasWindow();
      },
      _clean: noop2,
      _modelByElement() {
        var {
          modelByElement
        } = this.option();
        var $element = this.$element();
        return modelByElement ? modelByElement($element) : void 0;
      },
      _invalidate() {
        if (this._isUpdateAllowed()) {
          throw errors_default.Error("E0007");
        }
        this._requireRefresh = true;
      },
      _refresh() {
        this._clean();
        this._renderComponent();
      },
      _dispose() {
        this._templateManager && this._templateManager.dispose();
        this.callBase();
        this._clean();
        this._detachWindowResizeCallback();
      },
      _detachWindowResizeCallback() {
        if (this._isDimensionChangeSupported()) {
          resize_callbacks_default.remove(this._windowResizeCallBack);
        }
      },
      _toggleRTLDirection(rtl) {
        var $element = this.$element();
        $element.toggleClass("dx-rtl", rtl);
      },
      _createComponent(element, component) {
        var config2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
        var synchronizableOptions = grep(this._getSynchronizableOptionsForCreateComponent(), (value2) => !(value2 in config2));
        var {
          integrationOptions
        } = this.option();
        var {
          nestedComponentOptions
        } = this.option();
        nestedComponentOptions = nestedComponentOptions || noop2;
        var nestedComponentConfig = extend2({
          integrationOptions
        }, nestedComponentOptions(this));
        synchronizableOptions.forEach((optionName) => nestedComponentConfig[optionName] = this.option(optionName));
        this._extendConfig(config2, nestedComponentConfig);
        var instance = void 0;
        if (isString2(component)) {
          var $element = renderer_default(element)[component](config2);
          instance = $element[component]("instance");
        } else if (element) {
          instance = component.getInstance(element);
          if (instance) {
            instance.option(config2);
          } else {
            instance = new component(element, config2);
          }
        }
        if (instance) {
          var optionChangedHandler = (_ref) => {
            var {
              name: name2,
              value: value2
            } = _ref;
            if (inArray(name2, synchronizableOptions) >= 0) {
              instance.option(name2, value2);
            }
          };
          this.on("optionChanged", optionChangedHandler);
          instance.on("disposing", () => this.off("optionChanged", optionChangedHandler));
        }
        return instance;
      },
      _extendConfig(config2, extendConfig) {
        each(extendConfig, (key, value2) => {
          !Object.prototype.hasOwnProperty.call(config2, key) && (config2[key] = value2);
        });
      },
      _defaultActionConfig() {
        var $element = this.$element();
        var context2 = this._modelByElement($element);
        return extend2(this.callBase(), {
          context: context2
        });
      },
      _defaultActionArgs() {
        var $element = this.$element();
        var model = this._modelByElement($element);
        var element = this.element();
        return extend2(this.callBase(), {
          element,
          model
        });
      },
      _optionChanged(args) {
        switch (args.name) {
          case "width":
          case "height":
            this._renderDimensions();
            break;
          case "rtlEnabled":
            this._invalidate();
            break;
          case "elementAttr":
            this._renderElementAttributes();
            break;
          case "disabled":
          case "integrationOptions":
            break;
          default:
            this.callBase(args);
        }
      },
      _removeAttributes(element) {
        var attrs = element.attributes;
        for (var i = attrs.length - 1; i >= 0; i--) {
          var attr = attrs[i];
          if (attr) {
            var {
              name: name2
            } = attr;
            if (!name2.indexOf("aria-") || -1 !== name2.indexOf("dx-") || "role" === name2 || "style" === name2 || "tabindex" === name2) {
              element.removeAttribute(name2);
            }
          }
        }
      },
      _removeClasses(element) {
        element.className = element.className.split(" ").filter((cssClass) => 0 !== cssClass.lastIndexOf("dx-", 0)).join(" ");
      },
      _updateDOMComponent(renderRequired) {
        if (renderRequired) {
          this._renderComponent();
        } else if (this._requireRefresh) {
          this._requireRefresh = false;
          this._refresh();
        }
      },
      endUpdate() {
        var renderRequired = this._isInitializingRequired();
        this.callBase();
        this._isUpdateAllowed() && this._updateDOMComponent(renderRequired);
      },
      $element() {
        return this._$element;
      },
      element() {
        var $element = this.$element();
        return getPublicElement($element);
      },
      dispose() {
        var element = this.$element().get(0);
        cleanDataRecursive(element, true);
        element.textContent = "";
        this._removeAttributes(element);
        this._removeClasses(element);
      },
      resetOption(optionName) {
        this.callBase(optionName);
        if ("width" === optionName || "height" === optionName) {
          var initialOption = this.initialOption(optionName);
          !isDefined(initialOption) && this.$element().css(optionName, "");
        }
      },
      _getAnonymousTemplateName() {
        return;
      },
      _initTemplateManager() {
        if (this._templateManager || !this._useTemplates()) {
          return;
        }
        var {
          integrationOptions = {}
        } = this.option();
        var {
          createTemplate
        } = integrationOptions;
        this._templateManager = new TemplateManager(createTemplate, this._getAnonymousTemplateName());
        this._initTemplates();
      },
      _initTemplates() {
        var {
          templates,
          anonymousTemplateMeta
        } = this._templateManager.extractTemplates(this.$element());
        var anonymousTemplate = this.option("integrationOptions.templates.".concat(anonymousTemplateMeta.name));
        templates.forEach((_ref2) => {
          var {
            name: name2,
            template
          } = _ref2;
          this._options.silent("integrationOptions.templates.".concat(name2), template);
        });
        if (anonymousTemplateMeta.name && !anonymousTemplate) {
          this._options.silent("integrationOptions.templates.".concat(anonymousTemplateMeta.name), anonymousTemplateMeta.template);
          this._options.silent("_hasAnonymousTemplateContent", true);
        }
      },
      _getTemplateByOption(optionName) {
        return this._getTemplate(this.option(optionName));
      },
      _getTemplate(templateSource) {
        var templates = this.option("integrationOptions.templates");
        var isAsyncTemplate = this.option("templatesRenderAsynchronously");
        var skipTemplates = this.option("integrationOptions.skipTemplates");
        return this._templateManager.getTemplate(templateSource, templates, {
          isAsyncTemplate,
          skipTemplates
        }, this);
      },
      _saveTemplate(name2, template) {
        this._setOptionWithoutOptionChange("integrationOptions.templates." + name2, this._templateManager._createTemplate(template));
      },
      _useTemplates: () => true
    });
    DOMComponent.getInstance = function(element) {
      return getInstanceByElement(renderer_default(element), this);
    };
    DOMComponent.defaultOptions = function(rule) {
      this._classCustomRules = this._classCustomRules || [];
      this._classCustomRules.push(rule);
    };
    dom_component_default = DOMComponent;
  }
});

// node_modules/devextreme/esm/animation/frame.js
function requestAnimationFrame() {
  setAnimationFrameMethods();
  return request.apply(window8, arguments);
}
function cancelAnimationFrame() {
  setAnimationFrameMethods();
  cancel.apply(window8, arguments);
}
var window8, FRAME_ANIMATION_STEP_TIME, request, cancel, setAnimationFrameMethods;
var init_frame = __esm({
  "node_modules/devextreme/esm/animation/frame.js"() {
    init_window();
    init_call_once();
    window8 = hasWindow() ? getWindow() : {};
    FRAME_ANIMATION_STEP_TIME = 1e3 / 60;
    request = function(callback) {
      return setTimeout(callback, FRAME_ANIMATION_STEP_TIME);
    };
    cancel = function(requestID) {
      clearTimeout(requestID);
    };
    setAnimationFrameMethods = call_once_default(function() {
      var nativeRequest = window8.requestAnimationFrame || window8.webkitRequestAnimationFrame || window8.mozRequestAnimationFrame || window8.oRequestAnimationFrame || window8.msRequestAnimationFrame;
      var nativeCancel = window8.cancelAnimationFrame || window8.webkitCancelAnimationFrame || window8.mozCancelAnimationFrame || window8.oCancelAnimationFrame || window8.msCancelAnimationFrame;
      if (nativeRequest && nativeCancel) {
        request = nativeRequest;
        cancel = nativeCancel;
      }
      if (nativeRequest && !nativeCancel) {
        var canceledRequests = {};
        request = function(callback) {
          var requestId = nativeRequest.call(window8, function() {
            try {
              if (requestId in canceledRequests) {
                return;
              }
              callback.apply(this, arguments);
            } finally {
              delete canceledRequests[requestId];
            }
          });
          return requestId;
        };
        cancel = function(requestId) {
          canceledRequests[requestId] = true;
        };
      }
    });
  }
});

// node_modules/devextreme/esm/events/utils/event_nodes_disposing.js
function nodesByEvent(event) {
  return event && [event.target, event.delegateTarget, event.relatedTarget, event.currentTarget].filter((node) => !!node);
}
var subscribeNodesDisposing, unsubscribeNodesDisposing;
var init_event_nodes_disposing = __esm({
  "node_modules/devextreme/esm/events/utils/event_nodes_disposing.js"() {
    init_events_engine();
    init_remove();
    subscribeNodesDisposing = (event, callback) => {
      events_engine_default.one(nodesByEvent(event), removeEvent, callback);
    };
    unsubscribeNodesDisposing = (event, callback) => {
      events_engine_default.off(nodesByEvent(event), removeEvent, callback);
    };
  }
});

// node_modules/devextreme/esm/events/core/emitter.js
var Emitter, emitter_default;
var init_emitter = __esm({
  "node_modules/devextreme/esm/events/core/emitter.js"() {
    init_renderer();
    init_common();
    init_class();
    init_callbacks();
    init_extend();
    init_utils2();
    Emitter = class_default.inherit({
      ctor: function(element) {
        this._$element = renderer_default(element);
        this._cancelCallback = callbacks_default();
        this._acceptCallback = callbacks_default();
      },
      getElement: function() {
        return this._$element;
      },
      validate: function(e) {
        return !isDxMouseWheelEvent(e);
      },
      validatePointers: function(e) {
        return 1 === hasTouches(e);
      },
      allowInterruptionByMouseWheel: function() {
        return true;
      },
      configure: function(data2) {
        extend2(this, data2);
      },
      addCancelCallback: function(callback) {
        this._cancelCallback.add(callback);
      },
      removeCancelCallback: function() {
        this._cancelCallback.empty();
      },
      _cancel: function(e) {
        this._cancelCallback.fire(this, e);
      },
      addAcceptCallback: function(callback) {
        this._acceptCallback.add(callback);
      },
      removeAcceptCallback: function() {
        this._acceptCallback.empty();
      },
      _accept: function(e) {
        this._acceptCallback.fire(this, e);
      },
      _requestAccept: function(e) {
        this._acceptRequestEvent = e;
      },
      _forgetAccept: function() {
        this._accept(this._acceptRequestEvent);
        this._acceptRequestEvent = null;
      },
      start: noop2,
      move: noop2,
      end: noop2,
      cancel: noop2,
      reset: function() {
        if (this._acceptRequestEvent) {
          this._accept(this._acceptRequestEvent);
        }
      },
      _fireEvent: function(eventName, e, params) {
        var eventData2 = extend2({
          type: eventName,
          originalEvent: e,
          target: this._getEmitterTarget(e),
          delegateTarget: this.getElement().get(0)
        }, params);
        e = fireEvent(eventData2);
        if (e.cancel) {
          this._cancel(e);
        }
        return e;
      },
      _getEmitterTarget: function(e) {
        return (this.delegateSelector ? renderer_default(e.target).closest(this.delegateSelector) : this.getElement()).get(0);
      },
      dispose: noop2
    });
    emitter_default = Emitter;
  }
});

// node_modules/devextreme/esm/events/core/wheel.js
var EVENT_NAME, EVENT_NAMESPACE, NATIVE_EVENT_NAME, PIXEL_MODE, DELTA_MUTLIPLIER, wheel;
var init_wheel = __esm({
  "node_modules/devextreme/esm/events/core/wheel.js"() {
    init_renderer();
    init_events_engine();
    init_event_registrator();
    init_utils2();
    EVENT_NAME = "dxmousewheel";
    EVENT_NAMESPACE = "dxWheel";
    NATIVE_EVENT_NAME = "wheel";
    PIXEL_MODE = 0;
    DELTA_MUTLIPLIER = 30;
    wheel = {
      setup: function(element) {
        var $element = renderer_default(element);
        events_engine_default.on($element, addNamespace2(NATIVE_EVENT_NAME, EVENT_NAMESPACE), wheel._wheelHandler.bind(wheel));
      },
      teardown: function(element) {
        events_engine_default.off(element, ".".concat(EVENT_NAMESPACE));
      },
      _wheelHandler: function(e) {
        var {
          deltaMode,
          deltaY,
          deltaX,
          deltaZ
        } = e.originalEvent;
        fireEvent({
          type: EVENT_NAME,
          originalEvent: e,
          delta: this._normalizeDelta(deltaY, deltaMode),
          deltaX,
          deltaY,
          deltaZ,
          deltaMode,
          pointerType: "mouse"
        });
        e.stopPropagation();
      },
      _normalizeDelta(delta) {
        var deltaMode = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : PIXEL_MODE;
        if (deltaMode === PIXEL_MODE) {
          return -delta;
        } else {
          return -DELTA_MUTLIPLIER * delta;
        }
      }
    };
    event_registrator_default(EVENT_NAME, wheel);
  }
});

// node_modules/devextreme/esm/events/core/emitter_registrator.js
var MANAGER_EVENT, EMITTER_DATA, EventManager, eventManager, EMITTER_SUBSCRIPTION_DATA, registerEmitter, emitter_registrator_default;
var init_emitter_registrator = __esm({
  "node_modules/devextreme/esm/events/core/emitter_registrator.js"() {
    init_renderer();
    init_ready_callbacks();
    init_dom_adapter();
    init_events_engine();
    init_element_data();
    init_class();
    init_extend();
    init_array();
    init_iterator();
    init_event_registrator();
    init_utils2();
    init_pointer();
    init_wheel();
    MANAGER_EVENT = "dxEventManager";
    EMITTER_DATA = "dxEmitter";
    EventManager = class_default.inherit({
      ctor: function() {
        this._attachHandlers();
        this.reset();
        this._proxiedCancelHandler = this._cancelHandler.bind(this);
        this._proxiedAcceptHandler = this._acceptHandler.bind(this);
      },
      _attachHandlers: function() {
        ready_callbacks_default.add((function() {
          var document2 = dom_adapter_default.getDocument();
          events_engine_default.subscribeGlobal(document2, addNamespace2(pointer_default.down, MANAGER_EVENT), this._pointerDownHandler.bind(this));
          events_engine_default.subscribeGlobal(document2, addNamespace2(pointer_default.move, MANAGER_EVENT), this._pointerMoveHandler.bind(this));
          events_engine_default.subscribeGlobal(document2, addNamespace2([pointer_default.up, pointer_default.cancel].join(" "), MANAGER_EVENT), this._pointerUpHandler.bind(this));
          events_engine_default.subscribeGlobal(document2, addNamespace2(EVENT_NAME, MANAGER_EVENT), this._mouseWheelHandler.bind(this));
        }).bind(this));
      },
      _eachEmitter: function(callback) {
        var activeEmitters = this._activeEmitters || [];
        var i = 0;
        while (activeEmitters.length > i) {
          var emitter = activeEmitters[i];
          if (false === callback(emitter)) {
            break;
          }
          if (activeEmitters[i] === emitter) {
            i++;
          }
        }
      },
      _applyToEmitters: function(method, arg) {
        this._eachEmitter(function(emitter) {
          emitter[method].call(emitter, arg);
        });
      },
      reset: function() {
        this._eachEmitter(this._proxiedCancelHandler);
        this._activeEmitters = [];
      },
      resetEmitter: function(emitter) {
        this._proxiedCancelHandler(emitter);
      },
      _pointerDownHandler: function(e) {
        if (isMouseEvent(e) && e.which > 1) {
          return;
        }
        this._updateEmitters(e);
      },
      _updateEmitters: function(e) {
        if (!this._isSetChanged(e)) {
          return;
        }
        this._cleanEmitters(e);
        this._fetchEmitters(e);
      },
      _isSetChanged: function(e) {
        var currentSet = this._closestEmitter(e);
        var previousSet = this._emittersSet || [];
        var setChanged = currentSet.length !== previousSet.length;
        each(currentSet, function(index2, emitter) {
          setChanged = setChanged || previousSet[index2] !== emitter;
          return !setChanged;
        });
        this._emittersSet = currentSet;
        return setChanged;
      },
      _closestEmitter: function(e) {
        var that = this;
        var result2 = [];
        var $element = renderer_default(e.target);
        function handleEmitter(_2, emitter) {
          if (!!emitter && emitter.validatePointers(e) && emitter.validate(e)) {
            emitter.addCancelCallback(that._proxiedCancelHandler);
            emitter.addAcceptCallback(that._proxiedAcceptHandler);
            result2.push(emitter);
          }
        }
        while ($element.length) {
          var emitters = data($element.get(0), EMITTER_DATA) || [];
          each(emitters, handleEmitter);
          $element = $element.parent();
        }
        return result2;
      },
      _acceptHandler: function(acceptedEmitter, e) {
        var that = this;
        this._eachEmitter(function(emitter) {
          if (emitter !== acceptedEmitter) {
            that._cancelEmitter(emitter, e);
          }
        });
      },
      _cancelHandler: function(canceledEmitter, e) {
        this._cancelEmitter(canceledEmitter, e);
      },
      _cancelEmitter: function(emitter, e) {
        var activeEmitters = this._activeEmitters;
        if (e) {
          emitter.cancel(e);
        } else {
          emitter.reset();
        }
        emitter.removeCancelCallback();
        emitter.removeAcceptCallback();
        var emitterIndex = inArray(emitter, activeEmitters);
        if (emitterIndex > -1) {
          activeEmitters.splice(emitterIndex, 1);
        }
      },
      _cleanEmitters: function(e) {
        this._applyToEmitters("end", e);
        this.reset(e);
      },
      _fetchEmitters: function(e) {
        this._activeEmitters = this._emittersSet.slice();
        this._applyToEmitters("start", e);
      },
      _pointerMoveHandler: function(e) {
        this._applyToEmitters("move", e);
      },
      _pointerUpHandler: function(e) {
        this._updateEmitters(e);
      },
      _mouseWheelHandler: function(e) {
        if (!this._allowInterruptionByMouseWheel()) {
          return;
        }
        e.pointers = [null];
        this._pointerDownHandler(e);
        this._adjustWheelEvent(e);
        this._pointerMoveHandler(e);
        e.pointers = [];
        this._pointerUpHandler(e);
      },
      _allowInterruptionByMouseWheel: function() {
        var allowInterruption = true;
        this._eachEmitter(function(emitter) {
          allowInterruption = emitter.allowInterruptionByMouseWheel() && allowInterruption;
          return allowInterruption;
        });
        return allowInterruption;
      },
      _adjustWheelEvent: function(e) {
        var closestGestureEmitter = null;
        this._eachEmitter(function(emitter) {
          if (!emitter.gesture) {
            return;
          }
          var direction2 = emitter.getDirection(e);
          if ("horizontal" !== direction2 && !e.shiftKey || "vertical" !== direction2 && e.shiftKey) {
            closestGestureEmitter = emitter;
            return false;
          }
        });
        if (!closestGestureEmitter) {
          return;
        }
        var direction = closestGestureEmitter.getDirection(e);
        var verticalGestureDirection = "both" === direction && !e.shiftKey || "vertical" === direction;
        var prop = verticalGestureDirection ? "pageY" : "pageX";
        e[prop] += e.delta;
      },
      isActive: function(element) {
        var result2 = false;
        this._eachEmitter(function(emitter) {
          result2 = result2 || emitter.getElement().is(element);
        });
        return result2;
      }
    });
    eventManager = new EventManager();
    EMITTER_SUBSCRIPTION_DATA = "dxEmitterSubscription";
    registerEmitter = function(emitterConfig) {
      var emitterClass = emitterConfig.emitter;
      var emitterName = emitterConfig.events[0];
      var emitterEvents = emitterConfig.events;
      each(emitterEvents, function(_2, eventName) {
        event_registrator_default(eventName, {
          noBubble: !emitterConfig.bubble,
          setup: function(element) {
            var subscriptions = data(element, EMITTER_SUBSCRIPTION_DATA) || {};
            var emitters = data(element, EMITTER_DATA) || {};
            var emitter = emitters[emitterName] || new emitterClass(element);
            subscriptions[eventName] = true;
            emitters[emitterName] = emitter;
            data(element, EMITTER_DATA, emitters);
            data(element, EMITTER_SUBSCRIPTION_DATA, subscriptions);
          },
          add: function(element, handleObj) {
            var emitters = data(element, EMITTER_DATA);
            var emitter = emitters[emitterName];
            emitter.configure(extend2({
              delegateSelector: handleObj.selector
            }, handleObj.data), handleObj.type);
          },
          teardown: function(element) {
            var subscriptions = data(element, EMITTER_SUBSCRIPTION_DATA);
            var emitters = data(element, EMITTER_DATA);
            var emitter = emitters[emitterName];
            delete subscriptions[eventName];
            var disposeEmitter = true;
            each(emitterEvents, function(_3, eventName2) {
              disposeEmitter = disposeEmitter && !subscriptions[eventName2];
              return disposeEmitter;
            });
            if (disposeEmitter) {
              if (eventManager.isActive(element)) {
                eventManager.resetEmitter(emitter);
              }
              emitter && emitter.dispose();
              delete emitters[emitterName];
            }
          }
        });
      });
    };
    emitter_registrator_default = registerEmitter;
  }
});

// node_modules/devextreme/esm/core/utils/version.js
function compare(x, y, maxLevel) {
  function normalizeArg(value2) {
    if ("string" === typeof value2) {
      return value2.split(".");
    }
    if ("number" === typeof value2) {
      return [value2];
    }
    return value2;
  }
  x = normalizeArg(x);
  y = normalizeArg(y);
  var length = Math.max(x.length, y.length);
  if (isFinite(maxLevel)) {
    length = Math.min(length, maxLevel);
  }
  for (var i = 0; i < length; i++) {
    var xItem = parseInt(x[i] || 0, 10);
    var yItem = parseInt(y[i] || 0, 10);
    if (xItem < yItem) {
      return -1;
    }
    if (xItem > yItem) {
      return 1;
    }
  }
  return 0;
}
var init_version2 = __esm({
  "node_modules/devextreme/esm/core/utils/version.js"() {
  }
});

// node_modules/devextreme/esm/events/click.js
var CLICK_EVENT_NAME, TOUCH_BOUNDARY, abs, isInput, misc, ClickEmitter, realDevice, useNativeClick;
var init_click = __esm({
  "node_modules/devextreme/esm/events/click.js"() {
    init_renderer();
    init_events_engine();
    init_devices();
    init_dom_adapter();
    init_dom();
    init_frame();
    init_utils2();
    init_event_nodes_disposing();
    init_pointer();
    init_emitter();
    init_emitter_registrator();
    init_version2();
    CLICK_EVENT_NAME = "dxclick";
    TOUCH_BOUNDARY = 10;
    abs = Math.abs;
    isInput = function(element) {
      return renderer_default(element).is("input, textarea, select, button ,:focus, :focus *");
    };
    misc = {
      requestAnimationFrame,
      cancelAnimationFrame
    };
    ClickEmitter = emitter_default.inherit({
      ctor: function(element) {
        this.callBase(element);
        this._makeElementClickable(renderer_default(element));
      },
      _makeElementClickable: function($element) {
        if (!$element.attr("onclick")) {
          $element.attr("onclick", "void(0)");
        }
      },
      start: function(e) {
        this._blurPrevented = e.isDefaultPrevented();
        this._startTarget = e.target;
        this._startEventData = eventData(e);
      },
      end: function(e) {
        if (this._eventOutOfElement(e, this.getElement().get(0)) || e.type === pointer_default.cancel) {
          this._cancel(e);
          return;
        }
        if (!isInput(e.target) && !this._blurPrevented) {
          resetActiveElement();
        }
        this._accept(e);
        this._clickAnimationFrame = misc.requestAnimationFrame((function() {
          this._fireClickEvent(e);
        }).bind(this));
      },
      _eventOutOfElement: function(e, element) {
        var target = e.target;
        var targetChanged = !contains2(element, target) && element !== target;
        var gestureDelta = eventDelta(eventData(e), this._startEventData);
        var boundsExceeded = abs(gestureDelta.x) > TOUCH_BOUNDARY || abs(gestureDelta.y) > TOUCH_BOUNDARY;
        return targetChanged || boundsExceeded;
      },
      _fireClickEvent: function(e) {
        this._fireEvent(CLICK_EVENT_NAME, e, {
          target: closestCommonParent(this._startTarget, e.target)
        });
      },
      dispose: function() {
        misc.cancelAnimationFrame(this._clickAnimationFrame);
      }
    });
    realDevice = devices_default.real();
    useNativeClick = realDevice.generic || realDevice.ios && compare(realDevice.version, [9, 3]) >= 0 || realDevice.android && compare(realDevice.version, [5]) >= 0;
    !function() {
      var isNativeClickEvent = function(target) {
        return useNativeClick || renderer_default(target).closest(".dx-native-click").length;
      };
      var prevented = null;
      var lastFiredEvent = null;
      function onNodeRemove() {
        lastFiredEvent = null;
      }
      var clickHandler = function(e) {
        var originalEvent = e.originalEvent;
        var eventAlreadyFired = lastFiredEvent === originalEvent || originalEvent && originalEvent.DXCLICK_FIRED;
        var leftButton = !e.which || 1 === e.which;
        if (leftButton && !prevented && isNativeClickEvent(e.target) && !eventAlreadyFired) {
          if (originalEvent) {
            originalEvent.DXCLICK_FIRED = true;
          }
          unsubscribeNodesDisposing(lastFiredEvent, onNodeRemove);
          lastFiredEvent = originalEvent;
          subscribeNodesDisposing(lastFiredEvent, onNodeRemove);
          fireEvent({
            type: CLICK_EVENT_NAME,
            originalEvent: e
          });
        }
      };
      ClickEmitter = ClickEmitter.inherit({
        _makeElementClickable: function($element) {
          if (!isNativeClickEvent($element)) {
            this.callBase($element);
          }
          events_engine_default.on($element, "click", clickHandler);
        },
        configure: function(data2) {
          this.callBase(data2);
          if (data2.useNative) {
            this.getElement().addClass("dx-native-click");
          }
        },
        start: function(e) {
          prevented = null;
          if (!isNativeClickEvent(e.target)) {
            this.callBase(e);
          }
        },
        end: function(e) {
          if (!isNativeClickEvent(e.target)) {
            this.callBase(e);
          }
        },
        cancel: function() {
          prevented = true;
        },
        dispose: function() {
          this.callBase();
          events_engine_default.off(this.getElement(), "click", clickHandler);
        }
      });
    }();
    !function() {
      var desktopDevice = devices_default.real().generic;
      if (!desktopDevice) {
        var startTarget = null;
        var blurPrevented = false;
        var document2 = dom_adapter_default.getDocument();
        events_engine_default.subscribeGlobal(document2, addNamespace2(pointer_default.down, "NATIVE_CLICK_FIXER"), function(e) {
          startTarget = e.target;
          blurPrevented = e.isDefaultPrevented();
        });
        events_engine_default.subscribeGlobal(document2, addNamespace2("click", "NATIVE_CLICK_FIXER"), function(e) {
          var $target = renderer_default(e.target);
          if (!blurPrevented && startTarget && !$target.is(startTarget) && !renderer_default(startTarget).is("label") && isInput($target)) {
            resetActiveElement();
          }
          startTarget = null;
          blurPrevented = false;
        });
      }
    }();
    emitter_registrator_default({
      emitter: ClickEmitter,
      bubble: true,
      events: [CLICK_EVENT_NAME]
    });
  }
});

// node_modules/devextreme/esm/events/core/emitter.feedback.js
var ACTIVE_EVENT_NAME, INACTIVE_EVENT_NAME, ACTIVE_TIMEOUT, INACTIVE_TIMEOUT, FeedbackEvent, activeFeedback, FeedbackEmitter, lock;
var init_emitter_feedback = __esm({
  "node_modules/devextreme/esm/events/core/emitter.feedback.js"() {
    init_class();
    init_common();
    init_dom();
    init_devices();
    init_utils2();
    init_pointer();
    init_emitter();
    init_emitter_registrator();
    ACTIVE_EVENT_NAME = "dxactive";
    INACTIVE_EVENT_NAME = "dxinactive";
    ACTIVE_TIMEOUT = 30;
    INACTIVE_TIMEOUT = 400;
    FeedbackEvent = class_default.inherit({
      ctor: function(timeout, fire) {
        this._timeout = timeout;
        this._fire = fire;
      },
      start: function() {
        var that = this;
        this._schedule(function() {
          that.force();
        });
      },
      _schedule: function(fn) {
        this.stop();
        this._timer = setTimeout(fn, this._timeout);
      },
      stop: function() {
        clearTimeout(this._timer);
      },
      force: function() {
        if (this._fired) {
          return;
        }
        this.stop();
        this._fire();
        this._fired = true;
      },
      fired: function() {
        return this._fired;
      }
    });
    FeedbackEmitter = emitter_default.inherit({
      ctor: function() {
        this.callBase.apply(this, arguments);
        this._active = new FeedbackEvent(0, noop2);
        this._inactive = new FeedbackEvent(0, noop2);
      },
      configure: function(data2, eventName) {
        switch (eventName) {
          case ACTIVE_EVENT_NAME:
            data2.activeTimeout = data2.timeout;
            break;
          case INACTIVE_EVENT_NAME:
            data2.inactiveTimeout = data2.timeout;
        }
        this.callBase(data2);
      },
      start: function(e) {
        if (activeFeedback) {
          var activeChildExists = contains2(this.getElement().get(0), activeFeedback.getElement().get(0));
          var childJustActivated = !activeFeedback._active.fired();
          if (activeChildExists && childJustActivated) {
            this._cancel();
            return;
          }
          activeFeedback._inactive.force();
        }
        activeFeedback = this;
        this._initEvents(e);
        this._active.start();
      },
      _initEvents: function(e) {
        var that = this;
        var eventTarget = this._getEmitterTarget(e);
        var mouseEvent = isMouseEvent(e);
        var isSimulator = devices_default.isSimulator();
        var deferFeedback = isSimulator || !mouseEvent;
        var activeTimeout = ensureDefined(this.activeTimeout, ACTIVE_TIMEOUT);
        var inactiveTimeout = ensureDefined(this.inactiveTimeout, INACTIVE_TIMEOUT);
        this._active = new FeedbackEvent(deferFeedback ? activeTimeout : 0, function() {
          that._fireEvent(ACTIVE_EVENT_NAME, e, {
            target: eventTarget
          });
        });
        this._inactive = new FeedbackEvent(deferFeedback ? inactiveTimeout : 0, function() {
          that._fireEvent(INACTIVE_EVENT_NAME, e, {
            target: eventTarget
          });
          activeFeedback = null;
        });
      },
      cancel: function(e) {
        this.end(e);
      },
      end: function(e) {
        var skipTimers = e.type !== pointer_default.up;
        if (skipTimers) {
          this._active.stop();
        } else {
          this._active.force();
        }
        this._inactive.start();
        if (skipTimers) {
          this._inactive.force();
        }
      },
      dispose: function() {
        this._active.stop();
        this._inactive.stop();
        if (activeFeedback === this) {
          activeFeedback = null;
        }
        this.callBase();
      },
      lockInactive: function() {
        this._active.force();
        this._inactive.stop();
        activeFeedback = null;
        this._cancel();
        return this._inactive.force.bind(this._inactive);
      }
    });
    FeedbackEmitter.lock = function(deferred) {
      var lockInactive = activeFeedback ? activeFeedback.lockInactive() : noop2;
      deferred.done(lockInactive);
    };
    emitter_registrator_default({
      emitter: FeedbackEmitter,
      events: [ACTIVE_EVENT_NAME, INACTIVE_EVENT_NAME]
    });
    lock = FeedbackEmitter.lock;
  }
});

// node_modules/devextreme/esm/events/hover.js
var HOVERSTART_NAMESPACE, HOVERSTART, POINTERENTER_NAMESPACED_EVENT_NAME, HOVEREND_NAMESPACE, HOVEREND, POINTERLEAVE_NAMESPACED_EVENT_NAME, Hover, HoverStart, HoverEnd;
var init_hover = __esm({
  "node_modules/devextreme/esm/events/hover.js"() {
    init_events_engine();
    init_element_data();
    init_class();
    init_devices();
    init_event_registrator();
    init_utils2();
    init_pointer();
    HOVERSTART_NAMESPACE = "dxHoverStart";
    HOVERSTART = "dxhoverstart";
    POINTERENTER_NAMESPACED_EVENT_NAME = addNamespace2(pointer_default.enter, HOVERSTART_NAMESPACE);
    HOVEREND_NAMESPACE = "dxHoverEnd";
    HOVEREND = "dxhoverend";
    POINTERLEAVE_NAMESPACED_EVENT_NAME = addNamespace2(pointer_default.leave, HOVEREND_NAMESPACE);
    Hover = class_default.inherit({
      noBubble: true,
      ctor: function() {
        this._handlerArrayKeyPath = this._eventNamespace + "_HandlerStore";
      },
      setup: function(element) {
        data(element, this._handlerArrayKeyPath, {});
      },
      add: function(element, handleObj) {
        var that = this;
        var handler = function(e) {
          that._handler(e);
        };
        events_engine_default.on(element, this._originalEventName, handleObj.selector, handler);
        data(element, this._handlerArrayKeyPath)[handleObj.guid] = handler;
      },
      _handler: function(e) {
        if (isTouchEvent(e) || devices_default.isSimulator()) {
          return;
        }
        fireEvent({
          type: this._eventName,
          originalEvent: e,
          delegateTarget: e.delegateTarget
        });
      },
      remove: function(element, handleObj) {
        var handler = data(element, this._handlerArrayKeyPath)[handleObj.guid];
        events_engine_default.off(element, this._originalEventName, handleObj.selector, handler);
      },
      teardown: function(element) {
        removeData(element, this._handlerArrayKeyPath);
      }
    });
    HoverStart = Hover.inherit({
      ctor: function() {
        this._eventNamespace = HOVERSTART_NAMESPACE;
        this._eventName = HOVERSTART;
        this._originalEventName = POINTERENTER_NAMESPACED_EVENT_NAME;
        this.callBase();
      },
      _handler: function(e) {
        var pointers = e.pointers || [];
        if (!pointers.length) {
          this.callBase(e);
        }
      }
    });
    HoverEnd = Hover.inherit({
      ctor: function() {
        this._eventNamespace = HOVEREND_NAMESPACE;
        this._eventName = HOVEREND;
        this._originalEventName = POINTERLEAVE_NAMESPACED_EVENT_NAME;
        this.callBase();
      }
    });
    event_registrator_default(HOVERSTART, new HoverStart());
    event_registrator_default(HOVEREND, new HoverEnd());
  }
});

// node_modules/devextreme/esm/ui/widget/ui.widget.js
function setAttribute(name2, value2, target) {
  name2 = "role" === name2 || "id" === name2 ? name2 : "aria-".concat(name2);
  value2 = isDefined(value2) ? value2.toString() : null;
  target.attr(name2, value2);
}
var Widget, ui_widget_default;
var init_ui_widget = __esm({
  "node_modules/devextreme/esm/ui/widget/ui.widget.js"() {
    init_renderer();
    init_action();
    init_dom_component();
    init_short();
    init_common();
    init_iterator();
    init_extend();
    init_selectors();
    init_array();
    init_type();
    init_click();
    init_emitter_feedback();
    init_hover();
    Widget = dom_component_default.inherit({
      _feedbackHideTimeout: 400,
      _feedbackShowTimeout: 30,
      _supportedKeys: () => ({}),
      _getDefaultOptions() {
        return extend2(this.callBase(), {
          hoveredElement: null,
          isActive: false,
          disabled: false,
          visible: true,
          hint: void 0,
          activeStateEnabled: false,
          onContentReady: null,
          hoverStateEnabled: false,
          focusStateEnabled: false,
          tabIndex: 0,
          accessKey: void 0,
          onFocusIn: null,
          onFocusOut: null,
          onKeyboardHandled: null,
          ignoreParentReadOnly: false
        });
      },
      _init() {
        this.callBase();
        this._initContentReadyAction();
      },
      _innerWidgetOptionChanged: function(innerWidget, args) {
        var options2 = Widget.getOptionsFromContainer(args);
        innerWidget && innerWidget.option(options2);
        this._options.cache(args.name, options2);
      },
      _bindInnerWidgetOptions(innerWidget, optionsContainer) {
        var syncOptions = () => this._options.silent(optionsContainer, extend2({}, innerWidget.option()));
        syncOptions();
        innerWidget.on("optionChanged", syncOptions);
      },
      _getAriaTarget() {
        return this._focusTarget();
      },
      _initContentReadyAction() {
        this._contentReadyAction = this._createActionByOption("onContentReady", {
          excludeValidators: ["disabled", "readOnly"]
        });
      },
      _initMarkup() {
        var {
          disabled,
          visible: visible2
        } = this.option();
        this.$element().addClass("dx-widget");
        this._toggleDisabledState(disabled);
        this._toggleVisibility(visible2);
        this._renderHint();
        this._isFocusable() && this._renderFocusTarget();
        this.callBase();
      },
      _render() {
        this.callBase();
        this._renderContent();
        this._renderFocusState();
        this._attachFeedbackEvents();
        this._attachHoverEvents();
        this._toggleIndependentState();
      },
      _renderHint() {
        var {
          hint
        } = this.option();
        this.$element().attr("title", hint || null);
      },
      _renderContent() {
        deferRender(() => !this._disposed ? this._renderContentImpl() : void 0).done(() => !this._disposed ? this._fireContentReadyAction() : void 0);
      },
      _renderContentImpl: noop2,
      _fireContentReadyAction: deferRenderer(function() {
        return this._contentReadyAction();
      }),
      _dispose() {
        this._contentReadyAction = null;
        this._detachKeyboardEvents();
        this.callBase();
      },
      _resetActiveState() {
        this._toggleActiveState(this._eventBindingTarget(), false);
      },
      _clean() {
        this._cleanFocusState();
        this._resetActiveState();
        this.callBase();
        this.$element().empty();
      },
      _toggleVisibility(visible2) {
        this.$element().toggleClass("dx-state-invisible", !visible2);
        this.setAria("hidden", !visible2 || void 0);
      },
      _renderFocusState() {
        this._attachKeyboardEvents();
        if (this._isFocusable()) {
          this._renderFocusTarget();
          this._attachFocusEvents();
          this._renderAccessKey();
        }
      },
      _renderAccessKey() {
        var $el = this._focusTarget();
        var {
          accessKey
        } = this.option();
        $el.attr("accesskey", accessKey);
      },
      _isFocusable() {
        var {
          focusStateEnabled,
          disabled
        } = this.option();
        return focusStateEnabled && !disabled;
      },
      _eventBindingTarget() {
        return this.$element();
      },
      _focusTarget() {
        return this._getActiveElement();
      },
      _getActiveElement() {
        var activeElement = this._eventBindingTarget();
        if (this._activeStateUnit) {
          return activeElement.find(this._activeStateUnit).not(".dx-state-disabled");
        }
        return activeElement;
      },
      _renderFocusTarget() {
        var {
          tabIndex
        } = this.option();
        this._focusTarget().attr("tabIndex", tabIndex);
      },
      _keyboardEventBindingTarget() {
        return this._eventBindingTarget();
      },
      _refreshFocusEvent() {
        this._detachFocusEvents();
        this._attachFocusEvents();
      },
      _focusEventTarget() {
        return this._focusTarget();
      },
      _focusInHandler(event) {
        if (!event.isDefaultPrevented()) {
          this._createActionByOption("onFocusIn", {
            beforeExecute: () => this._updateFocusState(event, true),
            excludeValidators: ["readOnly"]
          })({
            event
          });
        }
      },
      _focusOutHandler(event) {
        if (!event.isDefaultPrevented()) {
          this._createActionByOption("onFocusOut", {
            beforeExecute: () => this._updateFocusState(event, false),
            excludeValidators: ["readOnly", "disabled"]
          })({
            event
          });
        }
      },
      _updateFocusState(_ref, isFocused) {
        var {
          target
        } = _ref;
        if (-1 !== inArray(target, this._focusTarget())) {
          this._toggleFocusClass(isFocused, renderer_default(target));
        }
      },
      _toggleFocusClass(isFocused, $element) {
        var $focusTarget = $element && $element.length ? $element : this._focusTarget();
        $focusTarget.toggleClass("dx-state-focused", isFocused);
      },
      _hasFocusClass(element) {
        var $focusTarget = renderer_default(element || this._focusTarget());
        return $focusTarget.hasClass("dx-state-focused");
      },
      _isFocused() {
        return this._hasFocusClass();
      },
      _getKeyboardListeners: () => [],
      _attachKeyboardEvents() {
        this._detachKeyboardEvents();
        var {
          focusStateEnabled,
          onKeyboardHandled
        } = this.option();
        var hasChildListeners = this._getKeyboardListeners().length;
        var hasKeyboardEventHandler = !!onKeyboardHandled;
        var shouldAttach = focusStateEnabled || hasChildListeners || hasKeyboardEventHandler;
        if (shouldAttach) {
          this._keyboardListenerId = keyboard.on(this._keyboardEventBindingTarget(), this._focusTarget(), (opts) => this._keyboardHandler(opts));
        }
      },
      _keyboardHandler(options2, onlyChildProcessing) {
        if (!onlyChildProcessing) {
          var {
            originalEvent,
            keyName,
            which
          } = options2;
          var keys = this._supportedKeys(originalEvent);
          var func = keys[keyName] || keys[which];
          if (void 0 !== func) {
            var handler = func.bind(this);
            var result2 = handler(originalEvent, options2);
            if (!result2) {
              return false;
            }
          }
        }
        var keyboardListeners = this._getKeyboardListeners();
        var {
          onKeyboardHandled
        } = this.option();
        keyboardListeners.forEach((listener) => listener && listener._keyboardHandler(options2));
        onKeyboardHandled && onKeyboardHandled(options2);
        return true;
      },
      _refreshFocusState() {
        this._cleanFocusState();
        this._renderFocusState();
      },
      _cleanFocusState() {
        var $element = this._focusTarget();
        $element.removeAttr("tabIndex");
        this._toggleFocusClass(false);
        this._detachFocusEvents();
        this._detachKeyboardEvents();
      },
      _detachKeyboardEvents() {
        keyboard.off(this._keyboardListenerId);
        this._keyboardListenerId = null;
      },
      _attachHoverEvents() {
        var {
          hoverStateEnabled
        } = this.option();
        var selector = this._activeStateUnit;
        var $el = this._eventBindingTarget();
        hover.off($el, {
          selector,
          namespace: "UIFeedback"
        });
        if (hoverStateEnabled) {
          hover.on($el, new Action((_ref2) => {
            var {
              event,
              element
            } = _ref2;
            this._hoverStartHandler(event);
            this.option("hoveredElement", renderer_default(element));
          }, {
            excludeValidators: ["readOnly"]
          }), (event) => {
            this.option("hoveredElement", null);
            this._hoverEndHandler(event);
          }, {
            selector,
            namespace: "UIFeedback"
          });
        }
      },
      _attachFeedbackEvents() {
        var {
          activeStateEnabled
        } = this.option();
        var selector = this._activeStateUnit;
        var $el = this._eventBindingTarget();
        active.off($el, {
          namespace: "UIFeedback",
          selector
        });
        if (activeStateEnabled) {
          active.on($el, new Action((_ref3) => {
            var {
              event,
              element
            } = _ref3;
            return this._toggleActiveState(renderer_default(element), true, event);
          }), new Action((_ref4) => {
            var {
              event,
              element
            } = _ref4;
            return this._toggleActiveState(renderer_default(element), false, event);
          }, {
            excludeValidators: ["disabled", "readOnly"]
          }), {
            showTimeout: this._feedbackShowTimeout,
            hideTimeout: this._feedbackHideTimeout,
            selector,
            namespace: "UIFeedback"
          });
        }
      },
      _detachFocusEvents() {
        var $el = this._focusEventTarget();
        focus.off($el, {
          namespace: "".concat(this.NAME, "Focus")
        });
      },
      _attachFocusEvents() {
        var $el = this._focusEventTarget();
        focus.on($el, (e) => this._focusInHandler(e), (e) => this._focusOutHandler(e), {
          namespace: "".concat(this.NAME, "Focus"),
          isFocusable: (index2, el) => renderer_default(el).is(focusable)
        });
      },
      _hoverStartHandler: noop2,
      _hoverEndHandler: noop2,
      _toggleActiveState($element, value2) {
        this.option("isActive", value2);
        $element.toggleClass("dx-state-active", value2);
      },
      _updatedHover() {
        var hoveredElement = this._options.silent("hoveredElement");
        this._hover(hoveredElement, hoveredElement);
      },
      _findHoverTarget($el) {
        return $el && $el.closest(this._activeStateUnit || this._eventBindingTarget());
      },
      _hover($el, $previous) {
        var {
          hoverStateEnabled,
          disabled,
          isActive
        } = this.option();
        $previous = this._findHoverTarget($previous);
        $previous && $previous.toggleClass("dx-state-hover", false);
        if ($el && hoverStateEnabled && !disabled && !isActive) {
          var newHoveredElement = this._findHoverTarget($el);
          newHoveredElement && newHoveredElement.toggleClass("dx-state-hover", true);
        }
      },
      _toggleDisabledState(value2) {
        this.$element().toggleClass("dx-state-disabled", Boolean(value2));
        this.setAria("disabled", value2 || void 0);
      },
      _toggleIndependentState() {
        this.$element().toggleClass("dx-state-independent", this.option("ignoreParentReadOnly"));
      },
      _setWidgetOption(widgetName, args) {
        if (!this[widgetName]) {
          return;
        }
        if (isPlainObject(args[0])) {
          each(args[0], (option, value3) => this._setWidgetOption(widgetName, [option, value3]));
          return;
        }
        var optionName = args[0];
        var value2 = args[1];
        if (1 === args.length) {
          value2 = this.option(optionName);
        }
        var widgetOptionMap = this["".concat(widgetName, "OptionMap")];
        this[widgetName].option(widgetOptionMap ? widgetOptionMap(optionName) : optionName, value2);
      },
      _optionChanged(args) {
        var {
          name: name2,
          value: value2,
          previousValue
        } = args;
        switch (name2) {
          case "disabled":
            this._toggleDisabledState(value2);
            this._updatedHover();
            this._refreshFocusState();
            break;
          case "hint":
            this._renderHint();
            break;
          case "ignoreParentReadOnly":
            this._toggleIndependentState();
            break;
          case "activeStateEnabled":
            this._attachFeedbackEvents();
            break;
          case "hoverStateEnabled":
            this._attachHoverEvents();
            this._updatedHover();
            break;
          case "tabIndex":
          case "focusStateEnabled":
            this._refreshFocusState();
            break;
          case "onFocusIn":
          case "onFocusOut":
            break;
          case "accessKey":
            this._renderAccessKey();
            break;
          case "hoveredElement":
            this._hover(value2, previousValue);
            break;
          case "isActive":
            this._updatedHover();
            break;
          case "visible":
            this._toggleVisibility(value2);
            if (this._isVisibilityChangeSupported()) {
              this._checkVisibilityChanged(value2 ? "shown" : "hiding");
            }
            break;
          case "onKeyboardHandled":
            this._attachKeyboardEvents();
            break;
          case "onContentReady":
            this._initContentReadyAction();
            break;
          default:
            this.callBase(args);
        }
      },
      _isVisible() {
        var {
          visible: visible2
        } = this.option();
        return this.callBase() && visible2;
      },
      beginUpdate() {
        this._ready(false);
        this.callBase();
      },
      endUpdate() {
        this.callBase();
        if (this._initialized) {
          this._ready(true);
        }
      },
      _ready(value2) {
        if (0 === arguments.length) {
          return this._isReady;
        }
        this._isReady = value2;
      },
      setAria() {
        if (!isPlainObject(arguments.length <= 0 ? void 0 : arguments[0])) {
          setAttribute(arguments.length <= 0 ? void 0 : arguments[0], arguments.length <= 1 ? void 0 : arguments[1], (arguments.length <= 2 ? void 0 : arguments[2]) || this._getAriaTarget());
        } else {
          var target = (arguments.length <= 1 ? void 0 : arguments[1]) || this._getAriaTarget();
          each(arguments.length <= 0 ? void 0 : arguments[0], (name2, value2) => setAttribute(name2, value2, target));
        }
      },
      isReady() {
        return this._ready();
      },
      repaint() {
        this._refresh();
      },
      focus() {
        focus.trigger(this._focusTarget());
      },
      registerKeyHandler(key, handler) {
        var currentKeys = this._supportedKeys();
        this._supportedKeys = () => extend2(currentKeys, {
          [key]: handler
        });
      }
    });
    Widget.getOptionsFromContainer = (_ref5) => {
      var {
        name: name2,
        fullName,
        value: value2
      } = _ref5;
      var options2 = {};
      if (name2 === fullName) {
        options2 = value2;
      } else {
        var option = fullName.split(".").pop();
        options2[option] = value2;
      }
      return options2;
    };
    ui_widget_default = Widget;
  }
});

// node_modules/devextreme/esm/core/utils/position.js
var getDefaultAlignment, getElementsFromPoint, getBoundingRect;
var init_position = __esm({
  "node_modules/devextreme/esm/core/utils/position.js"() {
    init_config();
    init_dom_adapter();
    init_browser();
    init_type();
    getDefaultAlignment = (isRtlEnabled) => {
      var rtlEnabled = null !== isRtlEnabled && void 0 !== isRtlEnabled ? isRtlEnabled : config_default().rtlEnabled;
      return rtlEnabled ? "right" : "left";
    };
    getElementsFromPoint = (x, y) => {
      var document2 = dom_adapter_default.getDocument();
      if (browser_default.msie) {
        var result2 = document2.msElementsFromPoint(x, y);
        if (result2) {
          return Array.prototype.slice.call(result2);
        }
        return [];
      }
      return document2.elementsFromPoint(x, y);
    };
    getBoundingRect = (element) => {
      if (isWindow(element)) {
        return {
          width: element.outerWidth,
          height: element.outerHeight
        };
      }
      var rect;
      try {
        rect = element.getBoundingClientRect();
      } catch (e) {
        rect = {
          width: 0,
          height: 0,
          bottom: 0,
          top: 0,
          left: 0,
          right: 0
        };
      }
      return rect;
    };
  }
});

// node_modules/devextreme/esm/localization/cldr-data/parent_locales.js
var parent_locales_default;
var init_parent_locales = __esm({
  "node_modules/devextreme/esm/localization/cldr-data/parent_locales.js"() {
    parent_locales_default = {
      "en-150": "en-001",
      "en-AG": "en-001",
      "en-AI": "en-001",
      "en-AU": "en-001",
      "en-BB": "en-001",
      "en-BM": "en-001",
      "en-BS": "en-001",
      "en-BW": "en-001",
      "en-BZ": "en-001",
      "en-CC": "en-001",
      "en-CK": "en-001",
      "en-CM": "en-001",
      "en-CX": "en-001",
      "en-CY": "en-001",
      "en-DG": "en-001",
      "en-DM": "en-001",
      "en-ER": "en-001",
      "en-FJ": "en-001",
      "en-FK": "en-001",
      "en-FM": "en-001",
      "en-GB": "en-001",
      "en-GD": "en-001",
      "en-GG": "en-001",
      "en-GH": "en-001",
      "en-GI": "en-001",
      "en-GM": "en-001",
      "en-GY": "en-001",
      "en-HK": "en-001",
      "en-IE": "en-001",
      "en-IL": "en-001",
      "en-IM": "en-001",
      "en-IN": "en-001",
      "en-IO": "en-001",
      "en-JE": "en-001",
      "en-JM": "en-001",
      "en-KE": "en-001",
      "en-KI": "en-001",
      "en-KN": "en-001",
      "en-KY": "en-001",
      "en-LC": "en-001",
      "en-LR": "en-001",
      "en-LS": "en-001",
      "en-MG": "en-001",
      "en-MO": "en-001",
      "en-MS": "en-001",
      "en-MT": "en-001",
      "en-MU": "en-001",
      "en-MV": "en-001",
      "en-MW": "en-001",
      "en-MY": "en-001",
      "en-NA": "en-001",
      "en-NF": "en-001",
      "en-NG": "en-001",
      "en-NR": "en-001",
      "en-NU": "en-001",
      "en-NZ": "en-001",
      "en-PG": "en-001",
      "en-PK": "en-001",
      "en-PN": "en-001",
      "en-PW": "en-001",
      "en-RW": "en-001",
      "en-SB": "en-001",
      "en-SC": "en-001",
      "en-SD": "en-001",
      "en-SG": "en-001",
      "en-SH": "en-001",
      "en-SL": "en-001",
      "en-SS": "en-001",
      "en-SX": "en-001",
      "en-SZ": "en-001",
      "en-TC": "en-001",
      "en-TK": "en-001",
      "en-TO": "en-001",
      "en-TT": "en-001",
      "en-TV": "en-001",
      "en-TZ": "en-001",
      "en-UG": "en-001",
      "en-VC": "en-001",
      "en-VG": "en-001",
      "en-VU": "en-001",
      "en-WS": "en-001",
      "en-ZA": "en-001",
      "en-ZM": "en-001",
      "en-ZW": "en-001",
      "en-AT": "en-150",
      "en-BE": "en-150",
      "en-CH": "en-150",
      "en-DE": "en-150",
      "en-DK": "en-150",
      "en-FI": "en-150",
      "en-NL": "en-150",
      "en-SE": "en-150",
      "en-SI": "en-150",
      "hi-Latn": "en-IN",
      "es-AR": "es-419",
      "es-BO": "es-419",
      "es-BR": "es-419",
      "es-BZ": "es-419",
      "es-CL": "es-419",
      "es-CO": "es-419",
      "es-CR": "es-419",
      "es-CU": "es-419",
      "es-DO": "es-419",
      "es-EC": "es-419",
      "es-GT": "es-419",
      "es-HN": "es-419",
      "es-MX": "es-419",
      "es-NI": "es-419",
      "es-PA": "es-419",
      "es-PE": "es-419",
      "es-PR": "es-419",
      "es-PY": "es-419",
      "es-SV": "es-419",
      "es-US": "es-419",
      "es-UY": "es-419",
      "es-VE": "es-419",
      nb: "no",
      nn: "no",
      "pt-AO": "pt-PT",
      "pt-CH": "pt-PT",
      "pt-CV": "pt-PT",
      "pt-FR": "pt-PT",
      "pt-GQ": "pt-PT",
      "pt-GW": "pt-PT",
      "pt-LU": "pt-PT",
      "pt-MO": "pt-PT",
      "pt-MZ": "pt-PT",
      "pt-ST": "pt-PT",
      "pt-TL": "pt-PT",
      "az-Arab": "und",
      "az-Cyrl": "und",
      "bal-Latn": "und",
      "blt-Latn": "und",
      "bm-Nkoo": "und",
      "bs-Cyrl": "und",
      "byn-Latn": "und",
      "cu-Glag": "und",
      "dje-Arab": "und",
      "dyo-Arab": "und",
      "en-Dsrt": "und",
      "en-Shaw": "und",
      "ff-Adlm": "und",
      "ff-Arab": "und",
      "ha-Arab": "und",
      "iu-Latn": "und",
      "kk-Arab": "und",
      "ks-Deva": "und",
      "ku-Arab": "und",
      "ky-Arab": "und",
      "ky-Latn": "und",
      "ml-Arab": "und",
      "mn-Mong": "und",
      "mni-Mtei": "und",
      "ms-Arab": "und",
      "pa-Arab": "und",
      "sat-Deva": "und",
      "sd-Deva": "und",
      "sd-Khoj": "und",
      "sd-Sind": "und",
      "shi-Latn": "und",
      "so-Arab": "und",
      "sr-Latn": "und",
      "sw-Arab": "und",
      "tg-Arab": "und",
      "ug-Cyrl": "und",
      "uz-Arab": "und",
      "uz-Cyrl": "und",
      "vai-Latn": "und",
      "wo-Arab": "und",
      "yo-Arab": "und",
      "yue-Hans": "und",
      "zh-Hant": "und",
      "zh-Hant-MO": "zh-Hant-HK"
    };
  }
});

// node_modules/devextreme/esm/localization/parentLocale.js
var PARENT_LOCALE_SEPARATOR, parentLocale_default;
var init_parentLocale = __esm({
  "node_modules/devextreme/esm/localization/parentLocale.js"() {
    PARENT_LOCALE_SEPARATOR = "-";
    parentLocale_default = (parentLocales, locale) => {
      var parentLocale = parentLocales[locale];
      if (parentLocale) {
        return "root" !== parentLocale && parentLocale;
      }
      return locale.substr(0, locale.lastIndexOf(PARENT_LOCALE_SEPARATOR));
    };
  }
});

// node_modules/devextreme/esm/localization/core.js
var DEFAULT_LOCALE, core_default;
var init_core = __esm({
  "node_modules/devextreme/esm/localization/core.js"() {
    init_dependency_injector();
    init_parent_locales();
    init_parentLocale();
    DEFAULT_LOCALE = "en";
    core_default = dependency_injector_default({
      locale: /* @__PURE__ */ (() => {
        var currentLocale = DEFAULT_LOCALE;
        return (locale) => {
          if (!locale) {
            return currentLocale;
          }
          currentLocale = locale;
        };
      })(),
      getValueByClosestLocale: function(getter) {
        var locale = this.locale();
        var value2 = getter(locale);
        var isRootLocale;
        while (!value2 && !isRootLocale) {
          locale = parentLocale_default(parent_locales_default, locale);
          if (locale) {
            value2 = getter(locale);
          } else {
            isRootLocale = true;
          }
        }
        if (void 0 === value2 && locale !== DEFAULT_LOCALE) {
          return getter(DEFAULT_LOCALE);
        }
        return value2;
      }
    });
  }
});

// node_modules/devextreme/esm/localization/default_messages.js
var defaultMessages;
var init_default_messages = __esm({
  "node_modules/devextreme/esm/localization/default_messages.js"() {
    defaultMessages = {
      en: {
        Yes: "Yes",
        No: "No",
        Cancel: "Cancel",
        Clear: "Clear",
        Done: "Done",
        Loading: "Loading...",
        Select: "Select...",
        Search: "Search",
        Back: "Back",
        OK: "OK",
        "dxCollectionWidget-noDataText": "No data to display",
        "dxDropDownEditor-selectLabel": "Select",
        "validation-required": "Required",
        "validation-required-formatted": "{0} is required",
        "validation-numeric": "Value must be a number",
        "validation-numeric-formatted": "{0} must be a number",
        "validation-range": "Value is out of range",
        "validation-range-formatted": "{0} is out of range",
        "validation-stringLength": "The length of the value is not correct",
        "validation-stringLength-formatted": "The length of {0} is not correct",
        "validation-custom": "Value is invalid",
        "validation-custom-formatted": "{0} is invalid",
        "validation-async": "Value is invalid",
        "validation-async-formatted": "{0} is invalid",
        "validation-compare": "Values do not match",
        "validation-compare-formatted": "{0} does not match",
        "validation-pattern": "Value does not match pattern",
        "validation-pattern-formatted": "{0} does not match pattern",
        "validation-email": "Email is invalid",
        "validation-email-formatted": "{0} is invalid",
        "validation-mask": "Value is invalid",
        "dxLookup-searchPlaceholder": "Minimum character number: {0}",
        "dxList-pullingDownText": "Pull down to refresh...",
        "dxList-pulledDownText": "Release to refresh...",
        "dxList-refreshingText": "Refreshing...",
        "dxList-pageLoadingText": "Loading...",
        "dxList-nextButtonText": "More",
        "dxList-selectAll": "Select All",
        "dxListEditDecorator-delete": "Delete",
        "dxListEditDecorator-more": "More",
        "dxScrollView-pullingDownText": "Pull down to refresh...",
        "dxScrollView-pulledDownText": "Release to refresh...",
        "dxScrollView-refreshingText": "Refreshing...",
        "dxScrollView-reachBottomText": "Loading...",
        "dxDateBox-simulatedDataPickerTitleTime": "Select time",
        "dxDateBox-simulatedDataPickerTitleDate": "Select date",
        "dxDateBox-simulatedDataPickerTitleDateTime": "Select date and time",
        "dxDateBox-validation-datetime": "Value must be a date or time",
        "dxFileUploader-selectFile": "Select a file",
        "dxFileUploader-dropFile": "or Drop a file here",
        "dxFileUploader-bytes": "bytes",
        "dxFileUploader-kb": "kb",
        "dxFileUploader-Mb": "Mb",
        "dxFileUploader-Gb": "Gb",
        "dxFileUploader-upload": "Upload",
        "dxFileUploader-uploaded": "Uploaded",
        "dxFileUploader-readyToUpload": "Ready to upload",
        "dxFileUploader-uploadAbortedMessage": "Upload cancelled",
        "dxFileUploader-uploadFailedMessage": "Upload failed",
        "dxFileUploader-invalidFileExtension": "File type is not allowed",
        "dxFileUploader-invalidMaxFileSize": "File is too large",
        "dxFileUploader-invalidMinFileSize": "File is too small",
        "dxRangeSlider-ariaFrom": "From",
        "dxRangeSlider-ariaTill": "Till",
        "dxSwitch-switchedOnText": "ON",
        "dxSwitch-switchedOffText": "OFF",
        "dxForm-optionalMark": "optional",
        "dxForm-requiredMessage": "{0} is required",
        "dxNumberBox-invalidValueMessage": "Value must be a number",
        "dxNumberBox-noDataText": "No data",
        "dxDataGrid-columnChooserTitle": "Column Chooser",
        "dxDataGrid-columnChooserEmptyText": "Drag a column here to hide it",
        "dxDataGrid-groupContinuesMessage": "Continues on the next page",
        "dxDataGrid-groupContinuedMessage": "Continued from the previous page",
        "dxDataGrid-groupHeaderText": "Group by This Column",
        "dxDataGrid-ungroupHeaderText": "Ungroup",
        "dxDataGrid-ungroupAllText": "Ungroup All",
        "dxDataGrid-editingEditRow": "Edit",
        "dxDataGrid-editingSaveRowChanges": "Save",
        "dxDataGrid-editingCancelRowChanges": "Cancel",
        "dxDataGrid-editingDeleteRow": "Delete",
        "dxDataGrid-editingUndeleteRow": "Undelete",
        "dxDataGrid-editingConfirmDeleteMessage": "Are you sure you want to delete this record?",
        "dxDataGrid-validationCancelChanges": "Cancel changes",
        "dxDataGrid-groupPanelEmptyText": "Drag a column header here to group by that column",
        "dxDataGrid-noDataText": "No data",
        "dxDataGrid-searchPanelPlaceholder": "Search...",
        "dxDataGrid-filterRowShowAllText": "(All)",
        "dxDataGrid-filterRowResetOperationText": "Reset",
        "dxDataGrid-filterRowOperationEquals": "Equals",
        "dxDataGrid-filterRowOperationNotEquals": "Does not equal",
        "dxDataGrid-filterRowOperationLess": "Less than",
        "dxDataGrid-filterRowOperationLessOrEquals": "Less than or equal to",
        "dxDataGrid-filterRowOperationGreater": "Greater than",
        "dxDataGrid-filterRowOperationGreaterOrEquals": "Greater than or equal to",
        "dxDataGrid-filterRowOperationStartsWith": "Starts with",
        "dxDataGrid-filterRowOperationContains": "Contains",
        "dxDataGrid-filterRowOperationNotContains": "Does not contain",
        "dxDataGrid-filterRowOperationEndsWith": "Ends with",
        "dxDataGrid-filterRowOperationBetween": "Between",
        "dxDataGrid-filterRowOperationBetweenStartText": "Start",
        "dxDataGrid-filterRowOperationBetweenEndText": "End",
        "dxDataGrid-applyFilterText": "Apply filter",
        "dxDataGrid-trueText": "true",
        "dxDataGrid-falseText": "false",
        "dxDataGrid-sortingAscendingText": "Sort Ascending",
        "dxDataGrid-sortingDescendingText": "Sort Descending",
        "dxDataGrid-sortingClearText": "Clear Sorting",
        "dxDataGrid-editingSaveAllChanges": "Save changes",
        "dxDataGrid-editingCancelAllChanges": "Discard changes",
        "dxDataGrid-editingAddRow": "Add a row",
        "dxDataGrid-summaryMin": "Min: {0}",
        "dxDataGrid-summaryMinOtherColumn": "Min of {1} is {0}",
        "dxDataGrid-summaryMax": "Max: {0}",
        "dxDataGrid-summaryMaxOtherColumn": "Max of {1} is {0}",
        "dxDataGrid-summaryAvg": "Avg: {0}",
        "dxDataGrid-summaryAvgOtherColumn": "Avg of {1} is {0}",
        "dxDataGrid-summarySum": "Sum: {0}",
        "dxDataGrid-summarySumOtherColumn": "Sum of {1} is {0}",
        "dxDataGrid-summaryCount": "Count: {0}",
        "dxDataGrid-columnFixingFix": "Fix",
        "dxDataGrid-columnFixingUnfix": "Unfix",
        "dxDataGrid-columnFixingLeftPosition": "To the left",
        "dxDataGrid-columnFixingRightPosition": "To the right",
        "dxDataGrid-exportTo": "Export",
        "dxDataGrid-exportToExcel": "Export to Excel file",
        "dxDataGrid-exporting": "Exporting...",
        "dxDataGrid-excelFormat": "Excel file",
        "dxDataGrid-selectedRows": "Selected rows",
        "dxDataGrid-exportSelectedRows": "Export selected rows",
        "dxDataGrid-exportAll": "Export all data",
        "dxDataGrid-headerFilterEmptyValue": "(Blanks)",
        "dxDataGrid-headerFilterOK": "OK",
        "dxDataGrid-headerFilterCancel": "Cancel",
        "dxDataGrid-ariaAdaptiveCollapse": "Hide additional data",
        "dxDataGrid-ariaAdaptiveExpand": "Display additional data",
        "dxDataGrid-ariaColumn": "Column",
        "dxDataGrid-ariaValue": "Value",
        "dxDataGrid-ariaFilterCell": "Filter cell",
        "dxDataGrid-ariaCollapse": "Collapse",
        "dxDataGrid-ariaExpand": "Expand",
        "dxDataGrid-ariaDataGrid": "Data grid",
        "dxDataGrid-ariaSearchInGrid": "Search in the data grid",
        "dxDataGrid-ariaSelectAll": "Select all",
        "dxDataGrid-ariaSelectRow": "Select row",
        "dxDataGrid-ariaToolbar": "Data grid toolbar",
        "dxDataGrid-filterBuilderPopupTitle": "Filter Builder",
        "dxDataGrid-filterPanelCreateFilter": "Create Filter",
        "dxDataGrid-filterPanelClearFilter": "Clear",
        "dxDataGrid-filterPanelFilterEnabledHint": "Enable the filter",
        "dxTreeList-ariaTreeList": "Tree list",
        "dxTreeList-ariaSearchInGrid": "Search in the tree list",
        "dxTreeList-ariaToolbar": "Tree list toolbar",
        "dxTreeList-editingAddRowToNode": "Add",
        "dxPager-infoText": "Page {0} of {1} ({2} items)",
        "dxPager-pagesCountText": "of",
        "dxPager-pageSizesAllText": "All",
        "dxPivotGrid-grandTotal": "Grand Total",
        "dxPivotGrid-total": "{0} Total",
        "dxPivotGrid-fieldChooserTitle": "Field Chooser",
        "dxPivotGrid-showFieldChooser": "Show Field Chooser",
        "dxPivotGrid-expandAll": "Expand All",
        "dxPivotGrid-collapseAll": "Collapse All",
        "dxPivotGrid-sortColumnBySummary": 'Sort "{0}" by This Column',
        "dxPivotGrid-sortRowBySummary": 'Sort "{0}" by This Row',
        "dxPivotGrid-removeAllSorting": "Remove All Sorting",
        "dxPivotGrid-dataNotAvailable": "N/A",
        "dxPivotGrid-rowFields": "Row Fields",
        "dxPivotGrid-columnFields": "Column Fields",
        "dxPivotGrid-dataFields": "Data Fields",
        "dxPivotGrid-filterFields": "Filter Fields",
        "dxPivotGrid-allFields": "All Fields",
        "dxPivotGrid-columnFieldArea": "Drop Column Fields Here",
        "dxPivotGrid-dataFieldArea": "Drop Data Fields Here",
        "dxPivotGrid-rowFieldArea": "Drop Row Fields Here",
        "dxPivotGrid-filterFieldArea": "Drop Filter Fields Here",
        "dxScheduler-editorLabelTitle": "Subject",
        "dxScheduler-editorLabelStartDate": "Start Date",
        "dxScheduler-editorLabelEndDate": "End Date",
        "dxScheduler-editorLabelDescription": "Description",
        "dxScheduler-editorLabelRecurrence": "Repeat",
        "dxScheduler-openAppointment": "Open appointment",
        "dxScheduler-recurrenceNever": "Never",
        "dxScheduler-recurrenceMinutely": "Every minute",
        "dxScheduler-recurrenceHourly": "Hourly",
        "dxScheduler-recurrenceDaily": "Daily",
        "dxScheduler-recurrenceWeekly": "Weekly",
        "dxScheduler-recurrenceMonthly": "Monthly",
        "dxScheduler-recurrenceYearly": "Yearly",
        "dxScheduler-recurrenceRepeatEvery": "Repeat Every",
        "dxScheduler-recurrenceRepeatOn": "Repeat On",
        "dxScheduler-recurrenceEnd": "End repeat",
        "dxScheduler-recurrenceAfter": "After",
        "dxScheduler-recurrenceOn": "On",
        "dxScheduler-recurrenceRepeatMinutely": "minute(s)",
        "dxScheduler-recurrenceRepeatHourly": "hour(s)",
        "dxScheduler-recurrenceRepeatDaily": "day(s)",
        "dxScheduler-recurrenceRepeatWeekly": "week(s)",
        "dxScheduler-recurrenceRepeatMonthly": "month(s)",
        "dxScheduler-recurrenceRepeatYearly": "year(s)",
        "dxScheduler-switcherDay": "Day",
        "dxScheduler-switcherWeek": "Week",
        "dxScheduler-switcherWorkWeek": "Work Week",
        "dxScheduler-switcherMonth": "Month",
        "dxScheduler-switcherAgenda": "Agenda",
        "dxScheduler-switcherTimelineDay": "Timeline Day",
        "dxScheduler-switcherTimelineWeek": "Timeline Week",
        "dxScheduler-switcherTimelineWorkWeek": "Timeline Work Week",
        "dxScheduler-switcherTimelineMonth": "Timeline Month",
        "dxScheduler-recurrenceRepeatOnDate": "on date",
        "dxScheduler-recurrenceRepeatCount": "occurrence(s)",
        "dxScheduler-allDay": "All day",
        "dxScheduler-confirmRecurrenceEditMessage": "Do you want to edit only this appointment or the whole series?",
        "dxScheduler-confirmRecurrenceDeleteMessage": "Do you want to delete only this appointment or the whole series?",
        "dxScheduler-confirmRecurrenceEditSeries": "Edit series",
        "dxScheduler-confirmRecurrenceDeleteSeries": "Delete series",
        "dxScheduler-confirmRecurrenceEditOccurrence": "Edit appointment",
        "dxScheduler-confirmRecurrenceDeleteOccurrence": "Delete appointment",
        "dxScheduler-noTimezoneTitle": "No timezone",
        "dxScheduler-moreAppointments": "{0} more",
        "dxCalendar-todayButtonText": "Today",
        "dxCalendar-ariaWidgetName": "Calendar",
        "dxColorView-ariaRed": "Red",
        "dxColorView-ariaGreen": "Green",
        "dxColorView-ariaBlue": "Blue",
        "dxColorView-ariaAlpha": "Transparency",
        "dxColorView-ariaHex": "Color code",
        "dxTagBox-selected": "{0} selected",
        "dxTagBox-allSelected": "All selected ({0})",
        "dxTagBox-moreSelected": "{0} more",
        "vizExport-printingButtonText": "Print",
        "vizExport-titleMenuText": "Exporting/Printing",
        "vizExport-exportButtonText": "{0} file",
        "dxFilterBuilder-and": "And",
        "dxFilterBuilder-or": "Or",
        "dxFilterBuilder-notAnd": "Not And",
        "dxFilterBuilder-notOr": "Not Or",
        "dxFilterBuilder-addCondition": "Add Condition",
        "dxFilterBuilder-addGroup": "Add Group",
        "dxFilterBuilder-enterValueText": "<enter a value>",
        "dxFilterBuilder-filterOperationEquals": "Equals",
        "dxFilterBuilder-filterOperationNotEquals": "Does not equal",
        "dxFilterBuilder-filterOperationLess": "Is less than",
        "dxFilterBuilder-filterOperationLessOrEquals": "Is less than or equal to",
        "dxFilterBuilder-filterOperationGreater": "Is greater than",
        "dxFilterBuilder-filterOperationGreaterOrEquals": "Is greater than or equal to",
        "dxFilterBuilder-filterOperationStartsWith": "Starts with",
        "dxFilterBuilder-filterOperationContains": "Contains",
        "dxFilterBuilder-filterOperationNotContains": "Does not contain",
        "dxFilterBuilder-filterOperationEndsWith": "Ends with",
        "dxFilterBuilder-filterOperationIsBlank": "Is blank",
        "dxFilterBuilder-filterOperationIsNotBlank": "Is not blank",
        "dxFilterBuilder-filterOperationBetween": "Is between",
        "dxFilterBuilder-filterOperationAnyOf": "Is any of",
        "dxFilterBuilder-filterOperationNoneOf": "Is none of",
        "dxHtmlEditor-dialogColorCaption": "Change Font Color",
        "dxHtmlEditor-dialogBackgroundCaption": "Change Background Color",
        "dxHtmlEditor-dialogLinkCaption": "Add Link",
        "dxHtmlEditor-dialogLinkUrlField": "URL",
        "dxHtmlEditor-dialogLinkTextField": "Text",
        "dxHtmlEditor-dialogLinkTargetField": "Open link in new window",
        "dxHtmlEditor-dialogImageCaption": "Add Image",
        "dxHtmlEditor-dialogImageUrlField": "URL",
        "dxHtmlEditor-dialogImageAltField": "Alternate text",
        "dxHtmlEditor-dialogImageWidthField": "Width (px)",
        "dxHtmlEditor-dialogImageHeightField": "Height (px)",
        "dxHtmlEditor-dialogInsertTableRowsField": "Rows",
        "dxHtmlEditor-dialogInsertTableColumnsField": "Columns",
        "dxHtmlEditor-dialogInsertTableCaption": "Insert Table",
        "dxHtmlEditor-heading": "Heading",
        "dxHtmlEditor-normalText": "Normal text",
        "dxHtmlEditor-background": "Background Color",
        "dxHtmlEditor-bold": "Bold",
        "dxHtmlEditor-color": "Font Color",
        "dxHtmlEditor-font": "Font",
        "dxHtmlEditor-italic": "Italic",
        "dxHtmlEditor-link": "Add Link",
        "dxHtmlEditor-image": "Add Image",
        "dxHtmlEditor-size": "Size",
        "dxHtmlEditor-strike": "Strikethrough",
        "dxHtmlEditor-subscript": "Subscript",
        "dxHtmlEditor-superscript": "Superscript",
        "dxHtmlEditor-underline": "Underline",
        "dxHtmlEditor-blockquote": "Blockquote",
        "dxHtmlEditor-header": "Header",
        "dxHtmlEditor-increaseIndent": "Increase Indent",
        "dxHtmlEditor-decreaseIndent": "Decrease Indent",
        "dxHtmlEditor-orderedList": "Ordered List",
        "dxHtmlEditor-bulletList": "Bullet List",
        "dxHtmlEditor-alignLeft": "Align Left",
        "dxHtmlEditor-alignCenter": "Align Center",
        "dxHtmlEditor-alignRight": "Align Right",
        "dxHtmlEditor-alignJustify": "Align Justify",
        "dxHtmlEditor-codeBlock": "Code Block",
        "dxHtmlEditor-variable": "Add Variable",
        "dxHtmlEditor-undo": "Undo",
        "dxHtmlEditor-redo": "Redo",
        "dxHtmlEditor-clear": "Clear Formatting",
        "dxHtmlEditor-insertTable": "Insert Table",
        "dxHtmlEditor-insertRowAbove": "Insert Row Above",
        "dxHtmlEditor-insertRowBelow": "Insert Row Below",
        "dxHtmlEditor-insertColumnLeft": "Insert Column Left",
        "dxHtmlEditor-insertColumnRight": "Insert Column Right",
        "dxHtmlEditor-deleteColumn": "Delete Column",
        "dxHtmlEditor-deleteRow": "Delete Row",
        "dxHtmlEditor-deleteTable": "Delete Table",
        "dxHtmlEditor-list": "List",
        "dxHtmlEditor-ordered": "Ordered",
        "dxHtmlEditor-bullet": "Bullet",
        "dxHtmlEditor-align": "Align",
        "dxHtmlEditor-center": "Center",
        "dxHtmlEditor-left": "Left",
        "dxHtmlEditor-right": "Right",
        "dxHtmlEditor-indent": "Indent",
        "dxHtmlEditor-justify": "Justify",
        "dxFileManager-newDirectoryName": "Untitled directory",
        "dxFileManager-rootDirectoryName": "Files",
        "dxFileManager-errorNoAccess": "Access Denied. Operation could not be completed.",
        "dxFileManager-errorDirectoryExistsFormat": "Directory '{0}' already exists.",
        "dxFileManager-errorFileExistsFormat": "File '{0}' already exists.",
        "dxFileManager-errorFileNotFoundFormat": "File '{0}' not found.",
        "dxFileManager-errorDirectoryNotFoundFormat": "Directory '{0}' not found.",
        "dxFileManager-errorWrongFileExtension": "File extension is not allowed.",
        "dxFileManager-errorMaxFileSizeExceeded": "File size exceeds the maximum allowed size.",
        "dxFileManager-errorInvalidSymbols": "This name contains invalid characters.",
        "dxFileManager-errorDefault": "Unspecified error.",
        "dxFileManager-errorDirectoryOpenFailed": "The directory cannot be opened",
        "dxFileManager-commandCreate": "New directory",
        "dxFileManager-commandRename": "Rename",
        "dxFileManager-commandMove": "Move to",
        "dxFileManager-commandCopy": "Copy to",
        "dxFileManager-commandDelete": "Delete",
        "dxFileManager-commandDownload": "Download",
        "dxFileManager-commandUpload": "Upload files",
        "dxFileManager-commandRefresh": "Refresh",
        "dxFileManager-commandThumbnails": "Thumbnails View",
        "dxFileManager-commandDetails": "Details View",
        "dxFileManager-commandClearSelection": "Clear selection",
        "dxFileManager-commandShowNavPane": "Toggle navigation pane",
        "dxFileManager-dialogDirectoryChooserMoveTitle": "Move to",
        "dxFileManager-dialogDirectoryChooserMoveButtonText": "Move",
        "dxFileManager-dialogDirectoryChooserCopyTitle": "Copy to",
        "dxFileManager-dialogDirectoryChooserCopyButtonText": "Copy",
        "dxFileManager-dialogRenameItemTitle": "Rename",
        "dxFileManager-dialogRenameItemButtonText": "Save",
        "dxFileManager-dialogCreateDirectoryTitle": "New directory",
        "dxFileManager-dialogCreateDirectoryButtonText": "Create",
        "dxFileManager-dialogDeleteItemTitle": "Delete",
        "dxFileManager-dialogDeleteItemButtonText": "Delete",
        "dxFileManager-dialogDeleteItemSingleItemConfirmation": "Are you sure you want to delete {0}?",
        "dxFileManager-dialogDeleteItemMultipleItemsConfirmation": "Are you sure you want to delete {0} items?",
        "dxFileManager-dialogButtonCancel": "Cancel",
        "dxFileManager-editingCreateSingleItemProcessingMessage": "Creating a directory inside {0}",
        "dxFileManager-editingCreateSingleItemSuccessMessage": "Created a directory inside {0}",
        "dxFileManager-editingCreateSingleItemErrorMessage": "Directory was not created",
        "dxFileManager-editingCreateCommonErrorMessage": "Directory was not created",
        "dxFileManager-editingRenameSingleItemProcessingMessage": "Renaming an item inside {0}",
        "dxFileManager-editingRenameSingleItemSuccessMessage": "Renamed an item inside {0}",
        "dxFileManager-editingRenameSingleItemErrorMessage": "Item was not renamed",
        "dxFileManager-editingRenameCommonErrorMessage": "Item was not renamed",
        "dxFileManager-editingDeleteSingleItemProcessingMessage": "Deleting an item from {0}",
        "dxFileManager-editingDeleteMultipleItemsProcessingMessage": "Deleting {0} items from {1}",
        "dxFileManager-editingDeleteSingleItemSuccessMessage": "Deleted an item from {0}",
        "dxFileManager-editingDeleteMultipleItemsSuccessMessage": "Deleted {0} items from {1}",
        "dxFileManager-editingDeleteSingleItemErrorMessage": "Item was not deleted",
        "dxFileManager-editingDeleteMultipleItemsErrorMessage": "{0} items were not deleted",
        "dxFileManager-editingDeleteCommonErrorMessage": "Some items were not deleted",
        "dxFileManager-editingMoveSingleItemProcessingMessage": "Moving an item to {0}",
        "dxFileManager-editingMoveMultipleItemsProcessingMessage": "Moving {0} items to {1}",
        "dxFileManager-editingMoveSingleItemSuccessMessage": "Moved an item to {0}",
        "dxFileManager-editingMoveMultipleItemsSuccessMessage": "Moved {0} items to {1}",
        "dxFileManager-editingMoveSingleItemErrorMessage": "Item was not moved",
        "dxFileManager-editingMoveMultipleItemsErrorMessage": "{0} items were not moved",
        "dxFileManager-editingMoveCommonErrorMessage": "Some items were not moved",
        "dxFileManager-editingCopySingleItemProcessingMessage": "Copying an item to {0}",
        "dxFileManager-editingCopyMultipleItemsProcessingMessage": "Copying {0} items to {1}",
        "dxFileManager-editingCopySingleItemSuccessMessage": "Copied an item to {0}",
        "dxFileManager-editingCopyMultipleItemsSuccessMessage": "Copied {0} items to {1}",
        "dxFileManager-editingCopySingleItemErrorMessage": "Item was not copied",
        "dxFileManager-editingCopyMultipleItemsErrorMessage": "{0} items were not copied",
        "dxFileManager-editingCopyCommonErrorMessage": "Some items were not copied",
        "dxFileManager-editingUploadSingleItemProcessingMessage": "Uploading an item to {0}",
        "dxFileManager-editingUploadMultipleItemsProcessingMessage": "Uploading {0} items to {1}",
        "dxFileManager-editingUploadSingleItemSuccessMessage": "Uploaded an item to {0}",
        "dxFileManager-editingUploadMultipleItemsSuccessMessage": "Uploaded {0} items to {1}",
        "dxFileManager-editingUploadSingleItemErrorMessage": "Item was not uploaded",
        "dxFileManager-editingUploadMultipleItemsErrorMessage": "{0} items were not uploaded",
        "dxFileManager-editingUploadCanceledMessage": "Canceled",
        "dxFileManager-listDetailsColumnCaptionName": "Name",
        "dxFileManager-listDetailsColumnCaptionDateModified": "Date Modified",
        "dxFileManager-listDetailsColumnCaptionFileSize": "File Size",
        "dxFileManager-listThumbnailsTooltipTextSize": "Size",
        "dxFileManager-listThumbnailsTooltipTextDateModified": "Date Modified",
        "dxFileManager-notificationProgressPanelTitle": "Progress",
        "dxFileManager-notificationProgressPanelEmptyListText": "No operations",
        "dxFileManager-notificationProgressPanelOperationCanceled": "Canceled",
        "dxDiagram-categoryGeneral": "General",
        "dxDiagram-categoryFlowchart": "Flowchart",
        "dxDiagram-categoryOrgChart": "Org Chart",
        "dxDiagram-categoryContainers": "Containers",
        "dxDiagram-categoryCustom": "Custom",
        "dxDiagram-commandExportToSvg": "Export to SVG",
        "dxDiagram-commandExportToPng": "Export to PNG",
        "dxDiagram-commandExportToJpg": "Export to JPEG",
        "dxDiagram-commandUndo": "Undo",
        "dxDiagram-commandRedo": "Redo",
        "dxDiagram-commandFontName": "Font Name",
        "dxDiagram-commandFontSize": "Font Size",
        "dxDiagram-commandBold": "Bold",
        "dxDiagram-commandItalic": "Italic",
        "dxDiagram-commandUnderline": "Underline",
        "dxDiagram-commandTextColor": "Font Color",
        "dxDiagram-commandLineColor": "Line Color",
        "dxDiagram-commandLineWidth": "Line Width",
        "dxDiagram-commandLineStyle": "Line Style",
        "dxDiagram-commandLineStyleSolid": "Solid",
        "dxDiagram-commandLineStyleDotted": "Dotted",
        "dxDiagram-commandLineStyleDashed": "Dashed",
        "dxDiagram-commandFillColor": "Fill Color",
        "dxDiagram-commandAlignLeft": "Align Left",
        "dxDiagram-commandAlignCenter": "Align Center",
        "dxDiagram-commandAlignRight": "Align Right",
        "dxDiagram-commandConnectorLineType": "Connector Line Type",
        "dxDiagram-commandConnectorLineStraight": "Straight",
        "dxDiagram-commandConnectorLineOrthogonal": "Orthogonal",
        "dxDiagram-commandConnectorLineStart": "Connector Line Start",
        "dxDiagram-commandConnectorLineEnd": "Connector Line End",
        "dxDiagram-commandConnectorLineNone": "None",
        "dxDiagram-commandConnectorLineArrow": "Arrow",
        "dxDiagram-commandFullscreen": "Full Screen",
        "dxDiagram-commandUnits": "Units",
        "dxDiagram-commandPageSize": "Page Size",
        "dxDiagram-commandPageOrientation": "Page Orientation",
        "dxDiagram-commandPageOrientationLandscape": "Landscape",
        "dxDiagram-commandPageOrientationPortrait": "Portrait",
        "dxDiagram-commandPageColor": "Page Color",
        "dxDiagram-commandShowGrid": "Show Grid",
        "dxDiagram-commandSnapToGrid": "Snap to Grid",
        "dxDiagram-commandGridSize": "Grid Size",
        "dxDiagram-commandZoomLevel": "Zoom Level",
        "dxDiagram-commandAutoZoom": "Auto Zoom",
        "dxDiagram-commandFitToContent": "Fit to Content",
        "dxDiagram-commandFitToWidth": "Fit to Width",
        "dxDiagram-commandAutoZoomByContent": "Auto Zoom by Content",
        "dxDiagram-commandAutoZoomByWidth": "Auto Zoom by Width",
        "dxDiagram-commandSimpleView": "Simple View",
        "dxDiagram-commandCut": "Cut",
        "dxDiagram-commandCopy": "Copy",
        "dxDiagram-commandPaste": "Paste",
        "dxDiagram-commandSelectAll": "Select All",
        "dxDiagram-commandDelete": "Delete",
        "dxDiagram-commandBringToFront": "Bring to Front",
        "dxDiagram-commandSendToBack": "Send to Back",
        "dxDiagram-commandLock": "Lock",
        "dxDiagram-commandUnlock": "Unlock",
        "dxDiagram-commandInsertShapeImage": "Insert Image...",
        "dxDiagram-commandEditShapeImage": "Change Image...",
        "dxDiagram-commandDeleteShapeImage": "Delete Image",
        "dxDiagram-commandLayoutLeftToRight": "Left-to-right",
        "dxDiagram-commandLayoutRightToLeft": "Right-to-left",
        "dxDiagram-commandLayoutTopToBottom": "Top-to-bottom",
        "dxDiagram-commandLayoutBottomToTop": "Bottom-to-top",
        "dxDiagram-unitIn": "in",
        "dxDiagram-unitCm": "cm",
        "dxDiagram-unitPx": "px",
        "dxDiagram-dialogButtonOK": "OK",
        "dxDiagram-dialogButtonCancel": "Cancel",
        "dxDiagram-dialogInsertShapeImageTitle": "Insert Image",
        "dxDiagram-dialogEditShapeImageTitle": "Change Image",
        "dxDiagram-dialogEditShapeImageSelectButton": "Select image",
        "dxDiagram-dialogEditShapeImageLabelText": "or drop a file here",
        "dxDiagram-uiExport": "Export",
        "dxDiagram-uiProperties": "Properties",
        "dxDiagram-uiSettings": "Settings",
        "dxDiagram-uiShowToolbox": "Show Toolbox",
        "dxDiagram-uiSearch": "Search",
        "dxDiagram-uiStyle": "Style",
        "dxDiagram-uiLayout": "Layout",
        "dxDiagram-uiLayoutTree": "Tree",
        "dxDiagram-uiLayoutLayered": "Layered",
        "dxDiagram-uiDiagram": "Diagram",
        "dxDiagram-uiText": "Text",
        "dxDiagram-uiObject": "Object",
        "dxDiagram-uiConnector": "Connector",
        "dxDiagram-uiPage": "Page",
        "dxDiagram-shapeText": "Text",
        "dxDiagram-shapeRectangle": "Rectangle",
        "dxDiagram-shapeEllipse": "Ellipse",
        "dxDiagram-shapeCross": "Cross",
        "dxDiagram-shapeTriangle": "Triangle",
        "dxDiagram-shapeDiamond": "Diamond",
        "dxDiagram-shapeHeart": "Heart",
        "dxDiagram-shapePentagon": "Pentagon",
        "dxDiagram-shapeHexagon": "Hexagon",
        "dxDiagram-shapeOctagon": "Octagon",
        "dxDiagram-shapeStar": "Star",
        "dxDiagram-shapeArrowLeft": "Left Arrow",
        "dxDiagram-shapeArrowUp": "Up Arrow",
        "dxDiagram-shapeArrowRight": "Right Arrow",
        "dxDiagram-shapeArrowDown": "Down Arrow",
        "dxDiagram-shapeArrowUpDown": "Up Down Arrow",
        "dxDiagram-shapeArrowLeftRight": "Left Right Arrow",
        "dxDiagram-shapeProcess": "Process",
        "dxDiagram-shapeDecision": "Decision",
        "dxDiagram-shapeTerminator": "Terminator",
        "dxDiagram-shapePredefinedProcess": "Predefined Process",
        "dxDiagram-shapeDocument": "Document",
        "dxDiagram-shapeMultipleDocuments": "Multiple Documents",
        "dxDiagram-shapeManualInput": "Manual Input",
        "dxDiagram-shapePreparation": "Preparation",
        "dxDiagram-shapeData": "Data",
        "dxDiagram-shapeDatabase": "Database",
        "dxDiagram-shapeHardDisk": "Hard Disk",
        "dxDiagram-shapeInternalStorage": "Internal Storage",
        "dxDiagram-shapePaperTape": "Paper Tape",
        "dxDiagram-shapeManualOperation": "Manual Operation",
        "dxDiagram-shapeDelay": "Delay",
        "dxDiagram-shapeStoredData": "Stored Data",
        "dxDiagram-shapeDisplay": "Display",
        "dxDiagram-shapeMerge": "Merge",
        "dxDiagram-shapeConnector": "Connector",
        "dxDiagram-shapeOr": "Or",
        "dxDiagram-shapeSummingJunction": "Summing Junction",
        "dxDiagram-shapeContainerDefaultText": "Container",
        "dxDiagram-shapeVerticalContainer": "Vertical Container",
        "dxDiagram-shapeHorizontalContainer": "Horizontal Container",
        "dxDiagram-shapeCardDefaultText": "Person's Name",
        "dxDiagram-shapeCardWithImageOnLeft": "Card with Image on the Left",
        "dxDiagram-shapeCardWithImageOnTop": "Card with Image on the Top",
        "dxDiagram-shapeCardWithImageOnRight": "Card with Image on the Right",
        "dxGantt-dialogTitle": "Title",
        "dxGantt-dialogStartTitle": "Start",
        "dxGantt-dialogEndTitle": "End",
        "dxGantt-dialogProgressTitle": "Progress",
        "dxGantt-dialogResourcesTitle": "Resources",
        "dxGantt-dialogResourceManagerTitle": "Resource Manager",
        "dxGantt-dialogTaskDetailsTitle": "Task Details",
        "dxGantt-dialogEditResourceListHint": "Edit Resource List",
        "dxGantt-dialogEditNoResources": "No resources",
        "dxGantt-dialogButtonAdd": "Add",
        "dxGantt-contextMenuNewTask": "New Task",
        "dxGantt-contextMenuNewSubtask": "New Subtask",
        "dxGantt-contextMenuDeleteTask": "Delete Task",
        "dxGantt-contextMenuDeleteDependency": "Delete Dependency",
        "dxGantt-dialogTaskDeleteConfirmation": "Deleting a task also deletes all its dependencies and subtasks. Are you sure you want to delete this task?",
        "dxGantt-dialogDependencyDeleteConfirmation": "Are you sure you want to delete the dependency from the task?",
        "dxGantt-dialogResourcesDeleteConfirmation": "Deleting a resource also deletes it from tasks to which this resource is assigned. Are you sure you want to delete these resources? Resources: {0}",
        "dxGantt-dialogConstraintCriticalViolationMessage": "The task you are attempting to move is linked to a second task by a dependency relation. This change would conflict with dependency rules. How would you like to proceed?",
        "dxGantt-dialogConstraintViolationMessage": "The task you are attempting to move is linked to a second task by a dependency relation. How would you like to proceed?",
        "dxGantt-dialogCancelOperationMessage": "Cancel the operation",
        "dxGantt-dialogDeleteDependencyMessage": "Delete the dependency",
        "dxGantt-dialogMoveTaskAndKeepDependencyMessage": "Move the task and keep the dependency",
        "dxGantt-undo": "Undo",
        "dxGantt-redo": "Redo",
        "dxGantt-expandAll": "Expand All",
        "dxGantt-collapseAll": "Collapse All",
        "dxGantt-addNewTask": "Add New Task",
        "dxGantt-deleteSelectedTask": "Delete Selected Task",
        "dxGantt-zoomIn": "Zoom In",
        "dxGantt-zoomOut": "Zoom Out",
        "dxGantt-fullScreen": "Full Screen",
        "dxGantt-quarter": "Q{0}",
        "dxGantt-sortingAscendingText": "Sort Ascending",
        "dxGantt-sortingDescendingText": "Sort Descending",
        "dxGantt-sortingClearText": "Clear Sorting",
        "dxGantt-showResources": "Show Resources",
        "dxGantt-showDependencies": "Show Dependencies",
        "dxGantt-dialogStartDateValidation": "Start date must be after {0}",
        "dxGantt-dialogEndDateValidation": "End date must be after {0}"
      }
    };
  }
});

// node_modules/devextreme/esm/localization/message.js
var baseDictionary, getDataByLocale, newMessages, messageLocalization, message_default;
var init_message = __esm({
  "node_modules/devextreme/esm/localization/message.js"() {
    init_renderer();
    init_dependency_injector();
    init_extend();
    init_iterator();
    init_string();
    init_inflector();
    init_core();
    init_default_messages();
    baseDictionary = extend2(true, {}, defaultMessages);
    getDataByLocale = (localeData, locale) => localeData[locale] || {};
    newMessages = {};
    messageLocalization = dependency_injector_default({
      engine: function() {
        return "base";
      },
      _dictionary: baseDictionary,
      load: function(messages) {
        extend2(true, this._dictionary, messages);
      },
      _localizablePrefix: "@",
      setup: function(localizablePrefix) {
        this._localizablePrefix = localizablePrefix;
      },
      localizeString: function(text) {
        var that = this;
        var regex = new RegExp("(^|[^a-zA-Z_0-9" + that._localizablePrefix + "-]+)(" + that._localizablePrefix + "{1,2})([a-zA-Z_0-9-]+)", "g");
        var escapeString = that._localizablePrefix + that._localizablePrefix;
        return text.replace(regex, (str, prefix, escape, localizationKey) => {
          var defaultResult = that._localizablePrefix + localizationKey;
          var result2;
          if (escape !== escapeString) {
            result2 = that.format(localizationKey);
          }
          if (!result2) {
            newMessages[localizationKey] = humanize(localizationKey);
          }
          return prefix + (result2 || defaultResult);
        });
      },
      localizeNode: function(node) {
        var that = this;
        renderer_default(node).each((index2, nodeItem) => {
          if (!nodeItem.nodeType) {
            return;
          }
          if (3 === nodeItem.nodeType) {
            nodeItem.nodeValue = that.localizeString(nodeItem.nodeValue);
          } else if (!renderer_default(nodeItem).is("iframe")) {
            each(nodeItem.attributes || [], (index3, attr) => {
              if ("string" === typeof attr.value) {
                var localizedValue = that.localizeString(attr.value);
                if (attr.value !== localizedValue) {
                  attr.value = localizedValue;
                }
              }
            });
            renderer_default(nodeItem).contents().each((index3, node2) => {
              that.localizeNode(node2);
            });
          }
        });
      },
      getMessagesByLocales: function() {
        return this._dictionary;
      },
      getDictionary: function(onlyNew) {
        if (onlyNew) {
          return newMessages;
        }
        return extend2({}, newMessages, this.getMessagesByLocales()[core_default.locale()]);
      },
      getFormatter: function(key) {
        return this._getFormatterBase(key) || this._getFormatterBase(key, "en");
      },
      _getFormatterBase: function(key, locale) {
        var message = core_default.getValueByClosestLocale((locale2) => getDataByLocale(this._dictionary, locale2)[key]);
        if (message) {
          return function() {
            var args = 1 === arguments.length && Array.isArray(arguments[0]) ? arguments[0].slice(0) : Array.prototype.slice.call(arguments, 0);
            args.unshift(message);
            return format.apply(this, args);
          };
        }
      },
      format: function(key) {
        var formatter = this.getFormatter(key);
        var values = Array.prototype.slice.call(arguments, 1);
        return formatter && formatter.apply(this, values) || "";
      }
    });
    message_default = messageLocalization;
  }
});

// node_modules/devextreme/esm/ui/widget/ui.errors.js
var ui_errors_default;
var init_ui_errors = __esm({
  "node_modules/devextreme/esm/ui/widget/ui.errors.js"() {
    init_error();
    init_errors();
    ui_errors_default = error_default(errors_default.ERROR_MESSAGES, {
      E1001: "Module '{0}'. Controller '{1}' is already registered",
      E1002: "Module '{0}'. Controller '{1}' does not inherit from DevExpress.ui.dxDataGrid.Controller",
      E1003: "Module '{0}'. View '{1}' is already registered",
      E1004: "Module '{0}'. View '{1}' does not inherit from DevExpress.ui.dxDataGrid.View",
      E1005: "Public method '{0}' is already registered",
      E1006: "Public method '{0}.{1}' does not exist",
      E1007: "State storing cannot be provided due to the restrictions of the browser",
      E1010: "The template does not contain the TextBox widget",
      E1011: 'Items cannot be deleted from the List. Implement the "remove" function in the data store',
      E1012: "Editing type '{0}' with the name '{1}' is unsupported",
      E1016: "Unexpected type of data source is provided for a lookup column",
      E1018: "The 'collapseAll' method cannot be called if you use a remote data source",
      E1019: "Search mode '{0}' is unavailable",
      E1020: "The type cannot be changed after initialization",
      E1021: "{0} '{1}' you are trying to remove does not exist",
      E1022: 'The "markers" option is given an invalid value. Assign an array instead',
      E1023: 'The "routes" option is given an invalid value. Assign an array instead',
      E1025: "This layout is too complex to render",
      E1026: 'The "calculateCustomSummary" function is missing from a field whose "summaryType" option is set to "custom"',
      E1031: "Unknown subscription in the Scheduler widget: '{0}'",
      E1032: "Unknown start date in an appointment: '{0}'",
      E1033: "Unknown step in the date navigator: '{0}'",
      E1034: "The browser does not implement an API for saving files",
      E1035: "The editor cannot be created because of an internal error: {0}",
      E1037: "Invalid structure of grouped data",
      E1038: "The browser does not support local storages for local web pages",
      E1039: "A cell's position cannot be calculated",
      E1040: "The '{0}' key value is not unique within the data array",
      E1041: "The '{0}' script is referenced after the DevExtreme scripts or not referenced at all",
      E1042: "{0} requires the key field to be specified",
      E1043: "Changes cannot be processed due to the incorrectly set key",
      E1044: "The key field specified by the keyExpr option does not match the key field specified in the data store",
      E1045: "Editing requires the key field to be specified in the data store",
      E1046: "The '{0}' key field is not found in data objects",
      E1047: 'The "{0}" field is not found in the fields array',
      E1048: 'The "{0}" operation is not found in the filterOperations array',
      E1049: "Column '{0}': filtering is allowed but the 'dataField' or 'name' option is not specified",
      E1050: "The validationRules option does not apply to third-party editors defined in the editCellTemplate",
      E1051: `HtmlEditor's valueType is "{0}", but the {0} converter was not imported.`,
      E1052: '{0} should have the "dataSource" option specified',
      E1053: 'The "buttons" option accepts an array that contains only objects or string values',
      E1054: "All text editor buttons must have names",
      E1055: 'One or several text editor buttons have invalid or non-unique "name" values',
      E1056: 'The {0} widget does not support buttons of the "{1}" type',
      E1058: 'The "startDayHour" must be earlier than the "endDayHour"',
      E1059: "The following column names are not unique: {0}",
      E1060: "All editable columns must have names",
      W1001: 'The "key" option cannot be modified after initialization',
      W1002: "An item with the key '{0}' does not exist",
      W1003: "A group with the key '{0}' in which you are trying to select items does not exist",
      W1004: "The item '{0}' you are trying to select in the group '{1}' does not exist",
      W1005: "Due to column data types being unspecified, data has been loaded twice in order to apply initial filter settings. To resolve this issue, specify data types for all grid columns.",
      W1006: "The map service returned the following error: '{0}'",
      W1007: "No item with key {0} was found in the data source, but this key was used as the parent key for item {1}",
      W1008: "Cannot scroll to the '{0}' date because it does not exist on the current view",
      W1009: "Searching works only if data is specified using the dataSource option",
      W1010: "The capability to select all items works with source data of plain structure only",
      W1011: 'The "keyExpr" option is not applied when dataSource is not an array',
      W1012: "The '{0}' key field is not found in data objects",
      W1013: 'The "message" field in the dialog component was renamed to "messageHtml". Change your code correspondingly. In addition, if you used HTML code in the message, make sure that it is secure',
      W1014: "The Floating Action Button exceeds the recommended speed dial action count. If you need to display more speed dial actions, increase the maxSpeedDialActionCount option value in the global config.",
      W1015: 'The "cellDuration" should divide the range from the "startDayHour" to the "endDayHour" into even intervals',
      W1016: "The '{0}' field in the HTML Editor toolbar item configuration was renamed to '{1}'. Please make a corresponding change in your code.",
      W1017: "The 'key' property is not specified for a lookup data source. Please specify it to prevent requests for the entire dataset when users filter data.",
      W1018: "Infinite scrolling may not work properly with multiple selection. To use these features together, set 'selection.deferred' to true or set 'selection.selectAllMode' to 'page'.",
      W1019: "Filter query string exceeds maximum length limit of {0} characters."
    });
  }
});

// node_modules/devextreme/esm/core/polyfills/promise.js
var promise, promise_default;
var init_promise = __esm({
  "node_modules/devextreme/esm/core/polyfills/promise.js"() {
    init_deferred();
    init_window();
    promise = hasWindow() ? getWindow().Promise : Promise;
    if (!promise) {
      promise = function(resolver) {
        var d = new Deferred();
        resolver(d.resolve.bind(this), d.reject.bind(this));
        return d.promise();
      };
      promise.resolve = function(val) {
        return new Deferred().resolve(val).promise();
      };
      promise.reject = function(val) {
        return new Deferred().reject(val).promise();
      };
      promise.all = function(promises) {
        return when.apply(this, promises).then(function() {
          return [].slice.call(arguments);
        });
      };
    }
    promise_default = promise;
  }
});

// node_modules/devextreme/esm/ui/themes_callback.js
var themeReadyCallback;
var init_themes_callback = __esm({
  "node_modules/devextreme/esm/ui/themes_callback.js"() {
    init_callbacks();
    themeReadyCallback = new callbacks_default();
  }
});

// node_modules/devextreme/esm/ui/themes.js
function readThemeMarker() {
  if (!hasWindow()) {
    return null;
  }
  var element = renderer_default("<div>", context).addClass("dx-theme-marker").appendTo(context.documentElement);
  var result2;
  try {
    result2 = window9.getComputedStyle(element.get(0)).fontFamily;
    if (!result2) {
      return null;
    }
    result2 = result2.replace(/["']/g, "");
    if (result2.substr(0, THEME_MARKER_PREFIX.length) !== THEME_MARKER_PREFIX) {
      return null;
    }
    return result2.substr(THEME_MARKER_PREFIX.length);
  } finally {
    element.remove();
  }
}
function waitForThemeLoad(themeName) {
  var waitStartTime;
  var timerId;
  var intervalCleared = true;
  pendingThemeName = themeName;
  function handleLoaded() {
    pendingThemeName = null;
    clearInterval(timerId);
    intervalCleared = true;
    themeReadyCallback.fire();
    themeReadyCallback.empty();
    initDeferred.resolve();
  }
  if (isPendingThemeLoaded() || !defaultTimeout) {
    handleLoaded();
  } else {
    if (!intervalCleared) {
      if (pendingThemeName) {
        pendingThemeName = themeName;
      }
      return;
    }
    waitStartTime = Date.now();
    intervalCleared = false;
    timerId = setInterval(function() {
      var isLoaded = isPendingThemeLoaded();
      var isTimeout = !isLoaded && Date.now() - waitStartTime > defaultTimeout;
      if (isTimeout) {
        ui_errors_default.log("W0004", pendingThemeName);
      }
      if (isLoaded || isTimeout) {
        handleLoaded();
      }
    }, 10);
  }
}
function isPendingThemeLoaded() {
  if (!pendingThemeName) {
    return true;
  }
  var anyThemePending = pendingThemeName === ANY_THEME;
  if ("resolved" === initDeferred.state() && anyThemePending) {
    return true;
  }
  var themeMarker = readThemeMarker();
  if (themeMarker && anyThemePending) {
    return true;
  }
  return themeMarker === pendingThemeName;
}
function processMarkup() {
  var $allThemeLinks = renderer_default(DX_LINK_SELECTOR, context);
  if (!$allThemeLinks.length) {
    return;
  }
  knownThemes = {};
  $activeThemeLink = renderer_default(parseHTML("<link rel=stylesheet>"), context);
  $allThemeLinks.each(function() {
    var link = renderer_default(this, context);
    var fullThemeName = link.attr(THEME_ATTR);
    var url = link.attr("href");
    var isActive = "true" === link.attr(ACTIVE_ATTR);
    knownThemes[fullThemeName] = {
      url,
      isActive
    };
  });
  $allThemeLinks.last().after($activeThemeLink);
  $allThemeLinks.remove();
}
function resolveFullThemeName(desiredThemeName) {
  var desiredThemeParts = desiredThemeName ? desiredThemeName.split(".") : [];
  var result2 = null;
  if (knownThemes) {
    if (desiredThemeName in knownThemes) {
      return desiredThemeName;
    }
    each(knownThemes, function(knownThemeName, themeData) {
      var knownThemeParts = knownThemeName.split(".");
      if (desiredThemeParts[0] && knownThemeParts[0] !== desiredThemeParts[0]) {
        return;
      }
      if (desiredThemeParts[1] && desiredThemeParts[1] !== knownThemeParts[1]) {
        return;
      }
      if (desiredThemeParts[2] && desiredThemeParts[2] !== knownThemeParts[2]) {
        return;
      }
      if (!result2 || themeData.isActive) {
        result2 = knownThemeName;
      }
      if (themeData.isActive) {
        return false;
      }
    });
  }
  return result2;
}
function initContext(newContext) {
  try {
    if (newContext !== context) {
      knownThemes = null;
    }
  } catch (x) {
    knownThemes = null;
  }
  context = newContext;
}
function init(options2) {
  options2 = options2 || {};
  initContext(options2.context || dom_adapter_default.getDocument());
  if (!context) {
    return;
  }
  processMarkup();
  currentThemeName = void 0;
  current(options2);
}
function current(options2) {
  if (!arguments.length) {
    currentThemeName = currentThemeName || readThemeMarker();
    return currentThemeName;
  }
  detachCssClasses(viewPort());
  options2 = options2 || {};
  if ("string" === typeof options2) {
    options2 = {
      theme: options2
    };
  }
  var isAutoInit = options2._autoInit;
  var loadCallback = options2.loadCallback;
  var currentThemeData;
  currentThemeName = resolveFullThemeName(options2.theme || currentThemeName);
  if (currentThemeName) {
    currentThemeData = knownThemes[currentThemeName];
  }
  if (loadCallback) {
    themeReadyCallback.add(loadCallback);
  }
  if (currentThemeData) {
    $activeThemeLink.attr("href", knownThemes[currentThemeName].url);
    if (themeReadyCallback.has() || "resolved" !== initDeferred.state() || options2._forceTimeout) {
      waitForThemeLoad(currentThemeName);
    }
  } else if (isAutoInit) {
    if (hasWindow()) {
      waitForThemeLoad(ANY_THEME);
    }
    themeReadyCallback.fire();
    themeReadyCallback.empty();
  } else {
    throw ui_errors_default.Error("E0021", currentThemeName);
  }
  initDeferred.done(() => attachCssClasses(originalViewPort(), currentThemeName));
}
function getCssClasses(themeName) {
  themeName = themeName || current();
  var result2 = [];
  var themeNameParts = themeName && themeName.split(".");
  if (themeNameParts) {
    result2.push("dx-theme-" + themeNameParts[0], "dx-theme-" + themeNameParts[0] + "-typography");
    if (themeNameParts.length > 1) {
      result2.push("dx-color-scheme-" + themeNameParts[1] + (isMaterial(themeName) ? "-" + themeNameParts[2] : ""));
    }
  }
  return result2;
}
function attachCssClasses(element, themeName) {
  themeClasses = getCssClasses(themeName).join(" ");
  renderer_default(element).addClass(themeClasses);
  !function() {
    var pixelRatio = hasWindow() && window9.devicePixelRatio;
    if (!pixelRatio || pixelRatio < 2) {
      return;
    }
    var $tester = renderer_default("<div>");
    $tester.css("border", ".5px solid transparent");
    renderer_default("body").append($tester);
    if (1 === $tester.outerHeight()) {
      renderer_default(element).addClass(DX_HAIRLINES_CLASS);
      themeClasses += " " + DX_HAIRLINES_CLASS;
    }
    $tester.remove();
  }();
}
function detachCssClasses(element) {
  renderer_default(element).removeClass(themeClasses);
}
function isTheme(themeRegExp, themeName) {
  if (!themeName) {
    themeName = currentThemeName || readThemeMarker();
  }
  return new RegExp(themeRegExp).test(themeName);
}
function isMaterial(themeName) {
  return isTheme("material", themeName);
}
function isGeneric(themeName) {
  return isTheme("generic", themeName);
}
function isWebFontLoaded(text, fontWeight) {
  var document2 = dom_adapter_default.getDocument();
  var testElement = document2.createElement("span");
  testElement.style.position = "absolute";
  testElement.style.top = "-9999px";
  testElement.style.left = "-9999px";
  testElement.style.visibility = "hidden";
  testElement.style.fontFamily = "Arial";
  testElement.style.fontSize = "250px";
  testElement.style.fontWeight = fontWeight;
  testElement.innerHTML = text;
  document2.body.appendChild(testElement);
  var etalonFontWidth = testElement.offsetWidth;
  testElement.style.fontFamily = "Roboto, RobotoFallback, Arial";
  var testedFontWidth = testElement.offsetWidth;
  testElement.parentNode.removeChild(testElement);
  return etalonFontWidth !== testedFontWidth;
}
function waitWebFont(text, fontWeight) {
  return new promise_default((resolve) => {
    var clear = () => {
      clearInterval(intervalId);
      clearTimeout(timeoutId);
      resolve();
    };
    var intervalId = setInterval(() => {
      if (isWebFontLoaded(text, fontWeight)) {
        clear();
      }
    }, 15);
    var timeoutId = setTimeout(clear, 2e3);
  });
}
function autoInit() {
  init({
    _autoInit: true,
    _forceTimeout: true
  });
  if (renderer_default(DX_LINK_SELECTOR, context).length) {
    throw ui_errors_default.Error("E0022");
  }
}
var window9, ready2, viewPort, viewPortChanged, initDeferred, DX_LINK_SELECTOR, THEME_ATTR, ACTIVE_ATTR, DX_HAIRLINES_CLASS, ANY_THEME, context, $activeThemeLink, knownThemes, currentThemeName, pendingThemeName, defaultTimeout, THEME_MARKER_PREFIX, themeClasses;
var init_themes = __esm({
  "node_modules/devextreme/esm/ui/themes.js"() {
    init_devices();
    init_dom_adapter();
    init_promise();
    init_renderer();
    init_deferred();
    init_html_parser();
    init_iterator();
    init_ready_callbacks();
    init_view_port();
    init_window();
    init_themes_callback();
    init_ui_errors();
    window9 = getWindow();
    ready2 = ready_callbacks_default.add;
    viewPort = value;
    viewPortChanged = changeCallback;
    initDeferred = new Deferred();
    DX_LINK_SELECTOR = "link[rel=dx-theme]";
    THEME_ATTR = "data-theme";
    ACTIVE_ATTR = "data-active";
    DX_HAIRLINES_CLASS = "dx-hairlines";
    ANY_THEME = "any";
    defaultTimeout = 15e3;
    THEME_MARKER_PREFIX = "dx.";
    if (hasWindow()) {
      autoInit();
    } else {
      ready2(autoInit);
    }
    viewPortChanged.add(function(viewPort2, prevViewPort) {
      initDeferred.done(function() {
        detachCssClasses(prevViewPort);
        attachCssClasses(viewPort2);
      });
    });
    devices_default.changed.add(function() {
      init({
        _autoInit: true
      });
    });
  }
});

// node_modules/devextreme/esm/data/utils.js
function isConjunctiveOperator(condition) {
  return /^(and|&&|&)$/i.test(condition);
}
function throttle(func, timeout) {
  var timeoutId;
  var lastArgs;
  return function() {
    lastArgs = arguments;
    if (!timeoutId) {
      timeoutId = setTimeout(() => {
        timeoutId = void 0;
        if (lastArgs) {
          func.call(this, lastArgs);
        }
      }, isFunction(timeout) ? timeout() : timeout);
    }
    return timeoutId;
  };
}
function throttleChanges(func, timeout) {
  var cache = [];
  var throttled = throttle(function() {
    func.call(this, cache);
    cache = [];
  }, timeout);
  return function(changes) {
    if (Array.isArray(changes)) {
      cache.push(...changes);
    }
    return throttled.call(this, cache);
  };
}
var ready3, XHR_ERROR_UNLOAD, normalizeBinaryCriterion, normalizeSortingInfo, errorMessageFromXhr, aggregators, processRequestResultLock, keysEqual, isUnaryOperation, isGroupOperator, isGroupCriterion, trivialPromise, rejectedPromise;
var init_utils3 = __esm({
  "node_modules/devextreme/esm/data/utils.js"() {
    init_type();
    init_dom_adapter();
    init_ready_callbacks();
    init_window();
    init_iterator();
    init_deferred();
    init_common();
    ready3 = ready_callbacks_default.add;
    XHR_ERROR_UNLOAD = "DEVEXTREME_XHR_ERROR_UNLOAD";
    normalizeBinaryCriterion = function(crit) {
      return [crit[0], crit.length < 3 ? "=" : String(crit[1]).toLowerCase(), crit.length < 2 ? true : crit[crit.length - 1]];
    };
    normalizeSortingInfo = function(info) {
      if (!Array.isArray(info)) {
        info = [info];
      }
      return map(info, function(i) {
        var result2 = {
          selector: isFunction(i) || "string" === typeof i ? i : i.getter || i.field || i.selector,
          desc: !!(i.desc || "d" === String(i.dir).charAt(0).toLowerCase())
        };
        if (i.compare) {
          result2.compare = i.compare;
        }
        return result2;
      });
    };
    errorMessageFromXhr = function() {
      var textStatusMessages = {
        timeout: "Network connection timeout",
        error: "Unspecified network error",
        parsererror: "Unexpected server response"
      };
      var unloading;
      ready3(function() {
        var window29 = getWindow();
        dom_adapter_default.listen(window29, "beforeunload", function() {
          unloading = true;
        });
      });
      return function(xhr, textStatus) {
        if (unloading) {
          return XHR_ERROR_UNLOAD;
        }
        if (xhr.status < 400) {
          return function(textStatus2) {
            var result2 = textStatusMessages[textStatus2];
            if (!result2) {
              return textStatus2;
            }
            return result2;
          }(textStatus);
        }
        return xhr.statusText;
      };
    }();
    aggregators = {
      count: {
        seed: 0,
        step: function(count) {
          return 1 + count;
        }
      },
      sum: {
        seed: 0,
        step: function(sum, item) {
          return sum + item;
        }
      },
      min: {
        step: function(min, item) {
          return item < min ? item : min;
        }
      },
      max: {
        step: function(max, item) {
          return item > max ? item : max;
        }
      },
      avg: {
        seed: [0, 0],
        step: function(pair, value2) {
          return [pair[0] + value2, pair[1] + 1];
        },
        finalize: function(pair) {
          return pair[1] ? pair[0] / pair[1] : NaN;
        }
      }
    };
    processRequestResultLock = /* @__PURE__ */ function() {
      var lockCount = 0;
      var lockDeferred;
      return {
        obtain: function() {
          if (0 === lockCount) {
            lockDeferred = new Deferred();
          }
          lockCount++;
        },
        release: function() {
          lockCount--;
          if (lockCount < 1) {
            lockDeferred.resolve();
          }
        },
        promise: function() {
          var deferred = 0 === lockCount ? new Deferred().resolve() : lockDeferred;
          return deferred.promise();
        },
        reset: function() {
          lockCount = 0;
          if (lockDeferred) {
            lockDeferred.resolve();
          }
        }
      };
    }();
    keysEqual = function(keyExpr, key1, key2) {
      if (Array.isArray(keyExpr)) {
        var names = map(key1, function(v, k) {
          return k;
        });
        var name2;
        for (var i = 0; i < names.length; i++) {
          name2 = names[i];
          if (!equalByValue(key1[name2], key2[name2], 0, false)) {
            return false;
          }
        }
        return true;
      }
      return equalByValue(key1, key2, 0, false);
    };
    isUnaryOperation = function(crit) {
      return "!" === crit[0] && Array.isArray(crit[1]);
    };
    isGroupOperator = function(value2) {
      return "and" === value2 || "or" === value2;
    };
    isGroupCriterion = function(crit) {
      var first = crit[0];
      var second = crit[1];
      if (Array.isArray(first)) {
        return true;
      }
      if (isFunction(first)) {
        if (Array.isArray(second) || isFunction(second) || isGroupOperator(second)) {
          return true;
        }
      }
      return false;
    };
    trivialPromise = function() {
      var d = new Deferred();
      return d.resolve.apply(d, arguments).promise();
    };
    rejectedPromise = function() {
      var d = new Deferred();
      return d.reject.apply(d, arguments).promise();
    };
  }
});

// node_modules/devextreme/esm/ui/shared/filtering.js
var DEFAULT_DATE_INTERVAL, DEFAULT_DATETIME_INTERVAL, isDateType, getGroupInterval, filtering_default;
var init_filtering = __esm({
  "node_modules/devextreme/esm/ui/shared/filtering.js"() {
    init_type();
    init_array();
    init_iterator();
    DEFAULT_DATE_INTERVAL = ["year", "month", "day"];
    DEFAULT_DATETIME_INTERVAL = ["year", "month", "day", "hour", "minute"];
    isDateType = function(dataType) {
      return "date" === dataType || "datetime" === dataType;
    };
    getGroupInterval = function(column) {
      var index2;
      var result2 = [];
      var dateIntervals = ["year", "month", "day", "hour", "minute", "second"];
      var groupInterval = column.headerFilter && column.headerFilter.groupInterval;
      var interval = "quarter" === groupInterval ? "month" : groupInterval;
      if (isDateType(column.dataType) && null !== groupInterval) {
        result2 = "datetime" === column.dataType ? DEFAULT_DATETIME_INTERVAL : DEFAULT_DATE_INTERVAL;
        index2 = inArray(interval, dateIntervals);
        if (index2 >= 0) {
          result2 = dateIntervals.slice(0, index2);
          result2.push(groupInterval);
          return result2;
        }
        return result2;
      } else if (isDefined(groupInterval)) {
        return Array.isArray(groupInterval) ? groupInterval : [groupInterval];
      }
    };
    filtering_default = /* @__PURE__ */ function() {
      var getFilterSelector = function(column, target) {
        var selector = column.dataField || column.selector;
        if ("search" === target) {
          selector = column.displayField || column.calculateDisplayValue || selector;
        }
        return selector;
      };
      var getFilterExpressionByRange = function(filterValue, target) {
        var endFilterValue;
        var startFilterExpression;
        var endFilterExpression;
        var selector = getFilterSelector(this, target);
        if (Array.isArray(filterValue) && isDefined(filterValue[0]) && isDefined(filterValue[1])) {
          startFilterExpression = [selector, ">=", filterValue[0]];
          endFilterExpression = [selector, "<=", filterValue[1]];
          if (isDateType(this.dataType) && (date = filterValue[1], date.getHours() + date.getMinutes() + date.getSeconds() + date.getMilliseconds() < 1)) {
            endFilterValue = new Date(filterValue[1].getTime());
            if ("date" === this.dataType) {
              endFilterValue.setDate(filterValue[1].getDate() + 1);
            }
            endFilterExpression = [selector, "<", endFilterValue];
          }
          return [startFilterExpression, "and", endFilterExpression];
        }
        var date;
      };
      var getFilterExpressionForDate = function(filterValue, selectedFilterOperation, target) {
        var dateStart;
        var dateEnd;
        var dateInterval;
        var values = function(dateValue) {
          if (isDate(dateValue)) {
            return [dateValue.getFullYear(), dateValue.getMonth(), dateValue.getDate(), dateValue.getHours(), dateValue.getMinutes(), dateValue.getSeconds()];
          }
          return map(("" + dateValue).split("/"), function(value2, index2) {
            return 1 === index2 ? Number(value2) - 1 : Number(value2);
          });
        }(filterValue);
        var selector = getFilterSelector(this, target);
        if ("headerFilter" === target) {
          dateInterval = getGroupInterval(this)[values.length - 1];
        } else if ("datetime" === this.dataType) {
          dateInterval = "minute";
        }
        switch (dateInterval) {
          case "year":
            dateStart = new Date(values[0], 0, 1);
            dateEnd = new Date(values[0] + 1, 0, 1);
            break;
          case "month":
            dateStart = new Date(values[0], values[1], 1);
            dateEnd = new Date(values[0], values[1] + 1, 1);
            break;
          case "quarter":
            dateStart = new Date(values[0], 3 * values[1], 1);
            dateEnd = new Date(values[0], 3 * values[1] + 3, 1);
            break;
          case "hour":
            dateStart = new Date(values[0], values[1], values[2], values[3]);
            dateEnd = new Date(values[0], values[1], values[2], values[3] + 1);
            break;
          case "minute":
            dateStart = new Date(values[0], values[1], values[2], values[3], values[4]);
            dateEnd = new Date(values[0], values[1], values[2], values[3], values[4] + 1);
            break;
          case "second":
            dateStart = new Date(values[0], values[1], values[2], values[3], values[4], values[5]);
            dateEnd = new Date(values[0], values[1], values[2], values[3], values[4], values[5] + 1);
            break;
          default:
            dateStart = new Date(values[0], values[1], values[2]);
            dateEnd = new Date(values[0], values[1], values[2] + 1);
        }
        switch (selectedFilterOperation) {
          case "<":
            return [selector, "<", dateStart];
          case "<=":
            return [selector, "<", dateEnd];
          case ">":
            return [selector, ">=", dateEnd];
          case ">=":
            return [selector, ">=", dateStart];
          case "<>":
            return [
              [selector, "<", dateStart],
              "or",
              [selector, ">=", dateEnd]
            ];
          default:
            return [
              [selector, ">=", dateStart],
              "and",
              [selector, "<", dateEnd]
            ];
        }
      };
      var getFilterExpressionForNumber = function(filterValue, selectedFilterOperation, target) {
        var selector = getFilterSelector(this, target);
        var groupInterval = getGroupInterval(this);
        if ("headerFilter" === target && groupInterval && isDefined(filterValue)) {
          var values = ("" + filterValue).split("/");
          var value2 = Number(values[values.length - 1]);
          var interval = groupInterval[values.length - 1];
          var startFilterValue = [selector, ">=", value2];
          var endFilterValue = [selector, "<", value2 + interval];
          var condition = [startFilterValue, "and", endFilterValue];
          return condition;
        }
        return [selector, selectedFilterOperation || "=", filterValue];
      };
      return {
        defaultCalculateFilterExpression: function(filterValue, selectedFilterOperation, target) {
          var column = this;
          var selector = getFilterSelector(column, target);
          var isSearchByDisplayValue = column.calculateDisplayValue && "search" === target;
          var dataType = isSearchByDisplayValue && column.lookup && column.lookup.dataType || column.dataType;
          var filter = null;
          if (("headerFilter" === target || "filterBuilder" === target) && null === filterValue) {
            filter = [selector, selectedFilterOperation || "=", null];
            if ("string" === dataType) {
              filter = [filter, "=" === selectedFilterOperation ? "or" : "and", [selector, selectedFilterOperation || "=", ""]];
            }
          } else if ("string" === dataType && (!column.lookup || isSearchByDisplayValue)) {
            filter = [selector, selectedFilterOperation || "contains", filterValue];
          } else if ("between" === selectedFilterOperation) {
            return getFilterExpressionByRange.apply(column, [filterValue, target]);
          } else if (isDateType(dataType) && isDefined(filterValue)) {
            return getFilterExpressionForDate.apply(column, arguments);
          } else if ("number" === dataType) {
            return getFilterExpressionForNumber.apply(column, arguments);
          } else if ("object" !== dataType) {
            filter = [selector, selectedFilterOperation || "=", filterValue];
          }
          return filter;
        },
        getGroupInterval
      };
    }();
  }
});

// node_modules/devextreme/esm/ui/load_indicator.js
var navigator3, LOADINDICATOR_CLASS, LOADINDICATOR_WRAPPER_CLASS, LOADINDICATOR_CONTENT_CLASS, LOADINDICATOR_ICON_CLASS, LOADINDICATOR_SEGMENT_CLASS, LOADINDICATOR_SEGMENT_INNER_CLASS, LOADINDICATOR_IMAGE_CLASS, LoadIndicator, load_indicator_default;
var init_load_indicator = __esm({
  "node_modules/devextreme/esm/ui/load_indicator.js"() {
    init_renderer();
    init_window();
    init_support();
    init_themes();
    init_extend();
    init_devices();
    init_component_registrator();
    init_ui_widget();
    navigator3 = getNavigator();
    LOADINDICATOR_CLASS = "dx-loadindicator";
    LOADINDICATOR_WRAPPER_CLASS = "dx-loadindicator-wrapper";
    LOADINDICATOR_CONTENT_CLASS = "dx-loadindicator-content";
    LOADINDICATOR_ICON_CLASS = "dx-loadindicator-icon";
    LOADINDICATOR_SEGMENT_CLASS = "dx-loadindicator-segment";
    LOADINDICATOR_SEGMENT_INNER_CLASS = "dx-loadindicator-segment-inner";
    LOADINDICATOR_IMAGE_CLASS = "dx-loadindicator-image";
    LoadIndicator = ui_widget_default.inherit({
      _getDefaultOptions: function() {
        return extend2(this.callBase(), {
          indicatorSrc: "",
          activeStateEnabled: false,
          hoverStateEnabled: false,
          _animatingSegmentCount: 1,
          _animatingSegmentInner: false
        });
      },
      _defaultOptionsRules: function() {
        var themeName = current();
        return this.callBase().concat([{
          device: function() {
            var realDevice4 = devices_default.real();
            var obsoleteAndroid = "android" === realDevice4.platform && !/chrome/i.test(navigator3.userAgent);
            return obsoleteAndroid;
          },
          options: {
            viaImage: true
          }
        }, {
          device: function() {
            return isMaterial(themeName);
          },
          options: {
            _animatingSegmentCount: 2,
            _animatingSegmentInner: true
          }
        }, {
          device: function() {
            return isGeneric(themeName);
          },
          options: {
            _animatingSegmentCount: 7
          }
        }]);
      },
      _useTemplates: function() {
        return false;
      },
      _init: function() {
        this.callBase();
        this.$element().addClass(LOADINDICATOR_CLASS);
      },
      _initMarkup: function() {
        this.callBase();
        this._renderWrapper();
        this._renderIndicatorContent();
        this._renderMarkup();
      },
      _renderWrapper: function() {
        this._$wrapper = renderer_default("<div>").addClass(LOADINDICATOR_WRAPPER_CLASS);
        this.$element().append(this._$wrapper);
      },
      _renderIndicatorContent: function() {
        this._$content = renderer_default("<div>").addClass(LOADINDICATOR_CONTENT_CLASS);
        this._$wrapper.append(this._$content);
      },
      _renderMarkup: function() {
        if (animation() && !this.option("viaImage") && !this.option("indicatorSrc")) {
          this._renderMarkupForAnimation();
        } else {
          this._renderMarkupForImage();
        }
      },
      _renderMarkupForAnimation: function() {
        var animatingSegmentInner = this.option("_animatingSegmentInner");
        this._$indicator = renderer_default("<div>").addClass(LOADINDICATOR_ICON_CLASS);
        this._$content.append(this._$indicator);
        for (var i = this.option("_animatingSegmentCount"); i >= 0; --i) {
          var $segment = renderer_default("<div>").addClass(LOADINDICATOR_SEGMENT_CLASS).addClass(LOADINDICATOR_SEGMENT_CLASS + i);
          if (animatingSegmentInner) {
            $segment.append(renderer_default("<div>").addClass(LOADINDICATOR_SEGMENT_INNER_CLASS));
          }
          this._$indicator.append($segment);
        }
      },
      _renderMarkupForImage: function() {
        var indicatorSrc = this.option("indicatorSrc");
        this._$wrapper.addClass(LOADINDICATOR_IMAGE_CLASS);
        if (indicatorSrc) {
          this._$wrapper.css("backgroundImage", "url(" + indicatorSrc + ")");
        }
      },
      _renderDimensions: function() {
        this.callBase();
        this._updateContentSizeForAnimation();
      },
      _updateContentSizeForAnimation: function() {
        if (!this._$indicator) {
          return;
        }
        var width = this.option("width");
        var height = this.option("height");
        if (width || height) {
          width = this.$element().width();
          height = this.$element().height();
          var minDimension = Math.min(height, width);
          this._$wrapper.css({
            height: minDimension,
            width: minDimension,
            fontSize: minDimension
          });
        }
      },
      _clean: function() {
        this.callBase();
        this._removeMarkupForAnimation();
        this._removeMarkupForImage();
      },
      _removeMarkupForAnimation: function() {
        if (!this._$indicator) {
          return;
        }
        this._$indicator.remove();
        delete this._$indicator;
      },
      _removeMarkupForImage: function() {
        this._$wrapper.css("backgroundImage", "none");
      },
      _optionChanged: function(args) {
        switch (args.name) {
          case "_animatingSegmentCount":
          case "_animatingSegmentInner":
          case "indicatorSrc":
            this._invalidate();
            break;
          default:
            this.callBase(args);
        }
      }
    });
    component_registrator_default("dxLoadIndicator", LoadIndicator);
    load_indicator_default = LoadIndicator;
  }
});

// node_modules/devextreme/esm/animation/translator.js
function isPercentValue(value2) {
  return "string" === type(value2) && "%" === value2[value2.length - 1];
}
function cacheTranslate($element, translate) {
  if ($element.length) {
    data($element.get(0), TRANSLATOR_DATA_KEY, translate);
  }
}
var TRANSLATOR_DATA_KEY, TRANSFORM_MATRIX_REGEX, TRANSLATE_REGEX, locate, clearCache, getTranslateCss, getTranslate, move, resetPosition, parseTranslate;
var init_translator = __esm({
  "node_modules/devextreme/esm/animation/translator.js"() {
    init_renderer();
    init_element_data();
    init_type();
    TRANSLATOR_DATA_KEY = "dxTranslator";
    TRANSFORM_MATRIX_REGEX = /matrix(3d)?\((.+?)\)/;
    TRANSLATE_REGEX = /translate(?:3d)?\((.+?)\)/;
    locate = function($element) {
      $element = renderer_default($element);
      var translate = getTranslate($element);
      return {
        left: translate.x,
        top: translate.y
      };
    };
    clearCache = function($element) {
      if ($element.length) {
        removeData($element.get(0), TRANSLATOR_DATA_KEY);
      }
    };
    getTranslateCss = function(translate) {
      translate.x = translate.x || 0;
      translate.y = translate.y || 0;
      var xValueString = isPercentValue(translate.x) ? translate.x : translate.x + "px";
      var yValueString = isPercentValue(translate.y) ? translate.y : translate.y + "px";
      return "translate(" + xValueString + ", " + yValueString + ")";
    };
    getTranslate = function($element) {
      var result2 = $element.length ? data($element.get(0), TRANSLATOR_DATA_KEY) : null;
      if (!result2) {
        var transformValue = $element.css("transform") || getTranslateCss({
          x: 0,
          y: 0
        });
        var matrix = transformValue.match(TRANSFORM_MATRIX_REGEX);
        var is3D = matrix && matrix[1];
        if (matrix) {
          matrix = matrix[2].split(",");
          if ("3d" === is3D) {
            matrix = matrix.slice(12, 15);
          } else {
            matrix.push(0);
            matrix = matrix.slice(4, 7);
          }
        } else {
          matrix = [0, 0, 0];
        }
        result2 = {
          x: parseFloat(matrix[0]),
          y: parseFloat(matrix[1]),
          z: parseFloat(matrix[2])
        };
        cacheTranslate($element, result2);
      }
      return result2;
    };
    move = function($element, position3) {
      $element = renderer_default($element);
      var left = position3.left;
      var top = position3.top;
      var translate;
      if (void 0 === left) {
        translate = getTranslate($element);
        translate.y = top || 0;
      } else if (void 0 === top) {
        translate = getTranslate($element);
        translate.x = left || 0;
      } else {
        translate = {
          x: left || 0,
          y: top || 0,
          z: 0
        };
        cacheTranslate($element, translate);
      }
      $element.css({
        transform: getTranslateCss(translate)
      });
      if (isPercentValue(left) || isPercentValue(top)) {
        clearCache($element);
      }
    };
    resetPosition = function($element, finishTransition) {
      $element = renderer_default($element);
      var originalTransition;
      var stylesConfig = {
        left: 0,
        top: 0,
        transform: "none"
      };
      if (finishTransition) {
        originalTransition = $element.css("transition");
        stylesConfig.transition = "none";
      }
      $element.css(stylesConfig);
      clearCache($element);
      if (finishTransition) {
        $element.get(0).offsetHeight;
        $element.css("transition", originalTransition);
      }
    };
    parseTranslate = function(translateString) {
      var result2 = translateString.match(TRANSLATE_REGEX);
      if (!result2 || !result2[1]) {
        return;
      }
      result2 = result2[1].split(",");
      result2 = {
        x: parseFloat(result2[0]),
        y: parseFloat(result2[1]),
        z: parseFloat(result2[2])
      };
      return result2;
    };
  }
});

// node_modules/devextreme/esm/animation/easing.js
function getEasing(name2) {
  return easing[name2];
}
var CSS_TRANSITION_EASING_REGEX, TransitionTimingFuncMap, polynomBezier, easing, convertTransitionTimingFuncToEasing;
var init_easing = __esm({
  "node_modules/devextreme/esm/animation/easing.js"() {
    init_type();
    CSS_TRANSITION_EASING_REGEX = /cubic-bezier\((\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\)/;
    TransitionTimingFuncMap = {
      linear: "cubic-bezier(0, 0, 1, 1)",
      swing: "cubic-bezier(0.445, 0.05, 0.55, 0.95)",
      ease: "cubic-bezier(0.25, 0.1, 0.25, 1)",
      "ease-in": "cubic-bezier(0.42, 0, 1, 1)",
      "ease-out": "cubic-bezier(0, 0, 0.58, 1)",
      "ease-in-out": "cubic-bezier(0.42, 0, 0.58, 1)"
    };
    polynomBezier = function(x1, y1, x2, y2) {
      var Cx = 3 * x1;
      var Bx = 3 * (x2 - x1) - Cx;
      var Ax = 1 - Cx - Bx;
      var Cy = 3 * y1;
      var By = 3 * (y2 - y1) - Cy;
      var Ay = 1 - Cy - By;
      var bezierX = function(t) {
        return t * (Cx + t * (Bx + t * Ax));
      };
      var derivativeX = function(t) {
        return Cx + t * (2 * Bx + 3 * t * Ax);
      };
      return function(t) {
        return function(t2) {
          return t2 * (Cy + t2 * (By + t2 * Ay));
        }(function(t2) {
          var x = t2;
          var i = 0;
          var z;
          while (i < 14) {
            z = bezierX(x) - t2;
            if (Math.abs(z) < 1e-3) {
              break;
            }
            x -= z / derivativeX(x);
            i++;
          }
          return x;
        }(t));
      };
    };
    easing = {};
    convertTransitionTimingFuncToEasing = function(cssTransitionEasing) {
      cssTransitionEasing = TransitionTimingFuncMap[cssTransitionEasing] || cssTransitionEasing;
      var coeffs = cssTransitionEasing.match(CSS_TRANSITION_EASING_REGEX);
      var forceName;
      if (!coeffs) {
        forceName = "linear";
        coeffs = TransitionTimingFuncMap[forceName].match(CSS_TRANSITION_EASING_REGEX);
      }
      coeffs = coeffs.slice(1, 5);
      for (var i = 0; i < coeffs.length; i++) {
        coeffs[i] = parseFloat(coeffs[i]);
      }
      var easingName = forceName || "cubicbezier_" + coeffs.join("_").replace(/\./g, "p");
      if (!isFunction(easing[easingName])) {
        easing[easingName] = function(x, t, b, c, d) {
          return c * polynomBezier(coeffs[0], coeffs[1], coeffs[2], coeffs[3])(t / d) + b;
        };
      }
      return easingName;
    };
  }
});

// node_modules/devextreme/esm/animation/position.js
var window10, horzRe, vertRe, collisionRe, scaleRe, IS_SAFARI, normalizeAlign, normalizeOffset, normalizeCollision, getAlignFactor, inverseAlign, calculateOversize, collisionSide, initMyLocation, collisionResolvers, scrollbarWidth, calculateScrollbarWidth, defaultPositionResult, calculatePosition, getOffsetWithoutScale, position, offset, position_default;
var init_position2 = __esm({
  "node_modules/devextreme/esm/animation/position.js"() {
    init_renderer();
    init_common();
    init_iterator();
    init_window();
    init_dom_adapter();
    init_type();
    init_extend();
    init_position();
    init_browser();
    init_translator();
    init_support();
    init_devices();
    window10 = getWindow();
    horzRe = /left|right/;
    vertRe = /top|bottom/;
    collisionRe = /fit|flip|none/;
    scaleRe = /scale(.+)/;
    IS_SAFARI = browser_default.safari;
    normalizeAlign = function(raw) {
      var result2 = {
        h: "center",
        v: "center"
      };
      var pair = splitPair(raw);
      if (pair) {
        each(pair, function() {
          var w = String(this).toLowerCase();
          if (horzRe.test(w)) {
            result2.h = w;
          } else if (vertRe.test(w)) {
            result2.v = w;
          }
        });
      }
      return result2;
    };
    normalizeOffset = function(raw) {
      return pairToObject(raw);
    };
    normalizeCollision = function(raw) {
      var pair = splitPair(raw);
      var h = String(pair && pair[0]).toLowerCase();
      var v = String(pair && pair[1]).toLowerCase();
      if (!collisionRe.test(h)) {
        h = "none";
      }
      if (!collisionRe.test(v)) {
        v = h;
      }
      return {
        h,
        v
      };
    };
    getAlignFactor = function(align) {
      switch (align) {
        case "center":
          return 0.5;
        case "right":
        case "bottom":
          return 1;
        default:
          return 0;
      }
    };
    inverseAlign = function(align) {
      switch (align) {
        case "left":
          return "right";
        case "right":
          return "left";
        case "top":
          return "bottom";
        case "bottom":
          return "top";
        default:
          return align;
      }
    };
    calculateOversize = function(data2, bounds) {
      var oversize = 0;
      if (data2.myLocation < bounds.min) {
        oversize += bounds.min - data2.myLocation;
      }
      if (data2.myLocation > bounds.max) {
        oversize += data2.myLocation - bounds.max;
      }
      return oversize;
    };
    collisionSide = function(direction, data2, bounds) {
      if (data2.myLocation < bounds.min) {
        return "h" === direction ? "left" : "top";
      }
      if (data2.myLocation > bounds.max) {
        return "h" === direction ? "right" : "bottom";
      }
      return "none";
    };
    initMyLocation = function(data2) {
      data2.myLocation = data2.atLocation + getAlignFactor(data2.atAlign) * data2.atSize - getAlignFactor(data2.myAlign) * data2.mySize + data2.offset;
    };
    collisionResolvers = {
      fit: function(data2, bounds) {
        var result2 = false;
        if (data2.myLocation > bounds.max) {
          data2.myLocation = bounds.max;
          result2 = true;
        }
        if (data2.myLocation < bounds.min) {
          data2.myLocation = bounds.min;
          result2 = true;
        }
        data2.fit = result2;
      },
      flip: function(data2, bounds) {
        data2.flip = false;
        if ("center" === data2.myAlign && "center" === data2.atAlign) {
          return;
        }
        if (data2.myLocation < bounds.min || data2.myLocation > bounds.max) {
          var inverseData = extend2({}, data2, {
            myAlign: inverseAlign(data2.myAlign),
            atAlign: inverseAlign(data2.atAlign),
            offset: -data2.offset
          });
          initMyLocation(inverseData);
          inverseData.oversize = calculateOversize(inverseData, bounds);
          if (inverseData.myLocation >= bounds.min && inverseData.myLocation <= bounds.max || data2.oversize > inverseData.oversize) {
            data2.myLocation = inverseData.myLocation;
            data2.oversize = inverseData.oversize;
            data2.flip = true;
          }
        }
      },
      flipfit: function(data2, bounds) {
        this.flip(data2, bounds);
        this.fit(data2, bounds);
      },
      none: function(data2) {
        data2.oversize = 0;
      }
    };
    calculateScrollbarWidth = function() {
      var $scrollDiv = renderer_default("<div>").css({
        width: 100,
        height: 100,
        overflow: "scroll",
        position: "absolute",
        top: -9999
      }).appendTo(renderer_default("body"));
      var result2 = $scrollDiv.get(0).offsetWidth - $scrollDiv.get(0).clientWidth;
      $scrollDiv.remove();
      scrollbarWidth = result2;
    };
    defaultPositionResult = {
      h: {
        location: 0,
        flip: false,
        fit: false,
        oversize: 0
      },
      v: {
        location: 0,
        flip: false,
        fit: false,
        oversize: 0
      }
    };
    calculatePosition = function(what, options2) {
      var $what = renderer_default(what);
      var currentOffset = $what.offset();
      var result2 = extend2(true, {}, defaultPositionResult, {
        h: {
          location: currentOffset.left
        },
        v: {
          location: currentOffset.top
        }
      });
      if (!options2) {
        return result2;
      }
      var my = normalizeAlign(options2.my);
      var at = normalizeAlign(options2.at);
      var of = renderer_default(options2.of).length && options2.of || window10;
      var offset2 = normalizeOffset(options2.offset);
      var collision = normalizeCollision(options2.collision);
      var boundary = options2.boundary;
      var boundaryOffset = normalizeOffset(options2.boundaryOffset);
      var h = {
        mySize: $what.outerWidth(),
        myAlign: my.h,
        atAlign: at.h,
        offset: offset2.h,
        collision: collision.h,
        boundaryOffset: boundaryOffset.h
      };
      var v = {
        mySize: $what.outerHeight(),
        myAlign: my.v,
        atAlign: at.v,
        offset: offset2.v,
        collision: collision.v,
        boundaryOffset: boundaryOffset.v
      };
      if (of.preventDefault) {
        h.atLocation = of.pageX;
        v.atLocation = of.pageY;
        h.atSize = 0;
        v.atSize = 0;
      } else {
        of = renderer_default(of);
        if (isWindow(of[0])) {
          h.atLocation = of.scrollLeft();
          v.atLocation = of.scrollTop();
          if ("phone" === devices_default.real().deviceType && of[0].visualViewport) {
            h.atLocation = Math.max(h.atLocation, of[0].visualViewport.offsetLeft);
            v.atLocation = Math.max(v.atLocation, of[0].visualViewport.offsetTop);
            h.atSize = of[0].visualViewport.width;
            v.atSize = of[0].visualViewport.height;
          } else {
            h.atSize = of[0].innerWidth > of[0].outerWidth ? of[0].innerWidth : of.width();
            v.atSize = of[0].innerHeight > of[0].outerHeight || IS_SAFARI ? of[0].innerHeight : of.height();
          }
        } else if (9 === of[0].nodeType) {
          h.atLocation = 0;
          v.atLocation = 0;
          h.atSize = of.width();
          v.atSize = of.height();
        } else {
          var ofRect = getBoundingRect(of.get(0));
          var o = getOffsetWithoutScale(of);
          h.atLocation = o.left;
          v.atLocation = o.top;
          h.atSize = Math.max(ofRect.width, of.outerWidth());
          v.atSize = Math.max(ofRect.height, of.outerHeight());
        }
      }
      initMyLocation(h);
      initMyLocation(v);
      var bounds = function() {
        var win = renderer_default(window10);
        var windowWidth = win.width();
        var windowHeight = win.height();
        var left = win.scrollLeft();
        var top = win.scrollTop();
        var documentElement = dom_adapter_default.getDocumentElement();
        var hZoomLevel = touch ? documentElement.clientWidth / windowWidth : 1;
        var vZoomLevel = touch ? documentElement.clientHeight / windowHeight : 1;
        if (void 0 === scrollbarWidth) {
          calculateScrollbarWidth();
        }
        var boundaryWidth = windowWidth;
        var boundaryHeight = windowHeight;
        if (boundary) {
          var $boundary = renderer_default(boundary);
          var boundaryPosition = $boundary.offset();
          left = boundaryPosition.left;
          top = boundaryPosition.top;
          boundaryWidth = $boundary.width();
          boundaryHeight = $boundary.height();
        }
        return {
          h: {
            min: left + h.boundaryOffset,
            max: left + boundaryWidth / hZoomLevel - h.mySize - h.boundaryOffset
          },
          v: {
            min: top + v.boundaryOffset,
            max: top + boundaryHeight / vZoomLevel - v.mySize - v.boundaryOffset
          }
        };
      }();
      h.oversize = calculateOversize(h, bounds.h);
      v.oversize = calculateOversize(v, bounds.v);
      h.collisionSide = collisionSide("h", h, bounds.h);
      v.collisionSide = collisionSide("v", v, bounds.v);
      if (collisionResolvers[h.collision]) {
        collisionResolvers[h.collision](h, bounds.h);
      }
      if (collisionResolvers[v.collision]) {
        collisionResolvers[v.collision](v, bounds.v);
      }
      var preciser = function(number2) {
        return options2.precise ? number2 : Math.round(number2);
      };
      extend2(true, result2, {
        h: {
          location: preciser(h.myLocation),
          oversize: preciser(h.oversize),
          fit: h.fit,
          flip: h.flip,
          collisionSide: h.collisionSide
        },
        v: {
          location: preciser(v.myLocation),
          oversize: preciser(v.oversize),
          fit: v.fit,
          flip: v.flip,
          collisionSide: v.collisionSide
        },
        precise: options2.precise
      });
      return result2;
    };
    getOffsetWithoutScale = function getOffsetWithoutScale2($startElement) {
      var _currentElement$getAt, _style$match;
      var $currentElement = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : $startElement;
      var currentElement = $currentElement.get(0);
      if (!currentElement) {
        return $startElement.offset();
      }
      var style = (null === (_currentElement$getAt = currentElement.getAttribute) || void 0 === _currentElement$getAt ? void 0 : _currentElement$getAt.call(currentElement, "style")) || "";
      var scale = null === (_style$match = style.match(scaleRe)) || void 0 === _style$match ? void 0 : _style$match[0];
      var offset2;
      if (scale) {
        currentElement.setAttribute("style", style.replace(scale, ""));
        offset2 = getOffsetWithoutScale2($startElement, $currentElement.parent());
        currentElement.setAttribute("style", style);
      } else {
        offset2 = getOffsetWithoutScale2($startElement, $currentElement.parent());
      }
      return offset2;
    };
    position = function(what, options2) {
      var $what = renderer_default(what);
      if (!options2) {
        return $what.offset();
      }
      resetPosition($what, true);
      var offset2 = getOffsetWithoutScale($what);
      var targetPosition = options2.h && options2.v ? options2 : calculatePosition($what, options2);
      var preciser = function(number2) {
        return options2.precise ? number2 : Math.round(number2);
      };
      move($what, {
        left: targetPosition.h.location - preciser(offset2.left),
        top: targetPosition.v.location - preciser(offset2.top)
      });
      return targetPosition;
    };
    offset = function(element) {
      element = renderer_default(element).get(0);
      if (isWindow(element)) {
        return null;
      } else if (element && "pageY" in element && "pageX" in element) {
        return {
          top: element.pageY,
          left: element.pageX
        };
      }
      return renderer_default(element).offset();
    };
    if (!position.inverseAlign) {
      position.inverseAlign = inverseAlign;
    }
    if (!position.normalizeAlign) {
      position.normalizeAlign = normalizeAlign;
    }
    position_default = {
      calculateScrollbarWidth,
      calculate: calculatePosition,
      setup: position,
      offset
    };
  }
});

// node_modules/devextreme/esm/animation/fx.js
function setupAnimationOnElement() {
  var $element = this.element;
  var config2 = this.config;
  setupPosition($element, config2.from);
  setupPosition($element, config2.to);
  this.configurator.setup($element, config2);
  $element.data(ANIM_DATA_KEY, this);
  if (fx.off) {
    config2.duration = 0;
    config2.delay = 0;
  }
  this.strategy.initAnimation($element, config2);
  if (config2.start) {
    var element = getPublicElement($element);
    config2.start.apply(this, [element, config2]);
  }
}
function pushInAnimationQueue($element, animation3) {
  var queueData = getAnimQueueData($element);
  writeAnimQueueData($element, queueData);
  queueData.push(animation3);
  if (!isAnimating($element)) {
    shiftFromAnimationQueue($element, queueData);
  }
}
function getAnimQueueData($element) {
  return $element.data(ANIM_QUEUE_KEY) || [];
}
function writeAnimQueueData($element, queueData) {
  $element.data(ANIM_QUEUE_KEY, queueData);
}
function isAnimating($element) {
  return !!$element.data(ANIM_DATA_KEY);
}
function shiftFromAnimationQueue($element, queueData) {
  queueData = getAnimQueueData($element);
  if (!queueData.length) {
    return;
  }
  var animation3 = queueData.shift();
  if (0 === queueData.length) {
    destroyAnimQueueData($element);
  }
  executeAnimation(animation3).done(function() {
    if (!isAnimating($element)) {
      shiftFromAnimationQueue($element);
    }
  });
}
function executeAnimation(animation3) {
  animation3.setup();
  if (fx.off || animation3.isSynchronous) {
    animation3.start();
  } else {
    animation3.startTimeout = setTimeout(function() {
      animation3.start();
    });
  }
  return animation3.deferred.promise();
}
function setupPosition($element, config2) {
  if (!config2 || !config2.position) {
    return;
  }
  var win = renderer_default(window11);
  var left = 0;
  var top = 0;
  var position3 = position_default.calculate($element, config2.position);
  var offset2 = $element.offset();
  var currentPosition = $element.position();
  if (currentPosition.top > offset2.top) {
    top = win.scrollTop();
  }
  if (currentPosition.left > offset2.left) {
    left = win.scrollLeft();
  }
  extend2(config2, {
    left: position3.h.location - offset2.left + currentPosition.left - left,
    top: position3.v.location - offset2.top + currentPosition.top - top
  });
  delete config2.position;
}
function setProps($element, props) {
  each(props, function(key, value2) {
    try {
      $element.css(key, isFunction(value2) ? value2() : value2);
    } catch (e) {
    }
  });
}
var window11, removeEventName, RELATIVE_VALUE_REGEX, ANIM_DATA_KEY, ANIM_QUEUE_KEY, TRANSFORM_PROP, TransitionAnimationStrategy, FrameAnimationStrategy, FallbackToNoAnimationStrategy, getAnimationStrategy, baseConfigValidator, isObjectConfigValidator, isStringConfigValidator, CustomAnimationConfigurator, CssAnimationConfigurator, positionAliases, SlideAnimationConfigurator, FadeAnimationConfigurator, PopAnimationConfigurator, animationConfigurators, getAnimationConfigurator, defaultJSConfig, defaultCssConfig, onElementAnimationComplete, startAnimationOnElement, stopAnimationOnElement, scopedRemoveEvent, subscribeToRemoveEvent, createAnimation, animate, destroyAnimQueueData, stop, fx, fx_default;
var init_fx = __esm({
  "node_modules/devextreme/esm/animation/fx.js"() {
    init_renderer();
    init_window();
    init_events_engine();
    init_errors();
    init_element();
    init_extend();
    init_type();
    init_iterator();
    init_translator();
    init_easing();
    init_frame();
    init_support();
    init_position2();
    init_remove();
    init_utils2();
    init_deferred();
    init_common();
    window11 = getWindow();
    removeEventName = addNamespace2(removeEvent, "dxFX");
    RELATIVE_VALUE_REGEX = /^([+-])=(.*)/i;
    ANIM_DATA_KEY = "dxAnimData";
    ANIM_QUEUE_KEY = "dxAnimQueue";
    TRANSFORM_PROP = "transform";
    TransitionAnimationStrategy = {
      initAnimation: function($element, config2) {
        $element.css({
          transitionProperty: "none"
        });
        if ("string" === typeof config2.from) {
          $element.addClass(config2.from);
        } else {
          setProps($element, config2.from);
        }
        var that = this;
        var deferred = new Deferred();
        var cleanupWhen = config2.cleanupWhen;
        config2.transitionAnimation = {
          deferred,
          finish: function() {
            that._finishTransition($element);
            if (cleanupWhen) {
              when(deferred, cleanupWhen).always(function() {
                that._cleanup($element, config2);
              });
            } else {
              that._cleanup($element, config2);
            }
            deferred.resolveWith($element, [config2, $element]);
          }
        };
        this._completeAnimationCallback($element, config2).done(function() {
          config2.transitionAnimation.finish();
        }).fail(function() {
          deferred.rejectWith($element, [config2, $element]);
        });
        if (!config2.duration) {
          config2.transitionAnimation.finish();
        }
        $element.css("transform");
      },
      animate: function($element, config2) {
        this._startAnimation($element, config2);
        return config2.transitionAnimation.deferred.promise();
      },
      _completeAnimationCallback: function($element, config2) {
        var that = this;
        var startTime = Date.now() + config2.delay;
        var deferred = new Deferred();
        var transitionEndFired = new Deferred();
        var simulatedTransitionEndFired = new Deferred();
        var simulatedEndEventTimer;
        var transitionEndEventFullName = transitionEndEventName() + ".dxFX";
        config2.transitionAnimation.cleanup = function() {
          clearTimeout(simulatedEndEventTimer);
          clearTimeout(waitForJSCompleteTimer);
          events_engine_default.off($element, transitionEndEventFullName);
          events_engine_default.off($element, removeEventName);
        };
        events_engine_default.one($element, transitionEndEventFullName, function() {
          if (Date.now() - startTime >= config2.duration) {
            transitionEndFired.reject();
          }
        });
        events_engine_default.off($element, removeEventName);
        events_engine_default.on($element, removeEventName, function() {
          that.stop($element, config2);
          deferred.reject();
        });
        var waitForJSCompleteTimer = setTimeout(function() {
          simulatedEndEventTimer = setTimeout(function() {
            simulatedTransitionEndFired.reject();
          }, config2.duration + config2.delay + fx._simulatedTransitionEndDelay);
          when(transitionEndFired, simulatedTransitionEndFired).fail((function() {
            deferred.resolve();
          }).bind(this));
        });
        return deferred.promise();
      },
      _startAnimation: function($element, config2) {
        $element.css({
          transitionProperty: "all",
          transitionDelay: config2.delay + "ms",
          transitionDuration: config2.duration + "ms",
          transitionTimingFunction: config2.easing
        });
        if ("string" === typeof config2.to) {
          $element[0].className += " " + config2.to;
        } else if (config2.to) {
          setProps($element, config2.to);
        }
      },
      _finishTransition: function($element) {
        $element.css("transition", "none");
      },
      _cleanup: function($element, config2) {
        config2.transitionAnimation.cleanup();
        if ("string" === typeof config2.from) {
          $element.removeClass(config2.from);
          $element.removeClass(config2.to);
        }
      },
      stop: function($element, config2, jumpToEnd) {
        if (!config2) {
          return;
        }
        if (jumpToEnd) {
          config2.transitionAnimation.finish();
        } else {
          if (isPlainObject(config2.to)) {
            each(config2.to, function(key) {
              $element.css(key, $element.css(key));
            });
          }
          this._finishTransition($element);
          this._cleanup($element, config2);
        }
      }
    };
    FrameAnimationStrategy = {
      initAnimation: function($element, config2) {
        setProps($element, config2.from);
      },
      animate: function($element, config2) {
        var deferred = new Deferred();
        var that = this;
        if (!config2) {
          return deferred.reject().promise();
        }
        each(config2.to, function(prop) {
          if (void 0 === config2.from[prop]) {
            config2.from[prop] = that._normalizeValue($element.css(prop));
          }
        });
        if (config2.to[TRANSFORM_PROP]) {
          config2.from[TRANSFORM_PROP] = that._parseTransform(config2.from[TRANSFORM_PROP]);
          config2.to[TRANSFORM_PROP] = that._parseTransform(config2.to[TRANSFORM_PROP]);
        }
        config2.frameAnimation = {
          to: config2.to,
          from: config2.from,
          currentValue: config2.from,
          easing: convertTransitionTimingFuncToEasing(config2.easing),
          duration: config2.duration,
          startTime: (/* @__PURE__ */ new Date()).valueOf(),
          finish: function() {
            this.currentValue = this.to;
            this.draw();
            cancelAnimationFrame(config2.frameAnimation.animationFrameId);
            deferred.resolve();
          },
          draw: function() {
            if (config2.draw) {
              config2.draw(this.currentValue);
              return;
            }
            var currentValue = extend2({}, this.currentValue);
            if (currentValue[TRANSFORM_PROP]) {
              currentValue[TRANSFORM_PROP] = map(currentValue[TRANSFORM_PROP], function(value2, prop) {
                if ("translate" === prop) {
                  return getTranslateCss(value2);
                } else if ("scale" === prop) {
                  return "scale(" + value2 + ")";
                } else if ("rotate" === prop.substr(0, prop.length - 1)) {
                  return prop + "(" + value2 + "deg)";
                }
              }).join(" ");
            }
            $element.css(currentValue);
          }
        };
        if (config2.delay) {
          config2.frameAnimation.startTime += config2.delay;
          config2.frameAnimation.delayTimeout = setTimeout(function() {
            that._startAnimation($element, config2);
          }, config2.delay);
        } else {
          that._startAnimation($element, config2);
        }
        return deferred.promise();
      },
      _startAnimation: function($element, config2) {
        events_engine_default.off($element, removeEventName);
        events_engine_default.on($element, removeEventName, function() {
          if (config2.frameAnimation) {
            cancelAnimationFrame(config2.frameAnimation.animationFrameId);
          }
        });
        this._animationStep($element, config2);
      },
      _parseTransform: function(transformString) {
        var result2 = {};
        each(transformString.match(/\w+\d*\w*\([^)]*\)\s*/g), function(i, part) {
          var translateData = parseTranslate(part);
          var scaleData = part.match(/scale\((.+?)\)/);
          var rotateData = part.match(/(rotate.)\((.+)deg\)/);
          if (translateData) {
            result2.translate = translateData;
          }
          if (scaleData && scaleData[1]) {
            result2.scale = parseFloat(scaleData[1]);
          }
          if (rotateData && rotateData[1]) {
            result2[rotateData[1]] = parseFloat(rotateData[2]);
          }
        });
        return result2;
      },
      stop: function($element, config2, jumpToEnd) {
        var frameAnimation = config2 && config2.frameAnimation;
        if (!frameAnimation) {
          return;
        }
        cancelAnimationFrame(frameAnimation.animationFrameId);
        clearTimeout(frameAnimation.delayTimeout);
        if (jumpToEnd) {
          frameAnimation.finish();
        }
        delete config2.frameAnimation;
      },
      _animationStep: function($element, config2) {
        var frameAnimation = config2 && config2.frameAnimation;
        if (!frameAnimation) {
          return;
        }
        var now = (/* @__PURE__ */ new Date()).valueOf();
        if (now >= frameAnimation.startTime + frameAnimation.duration) {
          frameAnimation.finish();
          return;
        }
        frameAnimation.currentValue = this._calcStepValue(frameAnimation, now - frameAnimation.startTime);
        frameAnimation.draw();
        var that = this;
        frameAnimation.animationFrameId = requestAnimationFrame(function() {
          that._animationStep($element, config2);
        });
      },
      _calcStepValue: function(frameAnimation, currentDuration) {
        return function calcValueRecursively(from, to) {
          var result2 = Array.isArray(to) ? [] : {};
          each(to, function(propName, endPropValue) {
            if ("string" === typeof endPropValue && false === parseFloat(endPropValue, 10)) {
              return true;
            }
            result2[propName] = "object" === typeof endPropValue ? calcValueRecursively(from[propName], endPropValue) : function(propName2) {
              var x = currentDuration / frameAnimation.duration;
              var t = currentDuration;
              var b = 1 * from[propName2];
              var c = to[propName2] - from[propName2];
              var d = frameAnimation.duration;
              return getEasing(frameAnimation.easing)(x, t, b, c, d);
            }(propName);
          });
          return result2;
        }(frameAnimation.from, frameAnimation.to);
      },
      _normalizeValue: function(value2) {
        var numericValue = parseFloat(value2, 10);
        if (false === numericValue) {
          return value2;
        }
        return numericValue;
      }
    };
    FallbackToNoAnimationStrategy = {
      initAnimation: function() {
      },
      animate: function() {
        return new Deferred().resolve().promise();
      },
      stop: noop2,
      isSynchronous: true
    };
    getAnimationStrategy = function(config2) {
      config2 = config2 || {};
      var animationStrategies = {
        transition: transition() ? TransitionAnimationStrategy : FrameAnimationStrategy,
        frame: FrameAnimationStrategy,
        noAnimation: FallbackToNoAnimationStrategy
      };
      var strategy3 = config2.strategy || "transition";
      if ("css" === config2.type && !transition()) {
        strategy3 = "noAnimation";
      }
      return animationStrategies[strategy3];
    };
    baseConfigValidator = function(config2, animationType, validate, typeMessage) {
      each(["from", "to"], function() {
        if (!validate(config2[this])) {
          throw errors_default.Error("E0010", animationType, this, typeMessage);
        }
      });
    };
    isObjectConfigValidator = function(config2, animationType) {
      return baseConfigValidator(config2, animationType, function(target) {
        return isPlainObject(target);
      }, "a plain object");
    };
    isStringConfigValidator = function(config2, animationType) {
      return baseConfigValidator(config2, animationType, function(target) {
        return "string" === typeof target;
      }, "a string");
    };
    CustomAnimationConfigurator = {
      setup: function() {
      }
    };
    CssAnimationConfigurator = {
      validateConfig: function(config2) {
        isStringConfigValidator(config2, "css");
      },
      setup: function() {
      }
    };
    positionAliases = {
      top: {
        my: "bottom center",
        at: "top center"
      },
      bottom: {
        my: "top center",
        at: "bottom center"
      },
      right: {
        my: "left center",
        at: "right center"
      },
      left: {
        my: "right center",
        at: "left center"
      }
    };
    SlideAnimationConfigurator = {
      validateConfig: function(config2) {
        isObjectConfigValidator(config2, "slide");
      },
      setup: function($element, config2) {
        var location = locate($element);
        if ("slide" !== config2.type) {
          var positioningConfig = "slideIn" === config2.type ? config2.from : config2.to;
          positioningConfig.position = extend2({
            of: window11
          }, positionAliases[config2.direction]);
          setupPosition($element, positioningConfig);
        }
        this._setUpConfig(location, config2.from);
        this._setUpConfig(location, config2.to);
        clearCache($element);
      },
      _setUpConfig: function(location, config2) {
        config2.left = "left" in config2 ? config2.left : "+=0";
        config2.top = "top" in config2 ? config2.top : "+=0";
        this._initNewPosition(location, config2);
      },
      _initNewPosition: function(location, config2) {
        var position3 = {
          left: config2.left,
          top: config2.top
        };
        delete config2.left;
        delete config2.top;
        var relativeValue = this._getRelativeValue(position3.left);
        if (void 0 !== relativeValue) {
          position3.left = relativeValue + location.left;
        } else {
          config2.left = 0;
        }
        relativeValue = this._getRelativeValue(position3.top);
        if (void 0 !== relativeValue) {
          position3.top = relativeValue + location.top;
        } else {
          config2.top = 0;
        }
        config2[TRANSFORM_PROP] = getTranslateCss({
          x: position3.left,
          y: position3.top
        });
      },
      _getRelativeValue: function(value2) {
        var relativeValue;
        if ("string" === typeof value2 && (relativeValue = RELATIVE_VALUE_REGEX.exec(value2))) {
          return parseInt(relativeValue[1] + "1") * relativeValue[2];
        }
      }
    };
    FadeAnimationConfigurator = {
      setup: function($element, config2) {
        var _from$opacity, _to$opacity;
        var from = config2.from;
        var to = config2.to;
        var defaultFromOpacity = "fadeOut" === config2.type ? 1 : 0;
        var defaultToOpacity = "fadeOut" === config2.type ? 0 : 1;
        var fromOpacity = isPlainObject(from) ? String(null !== (_from$opacity = from.opacity) && void 0 !== _from$opacity ? _from$opacity : defaultFromOpacity) : String(from);
        var toOpacity = isPlainObject(to) ? String(null !== (_to$opacity = to.opacity) && void 0 !== _to$opacity ? _to$opacity : defaultToOpacity) : String(to);
        if (!config2.skipElementInitialStyles) {
          fromOpacity = $element.css("opacity");
        }
        switch (config2.type) {
          case "fadeIn":
            toOpacity = 1;
            break;
          case "fadeOut":
            toOpacity = 0;
        }
        config2.from = {
          visibility: "visible",
          opacity: fromOpacity
        };
        config2.to = {
          opacity: toOpacity
        };
      }
    };
    PopAnimationConfigurator = {
      validateConfig: function(config2) {
        isObjectConfigValidator(config2, "pop");
      },
      setup: function($element, config2) {
        var from = config2.from;
        var to = config2.to;
        var fromOpacity = "opacity" in from ? from.opacity : $element.css("opacity");
        var toOpacity = "opacity" in to ? to.opacity : 1;
        var fromScale = "scale" in from ? from.scale : 0;
        var toScale = "scale" in to ? to.scale : 1;
        config2.from = {
          opacity: fromOpacity
        };
        var translate = getTranslate($element);
        config2.from[TRANSFORM_PROP] = this._getCssTransform(translate, fromScale);
        config2.to = {
          opacity: toOpacity
        };
        config2.to[TRANSFORM_PROP] = this._getCssTransform(translate, toScale);
      },
      _getCssTransform: function(translate, scale) {
        return getTranslateCss(translate) + "scale(" + scale + ")";
      }
    };
    animationConfigurators = {
      custom: CustomAnimationConfigurator,
      slide: SlideAnimationConfigurator,
      slideIn: SlideAnimationConfigurator,
      slideOut: SlideAnimationConfigurator,
      fade: FadeAnimationConfigurator,
      fadeIn: FadeAnimationConfigurator,
      fadeOut: FadeAnimationConfigurator,
      pop: PopAnimationConfigurator,
      css: CssAnimationConfigurator
    };
    getAnimationConfigurator = function(config2) {
      var result2 = animationConfigurators[config2.type];
      if (!result2) {
        throw errors_default.Error("E0011", config2.type);
      }
      return result2;
    };
    defaultJSConfig = {
      type: "custom",
      from: {},
      to: {},
      duration: 400,
      start: noop2,
      complete: noop2,
      easing: "ease",
      delay: 0
    };
    defaultCssConfig = {
      duration: 400,
      easing: "ease",
      delay: 0
    };
    onElementAnimationComplete = function(animation3) {
      var $element = animation3.element;
      var config2 = animation3.config;
      $element.removeData(ANIM_DATA_KEY);
      if (config2.complete) {
        var element = getPublicElement($element);
        config2.complete.apply(this, [element, config2]);
      }
      animation3.deferred.resolveWith(this, [$element, config2]);
    };
    startAnimationOnElement = function() {
      var animation3 = this;
      var $element = animation3.element;
      var config2 = animation3.config;
      animation3.isStarted = true;
      return animation3.strategy.animate($element, config2).done(function() {
        onElementAnimationComplete(animation3);
      }).fail(function() {
        animation3.deferred.rejectWith(this, [$element, config2]);
      });
    };
    stopAnimationOnElement = function(jumpToEnd) {
      var $element = this.element;
      var config2 = this.config;
      clearTimeout(this.startTimeout);
      if (!this.isStarted) {
        this.start();
      }
      this.strategy.stop($element, config2, jumpToEnd);
    };
    scopedRemoveEvent = addNamespace2(removeEvent, "dxFXStartAnimation");
    subscribeToRemoveEvent = function(animation3) {
      events_engine_default.off(animation3.element, scopedRemoveEvent);
      events_engine_default.on(animation3.element, scopedRemoveEvent, function() {
        fx.stop(animation3.element);
      });
      animation3.deferred.always(function() {
        events_engine_default.off(animation3.element, scopedRemoveEvent);
      });
    };
    createAnimation = function(element, initialConfig) {
      var defaultConfig = "css" === initialConfig.type ? defaultCssConfig : defaultJSConfig;
      var config2 = extend2(true, {}, defaultConfig, initialConfig);
      var configurator = getAnimationConfigurator(config2);
      var strategy3 = getAnimationStrategy(config2);
      var animation3 = {
        element: renderer_default(element),
        config: config2,
        configurator,
        strategy: strategy3,
        isSynchronous: strategy3.isSynchronous,
        setup: setupAnimationOnElement,
        start: startAnimationOnElement,
        stop: stopAnimationOnElement,
        deferred: new Deferred()
      };
      if (isFunction(configurator.validateConfig)) {
        configurator.validateConfig(config2);
      }
      subscribeToRemoveEvent(animation3);
      return animation3;
    };
    animate = function(element, config2) {
      var $element = renderer_default(element);
      if (!$element.length) {
        return new Deferred().resolve().promise();
      }
      var animation3 = createAnimation($element, config2);
      pushInAnimationQueue($element, animation3);
      return animation3.deferred.promise();
    };
    destroyAnimQueueData = function($element) {
      $element.removeData(ANIM_QUEUE_KEY);
    };
    stop = function(element, jumpToEnd) {
      var $element = renderer_default(element);
      var queueData = getAnimQueueData($element);
      each(queueData, function(_2, animation4) {
        animation4.config.delay = 0;
        animation4.config.duration = 0;
        animation4.isSynchronous = true;
      });
      if (!isAnimating($element)) {
        shiftFromAnimationQueue($element, queueData);
      }
      var animation3 = $element.data(ANIM_DATA_KEY);
      if (animation3) {
        animation3.stop(jumpToEnd);
      }
      $element.removeData(ANIM_DATA_KEY);
      destroyAnimQueueData($element);
    };
    fx = {
      off: false,
      animationTypes: animationConfigurators,
      animate,
      createAnimation,
      isAnimating,
      stop,
      _simulatedTransitionEndDelay: 100
    };
    fx_default = fx;
  }
});

// node_modules/devextreme/esm/core/utils/math.js
function getExponent(value2) {
  return Math.abs(parseInt(value2.toExponential().split("e")[1]));
}
function getExponentialNotation(value2) {
  var parts = value2.toExponential().split("e");
  var mantissa = parseFloat(parts[0]);
  var exponent = parseInt(parts[1]);
  return {
    exponent,
    mantissa
  };
}
function multiplyInExponentialForm(value2, exponentShift) {
  var exponentialNotation = getExponentialNotation(value2);
  return parseFloat("".concat(exponentialNotation.mantissa, "e").concat(exponentialNotation.exponent + exponentShift));
}
function _isEdgeBug() {
  return "0.000300" !== 3e-4.toPrecision(3);
}
function adjust(value2, interval) {
  var precision = getPrecision(interval || 0) + 2;
  var separatedValue = value2.toString().split(".");
  var sourceValue = value2;
  var absValue = Math.abs(value2);
  var separatedAdjustedValue;
  var isExponentValue = isExponential(value2);
  var integerPart = absValue > 1 ? 10 : 0;
  if (1 === separatedValue.length) {
    return value2;
  }
  if (!isExponentValue) {
    if (isExponential(interval)) {
      precision = separatedValue[0].length + getExponent(interval);
    }
    value2 = absValue;
    value2 = value2 - Math.floor(value2) + integerPart;
  }
  precision = _isEdgeBug() && getExponent(value2) > 6 || precision > 7 ? 15 : 7;
  if (!isExponentValue) {
    separatedAdjustedValue = parseFloat(value2.toPrecision(precision)).toString().split(".");
    if (separatedAdjustedValue[0] === integerPart.toString()) {
      return parseFloat(separatedValue[0] + "." + separatedAdjustedValue[1]);
    }
  }
  return parseFloat(sourceValue.toPrecision(precision));
}
function getPrecision(value2) {
  var str = value2.toString();
  if (str.indexOf(".") < 0) {
    return 0;
  }
  var mantissa = str.split(".");
  var positionOfDelimiter = mantissa[1].indexOf("e");
  return positionOfDelimiter >= 0 ? positionOfDelimiter : mantissa[1].length;
}
var sign, fitIntoRange, inRange;
var init_math = __esm({
  "node_modules/devextreme/esm/core/utils/math.js"() {
    init_type();
    sign = function(value2) {
      if (0 === value2) {
        return 0;
      }
      return value2 / Math.abs(value2);
    };
    fitIntoRange = function(value2, minValue, maxValue) {
      var isMinValueUndefined = !minValue && 0 !== minValue;
      var isMaxValueUndefined = !maxValue && 0 !== maxValue;
      isMinValueUndefined && (minValue = !isMaxValueUndefined ? Math.min(value2, maxValue) : value2);
      isMaxValueUndefined && (maxValue = !isMinValueUndefined ? Math.max(value2, minValue) : value2);
      return Math.min(Math.max(value2, minValue), maxValue);
    };
    inRange = function(value2, minValue, maxValue) {
      return value2 >= minValue && value2 <= maxValue;
    };
  }
});

// node_modules/devextreme/esm/events/gesture/emitter.gesture.js
var ready4, abs2, SLEEP, INITED, STARTED, TOUCH_BOUNDARY2, IMMEDIATE_TOUCH_BOUNDARY, IMMEDIATE_TIMEOUT, supportPointerEvents, setGestureCover, gestureCover, GestureEmitter, emitter_gesture_default;
var init_emitter_gesture = __esm({
  "node_modules/devextreme/esm/events/gesture/emitter.gesture.js"() {
    init_renderer();
    init_events_engine();
    init_devices();
    init_style();
    init_call_once();
    init_dom();
    init_ready_callbacks();
    init_math();
    init_common();
    init_type();
    init_utils2();
    init_emitter();
    ready4 = ready_callbacks_default.add;
    abs2 = Math.abs;
    SLEEP = 0;
    INITED = 1;
    STARTED = 2;
    TOUCH_BOUNDARY2 = 10;
    IMMEDIATE_TOUCH_BOUNDARY = 0;
    IMMEDIATE_TIMEOUT = 180;
    supportPointerEvents = function() {
      return styleProp("pointer-events");
    };
    setGestureCover = call_once_default(function() {
      var isDesktop = "desktop" === devices_default.real().deviceType;
      if (!supportPointerEvents() || !isDesktop) {
        return noop2;
      }
      var $cover = renderer_default("<div>").addClass("dx-gesture-cover").css("pointerEvents", "none");
      events_engine_default.subscribeGlobal($cover, "dxmousewheel", function(e) {
        e.preventDefault();
      });
      ready4(function() {
        $cover.appendTo("body");
      });
      return function(toggle, cursor) {
        $cover.css("pointerEvents", toggle ? "all" : "none");
        toggle && $cover.css("cursor", cursor);
      };
    });
    gestureCover = function(toggle, cursor) {
      var gestureCoverStrategy = setGestureCover();
      gestureCoverStrategy(toggle, cursor);
    };
    GestureEmitter = emitter_default.inherit({
      gesture: true,
      configure: function(data2) {
        this.getElement().css("msTouchAction", data2.immediate ? "pinch-zoom" : "");
        this.callBase(data2);
      },
      allowInterruptionByMouseWheel: function() {
        return this._stage !== STARTED;
      },
      getDirection: function() {
        return this.direction;
      },
      _cancel: function() {
        this.callBase.apply(this, arguments);
        this._toggleGestureCover(false);
        this._stage = SLEEP;
      },
      start: function(e) {
        if (e._needSkipEvent || needSkipEvent(e)) {
          this._cancel(e);
          return;
        }
        this._startEvent = createEvent(e);
        this._startEventData = eventData(e);
        this._stage = INITED;
        this._init(e);
        this._setupImmediateTimer();
      },
      _setupImmediateTimer: function() {
        clearTimeout(this._immediateTimer);
        this._immediateAccepted = false;
        if (!this.immediate) {
          return;
        }
        this._immediateTimer = setTimeout((function() {
          this._immediateAccepted = true;
        }).bind(this), IMMEDIATE_TIMEOUT);
      },
      move: function(e) {
        if (this._stage === INITED && this._directionConfirmed(e)) {
          this._stage = STARTED;
          this._resetActiveElement();
          this._toggleGestureCover(true);
          this._clearSelection(e);
          this._adjustStartEvent(e);
          this._start(this._startEvent);
          if (this._stage === SLEEP) {
            return;
          }
          this._requestAccept(e);
          this._move(e);
          this._forgetAccept();
        } else if (this._stage === STARTED) {
          this._clearSelection(e);
          this._move(e);
        }
      },
      _directionConfirmed: function(e) {
        var touchBoundary = this._getTouchBoundary(e);
        var delta = eventDelta(this._startEventData, eventData(e));
        var deltaX = abs2(delta.x);
        var deltaY = abs2(delta.y);
        var horizontalMove = this._validateMove(touchBoundary, deltaX, deltaY);
        var verticalMove = this._validateMove(touchBoundary, deltaY, deltaX);
        var direction = this.getDirection(e);
        var bothAccepted = "both" === direction && (horizontalMove || verticalMove);
        var horizontalAccepted = "horizontal" === direction && horizontalMove;
        var verticalAccepted = "vertical" === direction && verticalMove;
        return bothAccepted || horizontalAccepted || verticalAccepted || this._immediateAccepted;
      },
      _validateMove: function(touchBoundary, mainAxis, crossAxis) {
        return mainAxis && mainAxis >= touchBoundary && (this.immediate ? mainAxis >= crossAxis : true);
      },
      _getTouchBoundary: function(e) {
        return this.immediate || isDxMouseWheelEvent(e) ? IMMEDIATE_TOUCH_BOUNDARY : TOUCH_BOUNDARY2;
      },
      _adjustStartEvent: function(e) {
        var touchBoundary = this._getTouchBoundary(e);
        var delta = eventDelta(this._startEventData, eventData(e));
        this._startEvent.pageX += sign(delta.x) * touchBoundary;
        this._startEvent.pageY += sign(delta.y) * touchBoundary;
      },
      _resetActiveElement: function() {
        if ("ios" === devices_default.real().platform && this.getElement().find(":focus").length) {
          resetActiveElement();
        }
      },
      _toggleGestureCover: function(toggle) {
        this._toggleGestureCoverImpl(toggle);
      },
      _toggleGestureCoverImpl: function(toggle) {
        var isStarted = this._stage === STARTED;
        if (isStarted) {
          gestureCover(toggle, this.getElement().css("cursor"));
        }
      },
      _clearSelection: function(e) {
        if (isDxMouseWheelEvent(e) || isTouchEvent(e)) {
          return;
        }
        clearSelection();
      },
      end: function(e) {
        this._toggleGestureCover(false);
        if (this._stage === STARTED) {
          this._end(e);
        } else if (this._stage === INITED) {
          this._stop(e);
        }
        this._stage = SLEEP;
      },
      dispose: function() {
        clearTimeout(this._immediateTimer);
        this.callBase.apply(this, arguments);
        this._toggleGestureCover(false);
      },
      _init: noop2,
      _start: noop2,
      _move: noop2,
      _stop: noop2,
      _end: noop2
    });
    GestureEmitter.initialTouchBoundary = TOUCH_BOUNDARY2;
    GestureEmitter.touchBoundary = function(newBoundary) {
      if (isDefined(newBoundary)) {
        TOUCH_BOUNDARY2 = newBoundary;
        return;
      }
      return TOUCH_BOUNDARY2;
    };
    emitter_gesture_default = GestureEmitter;
  }
});

// node_modules/devextreme/esm/events/drag.js
var DRAG_START_EVENT, DRAG_EVENT, DRAG_END_EVENT, DRAG_ENTER_EVENT, DRAG_LEAVE_EVENT, DROP_EVENT, DX_DRAG_EVENTS_COUNT_KEY, knownDropTargets, knownDropTargetSelectors, knownDropTargetConfigs, dropTargetRegistration, getItemDelegatedTargets, getItemConfig, getItemPosition, getItemSize, DragEmitter;
var init_drag = __esm({
  "node_modules/devextreme/esm/events/drag.js"() {
    init_renderer();
    init_element_data();
    init_array();
    init_iterator();
    init_dom();
    init_event_registrator();
    init_utils2();
    init_emitter_gesture();
    init_emitter_registrator();
    DRAG_START_EVENT = "dxdragstart";
    DRAG_EVENT = "dxdrag";
    DRAG_END_EVENT = "dxdragend";
    DRAG_ENTER_EVENT = "dxdragenter";
    DRAG_LEAVE_EVENT = "dxdragleave";
    DROP_EVENT = "dxdrop";
    DX_DRAG_EVENTS_COUNT_KEY = "dxDragEventsCount";
    knownDropTargets = [];
    knownDropTargetSelectors = [];
    knownDropTargetConfigs = [];
    dropTargetRegistration = {
      setup: function(element, data2) {
        var knownDropTarget = -1 !== inArray(element, knownDropTargets);
        if (!knownDropTarget) {
          knownDropTargets.push(element);
          knownDropTargetSelectors.push([]);
          knownDropTargetConfigs.push(data2 || {});
        }
      },
      add: function(element, handleObj) {
        var index2 = inArray(element, knownDropTargets);
        this.updateEventsCounter(element, handleObj.type, 1);
        var selector = handleObj.selector;
        if (-1 === inArray(selector, knownDropTargetSelectors[index2])) {
          knownDropTargetSelectors[index2].push(selector);
        }
      },
      updateEventsCounter: function(element, event, value2) {
        if ([DRAG_ENTER_EVENT, DRAG_LEAVE_EVENT, DROP_EVENT].indexOf(event) > -1) {
          var eventsCount = data(element, DX_DRAG_EVENTS_COUNT_KEY) || 0;
          data(element, DX_DRAG_EVENTS_COUNT_KEY, Math.max(0, eventsCount + value2));
        }
      },
      remove: function(element, handleObj) {
        this.updateEventsCounter(element, handleObj.type, -1);
      },
      teardown: function(element) {
        var handlersCount = data(element, DX_DRAG_EVENTS_COUNT_KEY);
        if (!handlersCount) {
          var index2 = inArray(element, knownDropTargets);
          knownDropTargets.splice(index2, 1);
          knownDropTargetSelectors.splice(index2, 1);
          knownDropTargetConfigs.splice(index2, 1);
          removeData(element, DX_DRAG_EVENTS_COUNT_KEY);
        }
      }
    };
    event_registrator_default(DRAG_ENTER_EVENT, dropTargetRegistration);
    event_registrator_default(DRAG_LEAVE_EVENT, dropTargetRegistration);
    event_registrator_default(DROP_EVENT, dropTargetRegistration);
    getItemDelegatedTargets = function($element) {
      var dropTargetIndex = inArray($element.get(0), knownDropTargets);
      var dropTargetSelectors = knownDropTargetSelectors[dropTargetIndex].filter((selector) => selector);
      var $delegatedTargets = $element.find(dropTargetSelectors.join(", "));
      if (-1 !== inArray(void 0, knownDropTargetSelectors[dropTargetIndex])) {
        $delegatedTargets = $delegatedTargets.add($element);
      }
      return $delegatedTargets;
    };
    getItemConfig = function($element) {
      var dropTargetIndex = inArray($element.get(0), knownDropTargets);
      return knownDropTargetConfigs[dropTargetIndex];
    };
    getItemPosition = function(dropTargetConfig, $element) {
      if (dropTargetConfig.itemPositionFunc) {
        return dropTargetConfig.itemPositionFunc($element);
      } else {
        return $element.offset();
      }
    };
    getItemSize = function(dropTargetConfig, $element) {
      if (dropTargetConfig.itemSizeFunc) {
        return dropTargetConfig.itemSizeFunc($element);
      }
      return {
        width: $element.get(0).getBoundingClientRect().width,
        height: $element.get(0).getBoundingClientRect().height
      };
    };
    DragEmitter = emitter_gesture_default.inherit({
      ctor: function(element) {
        this.callBase(element);
        this.direction = "both";
      },
      _init: function(e) {
        this._initEvent = e;
      },
      _start: function(e) {
        e = this._fireEvent(DRAG_START_EVENT, this._initEvent);
        this._maxLeftOffset = e.maxLeftOffset;
        this._maxRightOffset = e.maxRightOffset;
        this._maxTopOffset = e.maxTopOffset;
        this._maxBottomOffset = e.maxBottomOffset;
        var dropTargets = wrapToArray(e.targetElements || (null === e.targetElements ? [] : knownDropTargets));
        this._dropTargets = map(dropTargets, function(element) {
          return renderer_default(element).get(0);
        });
      },
      _move: function(e) {
        var eventData2 = eventData(e);
        var dragOffset = this._calculateOffset(eventData2);
        e = this._fireEvent(DRAG_EVENT, e, {
          offset: dragOffset
        });
        this._processDropTargets(e);
        if (!e._cancelPreventDefault) {
          e.preventDefault();
        }
      },
      _calculateOffset: function(eventData2) {
        return {
          x: this._calculateXOffset(eventData2),
          y: this._calculateYOffset(eventData2)
        };
      },
      _calculateXOffset: function(eventData2) {
        if ("vertical" !== this.direction) {
          var offset2 = eventData2.x - this._startEventData.x;
          return this._fitOffset(offset2, this._maxLeftOffset, this._maxRightOffset);
        }
        return 0;
      },
      _calculateYOffset: function(eventData2) {
        if ("horizontal" !== this.direction) {
          var offset2 = eventData2.y - this._startEventData.y;
          return this._fitOffset(offset2, this._maxTopOffset, this._maxBottomOffset);
        }
        return 0;
      },
      _fitOffset: function(offset2, minOffset, maxOffset) {
        if (null != minOffset) {
          offset2 = Math.max(offset2, -minOffset);
        }
        if (null != maxOffset) {
          offset2 = Math.min(offset2, maxOffset);
        }
        return offset2;
      },
      _processDropTargets: function(e) {
        var target = this._findDropTarget(e);
        var sameTarget = target === this._currentDropTarget;
        if (!sameTarget) {
          this._fireDropTargetEvent(e, DRAG_LEAVE_EVENT);
          this._currentDropTarget = target;
          this._fireDropTargetEvent(e, DRAG_ENTER_EVENT);
        }
      },
      _fireDropTargetEvent: function(event, eventName) {
        if (!this._currentDropTarget) {
          return;
        }
        var eventData2 = {
          type: eventName,
          originalEvent: event,
          draggingElement: this._$element.get(0),
          target: this._currentDropTarget
        };
        fireEvent(eventData2);
      },
      _findDropTarget: function(e) {
        var that = this;
        var result2;
        each(knownDropTargets, function(_2, target) {
          if (!that._checkDropTargetActive(target)) {
            return;
          }
          var $target = renderer_default(target);
          each(getItemDelegatedTargets($target), function(_3, delegatedTarget) {
            var $delegatedTarget = renderer_default(delegatedTarget);
            if (that._checkDropTarget(getItemConfig($target), $delegatedTarget, renderer_default(result2), e)) {
              result2 = delegatedTarget;
            }
          });
        });
        return result2;
      },
      _checkDropTargetActive: function(target) {
        var active2 = false;
        each(this._dropTargets, function(_2, activeTarget) {
          active2 = active2 || activeTarget === target || contains2(activeTarget, target);
          return !active2;
        });
        return active2;
      },
      _checkDropTarget: function(config2, $target, $prevTarget, e) {
        var isDraggingElement = $target.get(0) === renderer_default(e.target).get(0);
        if (isDraggingElement) {
          return false;
        }
        var targetPosition = getItemPosition(config2, $target);
        if (e.pageX < targetPosition.left) {
          return false;
        }
        if (e.pageY < targetPosition.top) {
          return false;
        }
        var targetSize = getItemSize(config2, $target);
        if (e.pageX > targetPosition.left + targetSize.width) {
          return false;
        }
        if (e.pageY > targetPosition.top + targetSize.height) {
          return false;
        }
        if ($prevTarget.length && $prevTarget.closest($target).length) {
          return false;
        }
        if (config2.checkDropTarget && !config2.checkDropTarget($target, e)) {
          return false;
        }
        return $target;
      },
      _end: function(e) {
        var eventData2 = eventData(e);
        this._fireEvent(DRAG_END_EVENT, e, {
          offset: this._calculateOffset(eventData2)
        });
        this._fireDropTargetEvent(e, DROP_EVENT);
        delete this._currentDropTarget;
      }
    });
    emitter_registrator_default({
      emitter: DragEmitter,
      events: [DRAG_START_EVENT, DRAG_EVENT, DRAG_END_EVENT]
    });
  }
});

// node_modules/devextreme/esm/mobile/hide_callback.js
var hideCallback;
var init_hide_callback = __esm({
  "node_modules/devextreme/esm/mobile/hide_callback.js"() {
    init_array();
    hideCallback = /* @__PURE__ */ function() {
      var callbacks2 = [];
      return {
        add: function(callback) {
          var indexOfCallback = inArray(callback, callbacks2);
          if (-1 === indexOfCallback) {
            callbacks2.push(callback);
          }
        },
        remove: function(callback) {
          var indexOfCallback = inArray(callback, callbacks2);
          if (-1 !== indexOfCallback) {
            callbacks2.splice(indexOfCallback, 1);
          }
        },
        fire: function() {
          var callback = callbacks2.pop();
          var result2 = !!callback;
          if (result2) {
            callback();
          }
          return result2;
        },
        hasCallback: function() {
          return callbacks2.length > 0;
        }
      };
    }();
  }
});

// node_modules/devextreme/esm/ui/resizable.js
var RESIZABLE, RESIZABLE_CLASS, RESIZABLE_RESIZING_CLASS, RESIZABLE_HANDLE_CLASS, RESIZABLE_HANDLE_TOP_CLASS, RESIZABLE_HANDLE_BOTTOM_CLASS, RESIZABLE_HANDLE_LEFT_CLASS, RESIZABLE_HANDLE_RIGHT_CLASS, RESIZABLE_HANDLE_CORNER_CLASS, DRAGSTART_START_EVENT_NAME, DRAGSTART_EVENT_NAME, DRAGSTART_END_EVENT_NAME, SIDE_BORDER_WIDTH_STYLES, Resizable, resizable_default;
var init_resizable = __esm({
  "node_modules/devextreme/esm/ui/resizable.js"() {
    init_extends();
    init_translator();
    init_component_registrator();
    init_dom_component();
    init_renderer();
    init_array();
    init_common();
    init_extend();
    init_iterator();
    init_math();
    init_type();
    init_window();
    init_events_engine();
    init_drag();
    init_utils2();
    init_visibility_change();
    RESIZABLE = "dxResizable";
    RESIZABLE_CLASS = "dx-resizable";
    RESIZABLE_RESIZING_CLASS = "dx-resizable-resizing";
    RESIZABLE_HANDLE_CLASS = "dx-resizable-handle";
    RESIZABLE_HANDLE_TOP_CLASS = "dx-resizable-handle-top";
    RESIZABLE_HANDLE_BOTTOM_CLASS = "dx-resizable-handle-bottom";
    RESIZABLE_HANDLE_LEFT_CLASS = "dx-resizable-handle-left";
    RESIZABLE_HANDLE_RIGHT_CLASS = "dx-resizable-handle-right";
    RESIZABLE_HANDLE_CORNER_CLASS = "dx-resizable-handle-corner";
    DRAGSTART_START_EVENT_NAME = addNamespace2(DRAG_START_EVENT, RESIZABLE);
    DRAGSTART_EVENT_NAME = addNamespace2(DRAG_EVENT, RESIZABLE);
    DRAGSTART_END_EVENT_NAME = addNamespace2(DRAG_END_EVENT, RESIZABLE);
    SIDE_BORDER_WIDTH_STYLES = {
      left: "borderLeftWidth",
      top: "borderTopWidth",
      right: "borderRightWidth",
      bottom: "borderBottomWidth"
    };
    Resizable = dom_component_default.inherit({
      _getDefaultOptions: function() {
        return extend2(this.callBase(), {
          handles: "all",
          step: "1",
          stepPrecision: "simple",
          area: void 0,
          minWidth: 30,
          maxWidth: 1 / 0,
          minHeight: 30,
          maxHeight: 1 / 0,
          onResizeStart: null,
          onResize: null,
          onResizeEnd: null,
          roundStepValue: true,
          _keepAspectRatio: false
        });
      },
      _init: function() {
        this.callBase();
        this.$element().addClass(RESIZABLE_CLASS);
      },
      _initMarkup: function() {
        this.callBase();
        this._renderHandles();
      },
      _render: function() {
        this.callBase();
        this._renderActions();
      },
      _renderActions: function() {
        this._resizeStartAction = this._createActionByOption("onResizeStart");
        this._resizeEndAction = this._createActionByOption("onResizeEnd");
        this._resizeAction = this._createActionByOption("onResize");
      },
      _renderHandles: function() {
        this._handles = [];
        var handles = this.option("handles");
        if ("none" === handles) {
          return;
        }
        var directions = "all" === handles ? ["top", "bottom", "left", "right"] : handles.split(" ");
        each(directions, (index2, handleName) => {
          this._renderHandle(handleName);
        });
        inArray("bottom", directions) + 1 && inArray("right", directions) + 1 && this._renderHandle("corner-bottom-right");
        inArray("bottom", directions) + 1 && inArray("left", directions) + 1 && this._renderHandle("corner-bottom-left");
        inArray("top", directions) + 1 && inArray("right", directions) + 1 && this._renderHandle("corner-top-right");
        inArray("top", directions) + 1 && inArray("left", directions) + 1 && this._renderHandle("corner-top-left");
        this._attachEventHandlers();
      },
      _renderHandle: function(handleName) {
        var $handle = renderer_default("<div>").addClass(RESIZABLE_HANDLE_CLASS).addClass(RESIZABLE_HANDLE_CLASS + "-" + handleName).appendTo(this.$element());
        this._handles.push($handle);
      },
      _attachEventHandlers: function() {
        if (this.option("disabled")) {
          return;
        }
        var handlers = {};
        handlers[DRAGSTART_START_EVENT_NAME] = this._dragStartHandler.bind(this);
        handlers[DRAGSTART_EVENT_NAME] = this._dragHandler.bind(this);
        handlers[DRAGSTART_END_EVENT_NAME] = this._dragEndHandler.bind(this);
        this._handles.forEach((handleElement) => {
          events_engine_default.on(handleElement, handlers, {
            direction: "both",
            immediate: true
          });
        });
      },
      _detachEventHandlers: function() {
        this._handles.forEach((handleElement) => {
          events_engine_default.off(handleElement);
        });
      },
      _toggleEventHandlers: function(shouldAttachEvents) {
        shouldAttachEvents ? this._attachEventHandlers() : this._detachEventHandlers();
      },
      _getElementSize: function() {
        var $element = this.$element();
        return "border-box" === $element.css("boxSizing") ? {
          width: $element.outerWidth(),
          height: $element.outerHeight()
        } : {
          width: $element.width(),
          height: $element.height()
        };
      },
      _dragStartHandler: function(e) {
        var $element = this.$element();
        if ($element.is(".dx-state-disabled, .dx-state-disabled *")) {
          e.cancel = true;
          return;
        }
        this._toggleResizingClass(true);
        this._movingSides = this._getMovingSides(e);
        this._elementLocation = locate($element);
        this._elementSize = this._getElementSize();
        this._renderDragOffsets(e);
        this._resizeStartAction({
          event: e,
          width: this._elementSize.width,
          height: this._elementSize.height,
          handles: this._movingSides
        });
        e.targetElements = null;
      },
      _toggleResizingClass: function(value2) {
        this.$element().toggleClass(RESIZABLE_RESIZING_CLASS, value2);
      },
      _renderDragOffsets: function(e) {
        var area = this._getArea();
        if (!area) {
          return;
        }
        var $handle = renderer_default(e.target).closest("." + RESIZABLE_HANDLE_CLASS);
        var handleWidth = $handle.outerWidth();
        var handleHeight = $handle.outerHeight();
        var handleOffset = $handle.offset();
        var areaOffset = area.offset;
        var scrollOffset = this._getAreaScrollOffset();
        e.maxLeftOffset = this._leftMaxOffset = handleOffset.left - areaOffset.left - scrollOffset.scrollX;
        e.maxRightOffset = this._rightMaxOffset = areaOffset.left + area.width - handleOffset.left - handleWidth + scrollOffset.scrollX;
        e.maxTopOffset = this._topMaxOffset = handleOffset.top - areaOffset.top - scrollOffset.scrollY;
        e.maxBottomOffset = this._bottomMaxOffset = areaOffset.top + area.height - handleOffset.top - handleHeight + scrollOffset.scrollY;
      },
      _getBorderWidth: function($element, direction) {
        if (isWindow($element.get(0))) {
          return 0;
        }
        var borderWidth = $element.css(SIDE_BORDER_WIDTH_STYLES[direction]);
        return parseInt(borderWidth) || 0;
      },
      _proportionate: function(direction, value2) {
        var size = this._elementSize;
        var factor = "x" === direction ? size.width / size.height : size.height / size.width;
        return value2 * factor;
      },
      _getProportionalDelta: function(_ref) {
        var {
          x,
          y
        } = _ref;
        var proportionalY = this._proportionate("y", x);
        if (proportionalY >= y) {
          return {
            x,
            y: proportionalY
          };
        }
        var proportionalX = this._proportionate("x", y);
        if (proportionalX >= x) {
          return {
            x: proportionalX,
            y
          };
        }
        return {
          x: 0,
          y: 0
        };
      },
      _getDirectionName: function(axis) {
        var sides = this._movingSides;
        if ("x" === axis) {
          return sides.left ? "left" : "right";
        } else {
          return sides.top ? "top" : "bottom";
        }
      },
      _fitIntoArea: function(axis, value2) {
        var _this;
        var directionName = this._getDirectionName(axis);
        return Math.min(value2, null !== (_this = this["_".concat(directionName, "MaxOffset")]) && void 0 !== _this ? _this : 1 / 0);
      },
      _fitDeltaProportionally: function(delta) {
        var fittedDelta = _extends({}, delta);
        var size = this._elementSize;
        var {
          minWidth,
          minHeight,
          maxWidth,
          maxHeight
        } = this.option();
        var getWidth = () => size.width + fittedDelta.x;
        var getHeight = () => size.height + fittedDelta.y;
        var isInArea = (axis) => fittedDelta[axis] === this._fitIntoArea(axis, fittedDelta[axis]);
        var isFittedX = () => inRange(getWidth(), minWidth, maxWidth) && isInArea("x");
        var isFittedY = () => inRange(getHeight(), minHeight, maxHeight) && isInArea("y");
        if (!isFittedX()) {
          var x = this._fitIntoArea("x", fitIntoRange(getWidth(), minWidth, maxWidth) - size.width);
          fittedDelta = {
            x,
            y: this._proportionate("y", x)
          };
        }
        if (!isFittedY()) {
          var y = this._fitIntoArea("y", fitIntoRange(getHeight(), minHeight, maxHeight) - size.height);
          fittedDelta = {
            x: this._proportionate("x", y),
            y
          };
        }
        return isFittedX() && isFittedY() ? fittedDelta : {
          x: 0,
          y: 0
        };
      },
      _fitDelta: function(_ref2) {
        var {
          x,
          y
        } = _ref2;
        var size = this._elementSize;
        var {
          minWidth,
          minHeight,
          maxWidth,
          maxHeight
        } = this.option();
        return {
          x: fitIntoRange(size.width + x, minWidth, maxWidth) - size.width,
          y: fitIntoRange(size.height + y, minHeight, maxHeight) - size.height
        };
      },
      _getDeltaByOffset: function(offset2) {
        var sides = this._movingSides;
        var shouldKeepAspectRatio = this._isCornerHandler(sides) && this.option("_keepAspectRatio");
        var delta = {
          x: offset2.x * (sides.left ? -1 : 1),
          y: offset2.y * (sides.top ? -1 : 1)
        };
        if (shouldKeepAspectRatio) {
          var proportionalDelta = this._getProportionalDelta(delta);
          var fittedProportionalDelta = this._fitDeltaProportionally(proportionalDelta);
          delta = fittedProportionalDelta;
        } else {
          var fittedDelta = this._fitDelta(delta);
          var roundedFittedDelta = this._roundByStep(fittedDelta);
          delta = roundedFittedDelta;
        }
        return delta;
      },
      _updatePosition: function(delta, _ref3) {
        var {
          width,
          height
        } = _ref3;
        var location = this._elementLocation;
        var sides = this._movingSides;
        var $element = this.$element();
        var elementRect = this._getElementSize();
        var offsetTop = delta.y * (sides.top ? -1 : 1) - ((elementRect.height || height) - height);
        var offsetLeft = delta.x * (sides.left ? -1 : 1) - ((elementRect.width || width) - width);
        move($element, {
          top: location.top + (sides.top ? offsetTop : 0),
          left: location.left + (sides.left ? offsetLeft : 0)
        });
      },
      _dragHandler: function(e) {
        var offset2 = this._getOffset(e);
        var delta = this._getDeltaByOffset(offset2);
        var dimensions = this._updateDimensions(delta);
        this._updatePosition(delta, dimensions);
        this._triggerResizeAction(e, dimensions);
      },
      _updateDimensions: function(delta) {
        var isAbsoluteSize = (size2) => "px" === size2.substring(size2.length - 2);
        var isStepPrecisionStrict = "strict" === this.option("stepPrecision");
        var size = this._elementSize;
        var width = size.width + delta.x;
        var height = size.height + delta.y;
        var elementStyle = this.$element().get(0).style;
        var shouldRenderWidth = delta.x || isStepPrecisionStrict || isAbsoluteSize(elementStyle.width);
        var shouldRenderHeight = delta.y || isStepPrecisionStrict || isAbsoluteSize(elementStyle.height);
        if (shouldRenderWidth) {
          this.option({
            width
          });
        }
        if (shouldRenderHeight) {
          this.option({
            height
          });
        }
        return {
          width: shouldRenderWidth ? width : size.width,
          height: shouldRenderHeight ? height : size.height
        };
      },
      _triggerResizeAction: function(e, _ref4) {
        var {
          width,
          height
        } = _ref4;
        this._resizeAction({
          event: e,
          width: this.option("width") || width,
          height: this.option("height") || height,
          handles: this._movingSides
        });
        triggerResizeEvent(this.$element());
      },
      _isCornerHandler: (sides) => 0 === Object.keys(sides).map((key) => sides[key]).reduce((xor, value2) => xor ^ value2, 0),
      _getOffset: function(e) {
        var offset2 = e.offset;
        var sides = this._movingSides;
        if (!sides.left && !sides.right) {
          offset2.x = 0;
        }
        if (!sides.top && !sides.bottom) {
          offset2.y = 0;
        }
        return offset2;
      },
      _roundByStep: function(delta) {
        return "strict" === this.option("stepPrecision") ? this._roundStrict(delta) : this._roundNotStrict(delta);
      },
      _getSteps: function() {
        return pairToObject(this.option("step"), !this.option("roundStepValue"));
      },
      _roundNotStrict: function(delta) {
        var steps = this._getSteps();
        return {
          x: delta.x - delta.x % steps.h,
          y: delta.y - delta.y % steps.v
        };
      },
      _roundStrict: function(delta) {
        var sides = this._movingSides;
        var offset2 = {
          x: delta.x * (sides.left ? -1 : 1),
          y: delta.y * (sides.top ? -1 : 1)
        };
        var steps = this._getSteps();
        var location = this._elementLocation;
        var size = this._elementSize;
        var xPos = sides.left ? location.left : location.left + size.width;
        var yPos = sides.top ? location.top : location.top + size.height;
        var newXShift = (xPos + offset2.x) % steps.h;
        var newYShift = (yPos + offset2.y) % steps.v;
        var sign2 = Math.sign || ((x) => {
          x = +x;
          if (0 === x || isNaN(x)) {
            return x;
          }
          return x > 0 ? 1 : -1;
        });
        var separatorOffset = (steps2, offset3) => (1 + 0.2 * sign2(offset3)) % 1 * steps2;
        var isSmallOffset = (offset3, steps2) => Math.abs(offset3) < 0.2 * steps2;
        var newOffsetX = offset2.x - newXShift;
        var newOffsetY = offset2.y - newYShift;
        if (newXShift > separatorOffset(steps.h, offset2.x)) {
          newOffsetX += steps.h;
        }
        if (newYShift > separatorOffset(steps.v, offset2.y)) {
          newOffsetY += steps.v;
        }
        var roundedOffset_x = (sides.left || sides.right) && !isSmallOffset(offset2.x, steps.h) ? newOffsetX : 0, roundedOffset_y = (sides.top || sides.bottom) && !isSmallOffset(offset2.y, steps.v) ? newOffsetY : 0;
        return {
          x: roundedOffset_x * (sides.left ? -1 : 1),
          y: roundedOffset_y * (sides.top ? -1 : 1)
        };
      },
      _getMovingSides: function(e) {
        var $target = renderer_default(e.target);
        var hasCornerTopLeftClass = $target.hasClass(RESIZABLE_HANDLE_CORNER_CLASS + "-top-left");
        var hasCornerTopRightClass = $target.hasClass(RESIZABLE_HANDLE_CORNER_CLASS + "-top-right");
        var hasCornerBottomLeftClass = $target.hasClass(RESIZABLE_HANDLE_CORNER_CLASS + "-bottom-left");
        var hasCornerBottomRightClass = $target.hasClass(RESIZABLE_HANDLE_CORNER_CLASS + "-bottom-right");
        return {
          top: $target.hasClass(RESIZABLE_HANDLE_TOP_CLASS) || hasCornerTopLeftClass || hasCornerTopRightClass,
          left: $target.hasClass(RESIZABLE_HANDLE_LEFT_CLASS) || hasCornerTopLeftClass || hasCornerBottomLeftClass,
          bottom: $target.hasClass(RESIZABLE_HANDLE_BOTTOM_CLASS) || hasCornerBottomLeftClass || hasCornerBottomRightClass,
          right: $target.hasClass(RESIZABLE_HANDLE_RIGHT_CLASS) || hasCornerTopRightClass || hasCornerBottomRightClass
        };
      },
      _getArea: function() {
        var area = this.option("area");
        if (isFunction(area)) {
          area = area.call(this);
        }
        if (isPlainObject(area)) {
          return this._getAreaFromObject(area);
        }
        return this._getAreaFromElement(area);
      },
      _getAreaScrollOffset: function() {
        var area = this.option("area");
        var isElement = !isFunction(area) && !isPlainObject(area);
        var scrollOffset = {
          scrollY: 0,
          scrollX: 0
        };
        if (isElement) {
          var areaElement = renderer_default(area)[0];
          if (isWindow(areaElement)) {
            scrollOffset.scrollX = areaElement.pageXOffset;
            scrollOffset.scrollY = areaElement.pageYOffset;
          }
        }
        return scrollOffset;
      },
      _getAreaFromObject: function(area) {
        var result2 = {
          width: area.right - area.left,
          height: area.bottom - area.top,
          offset: {
            left: area.left,
            top: area.top
          }
        };
        this._correctAreaGeometry(result2);
        return result2;
      },
      _getAreaFromElement: function(area) {
        var $area = renderer_default(area);
        var result2;
        if ($area.length) {
          result2 = {
            width: $area.innerWidth(),
            height: $area.innerHeight(),
            offset: extend2({
              top: 0,
              left: 0
            }, isWindow($area[0]) ? {} : $area.offset())
          };
          this._correctAreaGeometry(result2, $area);
        }
        return result2;
      },
      _correctAreaGeometry: function(result2, $area) {
        var areaBorderLeft = $area ? this._getBorderWidth($area, "left") : 0;
        var areaBorderTop = $area ? this._getBorderWidth($area, "top") : 0;
        result2.offset.left += areaBorderLeft + this._getBorderWidth(this.$element(), "left");
        result2.offset.top += areaBorderTop + this._getBorderWidth(this.$element(), "top");
        result2.width -= this.$element().outerWidth() - this.$element().innerWidth();
        result2.height -= this.$element().outerHeight() - this.$element().innerHeight();
      },
      _dragEndHandler: function(e) {
        var $element = this.$element();
        this._resizeEndAction({
          event: e,
          width: $element.outerWidth(),
          height: $element.outerHeight(),
          handles: this._movingSides
        });
        this._toggleResizingClass(false);
      },
      _renderWidth: function(width) {
        this.option("width", fitIntoRange(width, this.option("minWidth"), this.option("maxWidth")));
      },
      _renderHeight: function(height) {
        this.option("height", fitIntoRange(height, this.option("minHeight"), this.option("maxHeight")));
      },
      _optionChanged: function(args) {
        switch (args.name) {
          case "disabled":
            this._toggleEventHandlers(!args.value);
            this.callBase(args);
            break;
          case "handles":
            this._invalidate();
            break;
          case "minWidth":
          case "maxWidth":
            hasWindow() && this._renderWidth(this.$element().outerWidth());
            break;
          case "minHeight":
          case "maxHeight":
            hasWindow() && this._renderHeight(this.$element().outerHeight());
            break;
          case "onResize":
          case "onResizeStart":
          case "onResizeEnd":
            this._renderActions();
            break;
          case "area":
          case "stepPrecision":
          case "step":
          case "roundStepValue":
          case "_keepAspectRatio":
            break;
          default:
            this.callBase(args);
        }
      },
      _clean: function() {
        this.$element().find("." + RESIZABLE_HANDLE_CLASS).remove();
      },
      _useTemplates: function() {
        return false;
      }
    });
    component_registrator_default(RESIZABLE, Resizable);
    resizable_default = Resizable;
  }
});

// node_modules/devextreme/esm/ui/widget/swatch_container.js
var SWATCH_CONTAINER_CLASS_PREFIX, getSwatchContainer, swatch_container_default;
var init_swatch_container = __esm({
  "node_modules/devextreme/esm/ui/widget/swatch_container.js"() {
    init_renderer();
    init_view_port();
    SWATCH_CONTAINER_CLASS_PREFIX = "dx-swatch-";
    getSwatchContainer = (element) => {
      var $element = renderer_default(element);
      var swatchContainer = $element.closest('[class^="'.concat(SWATCH_CONTAINER_CLASS_PREFIX, '"], [class*=" ').concat(SWATCH_CONTAINER_CLASS_PREFIX, '"]'));
      var viewport = value();
      if (!swatchContainer.length) {
        return viewport;
      }
      var swatchClassRegex = new RegExp("(\\s|^)(".concat(SWATCH_CONTAINER_CLASS_PREFIX, ".*?)(\\s|$)"));
      var swatchClass = swatchContainer[0].className.match(swatchClassRegex)[2];
      var viewportSwatchContainer = viewport.children("." + swatchClass);
      if (!viewportSwatchContainer.length) {
        viewportSwatchContainer = renderer_default("<div>").addClass(swatchClass).appendTo(viewport);
      }
      return viewportSwatchContainer;
    };
    swatch_container_default = {
      getSwatchContainer
    };
  }
});

// node_modules/devextreme/esm/ui/overlay/z_index.js
var baseZIndex, zIndexStack, base, create, remove;
var init_z_index = __esm({
  "node_modules/devextreme/esm/ui/overlay/z_index.js"() {
    init_common();
    baseZIndex = 1500;
    zIndexStack = [];
    base = (ZIndex) => {
      baseZIndex = ensureDefined(ZIndex, baseZIndex);
      return baseZIndex;
    };
    create = function() {
      var baseIndex = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : baseZIndex;
      var length = zIndexStack.length;
      var index2 = (length ? zIndexStack[length - 1] : baseIndex) + 1;
      zIndexStack.push(index2);
      return index2;
    };
    remove = (zIndex) => {
      var position3 = zIndexStack.indexOf(zIndex);
      if (position3 >= 0) {
        zIndexStack.splice(position3, 1);
      }
    };
  }
});

// node_modules/devextreme/esm/ui/overlay/ui.overlay.js
var ready5, window12, viewPortChanged2, OVERLAY_CLASS, OVERLAY_WRAPPER_CLASS, OVERLAY_CONTENT_CLASS, OVERLAY_SHADER_CLASS, OVERLAY_MODAL_CLASS, INNER_OVERLAY_CLASS, INVISIBLE_STATE_CLASS, ANONYMOUS_TEMPLATE_NAME2, RTL_DIRECTION_CLASS, ACTIONS, OVERLAY_STACK, PREVENT_SAFARI_SCROLLING_CLASS, TAB_KEY, POSITION_ALIASES, realDevice2, firefoxDesktop, iOS, hasSafariAddressBar, forceRepaint, getElement, Overlay, ui_overlay_default;
var init_ui_overlay = __esm({
  "node_modules/devextreme/esm/ui/overlay/ui.overlay.js"() {
    init_fx();
    init_position2();
    init_translator();
    init_component_registrator();
    init_devices();
    init_dom_adapter();
    init_element();
    init_renderer();
    init_empty_template();
    init_array();
    init_browser();
    init_common();
    init_deferred();
    init_dom();
    init_extend();
    init_iterator();
    init_math();
    init_ready_callbacks();
    init_type();
    init_view_port();
    init_window();
    init_events_engine();
    init_drag();
    init_pointer();
    init_short();
    init_utils2();
    init_visibility_change();
    init_hide_callback();
    init_resizable();
    init_selectors();
    init_swatch_container();
    init_ui_widget();
    init_z_index();
    ready5 = ready_callbacks_default.add;
    window12 = getWindow();
    viewPortChanged2 = changeCallback;
    OVERLAY_CLASS = "dx-overlay";
    OVERLAY_WRAPPER_CLASS = "dx-overlay-wrapper";
    OVERLAY_CONTENT_CLASS = "dx-overlay-content";
    OVERLAY_SHADER_CLASS = "dx-overlay-shader";
    OVERLAY_MODAL_CLASS = "dx-overlay-modal";
    INNER_OVERLAY_CLASS = "dx-inner-overlay";
    INVISIBLE_STATE_CLASS = "dx-state-invisible";
    ANONYMOUS_TEMPLATE_NAME2 = "content";
    RTL_DIRECTION_CLASS = "dx-rtl";
    ACTIONS = ["onShowing", "onShown", "onHiding", "onHidden", "onPositioned", "onResizeStart", "onResize", "onResizeEnd"];
    OVERLAY_STACK = [];
    PREVENT_SAFARI_SCROLLING_CLASS = "dx-prevent-safari-scrolling";
    TAB_KEY = "tab";
    POSITION_ALIASES = {
      top: {
        my: "top center",
        at: "top center"
      },
      bottom: {
        my: "bottom center",
        at: "bottom center"
      },
      right: {
        my: "right center",
        at: "right center"
      },
      left: {
        my: "left center",
        at: "left center"
      },
      center: {
        my: "center",
        at: "center"
      },
      "right bottom": {
        my: "right bottom",
        at: "right bottom"
      },
      "right top": {
        my: "right top",
        at: "right top"
      },
      "left bottom": {
        my: "left bottom",
        at: "left bottom"
      },
      "left top": {
        my: "left top",
        at: "left top"
      }
    };
    realDevice2 = devices_default.real();
    firefoxDesktop = browser_default.mozilla && "desktop" === realDevice2.deviceType;
    iOS = "ios" === realDevice2.platform;
    hasSafariAddressBar = browser_default.safari && "desktop" !== realDevice2.deviceType;
    forceRepaint = ($element) => {
      if (firefoxDesktop) {
        $element.width();
      }
    };
    getElement = (value2) => {
      if (isEvent(value2)) {
        value2 = value2.target;
      }
      return renderer_default(value2);
    };
    ready5(() => {
      events_engine_default.subscribeGlobal(dom_adapter_default.getDocument(), pointer_default.down, (e) => {
        for (var i = OVERLAY_STACK.length - 1; i >= 0; i--) {
          if (!OVERLAY_STACK[i]._proxiedDocumentDownHandler(e)) {
            return;
          }
        }
      });
    });
    Overlay = ui_widget_default.inherit({
      _supportedKeys: function() {
        var move2 = function(top, left, e) {
          if (!this.option("dragEnabled")) {
            return;
          }
          e.preventDefault();
          e.stopPropagation();
          var allowedOffsets = this._allowedOffsets();
          var offset2 = {
            top: fitIntoRange(top, -allowedOffsets.top, allowedOffsets.bottom),
            left: fitIntoRange(left, -allowedOffsets.left, allowedOffsets.right)
          };
          this._changePosition(offset2);
        };
        return extend2(this.callBase(), {
          escape: function() {
            this.hide();
          },
          upArrow: move2.bind(this, -5, 0),
          downArrow: move2.bind(this, 5, 0),
          leftArrow: move2.bind(this, 0, -5),
          rightArrow: move2.bind(this, 0, 5)
        });
      },
      _getDefaultOptions: function() {
        return extend2(this.callBase(), {
          activeStateEnabled: false,
          visible: false,
          deferRendering: true,
          shading: true,
          shadingColor: "",
          position: {
            my: "center",
            at: "center"
          },
          width: function() {
            return 0.8 * renderer_default(window12).width();
          },
          minWidth: null,
          maxWidth: null,
          height: function() {
            return 0.8 * renderer_default(window12).height();
          },
          minHeight: null,
          maxHeight: null,
          animation: {
            show: {
              type: "pop",
              duration: 300,
              from: {
                scale: 0.55
              }
            },
            hide: {
              type: "pop",
              duration: 300,
              to: {
                opacity: 0,
                scale: 0.55
              },
              from: {
                opacity: 1,
                scale: 1
              }
            }
          },
          closeOnOutsideClick: false,
          onShowing: null,
          onShown: null,
          onHiding: null,
          onHidden: null,
          contentTemplate: "content",
          dragEnabled: false,
          resizeEnabled: false,
          onResizeStart: null,
          onResize: null,
          onResizeEnd: null,
          innerOverlay: false,
          target: void 0,
          container: void 0,
          hideTopOverlayHandler: () => {
            this.hide();
          },
          closeOnTargetScroll: false,
          onPositioned: null,
          boundaryOffset: {
            h: 0,
            v: 0
          },
          propagateOutsideClick: false,
          ignoreChildEvents: true,
          _checkParentVisibility: true,
          _fixedPosition: false
        });
      },
      _defaultOptionsRules: function() {
        return this.callBase().concat([{
          device: function() {
            return !hasWindow();
          },
          options: {
            width: null,
            height: null,
            animation: null,
            _checkParentVisibility: false
          }
        }]);
      },
      _setOptionsByReference: function() {
        this.callBase();
        extend2(this._optionsByReference, {
          animation: true
        });
      },
      $wrapper: function() {
        return this._$wrapper;
      },
      _eventBindingTarget: function() {
        return this._$content;
      },
      _init: function() {
        this.callBase();
        this._initActions();
        this._initCloseOnOutsideClickHandler();
        this._initTabTerminatorHandler();
        this._$wrapper = renderer_default("<div>").addClass(OVERLAY_WRAPPER_CLASS);
        this._$content = renderer_default("<div>").addClass(OVERLAY_CONTENT_CLASS);
        this._initInnerOverlayClass();
        var $element = this.$element();
        this._$wrapper.addClass($element.attr("class"));
        $element.addClass(OVERLAY_CLASS);
        this._$wrapper.attr("data-bind", "dxControlsDescendantBindings: true");
        events_engine_default.on(this._$wrapper, "MSPointerDown", noop2);
        this._toggleViewPortSubscription(true);
        this._initHideTopOverlayHandler(this.option("hideTopOverlayHandler"));
      },
      _initOptions: function(options2) {
        this._initTarget(options2.target);
        var container = void 0 === options2.container ? this.option("container") : options2.container;
        this._initContainer(container);
        this.callBase(options2);
      },
      _initInnerOverlayClass: function() {
        this._$content.toggleClass(INNER_OVERLAY_CLASS, this.option("innerOverlay"));
      },
      _initTarget: function(target) {
        if (!isDefined(target)) {
          return;
        }
        var options2 = this.option();
        each(["position.of", "animation.show.from.position.of", "animation.show.to.position.of", "animation.hide.from.position.of", "animation.hide.to.position.of"], (_2, path) => {
          var pathParts = path.split(".");
          var option = options2;
          while (option) {
            if (1 === pathParts.length) {
              if (isPlainObject(option)) {
                option[pathParts.shift()] = target;
              }
              break;
            } else {
              option = option[pathParts.shift()];
            }
          }
        });
      },
      _initContainer: function(container) {
        container = void 0 === container ? value() : container;
        var $element = this.$element();
        var $container = $element.closest(container);
        if (!$container.length) {
          $container = renderer_default(container).first();
        }
        this._$container = $container.length ? $container : $element.parent();
      },
      _initHideTopOverlayHandler: function(handler) {
        this._hideTopOverlayHandler = handler;
      },
      _initActions: function() {
        this._actions = {};
        each(ACTIONS, (_2, action) => {
          this._actions[action] = this._createActionByOption(action, {
            excludeValidators: ["disabled", "readOnly"]
          }) || noop2;
        });
      },
      _initCloseOnOutsideClickHandler: function() {
        var that = this;
        this._proxiedDocumentDownHandler = function() {
          return that._documentDownHandler(...arguments);
        };
      },
      _documentDownHandler: function(e) {
        if (this._showAnimationProcessing) {
          this._stopAnimation();
        }
        var closeOnOutsideClick = this.option("closeOnOutsideClick");
        if (isFunction(closeOnOutsideClick)) {
          closeOnOutsideClick = closeOnOutsideClick(e);
        }
        var $container = this._$content;
        var isAttachedTarget = renderer_default(window12.document).is(e.target) || contains2(window12.document, e.target);
        var isInnerOverlay = renderer_default(e.target).closest("." + INNER_OVERLAY_CLASS).length;
        var outsideClick = isAttachedTarget && !isInnerOverlay && !($container.is(e.target) || contains2($container.get(0), e.target));
        if (outsideClick && closeOnOutsideClick) {
          this._outsideClickHandler(e);
        }
        return this.option("propagateOutsideClick");
      },
      _outsideClickHandler(e) {
        if (this.option("shading")) {
          e.preventDefault();
        }
        this.hide();
      },
      _getAnonymousTemplateName: function() {
        return ANONYMOUS_TEMPLATE_NAME2;
      },
      _initTemplates: function() {
        this._templateManager.addDefaultTemplates({
          content: new EmptyTemplate()
        });
        this.callBase();
      },
      _isTopOverlay: function() {
        var overlayStack = this._overlayStack();
        for (var i = overlayStack.length - 1; i >= 0; i--) {
          var tabbableElements = overlayStack[i]._findTabbableBounds();
          if (tabbableElements.first || tabbableElements.last) {
            return overlayStack[i] === this;
          }
        }
        return false;
      },
      _overlayStack: function() {
        return OVERLAY_STACK;
      },
      _zIndexInitValue: function() {
        return Overlay.baseZIndex();
      },
      _toggleViewPortSubscription: function(toggle) {
        viewPortChanged2.remove(this._viewPortChangeHandle);
        if (toggle) {
          this._viewPortChangeHandle = this._viewPortChangeHandler.bind(this);
          viewPortChanged2.add(this._viewPortChangeHandle);
        }
      },
      _viewPortChangeHandler: function() {
        this._initContainer(this.option("container"));
        this._refresh();
      },
      _renderVisibilityAnimate: function(visible2) {
        this._stopAnimation();
        return visible2 ? this._show() : this._hide();
      },
      _normalizePosition: function() {
        var position3 = this.option("position");
        this._position = "function" === typeof position3 ? position3() : position3;
      },
      _getAnimationConfig: function() {
        var animation3 = this.option("animation");
        if (isFunction(animation3)) {
          animation3 = animation3.call(this);
        }
        return animation3;
      },
      _show: function() {
        var that = this;
        var deferred = new Deferred();
        this._parentHidden = this._isParentHidden();
        deferred.done(() => {
          delete that._parentHidden;
        });
        if (this._parentHidden) {
          this._isHidden = true;
          return deferred.resolve();
        }
        if (this._currentVisible) {
          return new Deferred().resolve().promise();
        }
        this._currentVisible = true;
        this._isShown = false;
        this._normalizePosition();
        var animation3 = that._getAnimationConfig() || {};
        var showAnimation = this._normalizeAnimation(animation3.show, "to");
        var startShowAnimation = showAnimation && showAnimation.start || noop2;
        var completeShowAnimation = showAnimation && showAnimation.complete || noop2;
        if (this._isHidingActionCanceled) {
          delete this._isHidingActionCanceled;
          deferred.resolve();
        } else {
          var show = () => {
            this._renderVisibility(true);
            if (this._isShowingActionCanceled) {
              delete this._isShowingActionCanceled;
              deferred.resolve();
              return;
            }
            this._animate(showAnimation, function() {
              if (that.option("focusStateEnabled")) {
                events_engine_default.trigger(that._focusTarget(), "focus");
              }
              completeShowAnimation.apply(this, arguments);
              that._showAnimationProcessing = false;
              that._isShown = true;
              that._actions.onShown();
              that._toggleSafariScrolling(false);
              deferred.resolve();
            }, function() {
              startShowAnimation.apply(this, arguments);
              that._showAnimationProcessing = true;
            });
          };
          if (this.option("templatesRenderAsynchronously")) {
            this._stopShowTimer();
            this._asyncShowTimeout = setTimeout(show);
          } else {
            show();
          }
        }
        return deferred.promise();
      },
      _normalizeAnimation: function(animation3, prop) {
        if (animation3) {
          animation3 = extend2({
            type: "slide",
            skipElementInitialStyles: true
          }, animation3);
          if (animation3[prop] && "object" === typeof animation3[prop]) {
            extend2(animation3[prop], {
              position: this._position
            });
          }
        }
        return animation3;
      },
      _hide: function() {
        if (!this._currentVisible) {
          return new Deferred().resolve().promise();
        }
        this._currentVisible = false;
        var that = this;
        var deferred = new Deferred();
        var animation3 = that._getAnimationConfig() || {};
        var hideAnimation = this._normalizeAnimation(animation3.hide, "from");
        var startHideAnimation = hideAnimation && hideAnimation.start || noop2;
        var completeHideAnimation = hideAnimation && hideAnimation.complete || noop2;
        var hidingArgs = {
          cancel: false
        };
        if (this._isShowingActionCanceled) {
          deferred.resolve();
        } else {
          this._actions.onHiding(hidingArgs);
          that._toggleSafariScrolling(true);
          if (hidingArgs.cancel) {
            this._isHidingActionCanceled = true;
            this.option("visible", true);
            deferred.resolve();
          } else {
            this._forceFocusLost();
            this._toggleShading(false);
            this._toggleSubscriptions(false);
            this._stopShowTimer();
            this._animate(hideAnimation, function() {
              var _that$_actions;
              that._$content.css("pointerEvents", "");
              that._renderVisibility(false);
              completeHideAnimation.apply(this, arguments);
              that._hideAnimationProcessing = false;
              null === (_that$_actions = that._actions) || void 0 === _that$_actions ? void 0 : _that$_actions.onHidden();
              deferred.resolve();
            }, function() {
              that._$content.css("pointerEvents", "none");
              startHideAnimation.apply(this, arguments);
              that._hideAnimationProcessing = true;
            });
          }
        }
        return deferred.promise();
      },
      _forceFocusLost: function() {
        var activeElement = dom_adapter_default.getActiveElement();
        var shouldResetActiveElement = !!this._$content.find(activeElement).length;
        if (shouldResetActiveElement) {
          resetActiveElement();
        }
      },
      _animate: function(animation3, completeCallback, startCallback) {
        if (animation3) {
          startCallback = startCallback || animation3.start || noop2;
          fx_default.animate(this._$content, extend2({}, animation3, {
            start: startCallback,
            complete: completeCallback
          }));
        } else {
          completeCallback();
        }
      },
      _stopAnimation: function() {
        fx_default.stop(this._$content, true);
      },
      _renderVisibility: function(visible2) {
        if (visible2 && this._isParentHidden()) {
          return;
        }
        this._currentVisible = visible2;
        this._stopAnimation();
        if (!visible2) {
          triggerHidingEvent(this._$content);
        }
        this._toggleVisibility(visible2);
        this._$content.toggleClass(INVISIBLE_STATE_CLASS, !visible2);
        this._updateZIndexStackPosition(visible2);
        if (visible2) {
          this._renderContent();
          var showingArgs = {
            cancel: false
          };
          this._actions.onShowing(showingArgs);
          if (showingArgs.cancel) {
            this._toggleVisibility(false);
            this._$content.toggleClass(INVISIBLE_STATE_CLASS, true);
            this._updateZIndexStackPosition(false);
            this._moveFromContainer();
            this._isShowingActionCanceled = true;
            this.option("visible", false);
            return;
          }
          this._moveToContainer();
          this._renderGeometry();
          triggerShownEvent(this._$content);
          triggerResizeEvent(this._$content);
        } else {
          this._moveFromContainer();
        }
        this._toggleShading(visible2);
        this._toggleSubscriptions(visible2);
      },
      _updateZIndexStackPosition: function(pushToStack) {
        var overlayStack = this._overlayStack();
        var index2 = inArray(this, overlayStack);
        if (pushToStack) {
          if (-1 === index2) {
            this._zIndex = create(this._zIndexInitValue());
            overlayStack.push(this);
          }
          this._$wrapper.css("zIndex", this._zIndex);
          this._$content.css("zIndex", this._zIndex);
        } else if (-1 !== index2) {
          overlayStack.splice(index2, 1);
          remove(this._zIndex);
        }
      },
      _toggleShading: function(visible2) {
        this._$wrapper.toggleClass(OVERLAY_MODAL_CLASS, this.option("shading") && !this.option("container"));
        this._$wrapper.toggleClass(OVERLAY_SHADER_CLASS, visible2 && this.option("shading"));
        this._$wrapper.css("backgroundColor", this.option("shading") ? this.option("shadingColor") : "");
        this._toggleTabTerminator(visible2 && this.option("shading"));
      },
      _initTabTerminatorHandler: function() {
        var that = this;
        this._proxiedTabTerminatorHandler = function() {
          that._tabKeyHandler(...arguments);
        };
      },
      _toggleTabTerminator: function(enabled) {
        var eventName = addNamespace2("keydown", this.NAME);
        if (enabled) {
          events_engine_default.on(dom_adapter_default.getDocument(), eventName, this._proxiedTabTerminatorHandler);
        } else {
          events_engine_default.off(dom_adapter_default.getDocument(), eventName, this._proxiedTabTerminatorHandler);
        }
      },
      _findTabbableBounds: function() {
        var $elements = this._$wrapper.find("*");
        var elementsCount = $elements.length - 1;
        var result2 = {
          first: null,
          last: null
        };
        for (var i = 0; i <= elementsCount; i++) {
          if (!result2.first && $elements.eq(i).is(tabbable)) {
            result2.first = $elements.eq(i);
          }
          if (!result2.last && $elements.eq(elementsCount - i).is(tabbable)) {
            result2.last = $elements.eq(elementsCount - i);
          }
          if (result2.first && result2.last) {
            break;
          }
        }
        return result2;
      },
      _tabKeyHandler: function(e) {
        if (normalizeKeyName(e) !== TAB_KEY || !this._isTopOverlay()) {
          return;
        }
        var tabbableElements = this._findTabbableBounds();
        var $firstTabbable = tabbableElements.first;
        var $lastTabbable = tabbableElements.last;
        var isTabOnLast = !e.shiftKey && e.target === $lastTabbable.get(0);
        var isShiftTabOnFirst = e.shiftKey && e.target === $firstTabbable.get(0);
        var isEmptyTabList = 0 === tabbableElements.length;
        var isOutsideTarget = !contains2(this._$wrapper.get(0), e.target);
        if (isTabOnLast || isShiftTabOnFirst || isEmptyTabList || isOutsideTarget) {
          e.preventDefault();
          var $focusElement = e.shiftKey ? $lastTabbable : $firstTabbable;
          events_engine_default.trigger($focusElement, "focusin");
          events_engine_default.trigger($focusElement, "focus");
        }
      },
      _toggleSubscriptions: function(enabled) {
        if (hasWindow()) {
          this._toggleHideTopOverlayCallback(enabled);
          this._toggleParentsScrollSubscription(enabled);
        }
      },
      _toggleHideTopOverlayCallback: function(subscribe) {
        if (!this._hideTopOverlayHandler) {
          return;
        }
        if (subscribe) {
          hideCallback.add(this._hideTopOverlayHandler);
        } else {
          hideCallback.remove(this._hideTopOverlayHandler);
        }
      },
      _toggleParentsScrollSubscription: function(subscribe) {
        if (!this._position) {
          return;
        }
        var target = this._position.of || renderer_default();
        var closeOnScroll = this.option("closeOnTargetScroll");
        var $parents = getElement(target).parents();
        var scrollEvent = addNamespace2("scroll", this.NAME);
        if ("desktop" === devices_default.real().deviceType) {
          $parents = $parents.add(window12);
        }
        this._proxiedTargetParentsScrollHandler = this._proxiedTargetParentsScrollHandler || ((e) => {
          this._targetParentsScrollHandler(e);
        });
        events_engine_default.off(renderer_default().add(this._$prevTargetParents), scrollEvent, this._proxiedTargetParentsScrollHandler);
        if (subscribe && closeOnScroll) {
          events_engine_default.on($parents, scrollEvent, this._proxiedTargetParentsScrollHandler);
          this._$prevTargetParents = $parents;
        }
      },
      _targetParentsScrollHandler: function(e) {
        var closeHandled = false;
        var closeOnScroll = this.option("closeOnTargetScroll");
        if (isFunction(closeOnScroll)) {
          closeHandled = closeOnScroll(e);
        }
        if (!closeHandled && !this._showAnimationProcessing) {
          this.hide();
        }
      },
      _render: function() {
        this.callBase();
        this._appendContentToElement();
        this._renderVisibilityAnimate(this.option("visible"));
      },
      _appendContentToElement: function() {
        if (!this._$content.parent().is(this.$element())) {
          this._$content.appendTo(this.$element());
        }
      },
      _renderContent: function() {
        var shouldDeferRendering = !this._currentVisible && this.option("deferRendering");
        var isParentHidden = this.option("visible") && this._isParentHidden();
        if (isParentHidden) {
          this._isHidden = true;
          return;
        }
        if (this._contentAlreadyRendered || shouldDeferRendering) {
          return;
        }
        this._contentAlreadyRendered = true;
        this._appendContentToElement();
        this.callBase();
      },
      _isParentHidden: function() {
        if (!this.option("_checkParentVisibility")) {
          return false;
        }
        if (void 0 !== this._parentHidden) {
          return this._parentHidden;
        }
        var $parent = this.$element().parent();
        if ($parent.is(":visible")) {
          return false;
        }
        var isHidden = false;
        $parent.add($parent.parents()).each(function() {
          var $element = renderer_default(this);
          if ("none" === $element.css("display")) {
            isHidden = true;
            return false;
          }
        });
        return isHidden || !dom_adapter_default.getBody().contains($parent.get(0));
      },
      _renderContentImpl: function() {
        var whenContentRendered = new Deferred();
        var contentTemplateOption = this.option("contentTemplate");
        var contentTemplate = this._getTemplate(contentTemplateOption);
        var transclude = this._templateManager.anonymousTemplateName === contentTemplateOption;
        contentTemplate && contentTemplate.render({
          container: getPublicElement(this.$content()),
          noModel: true,
          transclude,
          onRendered: () => {
            whenContentRendered.resolve();
          }
        });
        this._renderDrag();
        this._renderResize();
        this._renderScrollTerminator();
        whenContentRendered.done(() => {
          if (this.option("visible")) {
            this._moveToContainer();
          }
        });
        return whenContentRendered.promise();
      },
      _renderDrag: function() {
        var $dragTarget = this._getDragTarget();
        if (!$dragTarget) {
          return;
        }
        var startEventName = addNamespace2(DRAG_START_EVENT, this.NAME);
        var updateEventName = addNamespace2(DRAG_EVENT, this.NAME);
        events_engine_default.off($dragTarget, startEventName);
        events_engine_default.off($dragTarget, updateEventName);
        if (!this.option("dragEnabled")) {
          return;
        }
        events_engine_default.on($dragTarget, startEventName, this._dragStartHandler.bind(this));
        events_engine_default.on($dragTarget, updateEventName, this._dragUpdateHandler.bind(this));
      },
      _renderResize: function() {
        this._resizable = this._createComponent(this._$content, resizable_default, {
          handles: this.option("resizeEnabled") ? "all" : "none",
          onResizeEnd: (e) => {
            this._resizeEndHandler(e);
          },
          onResize: (e) => {
            this._actions.onResize(e);
          },
          onResizeStart: (e) => {
            this._actions.onResizeStart(e);
          },
          minHeight: 100,
          minWidth: 100,
          area: this._getDragResizeContainer()
        });
      },
      _resizeEndHandler: function(e) {
        this._positionChangeHandled = true;
        var width = this._resizable.option("width");
        var height = this._resizable.option("height");
        width && this.option("width", width);
        height && this.option("height", height);
        this._actions.onResizeEnd(e);
      },
      _renderScrollTerminator: function() {
        var $scrollTerminator = this._$wrapper;
        var terminatorEventName = addNamespace2(DRAG_EVENT, this.NAME);
        events_engine_default.off($scrollTerminator, terminatorEventName);
        events_engine_default.on($scrollTerminator, terminatorEventName, {
          validate: function() {
            return true;
          },
          getDirection: function() {
            return "both";
          },
          _toggleGestureCover: function(toggle) {
            if (!toggle) {
              this._toggleGestureCoverImpl(toggle);
            }
          },
          _clearSelection: noop2,
          isNative: true
        }, (e) => {
          var originalEvent = e.originalEvent.originalEvent;
          var {
            type: type2
          } = originalEvent || {};
          var isWheel = "wheel" === type2;
          var isMouseMove = "mousemove" === type2;
          var isScrollByWheel = isWheel && !isCommandKeyPressed(e);
          e._cancelPreventDefault = true;
          if (originalEvent && false !== e.cancelable && (!isMouseMove && !isWheel || isScrollByWheel)) {
            e.preventDefault();
          }
        });
      },
      _getDragTarget: function() {
        return this.$content();
      },
      _dragStartHandler: function(e) {
        e.targetElements = [];
        this._prevOffset = {
          x: 0,
          y: 0
        };
        var allowedOffsets = this._allowedOffsets();
        e.maxTopOffset = allowedOffsets.top;
        e.maxBottomOffset = allowedOffsets.bottom;
        e.maxLeftOffset = allowedOffsets.left;
        e.maxRightOffset = allowedOffsets.right;
      },
      _getDragResizeContainer: function() {
        var isContainerDefined = originalViewPort().get(0) || this.option("container");
        var $container = !isContainerDefined ? renderer_default(window12) : this._$container;
        return $container;
      },
      _deltaSize: function() {
        var $content = this._$content;
        var $container = this._getDragResizeContainer();
        var contentWidth = $content.outerWidth();
        var contentHeight = $content.outerHeight();
        var containerWidth = $container.outerWidth();
        var containerHeight = $container.outerHeight();
        if (this._isWindow($container)) {
          var document2 = dom_adapter_default.getDocument();
          var fullPageHeight = Math.max(renderer_default(document2).outerHeight(), containerHeight);
          var fullPageWidth = Math.max(renderer_default(document2).outerWidth(), containerWidth);
          containerHeight = fullPageHeight;
          containerWidth = fullPageWidth;
        }
        return {
          width: containerWidth - contentWidth,
          height: containerHeight - contentHeight
        };
      },
      _dragUpdateHandler: function(e) {
        var offset2 = e.offset;
        var prevOffset = this._prevOffset;
        var targetOffset = {
          top: offset2.y - prevOffset.y,
          left: offset2.x - prevOffset.x
        };
        this._changePosition(targetOffset);
        this._prevOffset = offset2;
      },
      _changePosition: function(offset2) {
        var position3 = locate(this._$content);
        move(this._$content, {
          left: position3.left + offset2.left,
          top: position3.top + offset2.top
        });
        this._positionChangeHandled = true;
      },
      _allowedOffsets: function() {
        var position3 = locate(this._$content);
        var deltaSize = this._deltaSize();
        var isAllowedDrag = deltaSize.height >= 0 && deltaSize.width >= 0;
        var shaderOffset = this.option("shading") && !this.option("container") && !this._isWindow(this._getContainer()) ? locate(this._$wrapper) : {
          top: 0,
          left: 0
        };
        var boundaryOffset = this.option("boundaryOffset");
        return {
          top: isAllowedDrag ? position3.top + shaderOffset.top + boundaryOffset.v : 0,
          bottom: isAllowedDrag ? -position3.top - shaderOffset.top + deltaSize.height - boundaryOffset.v : 0,
          left: isAllowedDrag ? position3.left + shaderOffset.left + boundaryOffset.h : 0,
          right: isAllowedDrag ? -position3.left - shaderOffset.left + deltaSize.width - boundaryOffset.h : 0
        };
      },
      _moveFromContainer: function() {
        this._$content.appendTo(this.$element());
        this._detachWrapperToContainer();
      },
      _detachWrapperToContainer: function() {
        this._$wrapper.detach();
      },
      _moveToContainer: function() {
        this._attachWrapperToContainer();
        this._$content.appendTo(this._$wrapper);
      },
      _attachWrapperToContainer: function() {
        var $element = this.$element();
        var containerDefined = void 0 !== this.option("container");
        var renderContainer = containerDefined ? this._$container : swatch_container_default.getSwatchContainer($element);
        if (renderContainer && renderContainer[0] === $element.parent()[0]) {
          renderContainer = $element;
        }
        this._$wrapper.appendTo(renderContainer);
      },
      _fixHeightAfterSafariAddressBarResizing: function() {
        if (this._isWindow(this._getContainer()) && hasSafariAddressBar) {
          this._$wrapper.css("minHeight", window12.innerHeight);
        }
      },
      _renderGeometry: function(isDimensionChanged) {
        if (this.option("visible") && hasWindow()) {
          this._renderGeometryImpl(isDimensionChanged);
        }
      },
      _renderGeometryImpl: function(isDimensionChanged) {
        this._stopAnimation();
        this._normalizePosition();
        this._renderWrapper();
        this._fixHeightAfterSafariAddressBarResizing();
        this._renderDimensions();
        var resultPosition = this._renderPosition();
        this._actions.onPositioned({
          position: resultPosition
        });
      },
      _fixWrapperPosition: function() {
        this._$wrapper.css("position", this._useFixedPosition() ? "fixed" : "absolute");
      },
      _useFixedPosition: function() {
        return this._shouldFixBodyPosition() || this.option("_fixedPosition");
      },
      _shouldFixBodyPosition: function() {
        var $container = this._getContainer();
        return this._isWindow($container) && (!iOS || void 0 !== this._bodyScrollTop);
      },
      _toggleSafariScrolling: function(scrollingEnabled) {
        if (iOS && this._shouldFixBodyPosition()) {
          var body = dom_adapter_default.getBody();
          if (scrollingEnabled) {
            renderer_default(body).removeClass(PREVENT_SAFARI_SCROLLING_CLASS);
            window12.scrollTo(0, this._bodyScrollTop);
            this._bodyScrollTop = void 0;
          } else if (this.option("visible")) {
            this._bodyScrollTop = window12.pageYOffset;
            renderer_default(body).addClass(PREVENT_SAFARI_SCROLLING_CLASS);
          }
        }
      },
      _renderWrapper: function() {
        this._fixWrapperPosition();
        this._renderWrapperDimensions();
        this._renderWrapperPosition();
      },
      _renderWrapperDimensions: function() {
        var wrapperWidth;
        var wrapperHeight;
        var $container = this._getContainer();
        if (!$container) {
          return;
        }
        var isWindow2 = this._isWindow($container);
        wrapperWidth = isWindow2 ? "" : $container.outerWidth(), wrapperHeight = isWindow2 ? "" : $container.outerHeight();
        this._$wrapper.css({
          width: wrapperWidth,
          height: wrapperHeight
        });
      },
      _isWindow: function($element) {
        return !!$element && isWindow($element.get(0));
      },
      _renderWrapperPosition: function() {
        var $container = this._getContainer();
        if ($container) {
          position_default.setup(this._$wrapper, {
            my: "top left",
            at: "top left",
            of: $container
          });
        }
      },
      _getContainer: function() {
        var position3 = this._position;
        var container = this.option("container");
        var positionOf = null;
        if (!container && position3) {
          positionOf = isEvent(position3.of) ? window12 : position3.of || window12;
        }
        return getElement(container || positionOf);
      },
      _renderDimensions: function() {
        var content = this._$content.get(0);
        this._$content.css({
          minWidth: this._getOptionValue("minWidth", content),
          maxWidth: this._getOptionValue("maxWidth", content),
          minHeight: this._getOptionValue("minHeight", content),
          maxHeight: this._getOptionValue("maxHeight", content),
          width: this._getOptionValue("width", content),
          height: this._getOptionValue("height", content)
        });
      },
      _renderPosition: function() {
        if (this._positionChangeHandled) {
          var allowedOffsets = this._allowedOffsets();
          this._changePosition({
            top: fitIntoRange(0, -allowedOffsets.top, allowedOffsets.bottom),
            left: fitIntoRange(0, -allowedOffsets.left, allowedOffsets.right)
          });
        } else {
          this._renderOverlayBoundaryOffset();
          resetPosition(this._$content);
          var wrapperOverflow = this._$wrapper.css("overflow");
          this._$wrapper.css("overflow", "hidden");
          var position3 = this._transformStringPosition(this._position, POSITION_ALIASES);
          var resultPosition = position_default.setup(this._$content, position3);
          this._$wrapper.css("overflow", wrapperOverflow);
          forceRepaint(this._$content);
          return resultPosition;
        }
      },
      _transformStringPosition: function(position3, positionAliases2) {
        if (isString2(position3)) {
          position3 = extend2({}, positionAliases2[position3]);
        }
        return position3;
      },
      _renderOverlayBoundaryOffset: function() {
        var boundaryOffset = this.option("boundaryOffset");
        this._$content.css("margin", boundaryOffset.v + "px " + boundaryOffset.h + "px");
      },
      _focusTarget: function() {
        return this._$content;
      },
      _attachKeyboardEvents: function() {
        this._keyboardListenerId = keyboard.on(this._$content, null, (opts) => this._keyboardHandler(opts));
      },
      _keyboardHandler: function(options2) {
        var e = options2.originalEvent;
        var $target = renderer_default(e.target);
        if ($target.is(this._$content) || !this.option("ignoreChildEvents")) {
          this.callBase(...arguments);
        }
      },
      _isVisible: function() {
        return this.option("visible");
      },
      _visibilityChanged: function(visible2) {
        if (visible2) {
          if (this.option("visible")) {
            this._renderVisibilityAnimate(visible2);
          }
        } else {
          this._renderVisibilityAnimate(visible2);
        }
      },
      _dimensionChanged: function() {
        this._renderGeometry(true);
      },
      _clean: function() {
        if (!this._contentAlreadyRendered) {
          this.$content().empty();
        }
        this._renderVisibility(false);
        this._stopShowTimer();
        this._cleanFocusState();
      },
      _stopShowTimer() {
        if (this._asyncShowTimeout) {
          clearTimeout(this._asyncShowTimeout);
        }
        this._asyncShowTimeout = null;
      },
      _dispose: function() {
        fx_default.stop(this._$content, false);
        clearTimeout(this._deferShowTimer);
        this._toggleViewPortSubscription(false);
        this._toggleSubscriptions(false);
        this._updateZIndexStackPosition(false);
        this._toggleTabTerminator(false);
        this._toggleSafariScrolling(true);
        this._actions = null;
        this.callBase();
        this.option("visible") && remove(this._zIndex);
        this._$wrapper.remove();
        this._$content.remove();
      },
      _toggleRTLDirection: function(rtl) {
        this._$content.toggleClass(RTL_DIRECTION_CLASS, rtl);
      },
      _optionChanged: function(args) {
        var value2 = args.value;
        if (inArray(args.name, ACTIONS) > -1) {
          this._initActions();
          return;
        }
        switch (args.name) {
          case "dragEnabled":
            this._renderDrag();
            this._renderGeometry();
            break;
          case "resizeEnabled":
            this._renderResize();
            this._renderGeometry();
            break;
          case "shading":
          case "shadingColor":
            this._toggleShading(this.option("visible"));
            break;
          case "width":
          case "height":
          case "minWidth":
          case "maxWidth":
          case "minHeight":
          case "maxHeight":
          case "boundaryOffset":
            this._renderGeometry();
            break;
          case "position":
            this._positionChangeHandled = false;
            this._renderGeometry();
            break;
          case "visible":
            this._renderVisibilityAnimate(value2).done(() => {
              if (!this._animateDeferred) {
                return;
              }
              this._animateDeferred.resolveWith(this);
            });
            break;
          case "target":
            this._initTarget(value2);
            this._invalidate();
            break;
          case "container":
            this._initContainer(value2);
            this._invalidate();
            break;
          case "innerOverlay":
            this._initInnerOverlayClass();
            break;
          case "deferRendering":
          case "contentTemplate":
            this._contentAlreadyRendered = false;
            this._clean();
            this._invalidate();
            break;
          case "hideTopOverlayHandler":
            this._toggleHideTopOverlayCallback(false);
            this._initHideTopOverlayHandler(args.value);
            this._toggleHideTopOverlayCallback(this.option("visible"));
            break;
          case "closeOnTargetScroll":
            this._toggleParentsScrollSubscription(this.option("visible"));
            break;
          case "closeOnOutsideClick":
          case "animation":
          case "propagateOutsideClick":
            break;
          case "rtlEnabled":
            this._contentAlreadyRendered = false;
            this.callBase(args);
            break;
          case "_fixedPosition":
            this._fixWrapperPosition();
            break;
          default:
            this.callBase(args);
        }
      },
      toggle: function(showing) {
        showing = void 0 === showing ? !this.option("visible") : showing;
        var result2 = new Deferred();
        if (showing === this.option("visible")) {
          return result2.resolveWith(this, [showing]).promise();
        }
        var animateDeferred = new Deferred();
        this._animateDeferred = animateDeferred;
        this.option("visible", showing);
        animateDeferred.promise().done(() => {
          delete this._animateDeferred;
          result2.resolveWith(this, [this.option("visible")]);
        });
        return result2.promise();
      },
      $content: function() {
        return this._$content;
      },
      show: function() {
        return this.toggle(true);
      },
      hide: function() {
        return this.toggle(false);
      },
      content: function() {
        return getPublicElement(this._$content);
      },
      repaint: function() {
        if (this._contentAlreadyRendered) {
          this._renderGeometry();
          triggerResizeEvent(this._$content);
        } else {
          this.callBase();
        }
      }
    });
    Overlay.baseZIndex = (zIndex) => base(zIndex);
    component_registrator_default("dxOverlay", Overlay);
    ui_overlay_default = Overlay;
  }
});

// node_modules/devextreme/esm/ui/load_panel.js
var LOADPANEL_CLASS, LOADPANEL_WRAPPER_CLASS, LOADPANEL_INDICATOR_CLASS, LOADPANEL_MESSAGE_CLASS, LOADPANEL_CONTENT_CLASS, LOADPANEL_CONTENT_WRAPPER_CLASS, LOADPANEL_PANE_HIDDEN_CLASS, LoadPanel, load_panel_default;
var init_load_panel = __esm({
  "node_modules/devextreme/esm/ui/load_panel.js"() {
    init_renderer();
    init_common();
    init_message();
    init_component_registrator();
    init_extend();
    init_load_indicator();
    init_ui_overlay();
    init_deferred();
    init_themes();
    LOADPANEL_CLASS = "dx-loadpanel";
    LOADPANEL_WRAPPER_CLASS = "dx-loadpanel-wrapper";
    LOADPANEL_INDICATOR_CLASS = "dx-loadpanel-indicator";
    LOADPANEL_MESSAGE_CLASS = "dx-loadpanel-message";
    LOADPANEL_CONTENT_CLASS = "dx-loadpanel-content";
    LOADPANEL_CONTENT_WRAPPER_CLASS = "dx-loadpanel-content-wrapper";
    LOADPANEL_PANE_HIDDEN_CLASS = "dx-loadpanel-pane-hidden";
    LoadPanel = ui_overlay_default.inherit({
      _supportedKeys: function() {
        return extend2(this.callBase(), {
          escape: noop2
        });
      },
      _getDefaultOptions: function() {
        return extend2(this.callBase(), {
          message: message_default.format("Loading"),
          width: 222,
          height: 90,
          animation: null,
          showIndicator: true,
          indicatorSrc: "",
          showPane: true,
          delay: 0,
          templatesRenderAsynchronously: false,
          hideTopOverlayHandler: null,
          resizeEnabled: false,
          focusStateEnabled: false
        });
      },
      _defaultOptionsRules: function() {
        return this.callBase().concat([{
          device: {
            platform: "generic"
          },
          options: {
            shadingColor: "transparent"
          }
        }, {
          device: function() {
            return isMaterial();
          },
          options: {
            message: "",
            width: 60,
            height: 60,
            maxHeight: 60,
            maxWidth: 60
          }
        }]);
      },
      _init: function() {
        this.callBase.apply(this, arguments);
      },
      _render: function() {
        this.callBase();
        this.$element().addClass(LOADPANEL_CLASS);
        this.$wrapper().addClass(LOADPANEL_WRAPPER_CLASS);
      },
      _renderContentImpl: function() {
        this.callBase();
        this.$content().addClass(LOADPANEL_CONTENT_CLASS);
        this._$loadPanelContentWrapper = renderer_default("<div>").addClass(LOADPANEL_CONTENT_WRAPPER_CLASS);
        this._$loadPanelContentWrapper.appendTo(this.$content());
        this._togglePaneVisible();
        this._cleanPreviousContent();
        this._renderLoadIndicator();
        this._renderMessage();
      },
      _show: function() {
        var delay = this.option("delay");
        if (!delay) {
          return this.callBase();
        }
        var deferred = new Deferred();
        var callBase = this.callBase.bind(this);
        this._clearShowTimeout();
        this._showTimeout = setTimeout(function() {
          callBase().done(function() {
            deferred.resolve();
          });
        }, delay);
        return deferred.promise();
      },
      _hide: function() {
        this._clearShowTimeout();
        return this.callBase();
      },
      _clearShowTimeout: function() {
        clearTimeout(this._showTimeout);
      },
      _renderMessage: function() {
        if (!this._$loadPanelContentWrapper) {
          return;
        }
        var message = this.option("message");
        if (!message) {
          return;
        }
        var $message = renderer_default("<div>").addClass(LOADPANEL_MESSAGE_CLASS).text(message);
        this._$loadPanelContentWrapper.append($message);
      },
      _renderLoadIndicator: function() {
        if (!this._$loadPanelContentWrapper || !this.option("showIndicator")) {
          return;
        }
        if (!this._$indicator) {
          this._$indicator = renderer_default("<div>").addClass(LOADPANEL_INDICATOR_CLASS).appendTo(this._$loadPanelContentWrapper);
        }
        this._createComponent(this._$indicator, load_indicator_default, {
          indicatorSrc: this.option("indicatorSrc")
        });
      },
      _cleanPreviousContent: function() {
        this.$content().find("." + LOADPANEL_MESSAGE_CLASS).remove();
        this.$content().find("." + LOADPANEL_INDICATOR_CLASS).remove();
        delete this._$indicator;
      },
      _togglePaneVisible: function() {
        this.$content().toggleClass(LOADPANEL_PANE_HIDDEN_CLASS, !this.option("showPane"));
      },
      _optionChanged: function(args) {
        switch (args.name) {
          case "delay":
            break;
          case "message":
          case "showIndicator":
            this._cleanPreviousContent();
            this._renderLoadIndicator();
            this._renderMessage();
            break;
          case "showPane":
            this._togglePaneVisible();
            break;
          case "indicatorSrc":
            this._renderLoadIndicator();
            break;
          default:
            this.callBase(args);
        }
      },
      _dispose: function() {
        this._clearShowTimeout();
        this.callBase();
      }
    });
    component_registrator_default("dxLoadPanel", LoadPanel);
    load_panel_default = LoadPanel;
  }
});

// node_modules/devextreme/esm/core/utils/date.js
function convertDateUnitToMilliseconds(dateUnit, count) {
  return toMilliseconds(dateUnit) * count;
}
function getDateUnitInterval(tickInterval) {
  var maxInterval = -1;
  var i;
  if (isString2(tickInterval)) {
    return tickInterval;
  }
  if (isObject2(tickInterval)) {
    each(tickInterval, function(key, value2) {
      for (i = 0; i < dateUnitIntervals.length; i++) {
        if (value2 && (key === dateUnitIntervals[i] + "s" || key === dateUnitIntervals[i]) && maxInterval < i) {
          maxInterval = i;
        }
      }
    });
    return dateUnitIntervals[maxInterval];
  }
  return "";
}
function getDateFormatByTickInterval(tickInterval) {
  return tickIntervalToFormatMap[getDateUnitInterval(tickInterval)] || "";
}
function correctDateWithUnitBeginning(date, dateInterval, withCorrection, firstDayOfWeek) {
  date = new Date(date.getTime());
  var oldDate = new Date(date.getTime());
  var firstQuarterMonth;
  var month;
  var dateUnitInterval = getDateUnitInterval(dateInterval);
  switch (dateUnitInterval) {
    case "second":
      date = new Date(1e3 * Math.floor(oldDate.getTime() / 1e3));
      break;
    case "minute":
      date = new Date(6e4 * Math.floor(oldDate.getTime() / 6e4));
      break;
    case "hour":
      date = new Date(36e5 * Math.floor(oldDate.getTime() / 36e5));
      break;
    case "year":
      date.setMonth(0);
    case "month":
      date.setDate(1);
    case "day":
      date.setHours(0, 0, 0, 0);
      break;
    case "week":
      date = getFirstWeekDate(date, firstDayOfWeek || 0);
      date.setHours(0, 0, 0, 0);
      break;
    case "quarter":
      firstQuarterMonth = getFirstQuarterMonth(date.getMonth());
      month = date.getMonth();
      date.setDate(1);
      date.setHours(0, 0, 0, 0);
      if (month !== firstQuarterMonth) {
        date.setMonth(firstQuarterMonth);
      }
  }
  if (withCorrection && "hour" !== dateUnitInterval && "minute" !== dateUnitInterval && "second" !== dateUnitInterval) {
    fixTimezoneGap(oldDate, date);
  }
  return date;
}
function trimTime(date) {
  return correctDateWithUnitBeginning(date, "day");
}
function addDateInterval(value2, interval, dir) {
  var result2 = new Date(value2.getTime());
  var intervalObject = isString2(interval) ? getDateIntervalByString(interval.toLowerCase()) : isNumeric(interval) ? convertMillisecondsToDateUnits(interval) : interval;
  if (intervalObject.years) {
    result2.setFullYear(result2.getFullYear() + intervalObject.years * dir);
  }
  if (intervalObject.quarters) {
    result2.setMonth(result2.getMonth() + 3 * intervalObject.quarters * dir);
  }
  if (intervalObject.months) {
    result2.setMonth(result2.getMonth() + intervalObject.months * dir);
  }
  if (intervalObject.weeks) {
    result2.setDate(result2.getDate() + 7 * intervalObject.weeks * dir);
  }
  if (intervalObject.days) {
    result2.setDate(result2.getDate() + intervalObject.days * dir);
  }
  if (intervalObject.hours) {
    result2.setTime(result2.getTime() + 36e5 * intervalObject.hours * dir);
  }
  if (intervalObject.minutes) {
    result2.setTime(result2.getTime() + 6e4 * intervalObject.minutes * dir);
  }
  if (intervalObject.seconds) {
    result2.setTime(result2.getTime() + 1e3 * intervalObject.seconds * dir);
  }
  if (intervalObject.milliseconds) {
    result2.setTime(result2.getTime() + intervalObject.milliseconds * dir);
  }
  return result2;
}
function getLastMonthDay(date) {
  var resultDate = createDateWithFullYear(date.getFullYear(), date.getMonth() + 1, 0);
  return resultDate.getDate();
}
function getDateIntervalByString(intervalString) {
  var result2 = {};
  switch (intervalString) {
    case "year":
      result2.years = 1;
      break;
    case "month":
      result2.months = 1;
      break;
    case "quarter":
      result2.months = 3;
      break;
    case "week":
      result2.weeks = 1;
      break;
    case "day":
      result2.days = 1;
      break;
    case "hour":
      result2.hours = 1;
      break;
    case "minute":
      result2.minutes = 1;
      break;
    case "second":
      result2.seconds = 1;
      break;
    case "millisecond":
      result2.milliseconds = 1;
  }
  return result2;
}
function sameDate(date1, date2) {
  return sameMonthAndYear(date1, date2) && date1.getDate() === date2.getDate();
}
function sameMonthAndYear(date1, date2) {
  return sameYear(date1, date2) && date1.getMonth() === date2.getMonth();
}
function sameYear(date1, date2) {
  return date1 && date2 && date1.getFullYear() === date2.getFullYear();
}
function sameHoursAndMinutes(date1, date2) {
  return date1 && date2 && date1.getHours() === date2.getHours() && date1.getMinutes() === date2.getMinutes();
}
function getFirstDecadeInCentury(date) {
  return date && date.getFullYear() - date.getFullYear() % 100;
}
function getFirstYearInDecade(date) {
  return date && date.getFullYear() - date.getFullYear() % 10;
}
function getFirstWeekDate(date, firstDayOfWeek) {
  var delta = (date.getDay() - firstDayOfWeek + 7) % 7;
  var result2 = new Date(date);
  result2.setDate(date.getDate() - delta);
  return result2;
}
function normalizeDate(date, min, max) {
  var normalizedDate = date;
  if (!isDefined(date)) {
    return date;
  }
  if (isDefined(min) && date < min) {
    normalizedDate = min;
  }
  if (isDefined(max) && date > max) {
    normalizedDate = max;
  }
  return normalizedDate;
}
function fixTimezoneGap(oldDate, newDate) {
  if (!isDefined(oldDate)) {
    return;
  }
  var diff = newDate.getHours() - oldDate.getHours();
  if (0 === diff) {
    return;
  }
  var sign2 = 1 === diff || -23 === diff ? -1 : 1;
  var trial = new Date(newDate.getTime() + 36e5 * sign2);
  if (sign2 > 0 || trial.getDate() === newDate.getDate()) {
    newDate.setTime(trial.getTime());
  }
}
function getTimezonesDifference(min, max) {
  return 60 * (max.getTimezoneOffset() - min.getTimezoneOffset()) * 1e3;
}
var isIE112, dateUnitIntervals, toMilliseconds, getDatesInterval, getNextDateUnit, convertMillisecondsToDateUnits, dateToMilliseconds, tickIntervalToFormatMap, getQuarter, getFirstQuarterMonth, setToDayEnd, getDatesDifferences, addInterval, getSequenceByInterval, getViewFirstCellDate, getViewLastCellDate, getViewMinBoundaryDate, getViewMaxBoundaryDate, getViewUp, getViewDown, getDifferenceInMonth, getDifferenceInMonthForCells, sameDecade, sameCentury, getShortDateFormat, getFirstMonthDate, getLastMonthDate, normalizeDateByWeek, dateInRange, intervalsOverlap, dateTimeFromDecimal, roundDateByStartDayHour, roundToHour, makeDate, getDatesOfInterval, createDate, createDateWithFullYear, dateUtils, date_default;
var init_date = __esm({
  "node_modules/devextreme/esm/core/utils/date.js"() {
    init_type();
    init_math();
    init_iterator();
    init_inflector();
    init_browser();
    isIE112 = browser_default.msie && parseInt(browser_default.version) <= 11;
    dateUnitIntervals = ["millisecond", "second", "minute", "hour", "day", "week", "month", "quarter", "year"];
    toMilliseconds = function toMilliseconds2(value2) {
      switch (value2) {
        case "millisecond":
          return 1;
        case "second":
          return 1e3 * toMilliseconds2("millisecond");
        case "minute":
          return 60 * toMilliseconds2("second");
        case "hour":
          return 60 * toMilliseconds2("minute");
        case "day":
          return 24 * toMilliseconds2("hour");
        case "week":
          return 7 * toMilliseconds2("day");
        case "month":
          return 30 * toMilliseconds2("day");
        case "quarter":
          return 3 * toMilliseconds2("month");
        case "year":
          return 365 * toMilliseconds2("day");
        default:
          return 0;
      }
    };
    getDatesInterval = function(startDate, endDate, intervalUnit) {
      var delta = endDate.getTime() - startDate.getTime();
      var millisecondCount = toMilliseconds(intervalUnit) || 1;
      return Math.floor(delta / millisecondCount);
    };
    getNextDateUnit = function(unit, withWeeks) {
      var interval = getDateUnitInterval(unit);
      switch (interval) {
        case "millisecond":
          return "second";
        case "second":
          return "minute";
        case "minute":
          return "hour";
        case "hour":
          return "day";
        case "day":
          return withWeeks ? "week" : "month";
        case "week":
          return "month";
        case "month":
          return "quarter";
        case "quarter":
        case "year":
          return "year";
        default:
          return 0;
      }
    };
    convertMillisecondsToDateUnits = function(value2) {
      var i;
      var dateUnitCount;
      var dateUnitInterval;
      var dateUnitIntervals2 = ["millisecond", "second", "minute", "hour", "day", "month", "year"];
      var result2 = {};
      for (i = dateUnitIntervals2.length - 1; i >= 0; i--) {
        dateUnitInterval = dateUnitIntervals2[i];
        dateUnitCount = Math.floor(value2 / toMilliseconds(dateUnitInterval));
        if (dateUnitCount > 0) {
          result2[dateUnitInterval + "s"] = dateUnitCount;
          value2 -= convertDateUnitToMilliseconds(dateUnitInterval, dateUnitCount);
        }
      }
      return result2;
    };
    dateToMilliseconds = function(tickInterval) {
      var milliseconds = 0;
      if (isObject2(tickInterval)) {
        each(tickInterval, function(key, value2) {
          milliseconds += convertDateUnitToMilliseconds(key.substr(0, key.length - 1), value2);
        });
      }
      if (isString2(tickInterval)) {
        milliseconds = convertDateUnitToMilliseconds(tickInterval, 1);
      }
      return milliseconds;
    };
    tickIntervalToFormatMap = {
      millisecond: "millisecond",
      second: "longtime",
      minute: "shorttime",
      hour: "shorttime",
      day: "day",
      week: "day",
      month: "month",
      quarter: "quarter",
      year: "year"
    };
    getQuarter = function(month) {
      return Math.floor(month / 3);
    };
    getFirstQuarterMonth = function(month) {
      return 3 * getQuarter(month);
    };
    setToDayEnd = function(date) {
      var result2 = trimTime(date);
      result2.setDate(result2.getDate() + 1);
      return new Date(result2.getTime() - 1);
    };
    getDatesDifferences = function(date1, date2) {
      var counter = 0;
      var differences = {
        year: date1.getFullYear() !== date2.getFullYear(),
        month: date1.getMonth() !== date2.getMonth(),
        day: date1.getDate() !== date2.getDate(),
        hour: date1.getHours() !== date2.getHours(),
        minute: date1.getMinutes() !== date2.getMinutes(),
        second: date1.getSeconds() !== date2.getSeconds(),
        millisecond: date1.getMilliseconds() !== date2.getMilliseconds()
      };
      each(differences, function(key, value2) {
        if (value2) {
          counter++;
        }
      });
      if (0 === counter && 0 !== getTimezonesDifference(date1, date2)) {
        differences.hour = true;
        counter++;
      }
      differences.count = counter;
      return differences;
    };
    addInterval = function(value2, interval, isNegative) {
      var dir = isNegative ? -1 : 1;
      return isDate(value2) ? addDateInterval(value2, interval, dir) : adjust(value2 + interval * dir, interval);
    };
    getSequenceByInterval = function(min, max, interval) {
      var intervals = [];
      var cur;
      intervals.push(isDate(min) ? new Date(min.getTime()) : min);
      cur = min;
      while (cur < max) {
        cur = addInterval(cur, interval);
        intervals.push(cur);
      }
      return intervals;
    };
    getViewFirstCellDate = function(viewType, date) {
      if ("month" === viewType) {
        return createDateWithFullYear(date.getFullYear(), date.getMonth(), 1);
      }
      if ("year" === viewType) {
        return createDateWithFullYear(date.getFullYear(), 0, date.getDate());
      }
      if ("decade" === viewType) {
        return createDateWithFullYear(getFirstYearInDecade(date), date.getMonth(), date.getDate());
      }
      if ("century" === viewType) {
        return createDateWithFullYear(getFirstDecadeInCentury(date), date.getMonth(), date.getDate());
      }
    };
    getViewLastCellDate = function(viewType, date) {
      if ("month" === viewType) {
        return createDateWithFullYear(date.getFullYear(), date.getMonth(), getLastMonthDay(date));
      }
      if ("year" === viewType) {
        return createDateWithFullYear(date.getFullYear(), 11, date.getDate());
      }
      if ("decade" === viewType) {
        return createDateWithFullYear(getFirstYearInDecade(date) + 9, date.getMonth(), date.getDate());
      }
      if ("century" === viewType) {
        return createDateWithFullYear(getFirstDecadeInCentury(date) + 90, date.getMonth(), date.getDate());
      }
    };
    getViewMinBoundaryDate = function(viewType, date) {
      var resultDate = createDateWithFullYear(date.getFullYear(), date.getMonth(), 1);
      if ("month" === viewType) {
        return resultDate;
      }
      resultDate.setMonth(0);
      if ("year" === viewType) {
        return resultDate;
      }
      if ("decade" === viewType) {
        resultDate.setFullYear(getFirstYearInDecade(date));
      }
      if ("century" === viewType) {
        resultDate.setFullYear(getFirstDecadeInCentury(date));
      }
      return resultDate;
    };
    getViewMaxBoundaryDate = function(viewType, date) {
      var resultDate = new Date(date);
      resultDate.setDate(getLastMonthDay(date));
      if ("month" === viewType) {
        return resultDate;
      }
      resultDate.setMonth(11);
      resultDate.setDate(getLastMonthDay(resultDate));
      if ("year" === viewType) {
        return resultDate;
      }
      if ("decade" === viewType) {
        resultDate.setFullYear(getFirstYearInDecade(date) + 9);
      }
      if ("century" === viewType) {
        resultDate.setFullYear(getFirstDecadeInCentury(date) + 99);
      }
      return resultDate;
    };
    getViewUp = function(typeView) {
      switch (typeView) {
        case "month":
          return "year";
        case "year":
          return "decade";
        case "decade":
          return "century";
      }
    };
    getViewDown = function(typeView) {
      switch (typeView) {
        case "century":
          return "decade";
        case "decade":
          return "year";
        case "year":
          return "month";
      }
    };
    getDifferenceInMonth = function(typeView) {
      var difference = 1;
      if ("year" === typeView) {
        difference = 12;
      }
      if ("decade" === typeView) {
        difference = 120;
      }
      if ("century" === typeView) {
        difference = 1200;
      }
      return difference;
    };
    getDifferenceInMonthForCells = function(typeView) {
      var difference = 1;
      if ("decade" === typeView) {
        difference = 12;
      }
      if ("century" === typeView) {
        difference = 120;
      }
      return difference;
    };
    sameDecade = function(date1, date2) {
      if (!isDefined(date1) || !isDefined(date2)) {
        return;
      }
      var startDecadeDate1 = date1.getFullYear() - date1.getFullYear() % 10;
      var startDecadeDate2 = date2.getFullYear() - date2.getFullYear() % 10;
      return date1 && date2 && startDecadeDate1 === startDecadeDate2;
    };
    sameCentury = function(date1, date2) {
      if (!isDefined(date1) || !isDefined(date2)) {
        return;
      }
      var startCenturyDate1 = date1.getFullYear() - date1.getFullYear() % 100;
      var startCenturyDate2 = date2.getFullYear() - date2.getFullYear() % 100;
      return date1 && date2 && startCenturyDate1 === startCenturyDate2;
    };
    getShortDateFormat = function() {
      return "yyyy/MM/dd";
    };
    getFirstMonthDate = function(date) {
      if (!isDefined(date)) {
        return;
      }
      return createDateWithFullYear(date.getFullYear(), date.getMonth(), 1);
    };
    getLastMonthDate = function(date) {
      if (!isDefined(date)) {
        return;
      }
      return createDateWithFullYear(date.getFullYear(), date.getMonth() + 1, 0);
    };
    normalizeDateByWeek = function(date, currentDate) {
      var differenceInDays = dateUtils.getDatesInterval(date, currentDate, "day");
      var resultDate = new Date(date);
      if (differenceInDays >= 6) {
        resultDate = new Date(resultDate.setDate(resultDate.getDate() + 7));
      }
      return resultDate;
    };
    dateInRange = function(date, min, max, format2) {
      if ("date" === format2) {
        min = min && dateUtils.correctDateWithUnitBeginning(min, "day");
        max = max && dateUtils.correctDateWithUnitBeginning(max, "day");
        date = date && dateUtils.correctDateWithUnitBeginning(date, "day");
      }
      return normalizeDate(date, min, max) === date;
    };
    intervalsOverlap = function(options2) {
      var {
        firstMin,
        firstMax,
        secondMin,
        secondMax
      } = options2;
      return firstMin <= secondMin && secondMin <= firstMax || firstMin > secondMin && firstMin < secondMax || firstMin < secondMax && firstMax > secondMax;
    };
    dateTimeFromDecimal = function(number2) {
      var hours = Math.floor(number2);
      var minutes = number2 % 1 * 60;
      return {
        hours,
        minutes
      };
    };
    roundDateByStartDayHour = function(date, startDayHour) {
      var startTime = this.dateTimeFromDecimal(startDayHour);
      var result2 = new Date(date);
      if (date.getHours() === startTime.hours && date.getMinutes() < startTime.minutes || date.getHours() < startTime.hours) {
        result2.setHours(startTime.hours, startTime.minutes, 0, 0);
      }
      return result2;
    };
    roundToHour = function(date) {
      date.setHours(date.getHours() + 1);
      date.setMinutes(0);
      return date;
    };
    makeDate = function(date) {
      return new Date(date);
    };
    getDatesOfInterval = function(startDate, endDate, step) {
      var result2 = [];
      var currentDate = new Date(startDate.getTime());
      while (currentDate < endDate) {
        result2.push(new Date(currentDate.getTime()));
        currentDate = this.addInterval(currentDate, step);
      }
      return result2;
    };
    createDate = function(date) {
      return new Date(isIE112 && isDate(date) ? date.getTime() : date);
    };
    createDateWithFullYear = function(year) {
      var result2 = new Date(...arguments);
      result2.setFullYear(year);
      return result2;
    };
    dateUtils = {
      dateUnitIntervals,
      convertMillisecondsToDateUnits,
      dateToMilliseconds,
      getNextDateUnit,
      convertDateUnitToMilliseconds,
      getDateUnitInterval,
      getDateFormatByTickInterval,
      getDatesDifferences,
      correctDateWithUnitBeginning,
      trimTime,
      setToDayEnd,
      roundDateByStartDayHour,
      dateTimeFromDecimal,
      addDateInterval,
      addInterval,
      getSequenceByInterval,
      getDateIntervalByString,
      sameHoursAndMinutes,
      sameDate,
      sameMonthAndYear,
      sameMonth: sameMonthAndYear,
      sameYear,
      sameDecade,
      sameCentury,
      getDifferenceInMonth,
      getDifferenceInMonthForCells,
      getFirstYearInDecade,
      getFirstDecadeInCentury,
      getShortDateFormat,
      getViewFirstCellDate,
      getViewLastCellDate,
      getViewDown,
      getViewUp,
      getLastMonthDay,
      getLastMonthDate,
      getFirstMonthDate,
      getFirstWeekDate,
      normalizeDateByWeek,
      getQuarter,
      getFirstQuarterMonth,
      dateInRange,
      intervalsOverlap,
      roundToHour,
      normalizeDate,
      getViewMinBoundaryDate,
      getViewMaxBoundaryDate,
      fixTimezoneGap,
      getTimezonesDifference,
      makeDate,
      getDatesInterval,
      getDatesOfInterval,
      createDate,
      createDateWithFullYear
    };
    dateUtils.sameView = function(view, date1, date2) {
      return dateUtils[camelize2("same " + view)](date1, date2);
    };
    date_default = dateUtils;
  }
});

// node_modules/devextreme/esm/localization/utils.js
function roundByAbs(value2) {
  var valueSign = sign(value2);
  return valueSign * Math.round(Math.abs(value2));
}
function adjustValue(value2, precision) {
  var precisionMultiplier = Math.pow(DECIMAL_BASE, precision);
  var intermediateValue = multiplyInExponentialForm(value2, precision);
  return roundByAbs(intermediateValue) / precisionMultiplier;
}
function toFixed(value2, precision) {
  var valuePrecision = precision || 0;
  var adjustedValue = valuePrecision > 0 ? adjustValue(...arguments) : value2;
  return adjustedValue.toFixed(valuePrecision);
}
var DECIMAL_BASE;
var init_utils4 = __esm({
  "node_modules/devextreme/esm/localization/utils.js"() {
    init_math();
    DECIMAL_BASE = 10;
  }
});

// node_modules/devextreme/esm/localization/ldml/number.js
function getGroupSizes(formatString) {
  return formatString.split(",").slice(1).map(function(str) {
    var singleQuotesLeft = 0;
    return str.split("").filter(function(char, index2) {
      singleQuotesLeft += "'" === char;
      var isDigit = "#" === char || "0" === char;
      var isInStub = singleQuotesLeft % 2;
      return isDigit && !isInStub;
    }).length;
  });
}
function getSignParts(format2) {
  var signParts = format2.split(";");
  if (1 === signParts.length) {
    signParts.push("-" + signParts[0]);
  }
  return signParts;
}
function reverseString(str) {
  return str.toString().split("").reverse().join("");
}
function isPercentFormat(format2) {
  return -1 !== format2.indexOf("%") && !format2.match(/'[^']*%[^']*'/g);
}
function removeStubs(str) {
  return str.replace(/'.+'/g, "");
}
function getNonRequiredDigitCount(floatFormat) {
  if (!floatFormat) {
    return 0;
  }
  var format2 = removeStubs(floatFormat);
  return format2.length - format2.replace(/[#]/g, "").length;
}
function getRequiredDigitCount(floatFormat) {
  if (!floatFormat) {
    return 0;
  }
  var format2 = removeStubs(floatFormat);
  return format2.length - format2.replace(/[0]/g, "").length;
}
function normalizeValueString(valuePart, minDigitCount, maxDigitCount) {
  if (!valuePart) {
    return "";
  }
  if (valuePart.length > maxDigitCount) {
    valuePart = valuePart.substr(0, maxDigitCount);
  }
  while (valuePart.length > minDigitCount && "0" === valuePart.slice(-1)) {
    valuePart = valuePart.substr(0, valuePart.length - 1);
  }
  while (valuePart.length < minDigitCount) {
    valuePart += "0";
  }
  return valuePart;
}
function applyGroups(valueString, groupSizes, thousandsSeparator) {
  if (!groupSizes.length) {
    return valueString;
  }
  var groups = [];
  var index2 = 0;
  while (valueString) {
    var groupSize = groupSizes[index2];
    if (!groupSize) {
      break;
    }
    groups.push(valueString.slice(0, groupSize));
    valueString = valueString.slice(groupSize);
    if (index2 < groupSizes.length - 1) {
      index2++;
    }
  }
  return groups.join(thousandsSeparator);
}
function formatNumberPart(format2, valueString) {
  return format2.split(ESCAPING_CHAR).map(function(formatPart, escapeIndex) {
    var isEscape = escapeIndex % 2;
    if (!formatPart && isEscape) {
      return ESCAPING_CHAR;
    }
    return isEscape ? formatPart : formatPart.replace(/[,#0]+/, valueString);
  }).join("");
}
function getFloatPointIndex(format2) {
  var isEscape = false;
  for (var index2 = 0; index2 < format2.length; index2++) {
    if ("'" === format2[index2]) {
      isEscape = !isEscape;
    }
    if ("." === format2[index2] && !isEscape) {
      return index2;
    }
  }
  return format2.length;
}
function getFormatter(format2, config2) {
  config2 = config2 || DEFAULT_CONFIG;
  return function(value2) {
    if ("number" !== typeof value2 || isNaN(value2)) {
      return "";
    }
    var signFormatParts = getSignParts(format2);
    var isPositiveZero = 1 / value2 === 1 / 0;
    var isPositive = value2 > 0 || isPositiveZero;
    var numberFormat = signFormatParts[isPositive ? 0 : 1];
    var floatPointIndex = getFloatPointIndex(numberFormat);
    var floatFormatParts = [numberFormat.substr(0, floatPointIndex), numberFormat.substr(floatPointIndex + 1)];
    var minFloatPrecision = getRequiredDigitCount(floatFormatParts[1]);
    var maxFloatPrecision = minFloatPrecision + getNonRequiredDigitCount(floatFormatParts[1]);
    if (isPercentFormat(numberFormat)) {
      value2 = multiplyInExponentialForm(value2, PERCENT_EXPONENT_SHIFT);
    }
    if (!isPositive) {
      value2 = -value2;
    }
    var minIntegerPrecision = getRequiredDigitCount(floatFormatParts[0]);
    var maxIntegerPrecision = getNonRequiredDigitCount(floatFormatParts[0]) || config2.unlimitedIntegerDigits ? void 0 : minIntegerPrecision;
    var integerLength = Math.floor(value2).toString().length;
    var floatPrecision = fitIntoRange(maxFloatPrecision, 0, MAXIMUM_NUMBER_LENGTH - integerLength);
    var groupSizes = getGroupSizes(floatFormatParts[0]).reverse();
    var valueParts = toFixed(value2, floatPrecision < 0 ? 0 : floatPrecision).split(".");
    var valueIntegerPart = normalizeValueString(reverseString(valueParts[0]), minIntegerPrecision, maxIntegerPrecision);
    var valueFloatPart = normalizeValueString(valueParts[1], minFloatPrecision, maxFloatPrecision);
    valueIntegerPart = applyGroups(valueIntegerPart, groupSizes, config2.thousandsSeparator);
    var integerString = reverseString(formatNumberPart(reverseString(floatFormatParts[0]), valueIntegerPart));
    var floatString = maxFloatPrecision ? formatNumberPart(floatFormatParts[1], valueFloatPart) : "";
    var result2 = integerString + (floatString.match(/\d/) ? config2.decimalSeparator : "") + floatString;
    return result2;
  };
}
function parseValue(text, isPercent, isNegative) {
  var value2 = (isPercent ? 0.01 : 1) * parseFloat(text) || 0;
  return isNegative ? -value2 : value2;
}
function prepareValueText(valueText, formatter, isPercent, isIntegerPart) {
  var nextValueText = valueText;
  var char;
  var text;
  var nextText;
  do {
    if (nextText) {
      char = text.length === nextText.length ? "0" : "1";
      valueText = isIntegerPart ? char + valueText : valueText + char;
    }
    text = nextText || formatter(parseValue(nextValueText, isPercent));
    nextValueText = isIntegerPart ? "1" + nextValueText : nextValueText + "1";
    nextText = formatter(parseValue(nextValueText, isPercent));
  } while (text !== nextText && (isIntegerPart ? text.length === nextText.length : text.length <= nextText.length));
  if (isIntegerPart && nextText.length > text.length) {
    var hasGroups = -1 === formatter(12345).indexOf("12345");
    do {
      valueText = "1" + valueText;
    } while (hasGroups && parseValue(valueText, isPercent) < 1e5);
  }
  return valueText;
}
function getFormatByValueText(valueText, formatter, isPercent, isNegative) {
  var format2 = formatter(parseValue(valueText, isPercent, isNegative));
  var valueTextParts = valueText.split(".");
  var valueTextWithModifiedFloat = valueTextParts[0] + ".3" + valueTextParts[1].slice(1);
  var valueWithModifiedFloat = parseValue(valueTextWithModifiedFloat, isPercent, isNegative);
  var decimalSeparatorIndex = formatter(valueWithModifiedFloat).indexOf("3") - 1;
  format2 = format2.replace(/(\d)\D(\d)/g, "$1,$2");
  if (decimalSeparatorIndex >= 0) {
    format2 = format2.slice(0, decimalSeparatorIndex) + "." + format2.slice(decimalSeparatorIndex + 1);
  }
  format2 = format2.replace(/1+/, "1").replace(/1/g, "#");
  if (!isPercent) {
    format2 = format2.replace("%", "'%'");
  }
  return format2;
}
function getFormat(formatter) {
  var valueText = ".";
  var isPercent = formatter(1).indexOf("100") >= 0;
  valueText = prepareValueText(valueText, formatter, isPercent, true);
  valueText = prepareValueText(valueText, formatter, isPercent, false);
  var positiveFormat = getFormatByValueText(valueText, formatter, isPercent, false);
  var negativeFormat = getFormatByValueText(valueText, formatter, isPercent, true);
  return negativeFormat === "-" + positiveFormat ? positiveFormat : positiveFormat + ";" + negativeFormat;
}
var DEFAULT_CONFIG, ESCAPING_CHAR, MAXIMUM_NUMBER_LENGTH, PERCENT_EXPONENT_SHIFT;
var init_number = __esm({
  "node_modules/devextreme/esm/localization/ldml/number.js"() {
    init_math();
    init_utils4();
    DEFAULT_CONFIG = {
      thousandsSeparator: ",",
      decimalSeparator: "."
    };
    ESCAPING_CHAR = "'";
    MAXIMUM_NUMBER_LENGTH = 15;
    PERCENT_EXPONENT_SHIFT = 2;
  }
});

// node_modules/devextreme/esm/localization/currency.js
var currency_default;
var init_currency = __esm({
  "node_modules/devextreme/esm/localization/currency.js"() {
    init_extend();
    currency_default = {
      _formatNumberCore: function(value2, format2, formatConfig) {
        if ("currency" === format2) {
          formatConfig.precision = formatConfig.precision || 0;
          var result2 = this.format(value2, extend2({}, formatConfig, {
            type: "fixedpoint"
          }));
          var currencyPart = this.getCurrencySymbol().symbol.replace(/\$/g, "$$$$");
          result2 = result2.replace(/^(\D*)(\d.*)/, "$1" + currencyPart + "$2");
          return result2;
        }
        return this.callBase.apply(this, arguments);
      },
      getCurrencySymbol: function() {
        return {
          symbol: "$"
        };
      },
      getOpenXmlCurrencyFormat: function() {
        return "$#,##0{0}_);\\($#,##0{0}\\)";
      }
    };
  }
});

// node_modules/devextreme/esm/localization/open_xml_currency_format.js
var open_xml_currency_format_default;
var init_open_xml_currency_format = __esm({
  "node_modules/devextreme/esm/localization/open_xml_currency_format.js"() {
    open_xml_currency_format_default = (currencySymbol, accountingFormat) => {
      if (!accountingFormat) {
        return;
      }
      var encodedCurrencySymbol = currencySymbol;
      if ("string" === typeof currencySymbol) {
        encodedCurrencySymbol = "";
        for (var i = 0; i < currencySymbol.length; i++) {
          if ("$" !== currencySymbol[i]) {
            encodedCurrencySymbol += "\\";
          }
          encodedCurrencySymbol += currencySymbol[i];
        }
      }
      var encodeSymbols = {
        ".00": "{0}",
        "'": "\\'",
        "\\(": "\\(",
        "\\)": "\\)",
        " ": "\\ ",
        '"': "&quot;",
        "\\": encodedCurrencySymbol
      };
      var result2 = accountingFormat.split(";");
      for (var _i = 0; _i < result2.length; _i++) {
        for (var symbol in encodeSymbols) {
          if (Object.prototype.hasOwnProperty.call(encodeSymbols, symbol)) {
            result2[_i] = result2[_i].replace(new RegExp(symbol, "g"), encodeSymbols[symbol]);
          }
        }
      }
      return 2 === result2.length ? result2[0] + "_);" + result2[1] : result2[0];
    };
  }
});

// node_modules/devextreme/esm/localization/cldr-data/accounting_formats.js
var accounting_formats_default;
var init_accounting_formats = __esm({
  "node_modules/devextreme/esm/localization/cldr-data/accounting_formats.js"() {
    accounting_formats_default = {
      af: "#,##0.00;(#,##0.00)",
      "af-NA": "#,##0.00;(#,##0.00)",
      agq: "#,##0.00",
      ak: "#,##0.00",
      am: "#,##0.00;(#,##0.00)",
      ar: "#,##0.00;(#,##0.00)",
      "ar-AE": "#,##0.00;(#,##0.00)",
      "ar-BH": "#,##0.00;(#,##0.00)",
      "ar-DJ": "#,##0.00;(#,##0.00)",
      "ar-DZ": "#,##0.00;(#,##0.00)",
      "ar-EG": "#,##0.00;(#,##0.00)",
      "ar-EH": "#,##0.00;(#,##0.00)",
      "ar-ER": "#,##0.00;(#,##0.00)",
      "ar-IL": "#,##0.00;(#,##0.00)",
      "ar-IQ": "#,##0.00;(#,##0.00)",
      "ar-JO": "#,##0.00;(#,##0.00)",
      "ar-KM": "#,##0.00;(#,##0.00)",
      "ar-KW": "#,##0.00;(#,##0.00)",
      "ar-LB": "#,##0.00;(#,##0.00)",
      "ar-LY": "#,##0.00;(#,##0.00)",
      "ar-MA": "#,##0.00;(#,##0.00)",
      "ar-MR": "#,##0.00;(#,##0.00)",
      "ar-OM": "#,##0.00;(#,##0.00)",
      "ar-PS": "#,##0.00;(#,##0.00)",
      "ar-QA": "#,##0.00;(#,##0.00)",
      "ar-SA": "#,##0.00;(#,##0.00)",
      "ar-SD": "#,##0.00;(#,##0.00)",
      "ar-SO": "#,##0.00;(#,##0.00)",
      "ar-SS": "#,##0.00;(#,##0.00)",
      "ar-SY": "#,##0.00;(#,##0.00)",
      "ar-TD": "#,##0.00;(#,##0.00)",
      "ar-TN": "#,##0.00;(#,##0.00)",
      "ar-YE": "#,##0.00;(#,##0.00)",
      as: "#,##,##0.00",
      asa: "#,##0.00",
      ast: "#,##0.00",
      az: "#,##0.00",
      "az-Cyrl": "#,##0.00",
      "az-Latn": "#,##0.00",
      bas: "#,##0.00",
      be: "#,##0.00",
      "be-tarask": "#,##0.00",
      bem: "#,##0.00;(#,##0.00)",
      bez: "#,##0.00",
      bg: "0.00;(0.00)",
      bm: "#,##0.00;(#,##0.00)",
      bn: "#,##,##0.00;(#,##,##0.00)",
      "bn-IN": "#,##,##0.00;(#,##,##0.00)",
      bo: "#,##0.00",
      "bo-IN": "#,##0.00",
      br: "#,##0.00",
      brx: "#,##,##0.00",
      bs: "#,##0.00",
      "bs-Cyrl": "#,##0.00",
      "bs-Latn": "#,##0.00",
      ca: "#,##0.00;(#,##0.00)",
      "ca-AD": "#,##0.00;(#,##0.00)",
      "ca-ES-valencia": "#,##0.00;(#,##0.00)",
      "ca-FR": "#,##0.00;(#,##0.00)",
      "ca-IT": "#,##0.00;(#,##0.00)",
      ccp: "#,##,##0.00;(#,##,##0.00)",
      "ccp-IN": "#,##,##0.00;(#,##,##0.00)",
      ce: "#,##0.00",
      ceb: "#,##0.00;(#,##0.00)",
      cgg: "#,##0.00",
      chr: "#,##0.00;(#,##0.00)",
      ckb: "#,##0.00",
      "ckb-IR": "#,##0.00",
      cs: "#,##0.00",
      cy: "#,##0.00;(#,##0.00)",
      da: "#,##0.00",
      "da-GL": "#,##0.00",
      dav: "#,##0.00;(#,##0.00)",
      de: "#,##0.00",
      "de-AT": "#,##0.00",
      "de-BE": "#,##0.00",
      "de-CH": "#,##0.00",
      "de-IT": "#,##0.00",
      "de-LI": "#,##0.00",
      "de-LU": "#,##0.00",
      dje: "#,##0.00",
      doi: "#,##0.00",
      dsb: "#,##0.00",
      dua: "#,##0.00",
      dyo: "#,##0.00",
      dz: "#,##,##0.00",
      ebu: "#,##0.00;(#,##0.00)",
      ee: "#,##0.00;(#,##0.00)",
      "ee-TG": "#,##0.00;(#,##0.00)",
      el: "#,##0.00",
      "el-CY": "#,##0.00",
      en: "#,##0.00;(#,##0.00)",
      "en-001": "#,##0.00;(#,##0.00)",
      "en-150": "#,##0.00",
      "en-AE": "#,##0.00;(#,##0.00)",
      "en-AG": "#,##0.00;(#,##0.00)",
      "en-AI": "#,##0.00;(#,##0.00)",
      "en-AS": "#,##0.00;(#,##0.00)",
      "en-AT": "#,##0.00",
      "en-AU": "#,##0.00;(#,##0.00)",
      "en-BB": "#,##0.00;(#,##0.00)",
      "en-BE": "#,##0.00",
      "en-BI": "#,##0.00;(#,##0.00)",
      "en-BM": "#,##0.00;(#,##0.00)",
      "en-BS": "#,##0.00;(#,##0.00)",
      "en-BW": "#,##0.00;(#,##0.00)",
      "en-BZ": "#,##0.00;(#,##0.00)",
      "en-CA": "#,##0.00;(#,##0.00)",
      "en-CC": "#,##0.00;(#,##0.00)",
      "en-CH": "#,##0.00;-#,##0.00",
      "en-CK": "#,##0.00;(#,##0.00)",
      "en-CM": "#,##0.00;(#,##0.00)",
      "en-CX": "#,##0.00;(#,##0.00)",
      "en-CY": "#,##0.00;(#,##0.00)",
      "en-DE": "#,##0.00",
      "en-DG": "#,##0.00;(#,##0.00)",
      "en-DK": "#,##0.00",
      "en-DM": "#,##0.00;(#,##0.00)",
      "en-ER": "#,##0.00;(#,##0.00)",
      "en-FI": "#,##0.00",
      "en-FJ": "#,##0.00;(#,##0.00)",
      "en-FK": "#,##0.00;(#,##0.00)",
      "en-FM": "#,##0.00;(#,##0.00)",
      "en-GB": "#,##0.00;(#,##0.00)",
      "en-GD": "#,##0.00;(#,##0.00)",
      "en-GG": "#,##0.00;(#,##0.00)",
      "en-GH": "#,##0.00;(#,##0.00)",
      "en-GI": "#,##0.00;(#,##0.00)",
      "en-GM": "#,##0.00;(#,##0.00)",
      "en-GU": "#,##0.00;(#,##0.00)",
      "en-GY": "#,##0.00;(#,##0.00)",
      "en-HK": "#,##0.00;(#,##0.00)",
      "en-IE": "#,##0.00;(#,##0.00)",
      "en-IL": "#,##0.00;(#,##0.00)",
      "en-IM": "#,##0.00;(#,##0.00)",
      "en-IN": "#,##0.00;(#,##0.00)",
      "en-IO": "#,##0.00;(#,##0.00)",
      "en-JE": "#,##0.00;(#,##0.00)",
      "en-JM": "#,##0.00;(#,##0.00)",
      "en-KE": "#,##0.00;(#,##0.00)",
      "en-KI": "#,##0.00;(#,##0.00)",
      "en-KN": "#,##0.00;(#,##0.00)",
      "en-KY": "#,##0.00;(#,##0.00)",
      "en-LC": "#,##0.00;(#,##0.00)",
      "en-LR": "#,##0.00;(#,##0.00)",
      "en-LS": "#,##0.00;(#,##0.00)",
      "en-MG": "#,##0.00;(#,##0.00)",
      "en-MH": "#,##0.00;(#,##0.00)",
      "en-MO": "#,##0.00;(#,##0.00)",
      "en-MP": "#,##0.00;(#,##0.00)",
      "en-MS": "#,##0.00;(#,##0.00)",
      "en-MT": "#,##0.00;(#,##0.00)",
      "en-MU": "#,##0.00;(#,##0.00)",
      "en-MV": "#,##0.00",
      "en-MW": "#,##0.00;(#,##0.00)",
      "en-MY": "#,##0.00;(#,##0.00)",
      "en-NA": "#,##0.00;(#,##0.00)",
      "en-NF": "#,##0.00;(#,##0.00)",
      "en-NG": "#,##0.00;(#,##0.00)",
      "en-NL": "#,##0.00;(#,##0.00)",
      "en-NR": "#,##0.00;(#,##0.00)",
      "en-NU": "#,##0.00;(#,##0.00)",
      "en-NZ": "#,##0.00;(#,##0.00)",
      "en-PG": "#,##0.00;(#,##0.00)",
      "en-PH": "#,##0.00;(#,##0.00)",
      "en-PK": "#,##0.00;(#,##0.00)",
      "en-PN": "#,##0.00;(#,##0.00)",
      "en-PR": "#,##0.00;(#,##0.00)",
      "en-PW": "#,##0.00;(#,##0.00)",
      "en-RW": "#,##0.00;(#,##0.00)",
      "en-SB": "#,##0.00;(#,##0.00)",
      "en-SC": "#,##0.00;(#,##0.00)",
      "en-SD": "#,##0.00;(#,##0.00)",
      "en-SE": "#,##0.00",
      "en-SG": "#,##0.00;(#,##0.00)",
      "en-SH": "#,##0.00;(#,##0.00)",
      "en-SI": "#,##0.00;(#,##0.00)",
      "en-SL": "#,##0.00;(#,##0.00)",
      "en-SS": "#,##0.00;(#,##0.00)",
      "en-SX": "#,##0.00;(#,##0.00)",
      "en-SZ": "#,##0.00;(#,##0.00)",
      "en-TC": "#,##0.00;(#,##0.00)",
      "en-TK": "#,##0.00;(#,##0.00)",
      "en-TO": "#,##0.00;(#,##0.00)",
      "en-TT": "#,##0.00;(#,##0.00)",
      "en-TV": "#,##0.00;(#,##0.00)",
      "en-TZ": "#,##0.00;(#,##0.00)",
      "en-UG": "#,##0.00;(#,##0.00)",
      "en-UM": "#,##0.00;(#,##0.00)",
      "en-VC": "#,##0.00;(#,##0.00)",
      "en-VG": "#,##0.00;(#,##0.00)",
      "en-VI": "#,##0.00;(#,##0.00)",
      "en-VU": "#,##0.00;(#,##0.00)",
      "en-WS": "#,##0.00;(#,##0.00)",
      "en-ZA": "#,##0.00;(#,##0.00)",
      "en-ZM": "#,##0.00;(#,##0.00)",
      "en-ZW": "#,##0.00;(#,##0.00)",
      eo: "#,##0.00",
      es: "#,##0.00",
      "es-419": "#,##0.00",
      "es-AR": "#,##0.00;(#,##0.00)",
      "es-BO": "#,##0.00",
      "es-BR": "#,##0.00",
      "es-BZ": "#,##0.00",
      "es-CL": "#,##0.00",
      "es-CO": "#,##0.00",
      "es-CR": "#,##0.00",
      "es-CU": "#,##0.00",
      "es-DO": "#,##0.00;(#,##0.00)",
      "es-EA": "#,##0.00",
      "es-EC": "#,##0.00",
      "es-GQ": "#,##0.00",
      "es-GT": "#,##0.00",
      "es-HN": "#,##0.00",
      "es-IC": "#,##0.00",
      "es-MX": "#,##0.00",
      "es-NI": "#,##0.00",
      "es-PA": "#,##0.00",
      "es-PE": "#,##0.00",
      "es-PH": "#,##0.00",
      "es-PR": "#,##0.00",
      "es-PY": "#,##0.00",
      "es-SV": "#,##0.00",
      "es-US": "#,##0.00",
      "es-UY": "#,##0.00;(#,##0.00)",
      "es-VE": "#,##0.00",
      et: "#,##0.00;(#,##0.00)",
      eu: "#,##0.00;(#,##0.00)",
      ewo: "#,##0.00",
      fa: "#,##0.00;(#,##0.00)",
      "fa-AF": "#,##0.00;(#,##0.00)",
      ff: "#,##0.00",
      "ff-Adlm": "#,##0.00",
      "ff-Adlm-BF": "#,##0.00",
      "ff-Adlm-CM": "#,##0.00",
      "ff-Adlm-GH": "#,##0.00",
      "ff-Adlm-GM": "#,##0.00",
      "ff-Adlm-GW": "#,##0.00",
      "ff-Adlm-LR": "#,##0.00",
      "ff-Adlm-MR": "#,##0.00",
      "ff-Adlm-NE": "#,##0.00",
      "ff-Adlm-NG": "#,##0.00",
      "ff-Adlm-SL": "#,##0.00",
      "ff-Adlm-SN": "#,##0.00",
      "ff-Latn": "#,##0.00",
      "ff-Latn-BF": "#,##0.00",
      "ff-Latn-CM": "#,##0.00",
      "ff-Latn-GH": "#,##0.00",
      "ff-Latn-GM": "#,##0.00",
      "ff-Latn-GN": "#,##0.00",
      "ff-Latn-GW": "#,##0.00",
      "ff-Latn-LR": "#,##0.00",
      "ff-Latn-MR": "#,##0.00",
      "ff-Latn-NE": "#,##0.00",
      "ff-Latn-NG": "#,##0.00",
      "ff-Latn-SL": "#,##0.00",
      fi: "#,##0.00",
      fil: "#,##0.00;(#,##0.00)",
      fo: "#,##0.00;(#,##0.00)",
      "fo-DK": "#,##0.00;(#,##0.00)",
      fr: "#,##0.00;(#,##0.00)",
      "fr-BE": "#,##0.00;(#,##0.00)",
      "fr-BF": "#,##0.00;(#,##0.00)",
      "fr-BI": "#,##0.00;(#,##0.00)",
      "fr-BJ": "#,##0.00;(#,##0.00)",
      "fr-BL": "#,##0.00;(#,##0.00)",
      "fr-CA": "#,##0.00;(#,##0.00)",
      "fr-CD": "#,##0.00;(#,##0.00)",
      "fr-CF": "#,##0.00;(#,##0.00)",
      "fr-CG": "#,##0.00;(#,##0.00)",
      "fr-CH": "#,##0.00;(#,##0.00)",
      "fr-CI": "#,##0.00;(#,##0.00)",
      "fr-CM": "#,##0.00;(#,##0.00)",
      "fr-DJ": "#,##0.00;(#,##0.00)",
      "fr-DZ": "#,##0.00;(#,##0.00)",
      "fr-GA": "#,##0.00;(#,##0.00)",
      "fr-GF": "#,##0.00;(#,##0.00)",
      "fr-GN": "#,##0.00;(#,##0.00)",
      "fr-GP": "#,##0.00;(#,##0.00)",
      "fr-GQ": "#,##0.00;(#,##0.00)",
      "fr-HT": "#,##0.00;(#,##0.00)",
      "fr-KM": "#,##0.00;(#,##0.00)",
      "fr-LU": "#,##0.00;(#,##0.00)",
      "fr-MA": "#,##0.00;(#,##0.00)",
      "fr-MC": "#,##0.00;(#,##0.00)",
      "fr-MF": "#,##0.00;(#,##0.00)",
      "fr-MG": "#,##0.00;(#,##0.00)",
      "fr-ML": "#,##0.00;(#,##0.00)",
      "fr-MQ": "#,##0.00;(#,##0.00)",
      "fr-MR": "#,##0.00;(#,##0.00)",
      "fr-MU": "#,##0.00;(#,##0.00)",
      "fr-NC": "#,##0.00;(#,##0.00)",
      "fr-NE": "#,##0.00;(#,##0.00)",
      "fr-PF": "#,##0.00;(#,##0.00)",
      "fr-PM": "#,##0.00;(#,##0.00)",
      "fr-RE": "#,##0.00;(#,##0.00)",
      "fr-RW": "#,##0.00;(#,##0.00)",
      "fr-SC": "#,##0.00;(#,##0.00)",
      "fr-SN": "#,##0.00;(#,##0.00)",
      "fr-SY": "#,##0.00;(#,##0.00)",
      "fr-TD": "#,##0.00;(#,##0.00)",
      "fr-TG": "#,##0.00;(#,##0.00)",
      "fr-TN": "#,##0.00;(#,##0.00)",
      "fr-VU": "#,##0.00;(#,##0.00)",
      "fr-WF": "#,##0.00;(#,##0.00)",
      "fr-YT": "#,##0.00;(#,##0.00)",
      fur: "#,##0.00",
      fy: "#,##0.00;(#,##0.00)",
      ga: "#,##0.00;(#,##0.00)",
      "ga-GB": "#,##0.00;(#,##0.00)",
      gd: "#,##0.00;(#,##0.00)",
      gl: "#,##0.00",
      gsw: "#,##0.00",
      "gsw-FR": "#,##0.00",
      "gsw-LI": "#,##0.00",
      gu: "#,##,##0.00;(#,##,##0.00)",
      guz: "#,##0.00;(#,##0.00)",
      gv: "#,##0.00",
      ha: "#,##0.00",
      "ha-GH": "#,##0.00",
      "ha-NE": "#,##0.00",
      haw: "#,##0.00;(#,##0.00)",
      he: "#,##0.00",
      hi: "#,##,##0.00",
      "hi-Latn": "#,##,##0.00",
      hr: "#,##0.00",
      "hr-BA": "#,##0.00",
      hsb: "#,##0.00",
      hu: "#,##0.00",
      hy: "#,##0.00",
      ia: "#,##0.00;(#,##0.00)",
      id: "#,##0.00",
      ig: "#,##0.00;(#,##0.00)",
      ii: "#,##0.00",
      is: "#,##0.00",
      it: "#,##0.00",
      "it-CH": "#,##0.00",
      "it-SM": "#,##0.00",
      "it-VA": "#,##0.00",
      ja: "#,##0.00;(#,##0.00)",
      jgo: "#,##0.00",
      jmc: "#,##0.00",
      jv: "#,##0.00",
      ka: "#,##0.00",
      kab: "#,##0.00",
      kam: "#,##0.00;(#,##0.00)",
      kde: "#,##0.00;(#,##0.00)",
      kea: "#,##0.00;(#,##0.00)",
      kgp: "#,##0.00",
      khq: "#,##0.00",
      ki: "#,##0.00;(#,##0.00)",
      kk: "#,##0.00",
      kkj: "#,##0.00",
      kl: "#,##0.00;-#,##0.00",
      kln: "#,##0.00;(#,##0.00)",
      km: "#,##0.00;(#,##0.00)",
      kn: "#,##0.00;(#,##0.00)",
      ko: "#,##0.00;(#,##0.00)",
      "ko-KP": "#,##0.00;(#,##0.00)",
      kok: "#,##0.00;(#,##0.00)",
      ks: "#,##0.00",
      "ks-Arab": "#,##0.00",
      "ks-Deva": "#,##0.00",
      ksb: "#,##0.00",
      ksf: "#,##0.00",
      ksh: "#,##0.00",
      ku: "#,##0.00;(#,##0.00)",
      kw: "#,##0.00",
      ky: "#,##0.00",
      lag: "#,##0.00",
      lb: "#,##0.00",
      lg: "#,##0.00",
      lkt: "#,##0.00",
      ln: "#,##0.00",
      "ln-AO": "#,##0.00",
      "ln-CF": "#,##0.00",
      "ln-CG": "#,##0.00",
      lo: "#,##0.00;-#,##0.00",
      lrc: "#,##0.00",
      "lrc-IQ": "#,##0.00",
      lt: "#,##0.00",
      lu: "#,##0.00",
      luo: "#,##0.00",
      luy: "#,##0.00;-#,##0.00",
      lv: "#,##0.00",
      mai: "#,##0.00",
      mas: "#,##0.00;(#,##0.00)",
      "mas-TZ": "#,##0.00;(#,##0.00)",
      mer: "#,##0.00;(#,##0.00)",
      mfe: "#,##0.00",
      mg: "#,##0.00",
      mgh: "#,##0.00",
      mgo: "#,##0.00",
      mi: "#,##0.00",
      mk: "#,##0.00",
      ml: "#,##0.00;(#,##0.00)",
      mn: "#,##0.00",
      mni: "#,##0.00",
      "mni-Beng": "#,##0.00",
      mr: "#,##0.00;(#,##0.00)",
      ms: "#,##0.00;(#,##0.00)",
      "ms-BN": "#,##0.00;(#,##0.00)",
      "ms-ID": "#,##0.00",
      "ms-SG": "#,##0.00;(#,##0.00)",
      mt: "#,##0.00",
      mua: "#,##0.00;(#,##0.00)",
      my: "#,##0.00",
      mzn: "#,##0.00",
      naq: "#,##0.00",
      nb: "#,##0.00;(#,##0.00)",
      "nb-SJ": "#,##0.00;(#,##0.00)",
      nd: "#,##0.00;(#,##0.00)",
      nds: "#,##0.00",
      "nds-NL": "#,##0.00",
      ne: "#,##,##0.00",
      "ne-IN": "#,##,##0.00",
      nl: "#,##0.00;(#,##0.00)",
      "nl-AW": "#,##0.00;(#,##0.00)",
      "nl-BE": "#,##0.00;(#,##0.00)",
      "nl-BQ": "#,##0.00;(#,##0.00)",
      "nl-CW": "#,##0.00;(#,##0.00)",
      "nl-SR": "#,##0.00;(#,##0.00)",
      "nl-SX": "#,##0.00;(#,##0.00)",
      nmg: "#,##0.00",
      nn: "#,##0.00",
      nnh: "#,##0.00",
      no: "#,##0.00;(#,##0.00)",
      nus: "#,##0.00;(#,##0.00)",
      nyn: "#,##0.00",
      om: "#,##0.00",
      "om-KE": "#,##0.00",
      or: "#,##0.00;(#,##0.00)",
      os: "#,##0.00",
      "os-RU": "#,##0.00",
      pa: "#,##0.00",
      "pa-Arab": "#,##0.00",
      "pa-Guru": "#,##0.00",
      pcm: "#,##0.00",
      pl: "#,##0.00;(#,##0.00)",
      ps: "#,##0.00;(#,##0.00)",
      "ps-PK": "#,##0.00;(#,##0.00)",
      pt: "#,##0.00",
      "pt-AO": "#,##0.00;(#,##0.00)",
      "pt-CH": "#,##0.00;(#,##0.00)",
      "pt-CV": "#,##0.00;(#,##0.00)",
      "pt-GQ": "#,##0.00;(#,##0.00)",
      "pt-GW": "#,##0.00;(#,##0.00)",
      "pt-LU": "#,##0.00;(#,##0.00)",
      "pt-MO": "#,##0.00;(#,##0.00)",
      "pt-MZ": "#,##0.00;(#,##0.00)",
      "pt-PT": "#,##0.00;(#,##0.00)",
      "pt-ST": "#,##0.00;(#,##0.00)",
      "pt-TL": "#,##0.00;(#,##0.00)",
      qu: "#,##0.00",
      "qu-BO": "#,##0.00",
      "qu-EC": "#,##0.00",
      rm: "#,##0.00",
      rn: "#,##0.00",
      ro: "#,##0.00;(#,##0.00)",
      "ro-MD": "#,##0.00;(#,##0.00)",
      rof: "#,##0.00",
      ru: "#,##0.00",
      "ru-BY": "#,##0.00",
      "ru-KG": "#,##0.00",
      "ru-KZ": "#,##0.00",
      "ru-MD": "#,##0.00",
      "ru-UA": "#,##0.00",
      rw: "#,##0.00",
      rwk: "#,##0.00",
      sa: "#,##0.00",
      sah: "#,##0.00",
      saq: "#,##0.00;(#,##0.00)",
      sat: "#,##0.00",
      "sat-Olck": "#,##0.00",
      sbp: "#,##0.00",
      sc: "#,##0.00",
      sd: "#,##0.00",
      "sd-Arab": "#,##0.00",
      "sd-Deva": "#,##0.00",
      se: "#,##0.00",
      "se-FI": "#,##0.00",
      "se-SE": "#,##0.00",
      seh: "#,##0.00",
      ses: "#,##0.00",
      sg: "#,##0.00;-#,##0.00",
      shi: "#,##0.00",
      "shi-Latn": "#,##0.00",
      "shi-Tfng": "#,##0.00",
      si: "#,##0.00;(#,##0.00)",
      sk: "#,##0.00;(#,##0.00)",
      sl: "#,##0.00;(#,##0.00)",
      smn: "#,##0.00",
      sn: "#,##0.00;(#,##0.00)",
      so: "#,##0.00;(#,##0.00)",
      "so-DJ": "#,##0.00;(#,##0.00)",
      "so-ET": "#,##0.00;(#,##0.00)",
      "so-KE": "#,##0.00;(#,##0.00)",
      sq: "#,##0.00;(#,##0.00)",
      "sq-MK": "#,##0.00;(#,##0.00)",
      "sq-XK": "#,##0.00;(#,##0.00)",
      sr: "#,##0.00;(#,##0.00)",
      "sr-Cyrl": "#,##0.00;(#,##0.00)",
      "sr-Cyrl-BA": "#,##0.00;(#,##0.00)",
      "sr-Cyrl-ME": "#,##0.00;(#,##0.00)",
      "sr-Cyrl-XK": "#,##0.00;(#,##0.00)",
      "sr-Latn": "#,##0.00;(#,##0.00)",
      "sr-Latn-BA": "#,##0.00;(#,##0.00)",
      "sr-Latn-ME": "#,##0.00;(#,##0.00)",
      "sr-Latn-XK": "#,##0.00;(#,##0.00)",
      su: "#,##0.00",
      "su-Latn": "#,##0.00",
      sv: "#,##0.00",
      "sv-AX": "#,##0.00",
      "sv-FI": "#,##0.00",
      sw: "#,##0.00",
      "sw-CD": "#,##0.00",
      "sw-KE": "#,##0.00",
      "sw-UG": "#,##0.00",
      ta: "#,##0.00;(#,##0.00)",
      "ta-LK": "#,##0.00;(#,##0.00)",
      "ta-MY": "#,##0.00;(#,##0.00)",
      "ta-SG": "#,##0.00;(#,##0.00)",
      te: "#,##0.00;(#,##0.00)",
      teo: "#,##0.00;(#,##0.00)",
      "teo-KE": "#,##0.00;(#,##0.00)",
      tg: "#,##0.00",
      th: "#,##0.00;(#,##0.00)",
      ti: "#,##0.00",
      "ti-ER": "#,##0.00",
      tk: "#,##0.00",
      to: "#,##0.00",
      tr: "#,##0.00;(#,##0.00)",
      "tr-CY": "#,##0.00;(#,##0.00)",
      tt: "#,##0.00",
      twq: "#,##0.00",
      tzm: "#,##0.00",
      ug: "#,##0.00;(#,##0.00)",
      uk: "#,##0.00",
      und: "#,##0.00",
      ur: "#,##0.00;(#,##0.00)",
      "ur-IN": "#,##0.00;(#,##0.00)",
      uz: "#,##0.00",
      "uz-Arab": "#,##0.00",
      "uz-Cyrl": "#,##0.00",
      "uz-Latn": "#,##0.00",
      vai: "#,##0.00;(#,##0.00)",
      "vai-Latn": "#,##0.00;(#,##0.00)",
      "vai-Vaii": "#,##0.00;(#,##0.00)",
      vi: "#,##0.00",
      vun: "#,##0.00",
      wae: "#,##0.00",
      wo: "#,##0.00",
      xh: "#,##0.00",
      xog: "#,##0.00",
      yav: "#,##0.00;(#,##0.00)",
      yi: "#,##0.00",
      yo: "#,##0.00;(#,##0.00)",
      "yo-BJ": "#,##0.00;(#,##0.00)",
      yrl: "#,##0.00",
      "yrl-CO": "#,##0.00",
      "yrl-VE": "#,##0.00",
      yue: "#,##0.00;(#,##0.00)",
      "yue-Hans": "#,##0.00;(#,##0.00)",
      "yue-Hant": "#,##0.00;(#,##0.00)",
      zgh: "#,##0.00",
      zh: "#,##0.00;(#,##0.00)",
      "zh-Hans": "#,##0.00;(#,##0.00)",
      "zh-Hans-HK": "#,##0.00;(#,##0.00)",
      "zh-Hans-MO": "#,##0.00;(#,##0.00)",
      "zh-Hans-SG": "#,##0.00;(#,##0.00)",
      "zh-Hant": "#,##0.00;(#,##0.00)",
      "zh-Hant-HK": "#,##0.00;(#,##0.00)",
      "zh-Hant-MO": "#,##0.00;(#,##0.00)",
      zu: "#,##0.00;(#,##0.00)"
    };
  }
});

// node_modules/devextreme/esm/localization/intl/number.js
var detectCurrencySymbolRegex, formattersCache, getFormatter2, getCurrencyFormatter, number_default;
var init_number2 = __esm({
  "node_modules/devextreme/esm/localization/intl/number.js"() {
    init_config();
    init_core();
    init_open_xml_currency_format();
    init_accounting_formats();
    detectCurrencySymbolRegex = /([^\s0]+)?(\s*)0*[.,]*0*(\s*)([^\s0]+)?/;
    formattersCache = {};
    getFormatter2 = (format2) => {
      var key = core_default.locale() + "/" + JSON.stringify(format2);
      if (!formattersCache[key]) {
        formattersCache[key] = new Intl.NumberFormat(core_default.locale(), format2).format;
      }
      return formattersCache[key];
    };
    getCurrencyFormatter = (currency) => new Intl.NumberFormat(core_default.locale(), {
      style: "currency",
      currency
    });
    number_default = {
      engine: function() {
        return "intl";
      },
      _formatNumberCore: function(value2, format2, formatConfig) {
        if ("exponential" === format2) {
          return this.callBase.apply(this, arguments);
        }
        return getFormatter2(this._normalizeFormatConfig(format2, formatConfig, value2))(value2);
      },
      _normalizeFormatConfig: function(format2, formatConfig, value2) {
        var config2;
        if ("decimal" === format2) {
          config2 = {
            minimumIntegerDigits: formatConfig.precision || void 0,
            useGrouping: false,
            maximumFractionDigits: String(value2).length,
            round: value2 < 0 ? "ceil" : "floor"
          };
        } else {
          config2 = this._getPrecisionConfig(formatConfig.precision);
        }
        if ("percent" === format2) {
          config2.style = "percent";
        } else if ("currency" === format2) {
          config2.style = "currency";
          config2.currency = formatConfig.currency || config_default().defaultCurrency;
        }
        return config2;
      },
      _getPrecisionConfig: function(precision) {
        var config2;
        if (null === precision) {
          config2 = {
            minimumFractionDigits: 0,
            maximumFractionDigits: 20
          };
        } else {
          config2 = {
            minimumFractionDigits: precision || 0,
            maximumFractionDigits: precision || 0
          };
        }
        return config2;
      },
      format: function(value2, _format) {
        if ("number" !== typeof value2) {
          return value2;
        }
        _format = this._normalizeFormat(_format);
        if ("default" === _format.currency) {
          _format.currency = config_default().defaultCurrency;
        }
        if (!_format || "function" !== typeof _format && !_format.type && !_format.formatter) {
          return getFormatter2(_format)(value2);
        }
        return this.callBase.apply(this, arguments);
      },
      _getCurrencySymbolInfo: function(currency) {
        var formatter = getCurrencyFormatter(currency);
        return this._extractCurrencySymbolInfo(formatter.format(0));
      },
      _extractCurrencySymbolInfo: function(currencyValueString) {
        var match2 = detectCurrencySymbolRegex.exec(currencyValueString) || [];
        var position3 = match2[1] ? "before" : "after";
        var symbol = match2[1] || match2[4] || "";
        var delimiter = match2[2] || match2[3] || "";
        return {
          position: position3,
          symbol,
          delimiter
        };
      },
      getCurrencySymbol: function(currency) {
        if (!currency) {
          currency = config_default().defaultCurrency;
        }
        var symbolInfo = this._getCurrencySymbolInfo(currency);
        return {
          symbol: symbolInfo.symbol
        };
      },
      getOpenXmlCurrencyFormat: function(currency) {
        var targetCurrency = currency || config_default().defaultCurrency;
        var currencySymbol = this._getCurrencySymbolInfo(targetCurrency).symbol;
        var closestAccountingFormat = core_default.getValueByClosestLocale((locale) => accounting_formats_default[locale]);
        return open_xml_currency_format_default(currencySymbol, closestAccountingFormat);
      }
    };
  }
});

// node_modules/devextreme/esm/localization/number.js
var hasIntl, MAX_LARGE_NUMBER_POWER, DECIMAL_BASE2, NUMERIC_FORMATS, LargeNumberFormatPostfixes, LargeNumberFormatPowers, numberLocalization, number_default2;
var init_number3 = __esm({
  "node_modules/devextreme/esm/localization/number.js"() {
    init_dependency_injector();
    init_array();
    init_common();
    init_iterator();
    init_type();
    init_number();
    init_config();
    init_errors();
    init_utils4();
    init_currency();
    init_number2();
    hasIntl = "undefined" !== typeof Intl;
    MAX_LARGE_NUMBER_POWER = 4;
    DECIMAL_BASE2 = 10;
    NUMERIC_FORMATS = ["currency", "fixedpoint", "exponential", "percent", "decimal"];
    LargeNumberFormatPostfixes = {
      1: "K",
      2: "M",
      3: "B",
      4: "T"
    };
    LargeNumberFormatPowers = {
      largenumber: "auto",
      thousands: 1,
      millions: 2,
      billions: 3,
      trillions: 4
    };
    numberLocalization = dependency_injector_default({
      engine: function() {
        return "base";
      },
      numericFormats: NUMERIC_FORMATS,
      defaultLargeNumberFormatPostfixes: LargeNumberFormatPostfixes,
      _parseNumberFormatString: function(formatType) {
        var formatObject = {};
        if (!formatType || "string" !== typeof formatType) {
          return;
        }
        var formatList = formatType.toLowerCase().split(" ");
        each(formatList, (index2, value2) => {
          if (inArray(value2, NUMERIC_FORMATS) > -1) {
            formatObject.formatType = value2;
          } else if (value2 in LargeNumberFormatPowers) {
            formatObject.power = LargeNumberFormatPowers[value2];
          }
        });
        if (formatObject.power && !formatObject.formatType) {
          formatObject.formatType = "fixedpoint";
        }
        if (formatObject.formatType) {
          return formatObject;
        }
      },
      _calculateNumberPower: function(value2, base2, minPower, maxPower) {
        var number2 = Math.abs(value2);
        var power = 0;
        if (number2 > 1) {
          while (number2 && number2 >= base2 && (void 0 === maxPower || power < maxPower)) {
            power++;
            number2 /= base2;
          }
        } else if (number2 > 0 && number2 < 1) {
          while (number2 < 1 && (void 0 === minPower || power > minPower)) {
            power--;
            number2 *= base2;
          }
        }
        return power;
      },
      _getNumberByPower: function(number2, power, base2) {
        var result2 = number2;
        while (power > 0) {
          result2 /= base2;
          power--;
        }
        while (power < 0) {
          result2 *= base2;
          power++;
        }
        return result2;
      },
      _formatNumber: function(value2, formatObject, formatConfig) {
        if ("auto" === formatObject.power) {
          formatObject.power = this._calculateNumberPower(value2, 1e3, 0, MAX_LARGE_NUMBER_POWER);
        }
        if (formatObject.power) {
          value2 = this._getNumberByPower(value2, formatObject.power, 1e3);
        }
        var powerPostfix = this.defaultLargeNumberFormatPostfixes[formatObject.power] || "";
        var result2 = this._formatNumberCore(value2, formatObject.formatType, formatConfig);
        result2 = result2.replace(/(\d|.$)(\D*)$/, "$1" + powerPostfix + "$2");
        return result2;
      },
      _formatNumberExponential: function(value2, formatConfig) {
        var power = this._calculateNumberPower(value2, DECIMAL_BASE2);
        var number2 = this._getNumberByPower(value2, power, DECIMAL_BASE2);
        if (void 0 === formatConfig.precision) {
          formatConfig.precision = 1;
        }
        if (number2.toFixed(formatConfig.precision || 0) >= DECIMAL_BASE2) {
          power++;
          number2 /= DECIMAL_BASE2;
        }
        var powString = (power >= 0 ? "+" : "") + power.toString();
        return this._formatNumberCore(number2, "fixedpoint", formatConfig) + "E" + powString;
      },
      _addZeroes: function(value2, precision) {
        var multiplier = Math.pow(10, precision);
        var sign2 = value2 < 0 ? "-" : "";
        value2 = (Math.abs(value2) * multiplier >>> 0) / multiplier;
        var result2 = value2.toString();
        while (result2.length < precision) {
          result2 = "0" + result2;
        }
        return sign2 + result2;
      },
      _addGroupSeparators: function(value2) {
        var parts = value2.toString().split(".");
        return parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, config_default().thousandsSeparator) + (parts[1] ? config_default().decimalSeparator + parts[1] : "");
      },
      _formatNumberCore: function(value2, format2, formatConfig) {
        if ("exponential" === format2) {
          return this._formatNumberExponential(value2, formatConfig);
        }
        if ("decimal" !== format2 && null !== formatConfig.precision) {
          formatConfig.precision = formatConfig.precision || 0;
        }
        if ("percent" === format2) {
          value2 *= 100;
        }
        if (void 0 !== formatConfig.precision) {
          if ("decimal" === format2) {
            value2 = this._addZeroes(value2, formatConfig.precision);
          } else {
            value2 = null === formatConfig.precision ? value2.toPrecision() : toFixed(value2, formatConfig.precision);
          }
        }
        if ("decimal" !== format2) {
          value2 = this._addGroupSeparators(value2);
        } else {
          value2 = value2.toString().replace(".", config_default().decimalSeparator);
        }
        if ("percent" === format2) {
          value2 += "%";
        }
        return value2;
      },
      _normalizeFormat: function(format2) {
        if (!format2) {
          return {};
        }
        if ("function" === typeof format2) {
          return format2;
        }
        if (!isPlainObject(format2)) {
          format2 = {
            type: format2
          };
        }
        return format2;
      },
      _getSeparators: function() {
        return {
          decimalSeparator: this.getDecimalSeparator(),
          thousandsSeparator: this.getThousandsSeparator()
        };
      },
      getThousandsSeparator: function() {
        return this.format(1e4, "fixedPoint")[2];
      },
      getDecimalSeparator: function() {
        return this.format(1.2, {
          type: "fixedPoint",
          precision: 1
        })[1];
      },
      convertDigits: function(value2, toStandard) {
        var digits = this.format(90, "decimal");
        if ("string" !== typeof value2 || "0" === digits[1]) {
          return value2;
        }
        var fromFirstDigit = toStandard ? digits[1] : "0";
        var toFirstDigit = toStandard ? "0" : digits[1];
        var fromLastDigit = toStandard ? digits[0] : "9";
        var regExp2 = new RegExp("[" + fromFirstDigit + "-" + fromLastDigit + "]", "g");
        return value2.replace(regExp2, (char) => String.fromCharCode(char.charCodeAt(0) + (toFirstDigit.charCodeAt(0) - fromFirstDigit.charCodeAt(0))));
      },
      getNegativeEtalonRegExp: function(format2) {
        var separators = this._getSeparators();
        var digitalRegExp = new RegExp("[0-9" + escapeRegExp(separators.decimalSeparator + separators.thousandsSeparator) + "]+", "g");
        var negativeEtalon = this.format(-1, format2).replace(digitalRegExp, "1");
        ["\\", "(", ")", "[", "]", "*", "+", "$", "^", "?", "|", "{", "}"].forEach((char) => {
          negativeEtalon = negativeEtalon.replace(new RegExp("\\" + char, "g"), "\\".concat(char));
        });
        negativeEtalon = negativeEtalon.replace(/ /g, "\\s");
        negativeEtalon = negativeEtalon.replace(/1/g, ".+");
        return new RegExp(negativeEtalon, "g");
      },
      getSign: function(text, format2) {
        if (!format2) {
          if ("-" === text.replace(/[^0-9-]/g, "").charAt(0)) {
            return -1;
          }
          return 1;
        }
        var negativeEtalon = this.getNegativeEtalonRegExp(format2);
        return text.match(negativeEtalon) ? -1 : 1;
      },
      format: function(value2, _format) {
        if ("number" !== typeof value2) {
          return value2;
        }
        if ("number" === typeof _format) {
          return value2;
        }
        _format = _format && _format.formatter || _format;
        if ("function" === typeof _format) {
          return _format(value2);
        }
        _format = this._normalizeFormat(_format);
        if (!_format.type) {
          _format.type = "decimal";
        }
        var numberConfig = this._parseNumberFormatString(_format.type);
        if (!numberConfig) {
          var formatterConfig = this._getSeparators();
          formatterConfig.unlimitedIntegerDigits = _format.unlimitedIntegerDigits;
          return this.convertDigits(getFormatter(_format.type, formatterConfig)(value2));
        }
        return this._formatNumber(value2, numberConfig, _format);
      },
      parse: function(text, format2) {
        if (!text) {
          return;
        }
        if (format2 && format2.parser) {
          return format2.parser(text);
        }
        text = this.convertDigits(text, true);
        if (format2 && "string" !== typeof format2) {
          errors_default.log("W0011");
        }
        var decimalSeparator = this.getDecimalSeparator();
        var regExp2 = new RegExp("[^0-9" + escapeRegExp(decimalSeparator) + "]", "g");
        var cleanedText = text.replace(regExp2, "").replace(decimalSeparator, ".").replace(/\.$/g, "");
        if ("." === cleanedText || "" === cleanedText) {
          return null;
        }
        if (this._calcSignificantDigits(cleanedText) > 15) {
          return NaN;
        }
        var parsed = +cleanedText * this.getSign(text, format2);
        format2 = this._normalizeFormat(format2);
        var formatConfig = this._parseNumberFormatString(format2.type);
        var power = null === formatConfig || void 0 === formatConfig ? void 0 : formatConfig.power;
        if (power) {
          if ("auto" === power) {
            var match2 = text.match(/\d(K|M|B|T)/);
            if (match2) {
              power = find(Object.keys(LargeNumberFormatPostfixes), (power2) => LargeNumberFormatPostfixes[power2] === match2[1]);
            }
          }
          parsed *= Math.pow(10, 3 * power);
        }
        if ("percent" === (null === formatConfig || void 0 === formatConfig ? void 0 : formatConfig.formatType)) {
          parsed /= 100;
        }
        return parsed;
      },
      _calcSignificantDigits: function(text) {
        var [integer, fractional] = text.split(".");
        var calcDigitsAfterLeadingZeros = (digits) => {
          var index2 = -1;
          for (var i = 0; i < digits.length; i++) {
            if ("0" !== digits[i]) {
              index2 = i;
              break;
            }
          }
          return index2 > -1 ? digits.length - index2 : 0;
        };
        var result2 = 0;
        if (integer) {
          result2 += calcDigitsAfterLeadingZeros(integer.split(""));
        }
        if (fractional) {
          result2 += calcDigitsAfterLeadingZeros(fractional.split("").reverse());
        }
        return result2;
      }
    });
    numberLocalization.inject(currency_default);
    if (hasIntl) {
      numberLocalization.inject(number_default);
    }
    number_default2 = numberLocalization;
  }
});

// node_modules/devextreme/esm/localization/ldml/date.formatter.js
function leftPad(text, length) {
  while (text.length < length) {
    text = "0" + text;
  }
  return text;
}
var FORMAT_TYPES, LDML_FORMATTERS, getFormatter3;
var init_date_formatter = __esm({
  "node_modules/devextreme/esm/localization/ldml/date.formatter.js"() {
    FORMAT_TYPES = {
      3: "abbreviated",
      4: "wide",
      5: "narrow"
    };
    LDML_FORMATTERS = {
      y: function(date, count, useUtc) {
        var year = date[useUtc ? "getUTCFullYear" : "getFullYear"]();
        if (2 === count) {
          year %= 100;
        }
        return leftPad(year.toString(), count);
      },
      M: function(date, count, useUtc, dateParts) {
        var month = date[useUtc ? "getUTCMonth" : "getMonth"]();
        var formatType = FORMAT_TYPES[count];
        if (formatType) {
          return dateParts.getMonthNames(formatType, "format")[month];
        }
        return leftPad((month + 1).toString(), Math.min(count, 2));
      },
      L: function(date, count, useUtc, dateParts) {
        var month = date[useUtc ? "getUTCMonth" : "getMonth"]();
        var formatType = FORMAT_TYPES[count];
        if (formatType) {
          return dateParts.getMonthNames(formatType, "standalone")[month];
        }
        return leftPad((month + 1).toString(), Math.min(count, 2));
      },
      Q: function(date, count, useUtc, dateParts) {
        var month = date[useUtc ? "getUTCMonth" : "getMonth"]();
        var quarter = Math.floor(month / 3);
        var formatType = FORMAT_TYPES[count];
        if (formatType) {
          return dateParts.getQuarterNames(formatType)[quarter];
        }
        return leftPad((quarter + 1).toString(), Math.min(count, 2));
      },
      E: function(date, count, useUtc, dateParts) {
        var day = date[useUtc ? "getUTCDay" : "getDay"]();
        var formatType = FORMAT_TYPES[count < 3 ? 3 : count];
        return dateParts.getDayNames(formatType)[day];
      },
      a: function(date, count, useUtc, dateParts) {
        var hours = date[useUtc ? "getUTCHours" : "getHours"]();
        var period = hours < 12 ? 0 : 1;
        var formatType = FORMAT_TYPES[count];
        return dateParts.getPeriodNames(formatType)[period];
      },
      d: function(date, count, useUtc) {
        return leftPad(date[useUtc ? "getUTCDate" : "getDate"]().toString(), Math.min(count, 2));
      },
      H: function(date, count, useUtc) {
        return leftPad(date[useUtc ? "getUTCHours" : "getHours"]().toString(), Math.min(count, 2));
      },
      h: function(date, count, useUtc) {
        var hours = date[useUtc ? "getUTCHours" : "getHours"]();
        return leftPad((hours % 12 || 12).toString(), Math.min(count, 2));
      },
      m: function(date, count, useUtc) {
        return leftPad(date[useUtc ? "getUTCMinutes" : "getMinutes"]().toString(), Math.min(count, 2));
      },
      s: function(date, count, useUtc) {
        return leftPad(date[useUtc ? "getUTCSeconds" : "getSeconds"]().toString(), Math.min(count, 2));
      },
      S: function(date, count, useUtc) {
        return leftPad(date[useUtc ? "getUTCMilliseconds" : "getMilliseconds"]().toString(), 3).substr(0, count);
      },
      x: function(date, count, useUtc) {
        var timezoneOffset = useUtc ? 0 : date.getTimezoneOffset();
        var signPart = timezoneOffset > 0 ? "-" : "+";
        var timezoneOffsetAbs = Math.abs(timezoneOffset);
        var hours = Math.floor(timezoneOffsetAbs / 60);
        var minutes = timezoneOffsetAbs % 60;
        var hoursPart = leftPad(hours.toString(), 2);
        var minutesPart = leftPad(minutes.toString(), 2);
        return signPart + hoursPart + (count >= 3 ? ":" : "") + (count > 1 || minutes ? minutesPart : "");
      },
      X: function(date, count, useUtc) {
        if (useUtc || !date.getTimezoneOffset()) {
          return "Z";
        }
        return LDML_FORMATTERS.x(date, count, useUtc);
      },
      Z: function(date, count, useUtc) {
        return LDML_FORMATTERS.X(date, count >= 5 ? 3 : 2, useUtc);
      }
    };
    getFormatter3 = function(format2, dateParts) {
      return function(date) {
        var charIndex;
        var formatter;
        var char;
        var charCount = 0;
        var isEscaping = false;
        var isCurrentCharEqualsNext;
        var result2 = "";
        if (!date) {
          return null;
        }
        if (!format2) {
          return date;
        }
        var useUtc = "Z" === format2[format2.length - 1] || "'Z'" === format2.slice(-3);
        for (charIndex = 0; charIndex < format2.length; charIndex++) {
          char = format2[charIndex];
          formatter = LDML_FORMATTERS[char];
          isCurrentCharEqualsNext = char === format2[charIndex + 1];
          charCount++;
          if (!isCurrentCharEqualsNext) {
            if (formatter && !isEscaping) {
              result2 += formatter(date, charCount, useUtc, dateParts);
            }
            charCount = 0;
          }
          if ("'" === char && !isCurrentCharEqualsNext) {
            isEscaping = !isEscaping;
          } else if (isEscaping || !formatter) {
            result2 += char;
          }
          if ("'" === char && isCurrentCharEqualsNext) {
            charIndex++;
          }
        }
        return result2;
      };
    };
  }
});

// node_modules/devextreme/esm/localization/ldml/date.format.js
var ARABIC_COMMA, FORMAT_SEPARATORS, AM_PM_PATTERN, checkDigit, checkPatternContinue, getPatternStartIndex, getDifference, replaceCharsCore, replaceChars, formatValue, ESCAPE_CHARS_REGEXP, escapeChars, getFormat2;
var init_date_format = __esm({
  "node_modules/devextreme/esm/localization/ldml/date.format.js"() {
    init_number3();
    ARABIC_COMMA = "";
    FORMAT_SEPARATORS = " .,:;/\\<>()-[]" + ARABIC_COMMA;
    AM_PM_PATTERN = ". m.";
    checkDigit = function(char) {
      var code = char && number_default2.convertDigits(char, false).charCodeAt(0);
      var zeroCode = number_default2.convertDigits("0", false).charCodeAt(0);
      return zeroCode <= code && code < zeroCode + 10;
    };
    checkPatternContinue = function(text, patterns, index2, isDigit) {
      var char = text[index2];
      var nextChar = text[index2 + 1];
      if (!isDigit) {
        if ("." === char || " " === char && text.slice(index2 - 1, index2 + 3) === AM_PM_PATTERN) {
          return true;
        }
        if ("-" === char && !checkDigit(nextChar)) {
          return true;
        }
      }
      var isDigitChanged = isDigit && patterns.some((pattern) => text[index2] !== pattern[index2]);
      return FORMAT_SEPARATORS.indexOf(char) < 0 && isDigit === checkDigit(char) && (!isDigit || isDigitChanged);
    };
    getPatternStartIndex = function(defaultPattern, index2) {
      if (!checkDigit(defaultPattern[index2])) {
        while (index2 > 0 && !checkDigit(defaultPattern[index2 - 1]) && ("." === defaultPattern[index2 - 1] || FORMAT_SEPARATORS.indexOf(defaultPattern[index2 - 1]) < 0)) {
          index2--;
        }
      }
      return index2;
    };
    getDifference = function(defaultPattern, patterns, processedIndexes, isDigit) {
      var i = 0;
      var result2 = [];
      var patternsFilter = function(pattern) {
        return defaultPattern[i] !== pattern[i] && (void 0 === isDigit || checkDigit(defaultPattern[i]) === isDigit);
      };
      if (!Array.isArray(patterns)) {
        patterns = [patterns];
      }
      for (i = 0; i < defaultPattern.length; i++) {
        if (processedIndexes.indexOf(i) < 0 && patterns.filter(patternsFilter).length) {
          i = getPatternStartIndex(defaultPattern, i);
          do {
            isDigit = checkDigit(defaultPattern[i]);
            if (!result2.length && !isDigit && checkDigit(patterns[0][i])) {
              break;
            }
            result2.push(i);
            processedIndexes.unshift(i);
            i++;
          } while (defaultPattern[i] && checkPatternContinue(defaultPattern, patterns, i, isDigit));
          break;
        }
      }
      if (1 === result2.length && ("0" === defaultPattern[processedIndexes[0] - 1] || "" === defaultPattern[processedIndexes[0] - 1])) {
        processedIndexes.unshift(processedIndexes[0] - 1);
      }
      return result2;
    };
    replaceCharsCore = function(pattern, indexes, char, patternPositions) {
      var baseCharIndex = indexes[0];
      var patternIndex = baseCharIndex < patternPositions.length ? patternPositions[baseCharIndex] : baseCharIndex;
      indexes.forEach(function(_2, index2) {
        pattern = pattern.substr(0, patternIndex + index2) + (char.length > 1 ? char[index2] : char) + pattern.substr(patternIndex + index2 + 1);
      });
      if (1 === indexes.length) {
        pattern = pattern.replace("0" + char, char + char);
        pattern = pattern.replace("" + char, char + char);
      }
      return pattern;
    };
    replaceChars = function(pattern, indexes, char, patternPositions) {
      var i;
      var index2;
      var patternIndex;
      if (!checkDigit(pattern[indexes[0]] || "0")) {
        var letterCount = Math.max(indexes.length <= 3 ? 3 : 4, char.length);
        while (indexes.length > letterCount) {
          index2 = indexes.pop();
          patternIndex = patternPositions[index2];
          patternPositions[index2] = -1;
          for (i = index2 + 1; i < patternPositions.length; i++) {
            patternPositions[i]--;
          }
          pattern = pattern.substr(0, patternIndex) + pattern.substr(patternIndex + 1);
        }
        index2 = indexes[indexes.length - 1] + 1, patternIndex = index2 < patternPositions.length ? patternPositions[index2] : index2;
        while (indexes.length < letterCount) {
          indexes.push(indexes[indexes.length - 1] + 1);
          for (i = index2; i < patternPositions.length; i++) {
            patternPositions[i]++;
          }
          pattern = pattern.substr(0, patternIndex) + " " + pattern.substr(patternIndex);
        }
      }
      pattern = replaceCharsCore(pattern, indexes, char, patternPositions);
      return pattern;
    };
    formatValue = function(value2, formatter) {
      if (Array.isArray(value2)) {
        return value2.map(function(value3) {
          return (formatter(value3) || "").toString();
        });
      }
      return (formatter(value2) || "").toString();
    };
    ESCAPE_CHARS_REGEXP = /[a-zA-Z]/g;
    escapeChars = function(pattern, defaultPattern, processedIndexes, patternPositions) {
      var escapeIndexes = defaultPattern.split("").map(function(char, index2) {
        if (processedIndexes.indexOf(index2) < 0 && (char.match(ESCAPE_CHARS_REGEXP) || "'" === char)) {
          return patternPositions[index2];
        }
        return -1;
      });
      pattern = pattern.split("").map(function(char, index2) {
        var result2 = char;
        var isCurrentCharEscaped = escapeIndexes.indexOf(index2) >= 0;
        var isPrevCharEscaped = index2 > 0 && escapeIndexes.indexOf(index2 - 1) >= 0;
        var isNextCharEscaped = escapeIndexes.indexOf(index2 + 1) >= 0;
        if (isCurrentCharEscaped) {
          if (!isPrevCharEscaped) {
            result2 = "'" + result2;
          }
          if (!isNextCharEscaped) {
            result2 += "'";
          }
        }
        return result2;
      }).join("");
      return pattern;
    };
    getFormat2 = function(formatter) {
      var processedIndexes = [];
      var defaultPattern = formatValue(new Date(2009, 8, 8, 6, 5, 4), formatter);
      var patternPositions = defaultPattern.split("").map(function(_2, index2) {
        return index2;
      });
      var result2 = defaultPattern;
      var replacedPatterns = {};
      var datePatterns = [{
        date: new Date(2009, 8, 8, 6, 5, 4, 111),
        pattern: "S"
      }, {
        date: new Date(2009, 8, 8, 6, 5, 2),
        pattern: "s"
      }, {
        date: new Date(2009, 8, 8, 6, 2, 4),
        pattern: "m"
      }, {
        date: new Date(2009, 8, 8, 18, 5, 4),
        pattern: "H",
        isDigit: true
      }, {
        date: new Date(2009, 8, 8, 2, 5, 4),
        pattern: "h",
        isDigit: true
      }, {
        date: new Date(2009, 8, 8, 18, 5, 4),
        pattern: "a",
        isDigit: false
      }, {
        date: new Date(2009, 8, 1, 6, 5, 4),
        pattern: "d"
      }, {
        date: [new Date(2009, 8, 2, 6, 5, 4), new Date(2009, 8, 3, 6, 5, 4), new Date(2009, 8, 4, 6, 5, 4)],
        pattern: "E"
      }, {
        date: new Date(2009, 9, 6, 6, 5, 4),
        pattern: "M"
      }, {
        date: new Date(1998, 8, 8, 6, 5, 4),
        pattern: "y"
      }];
      if (!result2) {
        return;
      }
      datePatterns.forEach(function(test) {
        var diff = getDifference(defaultPattern, formatValue(test.date, formatter), processedIndexes, test.isDigit);
        var pattern = "M" === test.pattern && !replacedPatterns.d ? "L" : test.pattern;
        result2 = replaceChars(result2, diff, pattern, patternPositions);
        replacedPatterns[pattern] = diff.length;
      });
      result2 = escapeChars(result2, defaultPattern, processedIndexes, patternPositions);
      if (processedIndexes.length) {
        return result2;
      }
    };
  }
});

// node_modules/devextreme/esm/localization/ldml/date.parser.js
var FORMAT_TYPES2, monthRegExpGenerator, PATTERN_REGEXPS, parseNumber, caseInsensitiveIndexOf, monthPatternParser, PATTERN_PARSERS, ORDERED_PATTERNS, PATTERN_SETTERS, getSameCharCount, createPattern, getRegExpInfo, digitFieldSymbols, isPossibleForParsingFormat, getPatternSetters, setPatternPart, setPatternPartFromNow, getShortPatterns, getMaxOrderedPatternIndex, getOrderedFormatPatterns, getParser;
var init_date_parser = __esm({
  "node_modules/devextreme/esm/localization/ldml/date.parser.js"() {
    init_common();
    init_console();
    FORMAT_TYPES2 = {
      3: "abbreviated",
      4: "wide",
      5: "narrow"
    };
    monthRegExpGenerator = function(count, dateParts) {
      if (count > 2) {
        return Object.keys(FORMAT_TYPES2).map(function(count2) {
          return ["format", "standalone"].map(function(type2) {
            return dateParts.getMonthNames(FORMAT_TYPES2[count2], type2).join("|");
          }).join("|");
        }).join("|");
      }
      return 2 === count ? "1[012]|0?[1-9]" : "0??[1-9]|1[012]";
    };
    PATTERN_REGEXPS = {
      ":": function(count, dateParts) {
        var countSuffix = count > 1 ? "{".concat(count, "}") : "";
        var timeSeparator = escapeRegExp(dateParts.getTimeSeparator());
        ":" !== timeSeparator && (timeSeparator = "".concat(timeSeparator, "|:"));
        return "".concat(timeSeparator).concat(countSuffix);
      },
      y: function(count) {
        return 2 === count ? "[0-9]{".concat(count, "}") : "[0-9]+?";
      },
      M: monthRegExpGenerator,
      L: monthRegExpGenerator,
      Q: function(count, dateParts) {
        if (count > 2) {
          return dateParts.getQuarterNames(FORMAT_TYPES2[count], "format").join("|");
        }
        return "0?[1-4]";
      },
      E: function(count, dateParts) {
        return "\\D*";
      },
      a: function(count, dateParts) {
        return dateParts.getPeriodNames(FORMAT_TYPES2[count < 3 ? 3 : count], "format").join("|");
      },
      d: function(count) {
        return 2 === count ? "3[01]|[12][0-9]|0?[1-9]" : "0??[1-9]|[12][0-9]|3[01]";
      },
      H: function(count) {
        return 2 === count ? "2[0-3]|1[0-9]|0?[0-9]" : "0??[0-9]|1[0-9]|2[0-3]";
      },
      h: function(count) {
        return 2 === count ? "1[012]|0?[1-9]" : "0??[1-9]|1[012]";
      },
      m: function(count) {
        return 2 === count ? "[1-5][0-9]|0?[0-9]" : "0??[0-9]|[1-5][0-9]";
      },
      s: function(count) {
        return 2 === count ? "[1-5][0-9]|0?[0-9]" : "0??[0-9]|[1-5][0-9]";
      },
      S: function(count) {
        return "[0-9]{1,".concat(count, "}");
      },
      w: function(count) {
        return 2 === count ? "[1-5][0-9]|0?[0-9]" : "0??[0-9]|[1-5][0-9]";
      }
    };
    parseNumber = Number;
    caseInsensitiveIndexOf = function(array, value2) {
      return array.map((item) => item.toLowerCase()).indexOf(value2.toLowerCase());
    };
    monthPatternParser = function(text, count, dateParts) {
      if (count > 2) {
        return ["format", "standalone"].map(function(type2) {
          return Object.keys(FORMAT_TYPES2).map(function(count2) {
            var monthNames = dateParts.getMonthNames(FORMAT_TYPES2[count2], type2);
            return caseInsensitiveIndexOf(monthNames, text);
          });
        }).reduce(function(a, b) {
          return a.concat(b);
        }).filter(function(index2) {
          return index2 >= 0;
        })[0];
      }
      return parseNumber(text) - 1;
    };
    PATTERN_PARSERS = {
      y: function(text, count) {
        var year = parseNumber(text);
        if (2 === count) {
          return year < 30 ? 2e3 + year : 1900 + year;
        }
        return year;
      },
      M: monthPatternParser,
      L: monthPatternParser,
      Q: function(text, count, dateParts) {
        if (count > 2) {
          return dateParts.getQuarterNames(FORMAT_TYPES2[count], "format").indexOf(text);
        }
        return parseNumber(text) - 1;
      },
      E: function(text, count, dateParts) {
        var dayNames = dateParts.getDayNames(FORMAT_TYPES2[count < 3 ? 3 : count], "format");
        return caseInsensitiveIndexOf(dayNames, text);
      },
      a: function(text, count, dateParts) {
        var periodNames = dateParts.getPeriodNames(FORMAT_TYPES2[count < 3 ? 3 : count], "format");
        return caseInsensitiveIndexOf(periodNames, text);
      },
      d: parseNumber,
      H: parseNumber,
      h: parseNumber,
      m: parseNumber,
      s: parseNumber,
      S: function(text, count) {
        count = Math.max(count, 3);
        text = text.slice(0, 3);
        while (count < 3) {
          text += "0";
          count++;
        }
        return parseNumber(text);
      }
    };
    ORDERED_PATTERNS = ["y", "M", "d", "h", "m", "s", "S"];
    PATTERN_SETTERS = {
      y: "setFullYear",
      M: "setMonth",
      L: "setMonth",
      a: function(date, value2, datePartValues) {
        var hours = date.getHours();
        var hourPartValue = datePartValues.h;
        if (void 0 !== hourPartValue && hourPartValue !== hours) {
          hours--;
        }
        if (!value2 && 12 === hours) {
          hours = 0;
        } else if (value2 && 12 !== hours) {
          hours += 12;
        }
        date.setHours(hours);
      },
      d: "setDate",
      H: "setHours",
      h: "setHours",
      m: "setMinutes",
      s: "setSeconds",
      S: "setMilliseconds"
    };
    getSameCharCount = function(text, index2) {
      var char = text[index2];
      if (!char) {
        return 0;
      }
      var count = 0;
      do {
        index2++;
        count++;
      } while (text[index2] === char);
      return count;
    };
    createPattern = function(char, count) {
      var result2 = "";
      for (var i = 0; i < count; i++) {
        result2 += char;
      }
      return result2;
    };
    getRegExpInfo = function(format2, dateParts) {
      var regexpText = "";
      var stubText = "";
      var isEscaping;
      var patterns = [];
      var addPreviousStub = function() {
        if (stubText) {
          patterns.push("'".concat(stubText, "'"));
          regexpText += "".concat(escapeRegExp(stubText), ")");
          stubText = "";
        }
      };
      for (var i = 0; i < format2.length; i++) {
        var char = format2[i];
        var isEscapeChar = "'" === char;
        var regexpPart = PATTERN_REGEXPS[char];
        if (isEscapeChar) {
          isEscaping = !isEscaping;
          if ("'" !== format2[i - 1]) {
            continue;
          }
        }
        if (regexpPart && !isEscaping) {
          var count = getSameCharCount(format2, i);
          var pattern = createPattern(char, count);
          addPreviousStub();
          patterns.push(pattern);
          regexpText += "(".concat(regexpPart(count, dateParts), ")");
          i += count - 1;
        } else {
          if (!stubText) {
            regexpText += "(";
          }
          stubText += char;
        }
      }
      addPreviousStub();
      if (!isPossibleForParsingFormat(patterns)) {
        logger.warn("The following format may be parsed incorrectly: ".concat(format2, "."));
      }
      return {
        patterns,
        regexp: new RegExp("^".concat(regexpText, "$"), "i")
      };
    };
    digitFieldSymbols = ["d", "H", "h", "m", "s", "w", "M", "L", "Q"];
    isPossibleForParsingFormat = function(patterns) {
      var isDigitPattern = (pattern) => {
        if (!pattern) {
          return false;
        }
        var char = pattern[0];
        var yearOrFractionalSecond = "y" === char || "S" === char;
        var digitFieldSymbol = -1 !== digitFieldSymbols.indexOf(char);
        return yearOrFractionalSecond || digitFieldSymbol && pattern.length < 3;
      };
      var possibleForParsing = true;
      var ambiguousDigitPatternsCount = 0;
      return patterns.every((pattern, index2, patterns2) => {
        if (isDigitPattern(pattern)) {
          if (((pattern2) => "S" !== pattern2[0] && 2 !== pattern2.length)(pattern)) {
            possibleForParsing = ++ambiguousDigitPatternsCount < 2;
          }
          if (!isDigitPattern(patterns2[index2 + 1])) {
            ambiguousDigitPatternsCount = 0;
          }
        }
        return possibleForParsing;
      });
    };
    getPatternSetters = function() {
      return PATTERN_SETTERS;
    };
    setPatternPart = function(date, pattern, text, dateParts, datePartValues) {
      var patternChar = pattern[0];
      var partSetter = PATTERN_SETTERS[patternChar];
      var partParser = PATTERN_PARSERS[patternChar];
      if (partSetter && partParser) {
        var value2 = partParser(text, pattern.length, dateParts);
        datePartValues[pattern] = value2;
        if (date[partSetter]) {
          date[partSetter](value2);
        } else {
          partSetter(date, value2, datePartValues);
        }
      }
    };
    setPatternPartFromNow = function(date, pattern, now) {
      var setterName = PATTERN_SETTERS[pattern];
      var getterName = "g" + setterName.substr(1);
      var value2 = now[getterName]();
      date[setterName](value2);
    };
    getShortPatterns = function(fullPatterns) {
      return fullPatterns.map(function(pattern) {
        if ("'" === pattern[0]) {
          return "";
        } else {
          return "H" === pattern[0] ? "h" : pattern[0];
        }
      });
    };
    getMaxOrderedPatternIndex = function(patterns) {
      var indexes = patterns.map(function(pattern) {
        return ORDERED_PATTERNS.indexOf(pattern);
      });
      return Math.max.apply(Math, indexes);
    };
    getOrderedFormatPatterns = function(formatPatterns) {
      var otherPatterns = formatPatterns.filter(function(pattern) {
        return ORDERED_PATTERNS.indexOf(pattern) < 0;
      });
      return ORDERED_PATTERNS.concat(otherPatterns);
    };
    getParser = function(format2, dateParts) {
      var regExpInfo = getRegExpInfo(format2, dateParts);
      return function(text) {
        var regExpResult = regExpInfo.regexp.exec(text);
        if (regExpResult) {
          var now = /* @__PURE__ */ new Date();
          var date = new Date(now.getFullYear(), 0, 1);
          var formatPatterns = getShortPatterns(regExpInfo.patterns);
          var maxPatternIndex = getMaxOrderedPatternIndex(formatPatterns);
          var orderedFormatPatterns = getOrderedFormatPatterns(formatPatterns);
          var datePartValues = {};
          orderedFormatPatterns.forEach(function(pattern, index2) {
            if (!pattern || index2 < ORDERED_PATTERNS.length && index2 > maxPatternIndex) {
              return;
            }
            var patternIndex = formatPatterns.indexOf(pattern);
            if (patternIndex >= 0) {
              var regExpPattern = regExpInfo.patterns[patternIndex];
              var regExpText = regExpResult[patternIndex + 1];
              setPatternPart(date, regExpPattern, regExpText, dateParts, datePartValues);
            } else {
              setPatternPartFromNow(date, pattern, now);
            }
          });
          return date;
        }
        return null;
      };
    };
  }
});

// node_modules/devextreme/esm/localization/default_date_names.js
var MONTHS, DAYS, PERIODS, QUARTERS, cutCaptions, default_date_names_default;
var init_default_date_names = __esm({
  "node_modules/devextreme/esm/localization/default_date_names.js"() {
    init_iterator();
    MONTHS = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
    DAYS = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
    PERIODS = ["AM", "PM"];
    QUARTERS = ["Q1", "Q2", "Q3", "Q4"];
    cutCaptions = (captions, format2) => {
      var lengthByFormat = {
        abbreviated: 3,
        short: 2,
        narrow: 1
      };
      return map(captions, (caption) => caption.substr(0, lengthByFormat[format2]));
    };
    default_date_names_default = {
      getMonthNames: function(format2) {
        return cutCaptions(MONTHS, format2);
      },
      getDayNames: function(format2) {
        return cutCaptions(DAYS, format2);
      },
      getQuarterNames: function(format2) {
        return QUARTERS;
      },
      getPeriodNames: function(format2) {
        return PERIODS;
      }
    };
  }
});

// node_modules/devextreme/esm/localization/cldr-data/first_day_of_week_data.js
var first_day_of_week_data_default;
var init_first_day_of_week_data = __esm({
  "node_modules/devextreme/esm/localization/cldr-data/first_day_of_week_data.js"() {
    first_day_of_week_data_default = {
      "af-NA": 1,
      agq: 1,
      ak: 1,
      ar: 6,
      "ar-EH": 1,
      "ar-ER": 1,
      "ar-KM": 1,
      "ar-LB": 1,
      "ar-MA": 1,
      "ar-MR": 1,
      "ar-PS": 1,
      "ar-SO": 1,
      "ar-SS": 1,
      "ar-TD": 1,
      "ar-TN": 1,
      asa: 1,
      ast: 1,
      az: 1,
      "az-Cyrl": 1,
      bas: 1,
      be: 1,
      bem: 1,
      bez: 1,
      bg: 1,
      bm: 1,
      br: 1,
      bs: 1,
      "bs-Cyrl": 1,
      ca: 1,
      ce: 1,
      cgg: 1,
      ckb: 6,
      cs: 1,
      cy: 1,
      da: 1,
      de: 1,
      dje: 1,
      dsb: 1,
      dua: 1,
      dyo: 1,
      ee: 1,
      el: 1,
      "en-001": 1,
      "en-AE": 6,
      "en-BI": 1,
      "en-MP": 1,
      "en-MV": 5,
      "en-SD": 6,
      eo: 1,
      es: 1,
      et: 1,
      eu: 1,
      ewo: 1,
      fa: 6,
      ff: 1,
      "ff-Adlm": 1,
      fi: 1,
      fo: 1,
      fr: 1,
      "fr-DJ": 6,
      "fr-DZ": 6,
      "fr-SY": 6,
      fur: 1,
      fy: 1,
      ga: 1,
      gd: 1,
      gl: 1,
      gsw: 1,
      gv: 1,
      ha: 1,
      hr: 1,
      hsb: 1,
      hu: 1,
      hy: 1,
      ia: 1,
      ig: 1,
      is: 1,
      it: 1,
      jgo: 1,
      jmc: 1,
      ka: 1,
      kab: 6,
      kde: 1,
      kea: 1,
      khq: 1,
      kk: 1,
      kkj: 1,
      kl: 1,
      "ko-KP": 1,
      ksb: 1,
      ksf: 1,
      ksh: 1,
      ku: 1,
      kw: 1,
      ky: 1,
      lag: 1,
      lb: 1,
      lg: 1,
      ln: 1,
      lrc: 6,
      lt: 1,
      lu: 1,
      lv: 1,
      "mas-TZ": 1,
      mfe: 1,
      mg: 1,
      mgo: 1,
      mi: 1,
      mk: 1,
      mn: 1,
      ms: 1,
      mua: 1,
      mzn: 6,
      naq: 1,
      nds: 1,
      nl: 1,
      nmg: 1,
      nnh: 1,
      no: 1,
      nus: 1,
      nyn: 1,
      os: 1,
      pcm: 1,
      pl: 1,
      ps: 6,
      "pt-AO": 1,
      "pt-CH": 1,
      "pt-CV": 1,
      "pt-GQ": 1,
      "pt-GW": 1,
      "pt-LU": 1,
      "pt-ST": 1,
      "pt-TL": 1,
      "qu-BO": 1,
      "qu-EC": 1,
      rm: 1,
      rn: 1,
      ro: 1,
      rof: 1,
      ru: 1,
      rw: 1,
      rwk: 1,
      sah: 1,
      sbp: 1,
      sc: 1,
      se: 1,
      ses: 1,
      sg: 1,
      shi: 1,
      "shi-Latn": 1,
      si: 1,
      sk: 1,
      sl: 1,
      smn: 1,
      so: 1,
      "so-DJ": 6,
      sq: 1,
      sr: 1,
      "sr-Latn": 1,
      sv: 1,
      sw: 1,
      "ta-LK": 1,
      "ta-MY": 1,
      teo: 1,
      tg: 1,
      "ti-ER": 1,
      tk: 1,
      to: 1,
      tr: 1,
      tt: 1,
      twq: 1,
      tzm: 1,
      uk: 1,
      uz: 1,
      "uz-Arab": 6,
      "uz-Cyrl": 1,
      vai: 1,
      "vai-Latn": 1,
      vi: 1,
      vun: 1,
      wae: 1,
      wo: 1,
      xog: 1,
      yav: 1,
      yi: 1,
      yo: 1,
      zgh: 1
    };
  }
});

// node_modules/devextreme/esm/localization/intl/date.js
function formatDateTime(date, format2) {
  return getFormatter4(format2)(date).replace(SYMBOLS_TO_REMOVE_REGEX, "").replace(NARROW_NO_BREAK_SPACE_REGEX, " ");
}
var SYMBOLS_TO_REMOVE_REGEX, NARROW_NO_BREAK_SPACE_REGEX, getIntlFormatter, formattersCache2, getFormatter4, formatNumber, getAlternativeNumeralsMap, normalizeNumerals, removeLeadingZeroes, dateStringEquals, normalizeMonth, intlFormats, getIntlFormat, monthNameStrategies, date_default2;
var init_date2 = __esm({
  "node_modules/devextreme/esm/localization/intl/date.js"() {
    init_extend();
    init_core();
    SYMBOLS_TO_REMOVE_REGEX = /[\u200E\u200F]/g;
    NARROW_NO_BREAK_SPACE_REGEX = /[\u202F]/g;
    getIntlFormatter = (format2) => (date) => {
      if (!format2.timeZoneName) {
        var year = date.getFullYear();
        var recognizableAsTwentyCentury = String(year).length < 3;
        var temporaryYearValue = recognizableAsTwentyCentury ? year + 400 : year;
        var utcDate = new Date(Date.UTC(temporaryYearValue, date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds()));
        if (recognizableAsTwentyCentury) {
          utcDate.setFullYear(year);
        }
        var utcFormat = extend2({
          timeZone: "UTC"
        }, format2);
        return formatDateTime(utcDate, utcFormat);
      }
      return formatDateTime(date, format2);
    };
    formattersCache2 = {};
    getFormatter4 = (format2) => {
      var key = core_default.locale() + "/" + JSON.stringify(format2);
      if (!formattersCache2[key]) {
        formattersCache2[key] = new Intl.DateTimeFormat(core_default.locale(), format2).format;
      }
      return formattersCache2[key];
    };
    formatNumber = (number2) => new Intl.NumberFormat(core_default.locale()).format(number2);
    getAlternativeNumeralsMap = /* @__PURE__ */ (() => {
      var numeralsMapCache = {};
      return (locale) => {
        if (!(locale in numeralsMapCache)) {
          if ("0" === formatNumber(0)) {
            numeralsMapCache[locale] = false;
            return false;
          }
          numeralsMapCache[locale] = {};
          for (var i = 0; i < 10; ++i) {
            numeralsMapCache[locale][formatNumber(i)] = i;
          }
        }
        return numeralsMapCache[locale];
      };
    })();
    normalizeNumerals = (dateString) => {
      var alternativeNumeralsMap = getAlternativeNumeralsMap(core_default.locale());
      if (!alternativeNumeralsMap) {
        return dateString;
      }
      return dateString.split("").map((sign2) => sign2 in alternativeNumeralsMap ? String(alternativeNumeralsMap[sign2]) : sign2).join("");
    };
    removeLeadingZeroes = (str) => str.replace(/(\D)0+(\d)/g, "$1$2");
    dateStringEquals = (actual, expected) => removeLeadingZeroes(actual) === removeLeadingZeroes(expected);
    normalizeMonth = (text) => text.replace("d", "de ");
    intlFormats = {
      day: {
        day: "numeric"
      },
      dayofweek: {
        weekday: "long"
      },
      longdate: {
        weekday: "long",
        year: "numeric",
        month: "long",
        day: "numeric"
      },
      longdatelongtime: {
        weekday: "long",
        year: "numeric",
        month: "long",
        day: "numeric",
        hour: "numeric",
        minute: "numeric",
        second: "numeric"
      },
      longtime: {
        hour: "numeric",
        minute: "numeric",
        second: "numeric"
      },
      month: {
        month: "long"
      },
      monthandday: {
        month: "long",
        day: "numeric"
      },
      monthandyear: {
        year: "numeric",
        month: "long"
      },
      shortdate: {},
      shorttime: {
        hour: "numeric",
        minute: "numeric"
      },
      shortyear: {
        year: "2-digit"
      },
      year: {
        year: "numeric"
      }
    };
    Object.defineProperty(intlFormats, "shortdateshorttime", {
      get: function() {
        var defaultOptions = Intl.DateTimeFormat(core_default.locale()).resolvedOptions();
        return {
          year: defaultOptions.year,
          month: defaultOptions.month,
          day: defaultOptions.day,
          hour: "numeric",
          minute: "numeric"
        };
      }
    });
    getIntlFormat = (format2) => "string" === typeof format2 && intlFormats[format2.toLowerCase()];
    monthNameStrategies = {
      standalone: function(monthIndex, monthFormat) {
        var date = new Date(1999, monthIndex, 13, 1);
        var dateString = getIntlFormatter({
          month: monthFormat
        })(date);
        return dateString;
      },
      format: function(monthIndex, monthFormat) {
        var date = new Date(0, monthIndex, 13, 1);
        var dateString = normalizeMonth(getIntlFormatter({
          day: "numeric",
          month: monthFormat
        })(date));
        var parts = dateString.split(" ").filter((part) => part.indexOf("13") < 0);
        if (1 === parts.length) {
          return parts[0];
        } else if (2 === parts.length) {
          return parts[0].length > parts[1].length ? parts[0] : parts[1];
        }
        return monthNameStrategies.standalone(monthIndex, monthFormat);
      }
    };
    date_default2 = {
      engine: function() {
        return "intl";
      },
      getMonthNames: function(format2, type2) {
        var monthFormat = {
          wide: "long",
          abbreviated: "short",
          narrow: "narrow"
        }[format2 || "wide"];
        type2 = "format" === type2 ? type2 : "standalone";
        return Array.apply(null, new Array(12)).map((_2, monthIndex) => monthNameStrategies[type2](monthIndex, monthFormat));
      },
      getDayNames: function(format2) {
        var result2 = ((format3) => Array.apply(null, new Array(7)).map((_2, dayIndex) => getIntlFormatter({
          weekday: format3
        })(new Date(0, 0, dayIndex))))({
          wide: "long",
          abbreviated: "short",
          short: "narrow",
          narrow: "narrow"
        }[format2 || "wide"]);
        return result2;
      },
      getPeriodNames: function() {
        var hour12Formatter = getIntlFormatter({
          hour: "numeric",
          hour12: true
        });
        return [1, 13].map((hours) => {
          var hourNumberText = formatNumber(1);
          var timeParts = hour12Formatter(new Date(0, 0, 1, hours)).split(hourNumberText);
          if (2 !== timeParts.length) {
            return "";
          }
          var biggerPart = timeParts[0].length > timeParts[1].length ? timeParts[0] : timeParts[1];
          return biggerPart.trim();
        });
      },
      format: function(date, _format) {
        if (!date) {
          return;
        }
        if (!_format) {
          return date;
        }
        if ("function" !== typeof _format && !_format.formatter) {
          _format = _format.type || _format;
        }
        var intlFormat = getIntlFormat(_format);
        if (intlFormat) {
          return getIntlFormatter(intlFormat)(date);
        }
        var formatType = typeof _format;
        if (_format.formatter || "function" === formatType || "string" === formatType) {
          return this.callBase.apply(this, arguments);
        }
        return getIntlFormatter(_format)(date);
      },
      parse: function(dateString, format2) {
        var formatter;
        if (format2 && !format2.parser && "string" === typeof dateString) {
          dateString = normalizeMonth(dateString);
          formatter = (date) => normalizeMonth(this.format(date, format2));
        }
        return this.callBase(dateString, formatter || format2);
      },
      _parseDateBySimpleFormat: function(dateString, format2) {
        dateString = normalizeNumerals(dateString);
        var formatParts = this.getFormatParts(format2);
        var dateParts = dateString.split(/\D+/).filter((part) => part.length > 0);
        if (formatParts.length !== dateParts.length) {
          return;
        }
        var dateArgs = this._generateDateArgs(formatParts, dateParts);
        var constructValidDate = (ampmShift) => {
          var parsedDate = ((dateArgs2, ampmShift2) => {
            var hoursShift = ampmShift2 ? 12 : 0;
            return new Date(dateArgs2.year, dateArgs2.month, dateArgs2.day, (dateArgs2.hours + hoursShift) % 24, dateArgs2.minutes, dateArgs2.seconds);
          })(dateArgs, ampmShift);
          if (dateStringEquals(normalizeNumerals(this.format(parsedDate, format2)), dateString)) {
            return parsedDate;
          }
        };
        return constructValidDate(false) || constructValidDate(true);
      },
      _generateDateArgs: function(formatParts, dateParts) {
        var currentDate = /* @__PURE__ */ new Date();
        var dateArgs = {
          year: currentDate.getFullYear(),
          month: currentDate.getMonth(),
          day: currentDate.getDate(),
          hours: 0,
          minutes: 0,
          seconds: 0
        };
        formatParts.forEach((formatPart, index2) => {
          var datePart = dateParts[index2];
          var parsed = parseInt(datePart, 10);
          if ("month" === formatPart) {
            parsed -= 1;
          }
          dateArgs[formatPart] = parsed;
        });
        return dateArgs;
      },
      formatUsesMonthName: function(format2) {
        if ("object" === typeof format2 && !(format2.type || format2.format)) {
          return "long" === format2.month;
        }
        return this.callBase.apply(this, arguments);
      },
      formatUsesDayName: function(format2) {
        if ("object" === typeof format2 && !(format2.type || format2.format)) {
          return "long" === format2.weekday;
        }
        return this.callBase.apply(this, arguments);
      },
      getTimeSeparator: function() {
        return normalizeNumerals(formatDateTime(new Date(2001, 1, 1, 11, 11), {
          hour: "numeric",
          minute: "numeric",
          hour12: false
        })).replace(/\d/g, "");
      },
      getFormatParts: function(format2) {
        if ("string" === typeof format2) {
          return this.callBase(format2);
        }
        var intlFormat = extend2({}, intlFormats[format2.toLowerCase()]);
        var date = new Date(2001, 2, 4, 5, 6, 7);
        var formattedDate = getIntlFormatter(intlFormat)(date);
        formattedDate = normalizeNumerals(formattedDate);
        return [{
          name: "year",
          value: 1
        }, {
          name: "month",
          value: 3
        }, {
          name: "day",
          value: 4
        }, {
          name: "hours",
          value: 5
        }, {
          name: "minutes",
          value: 6
        }, {
          name: "seconds",
          value: 7
        }].map((part) => ({
          name: part.name,
          index: formattedDate.indexOf(part.value)
        })).filter((part) => part.index > -1).sort((a, b) => a.index - b.index).map((part) => part.name);
      }
    };
  }
});

// node_modules/devextreme/esm/localization/date.js
var DEFAULT_DAY_OF_WEEK_INDEX, hasIntl2, FORMATS_TO_PATTERN_MAP, possiblePartPatterns, dateLocalization, date_default3;
var init_date3 = __esm({
  "node_modules/devextreme/esm/localization/date.js"() {
    init_dependency_injector();
    init_type();
    init_iterator();
    init_array();
    init_errors();
    init_date_formatter();
    init_date_format();
    init_date_parser();
    init_default_date_names();
    init_first_day_of_week_data();
    init_core();
    init_number3();
    init_date2();
    DEFAULT_DAY_OF_WEEK_INDEX = 0;
    hasIntl2 = "undefined" !== typeof Intl;
    FORMATS_TO_PATTERN_MAP = {
      shortdate: "M/d/y",
      shorttime: "h:mm a",
      longdate: "EEEE, MMMM d, y",
      longtime: "h:mm:ss a",
      monthandday: "MMMM d",
      monthandyear: "MMMM y",
      quarterandyear: "QQQ y",
      day: "d",
      year: "y",
      shortdateshorttime: "M/d/y, h:mm a",
      longdatelongtime: "EEEE, MMMM d, y, h:mm:ss a",
      month: "LLLL",
      shortyear: "yy",
      dayofweek: "EEEE",
      quarter: "QQQ",
      hour: "HH",
      minute: "mm",
      second: "ss",
      millisecond: "SSS",
      "datetime-local": "yyyy-MM-ddTHH':'mm':'ss"
    };
    possiblePartPatterns = {
      year: ["y", "yy", "yyyy"],
      day: ["d", "dd"],
      month: ["M", "MM", "MMM", "MMMM"],
      hours: ["H", "HH", "h", "hh", "ah"],
      minutes: ["m", "mm"],
      seconds: ["s", "ss"],
      milliseconds: ["S", "SS", "SSS"]
    };
    dateLocalization = dependency_injector_default({
      engine: function() {
        return "base";
      },
      _getPatternByFormat: function(format2) {
        return FORMATS_TO_PATTERN_MAP[format2.toLowerCase()];
      },
      _expandPattern: function(pattern) {
        return this._getPatternByFormat(pattern) || pattern;
      },
      formatUsesMonthName: function(format2) {
        return -1 !== this._expandPattern(format2).indexOf("MMMM");
      },
      formatUsesDayName: function(format2) {
        return -1 !== this._expandPattern(format2).indexOf("EEEE");
      },
      getFormatParts: function(format2) {
        var pattern = this._getPatternByFormat(format2) || format2;
        var result2 = [];
        each(pattern.split(/\W+/), (_2, formatPart) => {
          each(possiblePartPatterns, (partName, possiblePatterns) => {
            if (inArray(formatPart, possiblePatterns) > -1) {
              result2.push(partName);
            }
          });
        });
        return result2;
      },
      getMonthNames: function(format2) {
        return default_date_names_default.getMonthNames(format2);
      },
      getDayNames: function(format2) {
        return default_date_names_default.getDayNames(format2);
      },
      getQuarterNames: function(format2) {
        return default_date_names_default.getQuarterNames(format2);
      },
      getPeriodNames: function(format2) {
        return default_date_names_default.getPeriodNames(format2);
      },
      getTimeSeparator: function() {
        return ":";
      },
      is24HourFormat: function(format2) {
        var amTime = new Date(2017, 0, 20, 11, 0, 0, 0);
        var pmTime = new Date(2017, 0, 20, 23, 0, 0, 0);
        var amTimeFormatted = this.format(amTime, format2);
        var pmTimeFormatted = this.format(pmTime, format2);
        for (var i = 0; i < amTimeFormatted.length; i++) {
          if (amTimeFormatted[i] !== pmTimeFormatted[i]) {
            return !isNaN(parseInt(amTimeFormatted[i]));
          }
        }
      },
      format: function(date, _format) {
        if (!date) {
          return;
        }
        if (!_format) {
          return date;
        }
        var formatter;
        if ("function" === typeof _format) {
          formatter = _format;
        } else if (_format.formatter) {
          formatter = _format.formatter;
        } else {
          _format = _format.type || _format;
          if (isString2(_format)) {
            _format = FORMATS_TO_PATTERN_MAP[_format.toLowerCase()] || _format;
            return number_default2.convertDigits(getFormatter3(_format, this)(date));
          }
        }
        if (!formatter) {
          return;
        }
        return formatter(date);
      },
      parse: function(text, format2) {
        var that = this;
        var ldmlFormat;
        var formatter;
        if (!text) {
          return;
        }
        if (!format2) {
          return this.parse(text, "shortdate");
        }
        if (format2.parser) {
          return format2.parser(text);
        }
        if ("string" === typeof format2 && !FORMATS_TO_PATTERN_MAP[format2.toLowerCase()]) {
          ldmlFormat = format2;
        } else {
          formatter = (value2) => {
            var text2 = that.format(value2, format2);
            return number_default2.convertDigits(text2, true);
          };
          try {
            ldmlFormat = getFormat2(formatter);
          } catch (e) {
          }
        }
        if (ldmlFormat) {
          text = number_default2.convertDigits(text, true);
          return getParser(ldmlFormat, this)(text);
        }
        errors_default.log("W0012");
        var result2 = new Date(text);
        if (!result2 || isNaN(result2.getTime())) {
          return;
        }
        return result2;
      },
      firstDayOfWeekIndex: function() {
        var index2 = core_default.getValueByClosestLocale((locale) => first_day_of_week_data_default[locale]);
        return void 0 === index2 ? DEFAULT_DAY_OF_WEEK_INDEX : index2;
      }
    });
    if (hasIntl2) {
      dateLocalization.inject(date_default2);
    }
    date_default3 = dateLocalization;
  }
});

// node_modules/devextreme/esm/format_helper.js
var format_helper_default;
var init_format_helper = __esm({
  "node_modules/devextreme/esm/format_helper.js"() {
    init_type();
    init_date();
    init_number3();
    init_date3();
    init_dependency_injector();
    init_currency();
    format_helper_default = dependency_injector_default({
      format: function(value2, _format) {
        var formatIsValid = isString2(_format) && "" !== _format || isPlainObject(_format) || isFunction(_format);
        var valueIsValid = isNumeric(value2) || isDate(value2);
        if (!formatIsValid || !valueIsValid) {
          return isDefined(value2) ? value2.toString() : "";
        }
        if (isFunction(_format)) {
          return _format(value2);
        }
        if (isString2(_format)) {
          _format = {
            type: _format
          };
        }
        if (isNumeric(value2)) {
          return number_default2.format(value2, _format);
        }
        if (isDate(value2)) {
          return date_default3.format(value2, _format);
        }
      },
      getTimeFormat: function(showSecond) {
        return showSecond ? "longtime" : "shorttime";
      },
      _normalizeFormat: function(format2) {
        if (!Array.isArray(format2)) {
          return format2;
        }
        if (1 === format2.length) {
          return format2[0];
        }
        return function(date) {
          return format2.map(function(formatPart) {
            return date_default3.format(date, formatPart);
          }).join(" ");
        };
      },
      getDateFormatByDifferences: function(dateDifferences, intervalFormat) {
        var resultFormat = [];
        var needSpecialSecondFormatter = intervalFormat && dateDifferences.millisecond && !(dateDifferences.year || dateDifferences.month || dateDifferences.day);
        if (needSpecialSecondFormatter) {
          resultFormat.push(function(date) {
            return date.getSeconds() + date.getMilliseconds() / 1e3 + "s";
          });
        } else if (dateDifferences.millisecond) {
          resultFormat.push("millisecond");
        }
        if (dateDifferences.hour || dateDifferences.minute || !needSpecialSecondFormatter && dateDifferences.second) {
          resultFormat.unshift(this.getTimeFormat(dateDifferences.second));
        }
        if (dateDifferences.year && dateDifferences.month && dateDifferences.day) {
          if (intervalFormat && "month" === intervalFormat) {
            return "monthandyear";
          } else {
            resultFormat.unshift("shortdate");
            return this._normalizeFormat(resultFormat);
          }
        }
        if (dateDifferences.year && dateDifferences.month) {
          return "monthandyear";
        }
        if (dateDifferences.year && dateDifferences.quarter) {
          return "quarterandyear";
        }
        if (dateDifferences.year) {
          return "year";
        }
        if (dateDifferences.quarter) {
          return "quarter";
        }
        if (dateDifferences.month && dateDifferences.day) {
          if (intervalFormat) {
            resultFormat.unshift(function(date) {
              return date_default3.getMonthNames("abbreviated")[date.getMonth()] + " " + date_default3.format(date, "day");
            });
          } else {
            resultFormat.unshift("monthandday");
          }
          return this._normalizeFormat(resultFormat);
        }
        if (dateDifferences.month) {
          return "month";
        }
        if (dateDifferences.day) {
          if (intervalFormat) {
            resultFormat.unshift("day");
          } else {
            resultFormat.unshift(function(date) {
              return date_default3.format(date, "dayofweek") + ", " + date_default3.format(date, "day");
            });
          }
          return this._normalizeFormat(resultFormat);
        }
        return this._normalizeFormat(resultFormat);
      },
      getDateFormatByTicks: function(ticks) {
        var maxDiff;
        var currentDiff;
        var i;
        if (ticks.length > 1) {
          maxDiff = date_default.getDatesDifferences(ticks[0], ticks[1]);
          for (i = 1; i < ticks.length - 1; i++) {
            currentDiff = date_default.getDatesDifferences(ticks[i], ticks[i + 1]);
            if (maxDiff.count < currentDiff.count) {
              maxDiff = currentDiff;
            }
          }
        } else {
          maxDiff = {
            year: true,
            month: true,
            day: true,
            hour: ticks[0].getHours() > 0,
            minute: ticks[0].getMinutes() > 0,
            second: ticks[0].getSeconds() > 0,
            millisecond: ticks[0].getMilliseconds() > 0
          };
        }
        var resultFormat = this.getDateFormatByDifferences(maxDiff);
        return resultFormat;
      },
      getDateFormatByTickInterval: function(startValue, endValue, tickInterval) {
        var dateUnitInterval;
        var correctDateDifferences = function(dateDifferences2, tickInterval2, value2) {
          switch (tickInterval2) {
            case "year":
            case "quarter":
              dateDifferences2.month = value2;
            case "month":
              dateDifferences2.day = value2;
            case "week":
            case "day":
              dateDifferences2.hour = value2;
            case "hour":
              dateDifferences2.minute = value2;
            case "minute":
              dateDifferences2.second = value2;
            case "second":
              dateDifferences2.millisecond = value2;
          }
        };
        tickInterval = isString2(tickInterval) ? tickInterval.toLowerCase() : tickInterval;
        var dateDifferences = date_default.getDatesDifferences(startValue, endValue);
        if (startValue !== endValue) {
          !function(differences, minDate, maxDate) {
            if (!maxDate.getMilliseconds() && maxDate.getSeconds()) {
              if (maxDate.getSeconds() - minDate.getSeconds() === 1) {
                differences.millisecond = true;
                differences.second = false;
              }
            } else if (!maxDate.getSeconds() && maxDate.getMinutes()) {
              if (maxDate.getMinutes() - minDate.getMinutes() === 1) {
                differences.second = true;
                differences.minute = false;
              }
            } else if (!maxDate.getMinutes() && maxDate.getHours()) {
              if (maxDate.getHours() - minDate.getHours() === 1) {
                differences.minute = true;
                differences.hour = false;
              }
            } else if (!maxDate.getHours() && maxDate.getDate() > 1) {
              if (maxDate.getDate() - minDate.getDate() === 1) {
                differences.hour = true;
                differences.day = false;
              }
            } else if (1 === maxDate.getDate() && maxDate.getMonth()) {
              if (maxDate.getMonth() - minDate.getMonth() === 1) {
                differences.day = true;
                differences.month = false;
              }
            } else if (!maxDate.getMonth() && maxDate.getFullYear()) {
              if (maxDate.getFullYear() - minDate.getFullYear() === 1) {
                differences.month = true;
                differences.year = false;
              }
            }
          }(dateDifferences, startValue > endValue ? endValue : startValue, startValue > endValue ? startValue : endValue);
        }
        dateUnitInterval = date_default.getDateUnitInterval(dateDifferences);
        correctDateDifferences(dateDifferences, dateUnitInterval, true);
        dateUnitInterval = date_default.getDateUnitInterval(tickInterval || "second");
        correctDateDifferences(dateDifferences, dateUnitInterval, false);
        dateDifferences[{
          week: "day"
        }[dateUnitInterval] || dateUnitInterval] = true;
        var resultFormat = this.getDateFormatByDifferences(dateDifferences);
        return resultFormat;
      }
    });
  }
});

// node_modules/devextreme/esm/ui/grid_core/ui.grid_core.utils.js
function isDateType2(dataType) {
  return "date" === dataType || "datetime" === dataType;
}
var DATAGRID_SELECTION_DISABLED_CLASS, DATAGRID_GROUP_OPENED_CLASS, DATAGRID_GROUP_CLOSED_CLASS, DATAGRID_EXPAND_CLASS, NO_DATA_CLASS, DATE_INTERVAL_SELECTORS, getIntervalSelector, equalSelectors, setEmptyText, normalizeSortingInfo2, formatValue2, getSummaryText, getWidgetInstance, equalFilterParameters, ui_grid_core_utils_default;
var init_ui_grid_core_utils = __esm({
  "node_modules/devextreme/esm/ui/grid_core/ui.grid_core.utils.js"() {
    init_renderer();
    init_type();
    init_deferred();
    init_filtering();
    init_string();
    init_iterator();
    init_extend();
    init_position();
    init_data();
    init_common();
    init_load_panel();
    init_utils3();
    init_format_helper();
    init_window();
    init_events_engine();
    DATAGRID_SELECTION_DISABLED_CLASS = "dx-selection-disabled";
    DATAGRID_GROUP_OPENED_CLASS = "dx-datagrid-group-opened";
    DATAGRID_GROUP_CLOSED_CLASS = "dx-datagrid-group-closed";
    DATAGRID_EXPAND_CLASS = "dx-datagrid-expand";
    NO_DATA_CLASS = "nodata";
    DATE_INTERVAL_SELECTORS = {
      year: function(value2) {
        return value2 && value2.getFullYear();
      },
      month: function(value2) {
        return value2 && value2.getMonth() + 1;
      },
      day: function(value2) {
        return value2 && value2.getDate();
      },
      quarter: function(value2) {
        return value2 && Math.floor(value2.getMonth() / 3) + 1;
      },
      hour: function(value2) {
        return value2 && value2.getHours();
      },
      minute: function(value2) {
        return value2 && value2.getMinutes();
      },
      second: function(value2) {
        return value2 && value2.getSeconds();
      }
    };
    getIntervalSelector = function() {
      var data2 = arguments[1];
      var value2 = this.calculateCellValue(data2);
      if (!isDefined(value2)) {
        return null;
      } else if (isDateType2(this.dataType)) {
        var nameIntervalSelector = arguments[0];
        return DATE_INTERVAL_SELECTORS[nameIntervalSelector](value2);
      } else if ("number" === this.dataType) {
        var groupInterval = arguments[0];
        return Math.floor(Number(value2) / groupInterval) * groupInterval;
      }
    };
    equalSelectors = function(selector1, selector2) {
      if (isFunction(selector1) && isFunction(selector2)) {
        if (selector1.originalCallback && selector2.originalCallback) {
          return selector1.originalCallback === selector2.originalCallback && selector1.columnIndex === selector2.columnIndex;
        }
      }
      return selector1 === selector2;
    };
    setEmptyText = function($container) {
      $container.get(0).textContent = "";
    };
    normalizeSortingInfo2 = function(sort) {
      sort = sort || [];
      var result2 = normalizeSortingInfo(sort);
      for (var i = 0; i < sort.length; i++) {
        if (sort && sort[i] && void 0 !== sort[i].isExpanded) {
          result2[i].isExpanded = sort[i].isExpanded;
        }
        if (sort && sort[i] && void 0 !== sort[i].groupInterval) {
          result2[i].groupInterval = sort[i].groupInterval;
        }
      }
      return result2;
    };
    formatValue2 = function(value2, options2) {
      var valueText = format_helper_default.format(value2, options2.format) || value2 && value2.toString() || "";
      var formatObject = {
        value: value2,
        valueText: options2.getDisplayFormat ? options2.getDisplayFormat(valueText) : valueText,
        target: options2.target || "row",
        groupInterval: options2.groupInterval
      };
      return options2.customizeText ? options2.customizeText.call(options2, formatObject) : formatObject.valueText;
    };
    getSummaryText = function(summaryItem, summaryTexts) {
      var displayFormat = summaryItem.displayFormat || summaryItem.columnCaption && summaryTexts[summaryItem.summaryType + "OtherColumn"] || summaryTexts[summaryItem.summaryType];
      return formatValue2(summaryItem.value, {
        format: summaryItem.valueFormat,
        getDisplayFormat: function(valueText) {
          return displayFormat ? format(displayFormat, valueText, summaryItem.columnCaption) : valueText;
        },
        customizeText: summaryItem.customizeText
      });
    };
    getWidgetInstance = function($element) {
      var editorData = $element.data && $element.data();
      var dxComponents = editorData && editorData.dxComponents;
      var widgetName = dxComponents && dxComponents[0];
      return widgetName && editorData[widgetName];
    };
    equalFilterParameters = function equalFilterParameters2(filter1, filter2) {
      if (Array.isArray(filter1) && Array.isArray(filter2)) {
        if (filter1.length !== filter2.length) {
          return false;
        } else {
          for (var i = 0; i < filter1.length; i++) {
            if (!equalFilterParameters2(filter1[i], filter2[i])) {
              return false;
            }
          }
        }
        return true;
      } else if (isFunction(filter1) && filter1.columnIndex >= 0 && isFunction(filter2) && filter2.columnIndex >= 0) {
        return filter1.columnIndex === filter2.columnIndex && toComparable(filter1.filterValue) === toComparable(filter2.filterValue);
      } else {
        return toComparable(filter1) == toComparable(filter2);
      }
    };
    ui_grid_core_utils_default = {
      renderNoDataText: function($element) {
        $element = $element || this.element();
        if (!$element) {
          return;
        }
        var noDataClass = this.addWidgetPrefix(NO_DATA_CLASS);
        var noDataElement = $element.find("." + noDataClass).last();
        var isVisible2 = this._dataController.isEmpty();
        var isLoading = this._dataController.isLoading();
        if (!noDataElement.length) {
          noDataElement = renderer_default("<span>").addClass(noDataClass).appendTo($element);
        }
        if (isVisible2 && !isLoading) {
          noDataElement.removeClass("dx-hidden").text(this._getNoDataText());
        } else {
          noDataElement.addClass("dx-hidden");
        }
      },
      renderLoadPanel: function($element, $container, isLocalStore) {
        var loadPanelOptions;
        this._loadPanel && this._loadPanel.$element().remove();
        loadPanelOptions = this.option("loadPanel");
        if (loadPanelOptions && ("auto" === loadPanelOptions.enabled ? !isLocalStore : loadPanelOptions.enabled)) {
          loadPanelOptions = extend2({
            shading: false,
            message: loadPanelOptions.text,
            position: function() {
              var $window = renderer_default(getWindow());
              if ($element.height() > $window.height()) {
                return {
                  of: $window,
                  boundary: $element,
                  collision: "fit"
                };
              }
              return {
                of: $element
              };
            },
            container: $container
          }, loadPanelOptions);
          this._loadPanel = this._createComponent(renderer_default("<div>").appendTo($container), load_panel_default, loadPanelOptions);
        } else {
          this._loadPanel = null;
        }
      },
      getIndexByKey: function(key, items, keyName) {
        var index2 = -1;
        if (void 0 !== key && Array.isArray(items)) {
          keyName = arguments.length <= 2 ? "key" : keyName;
          for (var i = 0; i < items.length; i++) {
            var item = isDefined(keyName) ? items[i][keyName] : items[i];
            if (equalByValue(key, item)) {
              index2 = i;
              break;
            }
          }
        }
        return index2;
      },
      combineFilters: function(filters, operation) {
        var resultFilter = [];
        operation = operation || "and";
        for (var i = 0; i < filters.length; i++) {
          var _filters$i;
          if (!filters[i]) {
            continue;
          }
          if (1 === (null === (_filters$i = filters[i]) || void 0 === _filters$i ? void 0 : _filters$i.length) && "!" === filters[i][0]) {
            if ("and" === operation) {
              return ["!"];
            } else if ("or" === operation) {
              continue;
            }
          }
          if (resultFilter.length) {
            resultFilter.push(operation);
          }
          resultFilter.push(filters[i]);
        }
        if (1 === resultFilter.length) {
          resultFilter = resultFilter[0];
        }
        if (resultFilter.length) {
          return resultFilter;
        }
      },
      checkChanges: function(changes, changeNames) {
        var changesWithChangeNamesCount = 0;
        for (var i = 0; i < changeNames.length; i++) {
          if (changes[changeNames[i]]) {
            changesWithChangeNamesCount++;
          }
        }
        return changes.length && changes.length === changesWithChangeNamesCount;
      },
      equalFilterParameters,
      proxyMethod: function(instance, methodName, defaultResult) {
        if (!instance[methodName]) {
          instance[methodName] = function() {
            var dataSource = this._dataSource;
            return dataSource ? dataSource[methodName].apply(dataSource, arguments) : defaultResult;
          };
        }
      },
      formatValue: formatValue2,
      getFormatOptionsByColumn: function(column, target) {
        return {
          format: column.format,
          getDisplayFormat: column.getDisplayFormat,
          customizeText: column.customizeText,
          target,
          trueText: column.trueText,
          falseText: column.falseText
        };
      },
      getDisplayValue: function(column, value2, data2, rowType) {
        if (column.displayValueMap && void 0 !== column.displayValueMap[value2]) {
          return column.displayValueMap[value2];
        } else if (column.calculateDisplayValue && data2 && "group" !== rowType) {
          return column.calculateDisplayValue(data2);
        } else if (column.lookup && !("group" === rowType && (column.calculateGroupValue || column.calculateDisplayValue))) {
          return column.lookup.calculateCellValue(value2);
        }
        return value2;
      },
      getGroupRowSummaryText: function(summaryItems, summaryTexts) {
        var result2 = "(";
        for (var i = 0; i < summaryItems.length; i++) {
          var summaryItem = summaryItems[i];
          result2 += (i > 0 ? ", " : "") + getSummaryText(summaryItem, summaryTexts);
        }
        return result2 + ")";
      },
      getSummaryText,
      normalizeSortingInfo: normalizeSortingInfo2,
      getFormatByDataType: function(dataType) {
        switch (dataType) {
          case "date":
            return "shortDate";
          case "datetime":
            return "shortDateShortTime";
        }
      },
      getHeaderFilterGroupParameters: function(column, remoteGrouping) {
        var result2 = [];
        var dataField = column.dataField || column.name;
        var groupInterval = filtering_default.getGroupInterval(column);
        if (groupInterval) {
          each(groupInterval, function(index2, interval) {
            result2.push(remoteGrouping ? {
              selector: dataField,
              groupInterval: interval,
              isExpanded: index2 < groupInterval.length - 1
            } : getIntervalSelector.bind(column, interval));
          });
          return result2;
        }
        if (remoteGrouping) {
          result2 = [{
            selector: dataField,
            isExpanded: false
          }];
        } else {
          result2 = function(data2) {
            var result3 = column.calculateCellValue(data2);
            if (void 0 === result3 || "" === result3) {
              result3 = null;
            }
            return result3;
          };
          if (column.sortingMethod) {
            result2 = [{
              selector: result2,
              compare: column.sortingMethod.bind(column)
            }];
          }
        }
        return result2;
      },
      equalSortParameters(sortParameters1, sortParameters2, ignoreIsExpanded) {
        sortParameters1 = normalizeSortingInfo2(sortParameters1);
        sortParameters2 = normalizeSortingInfo2(sortParameters2);
        if (Array.isArray(sortParameters1) && Array.isArray(sortParameters2)) {
          if (sortParameters1.length !== sortParameters2.length) {
            return false;
          } else {
            for (var i = 0; i < sortParameters1.length; i++) {
              if (!equalSelectors(sortParameters1[i].selector, sortParameters2[i].selector) || sortParameters1[i].desc !== sortParameters2[i].desc || sortParameters1[i].groupInterval !== sortParameters2[i].groupInterval || !ignoreIsExpanded && Boolean(sortParameters1[i].isExpanded) !== Boolean(sortParameters2[i].isExpanded)) {
                return false;
              }
            }
          }
          return true;
        } else {
          return (!sortParameters1 || !sortParameters1.length) === (!sortParameters2 || !sortParameters2.length);
        }
      },
      getPointsByColumns: function(items, pointCreated, isVertical, startColumnIndex) {
        var cellsLength = items.length;
        var notCreatePoint = false;
        var item;
        var offset2;
        var columnIndex = startColumnIndex || 0;
        var result2 = [];
        var rtlEnabled;
        for (var i = 0; i <= cellsLength; i++) {
          if (i < cellsLength) {
            item = items.eq(i);
            offset2 = item.offset();
            rtlEnabled = "rtl" === item.css("direction");
          }
          var point = {
            index: columnIndex,
            x: offset2 ? offset2.left + (!isVertical && rtlEnabled ^ i === cellsLength ? getBoundingRect(item[0]).width : 0) : 0,
            y: offset2 ? offset2.top + (isVertical && i === cellsLength ? getBoundingRect(item[0]).height : 0) : 0,
            columnIndex
          };
          if (!isVertical && i > 0) {
            var prevItemOffset = items.eq(i - 1).offset();
            if (prevItemOffset.top < point.y) {
              point.y = prevItemOffset.top;
            }
          }
          if (pointCreated) {
            notCreatePoint = pointCreated(point);
          }
          if (!notCreatePoint) {
            result2.push(point);
          }
          columnIndex++;
        }
        return result2;
      },
      getExpandCellTemplate: function() {
        return {
          allowRenderToDetachedContainer: true,
          render: function(container, options2) {
            var $container = renderer_default(container);
            if (isDefined(options2.value) && !(options2.data && options2.data.isContinuation) && !options2.row.isNewRow) {
              var rowsView = options2.component.getView("rowsView");
              $container.addClass(DATAGRID_EXPAND_CLASS).addClass(DATAGRID_SELECTION_DISABLED_CLASS);
              renderer_default("<div>").addClass(options2.value ? DATAGRID_GROUP_OPENED_CLASS : DATAGRID_GROUP_CLOSED_CLASS).appendTo($container);
              rowsView.setAria("label", options2.value ? rowsView.localize("dxDataGrid-ariaCollapse") : rowsView.localize("dxDataGrid-ariaExpand"), $container);
            } else {
              setEmptyText($container);
            }
          }
        };
      },
      setEmptyText,
      isDateType: isDateType2,
      getSelectionRange: function(focusedElement) {
        try {
          if (focusedElement) {
            return {
              selectionStart: focusedElement.selectionStart,
              selectionEnd: focusedElement.selectionEnd
            };
          }
        } catch (e) {
        }
        return {};
      },
      setSelectionRange: function(focusedElement, selectionRange) {
        try {
          if (focusedElement && focusedElement.setSelectionRange) {
            focusedElement.setSelectionRange(selectionRange.selectionStart, selectionRange.selectionEnd);
          }
        } catch (e) {
        }
      },
      focusAndSelectElement: function(component, $element) {
        var isFocused = $element.is(":focus");
        events_engine_default.trigger($element, "focus");
        var isSelectTextOnEditingStart = component.option("editing.selectTextOnEditStart");
        var element = $element.get(0);
        if (!isFocused && isSelectTextOnEditingStart && $element.is(".dx-texteditor-input") && !$element.is("[readonly]")) {
          var editor = getWidgetInstance($element.closest(".dx-texteditor"));
          when(editor && editor._loadItemDeferred).done(function() {
            element.select();
          });
        }
      },
      getWidgetInstance,
      getLastResizableColumnIndex: function(columns, resultWidths) {
        var hasResizableColumns = columns.some((column2) => column2 && !column2.command && !column2.fixed && false !== column2.allowResizing);
        var lastColumnIndex;
        for (lastColumnIndex = columns.length - 1; columns[lastColumnIndex]; lastColumnIndex--) {
          var column = columns[lastColumnIndex];
          var width = resultWidths && resultWidths[lastColumnIndex];
          var allowResizing2 = !hasResizableColumns || false !== column.allowResizing;
          if (!column.command && !column.fixed && "adaptiveHidden" !== width && allowResizing2) {
            break;
          }
        }
        return lastColumnIndex;
      },
      isElementInCurrentGrid: function(controller, $element) {
        if ($element && $element.length) {
          var $grid = $element.closest("." + controller.getWidgetContainerClass()).parent();
          return $grid.is(controller.component.$element());
        }
        return false;
      }
    };
  }
});

// node_modules/devextreme/esm/ui/grid_core/ui.grid_core.modules.js
var WIDGET_WITH_LEGACY_CONTAINER_NAME, ModuleItem, Controller, ViewController, View, MODULES_ORDER_MAX_INDEX, processModules, callModuleItemsMethod, ui_grid_core_modules_default;
var init_ui_grid_core_modules = __esm({
  "node_modules/devextreme/esm/ui/grid_core/ui.grid_core.modules.js"() {
    init_renderer();
    init_events_engine();
    init_class();
    init_callbacks();
    init_common();
    init_type();
    init_array();
    init_iterator();
    init_ui_errors();
    init_message();
    init_window();
    WIDGET_WITH_LEGACY_CONTAINER_NAME = "dxDataGrid";
    ModuleItem = class_default.inherit({
      _endUpdateCore: function() {
      },
      ctor: function(component) {
        var that = this;
        that._updateLockCount = 0;
        that.component = component;
        that._actions = {};
        that._actionConfigs = {};
        each(this.callbackNames() || [], function(index2, name2) {
          var flags = that.callbackFlags(name2) || {};
          flags.unique = true, flags.syncStrategy = true;
          that[this] = callbacks_default(flags);
        });
      },
      init: function() {
      },
      callbackNames: function() {
      },
      callbackFlags: function() {
      },
      publicMethods: function() {
      },
      beginUpdate: function() {
        this._updateLockCount++;
      },
      endUpdate: function() {
        if (this._updateLockCount > 0) {
          this._updateLockCount--;
          if (!this._updateLockCount) {
            this._endUpdateCore();
          }
        }
      },
      option: function(name2) {
        var component = this.component;
        var optionCache = component._optionCache;
        if (1 === arguments.length && optionCache) {
          if (!(name2 in optionCache)) {
            optionCache[name2] = component.option(name2);
          }
          return optionCache[name2];
        }
        return component.option.apply(component, arguments);
      },
      _silentOption: function(name2, value2) {
        var component = this.component;
        var optionCache = component._optionCache;
        if (optionCache) {
          optionCache[name2] = value2;
        }
        return component._setOptionWithoutOptionChange(name2, value2);
      },
      localize: function(name2) {
        var optionCache = this.component._optionCache;
        if (optionCache) {
          if (!(name2 in optionCache)) {
            optionCache[name2] = message_default.format(name2);
          }
          return optionCache[name2];
        }
        return message_default.format(name2);
      },
      on: function() {
        return this.component.on.apply(this.component, arguments);
      },
      off: function() {
        return this.component.off.apply(this.component, arguments);
      },
      optionChanged: function(args) {
        if (args.name in this._actions) {
          this.createAction(args.name, this._actionConfigs[args.name]);
          args.handled = true;
        }
      },
      getAction: function(actionName) {
        return this._actions[actionName];
      },
      setAria: function(name2, value2, $target) {
        var target = $target.get(0);
        var prefix = "role" !== name2 && "id" !== name2 ? "aria-" : "";
        if (target.setAttribute) {
          target.setAttribute(prefix + name2, value2);
        } else {
          $target.attr(prefix + name2, value2);
        }
      },
      _createComponent: function() {
        return this.component._createComponent.apply(this.component, arguments);
      },
      getController: function(name2) {
        return this.component._controllers[name2];
      },
      createAction: function(actionName, config2) {
        if (isFunction(actionName)) {
          var action = this.component._createAction(actionName.bind(this), config2);
          return function(e) {
            action({
              event: e
            });
          };
        } else {
          this._actions[actionName] = this.component._createActionByOption(actionName, config2);
          this._actionConfigs[actionName] = config2;
        }
      },
      executeAction: function(actionName, options2) {
        var action = this._actions[actionName];
        return action && action(options2);
      },
      dispose: function() {
        var that = this;
        each(that.callbackNames() || [], function() {
          that[this].empty();
        });
      },
      addWidgetPrefix: function(className) {
        var componentName = this.component.NAME;
        return "dx-" + componentName.slice(2).toLowerCase() + (className ? "-" + className : "");
      },
      getWidgetContainerClass: function() {
        var containerName = this.component.NAME === WIDGET_WITH_LEGACY_CONTAINER_NAME ? null : "container";
        return this.addWidgetPrefix(containerName);
      },
      elementIsInsideGrid: function($element) {
        var $gridElement = $element.closest("." + this.getWidgetContainerClass()).parent();
        return $gridElement.is(this.component.$element());
      }
    });
    Controller = ModuleItem;
    ViewController = Controller.inherit({
      getView: function(name2) {
        return this.component._views[name2];
      },
      getViews: function() {
        return this.component._views;
      }
    });
    View = ModuleItem.inherit({
      _isReady: function() {
        return this.component.isReady();
      },
      _endUpdateCore: function() {
        this.callBase();
        if (!this._isReady() && this._requireReady) {
          this._requireRender = false;
          this.component._requireResize = false;
        }
        if (this._requireRender) {
          this._requireRender = false;
          this.render(this._$parent);
        }
      },
      _invalidate: function(requireResize, requireReady) {
        this._requireRender = true;
        this.component._requireResize = hasWindow() && (this.component._requireResize || requireResize);
        this._requireReady = this._requireReady || requireReady;
      },
      _renderCore: function() {
      },
      _resizeCore: function() {
      },
      _parentElement: function() {
        return this._$parent;
      },
      ctor: function(component) {
        this.callBase(component);
        this.renderCompleted = callbacks_default();
        this.resizeCompleted = callbacks_default();
      },
      element: function() {
        return this._$element;
      },
      getElementHeight: function() {
        var $element = this.element();
        if (!$element) {
          return 0;
        }
        var marginTop = parseFloat($element.css("marginTop")) || 0;
        var marginBottom = parseFloat($element.css("marginBottom")) || 0;
        var offsetHeight = $element.get(0).offsetHeight;
        return offsetHeight + marginTop + marginBottom;
      },
      isVisible: function() {
        return true;
      },
      getTemplate: function(name2) {
        return this.component._getTemplate(name2);
      },
      render: function($parent, options2) {
        var $element = this._$element;
        var isVisible2 = this.isVisible();
        if (!$element && !$parent) {
          return;
        }
        this._requireReady = false;
        if (!$element) {
          $element = this._$element = renderer_default("<div>").appendTo($parent);
          this._$parent = $parent;
        }
        $element.toggleClass("dx-hidden", !isVisible2);
        if (isVisible2) {
          this.component._optionCache = {};
          this._renderCore(options2);
          this.component._optionCache = void 0;
          this.renderCompleted.fire(options2);
        }
      },
      resize: function() {
        this.isResizing = true;
        this._resizeCore();
        this.resizeCompleted.fire();
        this.isResizing = false;
      },
      focus: function() {
        events_engine_default.trigger(this.element(), "focus");
      }
    });
    MODULES_ORDER_MAX_INDEX = 1e6;
    processModules = function(that, componentClass) {
      var modules = componentClass.modules;
      var modulesOrder = componentClass.modulesOrder;
      var controllerTypes = componentClass.controllerTypes || {};
      var viewTypes = componentClass.viewTypes || {};
      if (!componentClass.controllerTypes) {
        if (modulesOrder) {
          modules.sort(function(module1, module2) {
            var orderIndex1 = inArray(module1.name, modulesOrder);
            var orderIndex2 = inArray(module2.name, modulesOrder);
            if (orderIndex1 < 0) {
              orderIndex1 = MODULES_ORDER_MAX_INDEX;
            }
            if (orderIndex2 < 0) {
              orderIndex2 = MODULES_ORDER_MAX_INDEX;
            }
            return orderIndex1 - orderIndex2;
          });
        }
        each(modules, function() {
          var controllers = this.controllers;
          var moduleName = this.name;
          var views = this.views;
          controllers && each(controllers, function(name2, type2) {
            if (controllerTypes[name2]) {
              throw ui_errors_default.Error("E1001", moduleName, name2);
            } else if (!(type2 && type2.subclassOf && type2.subclassOf(Controller))) {
              type2.subclassOf(Controller);
              throw ui_errors_default.Error("E1002", moduleName, name2);
            }
            controllerTypes[name2] = type2;
          });
          views && each(views, function(name2, type2) {
            if (viewTypes[name2]) {
              throw ui_errors_default.Error("E1003", moduleName, name2);
            } else if (!(type2 && type2.subclassOf && type2.subclassOf(View))) {
              throw ui_errors_default.Error("E1004", moduleName, name2);
            }
            viewTypes[name2] = type2;
          });
        });
        each(modules, function() {
          var extenders = this.extenders;
          if (extenders) {
            extenders.controllers && each(extenders.controllers, function(name2, extender) {
              if (controllerTypes[name2]) {
                controllerTypes[name2] = controllerTypes[name2].inherit(extender);
              }
            });
            extenders.views && each(extenders.views, function(name2, extender) {
              if (viewTypes[name2]) {
                viewTypes[name2] = viewTypes[name2].inherit(extender);
              }
            });
          }
        });
        componentClass.controllerTypes = controllerTypes;
        componentClass.viewTypes = viewTypes;
      }
      var createModuleItems = function(moduleTypes) {
        var moduleItems = {};
        each(moduleTypes, function(name2, moduleType) {
          var moduleItem = new moduleType(that);
          moduleItem.name = name2;
          !function(that2, name3, moduleItem2) {
            var publicMethods = moduleItem2.publicMethods();
            if (publicMethods) {
              each(publicMethods, function(index2, methodName) {
                if (moduleItem2[methodName]) {
                  if (!that2[methodName]) {
                    that2[methodName] = function() {
                      return moduleItem2[methodName].apply(moduleItem2, arguments);
                    };
                  } else {
                    throw ui_errors_default.Error("E1005", methodName);
                  }
                } else {
                  throw ui_errors_default.Error("E1006", name3, methodName);
                }
              });
            }
          }(that, name2, moduleItem);
          moduleItems[name2] = moduleItem;
        });
        return moduleItems;
      };
      that._controllers = createModuleItems(controllerTypes);
      that._views = createModuleItems(viewTypes);
    };
    callModuleItemsMethod = function(that, methodName, args) {
      args = args || [];
      if (that._controllers) {
        each(that._controllers, function() {
          this[methodName] && this[methodName].apply(this, args);
        });
      }
      if (that._views) {
        each(that._views, function() {
          this[methodName] && this[methodName].apply(this, args);
        });
      }
    };
    ui_grid_core_modules_default = {
      modules: [],
      View,
      ViewController,
      Controller,
      registerModule: function(name2, module) {
        var modules = this.modules;
        for (var i = 0; i < modules.length; i++) {
          if (modules[i].name === name2) {
            return;
          }
        }
        module.name = name2;
        modules.push(module);
        delete this.controllerTypes;
        delete this.viewTypes;
      },
      registerModulesOrder: function(moduleNames) {
        this.modulesOrder = moduleNames;
      },
      unregisterModule: function(name2) {
        this.modules = grep(this.modules, function(module) {
          return module.name !== name2;
        });
        delete this.controllerTypes;
        delete this.viewTypes;
      },
      processModules,
      callModuleItemsMethod
    };
  }
});

// node_modules/devextreme/esm/ui/data_grid/ui.data_grid.core.js
var ui_data_grid_core_default;
var init_ui_data_grid_core = __esm({
  "node_modules/devextreme/esm/ui/data_grid/ui.data_grid.core.js"() {
    init_extends();
    init_ui_grid_core_utils();
    init_ui_grid_core_modules();
    ui_data_grid_core_default = _extends({}, ui_grid_core_modules_default, ui_grid_core_utils_default, {
      modules: []
    });
  }
});

// node_modules/devextreme/esm/events/double_click.js
var DBLCLICK_EVENT_NAME, DBLCLICK_NAMESPACE, NAMESPACED_CLICK_EVENT, DBLCLICK_TIMEOUT, DblClick;
var init_double_click = __esm({
  "node_modules/devextreme/esm/events/double_click.js"() {
    init_events_engine();
    init_dom();
    init_dom_adapter();
    init_class();
    init_event_registrator();
    init_click();
    init_utils2();
    DBLCLICK_EVENT_NAME = "dxdblclick";
    DBLCLICK_NAMESPACE = "dxDblClick";
    NAMESPACED_CLICK_EVENT = addNamespace2(CLICK_EVENT_NAME, DBLCLICK_NAMESPACE);
    DBLCLICK_TIMEOUT = 300;
    DblClick = class_default.inherit({
      ctor: function() {
        this._handlerCount = 0;
        this._forgetLastClick();
      },
      _forgetLastClick: function() {
        this._firstClickTarget = null;
        this._lastClickTimeStamp = -DBLCLICK_TIMEOUT;
      },
      add: function() {
        if (this._handlerCount <= 0) {
          events_engine_default.on(dom_adapter_default.getDocument(), NAMESPACED_CLICK_EVENT, this._clickHandler.bind(this));
        }
        this._handlerCount++;
      },
      _clickHandler: function(e) {
        var timeStamp = e.timeStamp || Date.now();
        var timeBetweenClicks = timeStamp - this._lastClickTimeStamp;
        var isSimulated = timeBetweenClicks < 0;
        var isDouble = !isSimulated && timeBetweenClicks < DBLCLICK_TIMEOUT;
        if (isDouble) {
          fireEvent({
            type: DBLCLICK_EVENT_NAME,
            target: closestCommonParent(this._firstClickTarget, e.target),
            originalEvent: e
          });
          this._forgetLastClick();
        } else {
          this._firstClickTarget = e.target;
          this._lastClickTimeStamp = timeStamp;
        }
      },
      remove: function() {
        this._handlerCount--;
        if (this._handlerCount <= 0) {
          this._forgetLastClick();
          events_engine_default.off(dom_adapter_default.getDocument(), NAMESPACED_CLICK_EVENT);
        }
      }
    });
    event_registrator_default(DBLCLICK_EVENT_NAME, new DblClick());
  }
});

// node_modules/devextreme/esm/ui/grid_core/ui.grid_core.column_state_mixin.js
var COLUMN_INDICATORS_CLASS, GROUP_PANEL_ITEM_CLASS, ui_grid_core_column_state_mixin_default;
var init_ui_grid_core_column_state_mixin = __esm({
  "node_modules/devextreme/esm/ui/grid_core/ui.grid_core.column_state_mixin.js"() {
    init_renderer();
    init_common();
    init_extend();
    init_position();
    COLUMN_INDICATORS_CLASS = "dx-column-indicators";
    GROUP_PANEL_ITEM_CLASS = "dx-group-panel-item";
    ui_grid_core_column_state_mixin_default = {
      _applyColumnState: function(options2) {
        var _that$component;
        var rtlEnabled = this.option("rtlEnabled");
        var columnAlignment = this._getColumnAlignment(options2.column.alignment, rtlEnabled);
        var parameters = extend2(true, {
          columnAlignment
        }, options2);
        var isGroupPanelItem = parameters.rootElement.hasClass(GROUP_PANEL_ITEM_CLASS);
        var $indicatorsContainer = this._createIndicatorContainer(parameters, isGroupPanelItem);
        var $span = renderer_default("<span>").addClass(this._getIndicatorClassName(options2.name));
        var columnsController = null === (_that$component = this.component) || void 0 === _that$component ? void 0 : _that$component.getController("columns");
        var indicatorAlignment = (null === columnsController || void 0 === columnsController ? void 0 : columnsController.getHeaderContentAlignment(columnAlignment)) || columnAlignment;
        parameters.container = $indicatorsContainer;
        parameters.indicator = $span;
        this._renderIndicator(parameters);
        $indicatorsContainer[(isGroupPanelItem || !options2.showColumnLines) && "left" === indicatorAlignment ? "appendTo" : "prependTo"](options2.rootElement);
        return $span;
      },
      _getIndicatorClassName: noop2,
      _getColumnAlignment: function(alignment, rtlEnabled) {
        rtlEnabled = rtlEnabled || this.option("rtlEnabled");
        return alignment && "center" !== alignment ? alignment : getDefaultAlignment(rtlEnabled);
      },
      _createIndicatorContainer: function(options2, ignoreIndicatorAlignment) {
        var $indicatorsContainer = this._getIndicatorContainer(options2.rootElement);
        var indicatorAlignment = "left" === options2.columnAlignment ? "right" : "left";
        if (!$indicatorsContainer.length) {
          $indicatorsContainer = renderer_default("<div>").addClass(COLUMN_INDICATORS_CLASS);
        }
        this.setAria("role", "presentation", $indicatorsContainer);
        return $indicatorsContainer.css("float", options2.showColumnLines && !ignoreIndicatorAlignment ? indicatorAlignment : null);
      },
      _getIndicatorContainer: function($cell) {
        return $cell && $cell.find("." + COLUMN_INDICATORS_CLASS);
      },
      _getIndicatorElements: function($cell) {
        var $indicatorContainer = this._getIndicatorContainer($cell);
        return $indicatorContainer && $indicatorContainer.children();
      },
      _renderIndicator: function(options2) {
        var $container = options2.container;
        var $indicator = options2.indicator;
        $container && $indicator && $container.append($indicator);
      },
      _updateIndicators: function(indicatorName) {
        var columns = this.getColumns();
        var $cells = this.getColumnElements();
        var $cell;
        if (!$cells || columns.length !== $cells.length) {
          return;
        }
        for (var i = 0; i < columns.length; i++) {
          $cell = $cells.eq(i);
          this._updateIndicator($cell, columns[i], indicatorName);
          var rowOptions = $cell.parent().data("options");
          if (rowOptions && rowOptions.cells) {
            rowOptions.cells[$cell.index()].column = columns[i];
          }
        }
      },
      _updateIndicator: function($cell, column, indicatorName) {
        if (!column.command) {
          return this._applyColumnState({
            name: indicatorName,
            rootElement: $cell,
            column,
            showColumnLines: this.option("showColumnLines")
          });
        }
      }
    };
  }
});

// node_modules/devextreme/esm/ui/grid_core/ui.grid_core.columns_view.js
var SCROLL_CONTAINER_CLASS, SCROLLABLE_SIMULATED_CLASS, GROUP_SPACE_CLASS, CONTENT_CLASS, TABLE_CLASS, TABLE_FIXED_CLASS, CONTENT_FIXED_CLASS, ROW_CLASS, GROUP_ROW_CLASS, GROUP_CELL_CLASS, DETAIL_ROW_CLASS, FILTER_ROW_CLASS, ERROR_ROW_CLASS, CELL_UPDATED_ANIMATION_CLASS, HIDDEN_COLUMNS_WIDTH, CELL_HINT_VISIBLE, FORM_FIELD_ITEM_CONTENT_CLASS, appendElementTemplate, subscribeToRowEvents, getWidthStyle, setCellWidth, copyAttributes, ColumnsView;
var init_ui_grid_core_columns_view = __esm({
  "node_modules/devextreme/esm/ui/grid_core/ui.grid_core.columns_view.js"() {
    init_renderer();
    init_dom_adapter();
    init_window();
    init_events_engine();
    init_element_data();
    init_pointer();
    init_click();
    init_double_click();
    init_browser();
    init_common();
    init_style();
    init_element();
    init_type();
    init_position();
    init_iterator();
    init_extend();
    init_ui_grid_core_modules();
    init_ui_grid_core_utils();
    init_ui_grid_core_column_state_mixin();
    init_deferred();
    init_support();
    SCROLL_CONTAINER_CLASS = "scroll-container";
    SCROLLABLE_SIMULATED_CLASS = "scrollable-simulated";
    GROUP_SPACE_CLASS = "group-space";
    CONTENT_CLASS = "content";
    TABLE_CLASS = "table";
    TABLE_FIXED_CLASS = "table-fixed";
    CONTENT_FIXED_CLASS = "content-fixed";
    ROW_CLASS = "dx-row";
    GROUP_ROW_CLASS = "dx-group-row";
    GROUP_CELL_CLASS = "dx-group-cell";
    DETAIL_ROW_CLASS = "dx-master-detail-row";
    FILTER_ROW_CLASS = "filter-row";
    ERROR_ROW_CLASS = "dx-error-row";
    CELL_UPDATED_ANIMATION_CLASS = "cell-updated-animation";
    HIDDEN_COLUMNS_WIDTH = "0.0001px";
    CELL_HINT_VISIBLE = "dxCellHintVisible";
    FORM_FIELD_ITEM_CONTENT_CLASS = "dx-field-item-content";
    appendElementTemplate = {
      render: function(options2) {
        options2.container.append(options2.content);
      }
    };
    subscribeToRowEvents = function(that, $table) {
      var touchTarget;
      var touchCurrentTarget;
      var timeoutId;
      function clearTouchTargets(timeout) {
        return setTimeout(function() {
          touchTarget = touchCurrentTarget = null;
        }, timeout);
      }
      events_engine_default.on($table, "touchstart touchend", ".dx-row", function(e) {
        clearTimeout(timeoutId);
        if ("touchstart" === e.type) {
          touchTarget = e.target;
          touchCurrentTarget = e.currentTarget;
          timeoutId = clearTouchTargets(1e3);
        } else {
          timeoutId = clearTouchTargets();
        }
      });
      events_engine_default.on($table, [CLICK_EVENT_NAME, DBLCLICK_EVENT_NAME, pointer_default.down].join(" "), ".dx-row", {
        useNative: that._isNativeClick()
      }, that.createAction(function(e) {
        var event = e.event;
        if (touchTarget) {
          event.target = touchTarget;
          event.currentTarget = touchCurrentTarget;
        }
        if (!renderer_default(event.target).closest("a").length) {
          e.rowIndex = that.getRowIndex(event.currentTarget);
          if (e.rowIndex >= 0) {
            e.rowElement = getPublicElement(renderer_default(event.currentTarget));
            e.columns = that.getColumns();
            if (event.type === pointer_default.down) {
              that._rowPointerDown(e);
            } else if (event.type === CLICK_EVENT_NAME) {
              that._rowClick(e);
            } else {
              that._rowDblClick(e);
            }
          }
        }
      }));
    };
    getWidthStyle = function(width) {
      if ("auto" === width) {
        return "";
      }
      return isNumeric(width) ? width + "px" : width;
    };
    setCellWidth = function(cell, column, width) {
      cell.style.width = cell.style.maxWidth = "auto" === column.width ? "" : width;
    };
    copyAttributes = function(element, newElement) {
      if (!element || !newElement) {
        return;
      }
      var oldAttributes = element.attributes;
      var newAttributes = newElement.attributes;
      var i;
      for (i = 0; i < oldAttributes.length; i++) {
        var name2 = oldAttributes[i].nodeName;
        if (!newElement.hasAttribute(name2)) {
          element.removeAttribute(name2);
        }
      }
      for (i = 0; i < newAttributes.length; i++) {
        element.setAttribute(newAttributes[i].nodeName, newAttributes[i].nodeValue);
      }
    };
    ColumnsView = ui_grid_core_modules_default.View.inherit(ui_grid_core_column_state_mixin_default).inherit({
      _createScrollableOptions: function() {
        var scrollingOptions = this.option("scrolling");
        var useNativeScrolling = this.option("scrolling.useNative");
        var options2 = extend2({}, scrollingOptions, {
          direction: "both",
          bounceEnabled: false,
          useKeyboard: false
        });
        if (void 0 === useNativeScrolling) {
          useNativeScrolling = true;
        }
        if ("auto" === useNativeScrolling) {
          delete options2.useNative;
          delete options2.useSimulatedScrollbar;
        } else {
          options2.useNative = !!useNativeScrolling;
          options2.useSimulatedScrollbar = !useNativeScrolling;
        }
        return options2;
      },
      _updateCell: function($cell, parameters) {
        if (parameters.rowType) {
          this._cellPrepared($cell, parameters);
        }
      },
      _createCell: function(options2) {
        var column = options2.column;
        var alignment = column.alignment || getDefaultAlignment(this.option("rtlEnabled"));
        var cell = dom_adapter_default.createElement("td");
        cell.style.textAlign = alignment;
        var $cell = renderer_default(cell);
        if ("data" === options2.rowType && column.headerId && !column.type) {
          if (this.component.option("showColumnHeaders")) {
            this.setAria("describedby", column.headerId, $cell);
          }
        }
        if (column.cssClass) {
          $cell.addClass(column.cssClass);
        }
        if ("expand" === column.command) {
          $cell.addClass(column.cssClass);
          $cell.addClass(this.addWidgetPrefix(GROUP_SPACE_CLASS));
        }
        if (column.colspan > 1) {
          $cell.attr("colSpan", column.colspan);
        } else if (!column.isBand && "auto" !== column.visibleWidth && this.option("columnAutoWidth")) {
          if (column.width || column.minWidth) {
            cell.style.minWidth = getWidthStyle(column.minWidth || column.width);
          }
          if (column.width) {
            setCellWidth(cell, column, getWidthStyle(column.width));
          }
        }
        return $cell;
      },
      _createRow: function(rowObject) {
        var $element = renderer_default("<tr>").addClass(ROW_CLASS);
        this.setAria("role", "row", $element);
        return $element;
      },
      _isAltRow: function(row) {
        return row && row.dataIndex % 2 === 1;
      },
      _createTable: function(columns, isAppend) {
        var that = this;
        var $table = renderer_default("<table>").addClass(that.addWidgetPrefix(TABLE_CLASS)).addClass(that.addWidgetPrefix(TABLE_FIXED_CLASS));
        if (columns && !isAppend) {
          $table.append(that._createColGroup(columns));
          if (browser_default.safari) {
            $table.append(renderer_default("<thead>").append("<tr>"));
          }
          that.setAria("role", "presentation", $table);
        } else {
          that.setAria("hidden", true, $table);
        }
        this.setAria("role", "presentation", renderer_default("<tbody>").appendTo($table));
        if (isAppend) {
          return $table;
        }
        if (browser_default.mozilla) {
          events_engine_default.on($table, "mousedown", "td", function(e) {
            if (e.ctrlKey) {
              e.preventDefault();
            }
          });
        }
        if (that.option("cellHintEnabled")) {
          events_engine_default.on($table, "mousemove", ".dx-row > td", this.createAction(function(args) {
            var e = args.event;
            var $element = renderer_default(e.target);
            var $cell = renderer_default(e.currentTarget);
            var $row = $cell.parent();
            var isDataRow2 = $row.hasClass("dx-data-row");
            var isHeaderRow = $row.hasClass("dx-header-row");
            var isGroupRow2 = $row.hasClass(GROUP_ROW_CLASS);
            var isMasterDetailRow = $row.hasClass(DETAIL_ROW_CLASS);
            var isFilterRow = $row.hasClass(that.addWidgetPrefix(FILTER_ROW_CLASS));
            var visibleColumns = that._columnsController.getVisibleColumns();
            var rowOptions = $row.data("options");
            var columnIndex = $cell.index();
            var cellOptions = rowOptions && rowOptions.cells && rowOptions.cells[columnIndex];
            var column = cellOptions ? cellOptions.column : visibleColumns[columnIndex];
            var msieCorrection = browser_default.msie ? 1 : 0;
            if (!isMasterDetailRow && !isFilterRow && (!isDataRow2 || isDataRow2 && column && !column.cellTemplate) && (!isHeaderRow || isHeaderRow && column && !column.headerCellTemplate) && (!isGroupRow2 || isGroupRow2 && column && (void 0 === column.groupIndex || !column.groupCellTemplate))) {
              if ($element.data(CELL_HINT_VISIBLE)) {
                $element.removeAttr("title");
                $element.data(CELL_HINT_VISIBLE, false);
              }
              var difference = $element[0].scrollWidth - $element[0].clientWidth - msieCorrection;
              if (difference > 0 && !isDefined($element.attr("title"))) {
                $element.attr("title", $element.text());
                $element.data(CELL_HINT_VISIBLE, true);
              }
            }
          }));
        }
        var getOptions = function(event) {
          var $cell = renderer_default(event.currentTarget);
          var $fieldItemContent = renderer_default(event.target).closest("." + FORM_FIELD_ITEM_CONTENT_CLASS);
          var $row = $cell.parent();
          var rowOptions = $row.data("options");
          var options2 = rowOptions && rowOptions.cells && rowOptions.cells[$cell.index()];
          if (!$cell.closest("table").is(event.delegateTarget)) {
            return;
          }
          var resultOptions = extend2({}, options2, {
            cellElement: getPublicElement($cell),
            event,
            eventType: event.type
          });
          resultOptions.rowIndex = that.getRowIndex($row);
          if ($fieldItemContent.length) {
            var formItemOptions = $fieldItemContent.data("dx-form-item");
            if (formItemOptions.column) {
              resultOptions.column = formItemOptions.column;
              resultOptions.columnIndex = that._columnsController.getVisibleIndex(resultOptions.column.index);
            }
          }
          return resultOptions;
        };
        events_engine_default.on($table, "mouseover", ".dx-row > td", function(e) {
          var options2 = getOptions(e);
          options2 && that.executeAction("onCellHoverChanged", options2);
        });
        events_engine_default.on($table, "mouseout", ".dx-row > td", function(e) {
          var options2 = getOptions(e);
          options2 && that.executeAction("onCellHoverChanged", options2);
        });
        events_engine_default.on($table, CLICK_EVENT_NAME, ".dx-row > td", function(e) {
          var options2 = getOptions(e);
          options2 && that.executeAction("onCellClick", options2);
        });
        events_engine_default.on($table, DBLCLICK_EVENT_NAME, ".dx-row > td", function(e) {
          var options2 = getOptions(e);
          options2 && that.executeAction("onCellDblClick", options2);
        });
        subscribeToRowEvents(that, $table);
        return $table;
      },
      _isNativeClick: noop2,
      _rowPointerDown: noop2,
      _rowClick: noop2,
      _rowDblClick: noop2,
      _createColGroup: function(columns) {
        var colgroupElement = renderer_default("<colgroup>");
        for (var i = 0; i < columns.length; i++) {
          var colspan = columns[i].colspan || 1;
          for (var j = 0; j < colspan; j++) {
            colgroupElement.append(this._createCol(columns[i]));
          }
        }
        return colgroupElement;
      },
      _createCol: function(column) {
        var width = column.visibleWidth || column.width;
        if ("adaptiveHidden" === width) {
          width = HIDDEN_COLUMNS_WIDTH;
        }
        var col = renderer_default("<col>");
        setWidth(col, width);
        return col;
      },
      renderDelayedTemplates: function() {
        var delayedTemplates = this._delayedTemplates;
        var syncTemplates = delayedTemplates.filter((template) => !template.async);
        var asyncTemplates = delayedTemplates.filter((template) => template.async);
        this._delayedTemplates = [];
        this._renderDelayedTemplatesCore(syncTemplates);
        this._renderDelayedTemplatesCoreAsync(asyncTemplates);
      },
      _renderDelayedTemplatesCoreAsync: function(templates) {
        var that = this;
        if (templates.length) {
          getWindow().setTimeout(function() {
            that._renderDelayedTemplatesCore(templates, true);
          });
        }
      },
      _renderDelayedTemplatesCore: function(templates, isAsync) {
        var date = /* @__PURE__ */ new Date();
        while (templates.length) {
          var templateParameters = templates.shift();
          var options2 = templateParameters.options;
          var doc = dom_adapter_default.getDocument();
          if (!isAsync || renderer_default(options2.container).closest(doc).length) {
            templateParameters.template.render(options2);
          }
          if (isAsync && /* @__PURE__ */ new Date() - date > 30) {
            this._renderDelayedTemplatesCoreAsync(templates);
            break;
          }
        }
        if (!templates.length && this._delayedTemplates.length) {
          this.renderDelayedTemplates();
        }
      },
      _processTemplate: function(template) {
        var renderingTemplate;
        if (template && template.render && !isRenderer(template)) {
          renderingTemplate = {
            allowRenderToDetachedContainer: template.allowRenderToDetachedContainer,
            render: function(options2) {
              template.render(options2.container, options2.model);
              options2.deferred && options2.deferred.resolve();
            }
          };
        } else if (isFunction(template)) {
          renderingTemplate = {
            render: function(options2) {
              var renderedTemplate = template(getPublicElement(options2.container), options2.model);
              if (renderedTemplate && (renderedTemplate.nodeType || isRenderer(renderedTemplate))) {
                options2.container.append(renderedTemplate);
              }
              options2.deferred && options2.deferred.resolve();
            }
          };
        } else {
          var templateID = isString2(template) ? template : renderer_default(template).attr("id");
          if (!templateID) {
            renderingTemplate = this.getTemplate(template);
          } else {
            if (!this._templatesCache[templateID]) {
              this._templatesCache[templateID] = this.getTemplate(template);
            }
            renderingTemplate = this._templatesCache[templateID];
          }
        }
        return renderingTemplate;
      },
      renderTemplate: function(container, template, options2, allowRenderToDetachedContainer) {
        var renderingTemplate = this._processTemplate(template, options2);
        var column = options2.column;
        var isDataRow2 = "data" === options2.rowType;
        var templateDeferred = new Deferred();
        var templateOptions = {
          container,
          model: options2,
          deferred: templateDeferred,
          onRendered: () => {
            templateDeferred.resolve();
          }
        };
        if (renderingTemplate) {
          options2.component = this.component;
          var async = column && (column.renderAsync && isDataRow2 || this.option("renderAsync") && (false !== column.renderAsync && (column.command || column.showEditorAlways) && isDataRow2 || "filter" === options2.rowType));
          if ((renderingTemplate.allowRenderToDetachedContainer || allowRenderToDetachedContainer) && !async) {
            renderingTemplate.render(templateOptions);
          } else {
            this._delayedTemplates.push({
              template: renderingTemplate,
              options: templateOptions,
              async
            });
          }
        } else {
          templateDeferred.reject();
        }
        return templateDeferred.promise();
      },
      _getBodies: function(tableElement) {
        return renderer_default(tableElement).children("tbody").not(".dx-header").not(".dx-footer");
      },
      _wrapRowIfNeed: function($table, $row) {
        var $tBodies = this.option("rowTemplate") && this._getBodies(this._tableElement || $table);
        if ($tBodies && $tBodies.filter("." + ROW_CLASS).length) {
          var $tbody = renderer_default("<tbody>").addClass($row.attr("class"));
          this.setAria("role", "presentation", $tbody);
          return $tbody.append($row);
        }
        return $row;
      },
      _appendRow: function($table, $row, appendTemplate) {
        appendTemplate = appendTemplate || appendElementTemplate;
        appendTemplate.render({
          content: $row,
          container: $table
        });
      },
      _resizeCore: function() {
        var scrollLeft = this._scrollLeft;
        if (scrollLeft >= 0) {
          this._scrollLeft = 0;
          this.scrollTo({
            left: scrollLeft
          });
        }
      },
      _renderCore: function(e) {
        var $root = this.element().parent();
        if (!$root || $root.parent().length) {
          this.renderDelayedTemplates(e);
        }
      },
      _renderTable: function(options2) {
        options2 = options2 || {};
        options2.columns = this._columnsController.getVisibleColumns();
        var changeType = options2.change && options2.change.changeType;
        var $table = this._createTable(options2.columns, "append" === changeType || "prepend" === changeType || "update" === changeType);
        this._renderRows($table, options2);
        return $table;
      },
      _renderRows: function($table, options2) {
        var rows = this._getRows(options2.change);
        var columnIndices = options2.change && options2.change.columnIndices || [];
        var changeTypes = options2.change && options2.change.changeTypes || [];
        for (var i = 0; i < rows.length; i++) {
          this._renderRow($table, extend2({
            row: rows[i],
            columnIndices: columnIndices[i],
            changeType: changeTypes[i]
          }, options2));
        }
      },
      _renderRow: function($table, options2) {
        if (!options2.columnIndices) {
          options2.row.cells = [];
        }
        var $row = this._createRow(options2.row);
        var $wrappedRow = this._wrapRowIfNeed($table, $row);
        if ("remove" !== options2.changeType) {
          this._renderCells($row, options2);
        }
        this._appendRow($table, $wrappedRow);
        var rowOptions = extend2({
          columns: options2.columns
        }, options2.row);
        this._addWatchMethod(rowOptions, options2.row);
        this._rowPrepared($wrappedRow, rowOptions, options2.row);
      },
      _needRenderCell: function(columnIndex, columnIndices) {
        return !columnIndices || columnIndices.indexOf(columnIndex) >= 0;
      },
      _renderCells: function($row, options2) {
        var columnIndex = 0;
        var row = options2.row;
        var columns = options2.columns;
        for (var i = 0; i < columns.length; i++) {
          if (this._needRenderCell(i, options2.columnIndices)) {
            this._renderCell($row, extend2({
              column: columns[i],
              columnIndex,
              value: row.values && row.values[columnIndex],
              oldValue: row.oldValues && row.oldValues[columnIndex]
            }, options2));
          }
          if (columns[i].colspan > 1) {
            columnIndex += columns[i].colspan;
          } else {
            columnIndex++;
          }
        }
      },
      _updateCells: function($rowElement, $newRowElement, columnIndices) {
        var $cells = $rowElement.children();
        var $newCells = $newRowElement.children();
        var highlightChanges = this.option("highlightChanges");
        var cellUpdatedClass = this.addWidgetPrefix(CELL_UPDATED_ANIMATION_CLASS);
        columnIndices.forEach(function(columnIndex, index2) {
          var $cell = $cells.eq(columnIndex);
          var $newCell = $newCells.eq(index2);
          $cell.replaceWith($newCell);
          if (highlightChanges && !$newCell.hasClass("dx-command-expand")) {
            $newCell.addClass(cellUpdatedClass);
          }
        });
        copyAttributes($rowElement.get(0), $newRowElement.get(0));
      },
      _setCellAriaAttributes: function($cell, cellOptions) {
        if ("freeSpace" !== cellOptions.rowType) {
          this.setAria("role", "gridcell", $cell);
          var columnIndexOffset = this._columnsController.getColumnIndexOffset();
          var ariaColIndex = cellOptions.columnIndex + columnIndexOffset + 1;
          this.setAria("colindex", ariaColIndex, $cell);
        }
      },
      _renderCell: function($row, options2) {
        var cellOptions = this._getCellOptions(options2);
        if (options2.columnIndices) {
          if (options2.row.cells) {
            var cellIndex;
            options2.row.cells.forEach((cell, i) => {
              if (cell.columnIndex === cellOptions.columnIndex) {
                cellIndex = i;
              }
            });
            options2.row.cells[cellIndex] = cellOptions;
          }
        } else {
          options2.row.cells.push(cellOptions);
        }
        var $cell = this._createCell(cellOptions);
        this._setCellAriaAttributes($cell, cellOptions);
        this._renderCellContent($cell, cellOptions);
        $row.get(0).appendChild($cell.get(0));
        return $cell;
      },
      _renderCellContent: function($cell, options2) {
        var template = this._getCellTemplate(options2);
        when(!template || this.renderTemplate($cell, template, options2)).done(() => {
          this._updateCell($cell, options2);
        });
      },
      _getCellTemplate: function() {
      },
      _getRows: function() {
        return [];
      },
      _getCellOptions: function(options2) {
        var cellOptions = {
          column: options2.column,
          columnIndex: options2.columnIndex,
          rowType: options2.row.rowType,
          isAltRow: this._isAltRow(options2.row)
        };
        this._addWatchMethod(cellOptions);
        return cellOptions;
      },
      _addWatchMethod: function(options2, source) {
        if (!this.option("repaintChangesOnly")) {
          return;
        }
        var watchers = [];
        source = source || options2;
        source.watch = source.watch || function(getter, updateValueFunc, updateRowFunc) {
          var oldValue = getter(source.data);
          var watcher = function(row) {
            if (row && updateRowFunc) {
              updateRowFunc(row);
            }
            var newValue = getter(source.data);
            if (JSON.stringify(oldValue) !== JSON.stringify(newValue)) {
              if (row) {
                updateValueFunc(newValue);
              }
              oldValue = newValue;
            }
          };
          watchers.push(watcher);
          return function() {
            var index2 = watchers.indexOf(watcher);
            if (index2 >= 0) {
              watchers.splice(index2, 1);
            }
          };
        };
        source.update = source.update || function(row, keepRow) {
          if (row) {
            this.data = options2.data = row.data;
            this.rowIndex = options2.rowIndex = row.rowIndex;
            this.dataIndex = options2.dataIndex = row.dataIndex;
            this.isExpanded = options2.isExpanded = row.isExpanded;
            if (options2.row && !keepRow) {
              options2.row = row;
            }
          }
          watchers.forEach(function(watcher) {
            watcher(row);
          });
        };
        if (source !== options2) {
          options2.watch = source.watch.bind(source);
        }
        return options2;
      },
      _cellPrepared: function(cell, options2) {
        options2.cellElement = getPublicElement(renderer_default(cell));
        this.executeAction("onCellPrepared", options2);
      },
      _rowPrepared: function($row, options2) {
        data($row.get(0), "options", options2);
        options2.rowElement = getPublicElement($row);
        this.executeAction("onRowPrepared", options2);
      },
      _columnOptionChanged: function(e) {
        var optionNames = e.optionNames;
        if (ui_grid_core_utils_default.checkChanges(optionNames, ["width", "visibleWidth"])) {
          var visibleColumns = this._columnsController.getVisibleColumns();
          var widths = map(visibleColumns, function(column) {
            var width = column.visibleWidth || column.width;
            return isDefined(width) ? width : "auto";
          });
          this.setColumnWidths({
            widths,
            optionNames
          });
          return;
        }
        if (!this._requireReady) {
          this.render();
        }
      },
      getCellIndex: function($cell) {
        var cellIndex = $cell.length ? $cell[0].cellIndex : -1;
        return cellIndex;
      },
      getTableElements: function() {
        return this._tableElement || renderer_default();
      },
      getTableElement: function() {
        return this._tableElement;
      },
      setTableElement: function(tableElement) {
        this._tableElement = tableElement;
      },
      optionChanged: function(args) {
        this.callBase(args);
        switch (args.name) {
          case "cellHintEnabled":
          case "onCellPrepared":
          case "onRowPrepared":
          case "onCellHoverChanged":
            this._invalidate(true, true);
            args.handled = true;
        }
      },
      init: function() {
        var that = this;
        that._scrollLeft = -1;
        that._columnsController = that.getController("columns");
        that._dataController = that.getController("data");
        that._delayedTemplates = [];
        that._templatesCache = {};
        that.createAction("onCellClick");
        that.createAction("onRowClick");
        that.createAction("onCellDblClick");
        that.createAction("onRowDblClick");
        that.createAction("onCellHoverChanged", {
          excludeValidators: ["disabled", "readOnly"]
        });
        that.createAction("onCellPrepared", {
          excludeValidators: ["disabled", "readOnly"],
          category: "rendering"
        });
        that.createAction("onRowPrepared", {
          excludeValidators: ["disabled", "readOnly"],
          category: "rendering",
          afterExecute: function(e) {
            that._afterRowPrepared(e);
          }
        });
        that._columnsController.columnsChanged.add(that._columnOptionChanged.bind(that));
        that._dataController && that._dataController.changed.add(that._handleDataChanged.bind(that));
      },
      _afterRowPrepared: noop2,
      _handleDataChanged: function() {
      },
      callbackNames: function() {
        return ["scrollChanged"];
      },
      _updateScrollLeftPosition: function() {
        var scrollLeft = this._scrollLeft;
        if (scrollLeft >= 0) {
          this._scrollLeft = 0;
          this.scrollTo({
            left: scrollLeft
          });
        }
      },
      scrollTo: function(pos) {
        var $element = this.element();
        var $scrollContainer = $element && $element.children("." + this.addWidgetPrefix(SCROLL_CONTAINER_CLASS)).not("." + this.addWidgetPrefix(CONTENT_FIXED_CLASS));
        if (isDefined(pos) && isDefined(pos.left) && this._scrollLeft !== pos.left) {
          this._scrollLeft = pos.left;
          $scrollContainer && $scrollContainer.scrollLeft(pos.left);
        }
      },
      _wrapTableInScrollContainer: function($table) {
        var $scrollContainer = renderer_default("<div>");
        var useNative = this.option("scrolling.useNative");
        if (false === useNative || "auto" === useNative && !nativeScrolling) {
          $scrollContainer.addClass(this.addWidgetPrefix(SCROLLABLE_SIMULATED_CLASS));
        }
        events_engine_default.on($scrollContainer, "scroll", () => {
          var scrollLeft = $scrollContainer.scrollLeft();
          if (scrollLeft !== this._scrollLeft) {
            this.scrollChanged.fire({
              left: scrollLeft
            }, this.name);
          }
        });
        $scrollContainer.addClass(this.addWidgetPrefix(CONTENT_CLASS)).addClass(this.addWidgetPrefix(SCROLL_CONTAINER_CLASS)).append($table).appendTo(this.element());
        this.setAria("role", "presentation", $scrollContainer);
        return $scrollContainer;
      },
      _updateContent: function($newTableElement) {
        this.setTableElement($newTableElement);
        this._wrapTableInScrollContainer($newTableElement);
      },
      _findContentElement: noop2,
      _getWidths: function($cellElements) {
        var result2 = [];
        var width;
        if ($cellElements) {
          each($cellElements, function(index2, item) {
            width = item.offsetWidth;
            if (item.getBoundingClientRect) {
              var clientRect = getBoundingRect(item);
              if (clientRect.width > width - 1) {
                width = clientRect.width;
              }
            }
            result2.push(width);
          });
        }
        return result2;
      },
      getColumnWidths: function($tableElement) {
        var result2 = [];
        var $rows;
        var $cells;
        (this.option("forceApplyBindings") || noop2)();
        $tableElement = $tableElement || this.getTableElement();
        if ($tableElement) {
          $rows = $tableElement.children("tbody:not(.dx-header)").children();
          for (var i = 0; i < $rows.length; i++) {
            var $row = $rows.eq(i);
            var isRowVisible = "none" !== $row.get(0).style.display && !$row.hasClass("dx-state-invisible");
            if (!$row.is("." + GROUP_ROW_CLASS) && !$row.is("." + DETAIL_ROW_CLASS) && !$row.is("." + ERROR_ROW_CLASS) && isRowVisible) {
              $cells = $row.children("td");
              break;
            }
          }
          result2 = this._getWidths($cells);
        }
        return result2;
      },
      getVisibleColumnIndex: function(columnIndex, rowIndex) {
        return columnIndex;
      },
      setColumnWidths: function(_ref) {
        var {
          widths,
          $tableElement,
          columns,
          fixed
        } = _ref;
        var $cols;
        var width;
        var minWidth;
        var columnIndex;
        var columnAutoWidth = this.option("columnAutoWidth");
        $tableElement = $tableElement || this.getTableElement();
        if ($tableElement && $tableElement.length && widths) {
          columnIndex = 0;
          $cols = $tableElement.children("colgroup").children("col");
          setWidth($cols, "auto");
          columns = columns || this.getColumns(null, $tableElement);
          for (var i = 0; i < columns.length; i++) {
            if (columnAutoWidth && !fixed) {
              width = columns[i].width;
              if (width && !columns[i].command) {
                width = columns[i].visibleWidth || width;
                width = getWidthStyle(width);
                minWidth = getWidthStyle(columns[i].minWidth || width);
                var $rows = $rows || $tableElement.children().children(".dx-row").not("." + DETAIL_ROW_CLASS);
                for (var rowIndex = 0; rowIndex < $rows.length; rowIndex++) {
                  var row = $rows[rowIndex];
                  var cell = void 0;
                  var visibleIndex = this.getVisibleColumnIndex(i, rowIndex);
                  if (row.classList.contains(GROUP_ROW_CLASS)) {
                    cell = row.querySelector("td[aria-colindex='".concat(visibleIndex + 1, "']:not(.").concat(GROUP_CELL_CLASS, ")"));
                  } else {
                    cell = row.cells[visibleIndex];
                  }
                  if (cell) {
                    setCellWidth(cell, columns[i], width);
                    cell.style.minWidth = minWidth;
                  }
                }
              }
            }
            if (columns[i].colspan) {
              columnIndex += columns[i].colspan;
              continue;
            }
            width = widths[columnIndex];
            if ("adaptiveHidden" === width) {
              width = HIDDEN_COLUMNS_WIDTH;
            }
            if ("number" === typeof width) {
              width = width.toFixed(3) + "px";
            }
            setWidth($cols.eq(columnIndex), isDefined(width) ? width : "auto");
            columnIndex++;
          }
        }
      },
      getCellElements: function(rowIndex) {
        return this._getCellElementsCore(rowIndex);
      },
      _getCellElementsCore: function(rowIndex) {
        var $row = this._getRowElements().eq(rowIndex);
        return $row.children();
      },
      _getCellElement: function(rowIndex, columnIdentifier) {
        var $cell;
        var $cells = this.getCellElements(rowIndex);
        var columnVisibleIndex = this._getVisibleColumnIndex($cells, rowIndex, columnIdentifier);
        if ($cells.length && columnVisibleIndex >= 0) {
          $cell = $cells.eq(columnVisibleIndex);
        }
        if ($cell && $cell.length) {
          return $cell;
        }
      },
      _getRowElement: function(rowIndex) {
        var that = this;
        var $rowElement = renderer_default();
        var $tableElements = that.getTableElements();
        each($tableElements, function(_2, tableElement) {
          $rowElement = $rowElement.add(that._getRowElements(renderer_default(tableElement)).eq(rowIndex));
        });
        if ($rowElement.length) {
          return $rowElement;
        }
      },
      getCellElement: function(rowIndex, columnIdentifier) {
        return getPublicElement(this._getCellElement(rowIndex, columnIdentifier));
      },
      getRowElement: function(rowIndex) {
        var $rows = this._getRowElement(rowIndex);
        var elements = [];
        if ($rows && !getPublicElement($rows).get) {
          for (var i = 0; i < $rows.length; i++) {
            elements.push($rows[i]);
          }
        } else {
          elements = $rows;
        }
        return elements;
      },
      _getVisibleColumnIndex: function($cells, rowIndex, columnIdentifier) {
        if (isString2(columnIdentifier)) {
          var columnIndex = this._columnsController.columnOption(columnIdentifier, "index");
          return this._columnsController.getVisibleIndex(columnIndex);
        }
        return columnIdentifier;
      },
      getColumnElements: function() {
      },
      getColumns: function(rowIndex) {
        return this._columnsController.getVisibleColumns(rowIndex);
      },
      getCell: function(cellPosition, rows) {
        var $rows = rows || this._getRowElements();
        var $cells;
        if ($rows.length > 0 && cellPosition.rowIndex >= 0) {
          if ("virtual" !== this.option("scrolling.mode")) {
            cellPosition.rowIndex = cellPosition.rowIndex < $rows.length ? cellPosition.rowIndex : $rows.length - 1;
          }
          $cells = this.getCellElements(cellPosition.rowIndex);
          if ($cells && $cells.length > 0) {
            return $cells.eq($cells.length > cellPosition.columnIndex ? cellPosition.columnIndex : $cells.length - 1);
          }
        }
      },
      getRowsCount: function() {
        var tableElement = this.getTableElement();
        if (tableElement && 1 === tableElement.length) {
          return tableElement[0].rows.length;
        }
        return 0;
      },
      _getRowElementsCore: function(tableElement) {
        tableElement = tableElement || this.getTableElement();
        if (tableElement) {
          var tBodies = this.option("rowTemplate") && tableElement.find("> tbody." + ROW_CLASS);
          return tBodies && tBodies.length ? tBodies : tableElement.find("> tbody > ." + ROW_CLASS + ", > ." + ROW_CLASS);
        }
        return renderer_default();
      },
      _getRowElements: function(tableElement) {
        return this._getRowElementsCore(tableElement);
      },
      getRowIndex: function($row) {
        return this._getRowElements().index($row);
      },
      getBoundingRect: function() {
      },
      getName: function() {
      },
      setScrollerSpacing: function(width) {
        var $element = this.element();
        var rtlEnabled = this.option("rtlEnabled");
        $element && $element.css({
          paddingLeft: rtlEnabled ? width : "",
          paddingRight: !rtlEnabled ? width : ""
        });
      },
      isScrollbarVisible: function(isHorizontal) {
        var $element = this.element();
        var $tableElement = this._tableElement;
        if ($element && $tableElement) {
          return isHorizontal ? $tableElement.outerWidth() - $element.width() > 0 : $tableElement.outerHeight() - $element.height() > 0;
        }
        return false;
      }
    });
  }
});

// node_modules/devextreme/esm/ui/shared/accessibility.js
function processKeyDown(viewName2, instance, event, action, $mainElement, executeKeyDown) {
  var isHandled = fireKeyDownEvent(instance, event.originalEvent, executeKeyDown);
  if (isHandled) {
    return;
  }
  var keyName = normalizeKeyName(event);
  if ("enter" === keyName || "space" === keyName) {
    saveFocusedElementInfo(event.target, instance);
    action && action({
      event
    });
  } else if ("tab" === keyName) {
    $mainElement.addClass(FOCUS_STATE_CLASS);
  } else {
    selectView(viewName2, instance, event);
  }
}
function saveFocusedElementInfo(target, instance) {
  var $target = renderer_default(target);
  var ariaLabel = $target.attr("aria-label");
  var $activeElements = getActiveAccessibleElements(ariaLabel, instance.element());
  var targetIndex = $activeElements.index($target);
  focusedElementInfo = extend2({}, {
    ariaLabel,
    index: targetIndex
  }, {
    viewInstance: instance
  });
}
function getActiveAccessibleElements(ariaLabel, viewElement) {
  var $viewElement = renderer_default(viewElement);
  var $activeElements;
  if (ariaLabel) {
    $activeElements = $viewElement.find('[aria-label="'.concat(ariaLabel, '"][tabindex]'));
  } else {
    $activeElements = $viewElement.find("[tabindex]");
  }
  return $activeElements;
}
function findFocusedViewElement(viewSelectors) {
  for (var index2 in viewSelectors) {
    var selector = viewSelectors[index2];
    var $focusViewElement = renderer_default(selector).first();
    if ($focusViewElement.length) {
      return $focusViewElement;
    }
  }
}
function fireKeyDownEvent(instance, event, executeAction2) {
  var args = {
    event,
    handled: false
  };
  if (executeAction2) {
    executeAction2(args);
  } else {
    instance._createActionByOption("onKeyDown")(args);
  }
  return args.handled;
}
function onDocumentVisibilityChange() {
  isHiddenFocusing = "visible" === dom_adapter_default.getDocument().visibilityState;
}
function subscribeVisibilityChange() {
  events_engine_default.on(dom_adapter_default.getDocument(), "visibilitychange", onDocumentVisibilityChange);
}
function unsubscribeVisibilityChange() {
  events_engine_default.off(dom_adapter_default.getDocument(), "visibilitychange", onDocumentVisibilityChange);
}
function hiddenFocus(element) {
  isHiddenFocusing = true;
  element.focus();
  isHiddenFocusing = false;
}
function registerKeyboardAction(viewName2, instance, $element, selector, action, executeKeyDown) {
  if (instance.option("useLegacyKeyboardNavigation")) {
    return noop2;
  }
  var getMainElement = () => renderer_default(instance.element());
  var keyDownHandler = (e) => processKeyDown(viewName2, instance, e, action, getMainElement(), executeKeyDown);
  var mouseDownHandler = () => {
    isMouseDown = true;
    getMainElement().removeClass(FOCUS_STATE_CLASS);
  };
  var focusinHandler = () => {
    var needShowOverlay = !isMouseDown && !isHiddenFocusing;
    if (needShowOverlay) {
      getMainElement().addClass(FOCUS_STATE_CLASS);
    }
    isMouseDown = false;
  };
  events_engine_default.on($element, "keydown", selector, keyDownHandler);
  events_engine_default.on($element, "mousedown", selector, mouseDownHandler);
  events_engine_default.on($element, "focusin", selector, focusinHandler);
  return () => {
    events_engine_default.off($element, "keydown", selector, keyDownHandler);
    events_engine_default.off($element, "mousedown", selector, mouseDownHandler);
    events_engine_default.off($element, "focusin", selector, focusinHandler);
  };
}
function restoreFocus(instance) {
  if (!instance.option("useLegacyKeyboardNavigation") && focusedElementInfo) {
    var viewInstance = focusedElementInfo.viewInstance;
    if (viewInstance) {
      var $activeElements = getActiveAccessibleElements(focusedElementInfo.ariaLabel, viewInstance.element());
      var $targetElement = $activeElements.eq(focusedElementInfo.index);
      focusedElementInfo = null;
      events_engine_default.trigger($targetElement, "focus");
    }
  }
}
function selectView(viewName2, instance, event) {
  var keyName = normalizeKeyName(event);
  if (event.ctrlKey && ("upArrow" === keyName || "downArrow" === keyName)) {
    var viewNames = Object.keys(viewItemSelectorMap);
    var viewItemIndex = viewNames.indexOf(viewName2);
    while (viewItemIndex >= 0 && viewItemIndex < viewNames.length) {
      viewItemIndex = "upArrow" === keyName ? --viewItemIndex : ++viewItemIndex;
      var _viewName = viewNames[viewItemIndex];
      var viewSelectors = viewItemSelectorMap[_viewName];
      var $focusViewElement = findFocusedViewElement(viewSelectors);
      if ($focusViewElement && $focusViewElement.length) {
        $focusViewElement.attr("tabindex", instance.option("tabindex") || 0);
        events_engine_default.trigger($focusViewElement, "focus");
        $focusViewElement.removeClass(FOCUS_DISABLED_CLASS);
        break;
      }
    }
  }
}
function setTabIndex(instance, $element) {
  if (!instance.option("useLegacyKeyboardnavigation")) {
    $element.attr("tabindex", instance.option("tabindex") || 0);
  }
}
var FOCUS_STATE_CLASS, FOCUS_DISABLED_CLASS, FOCUSED_ROW_SELECTOR, GRID_ROW_SELECTOR, GRID_CELL_SELECTOR, TREELIST_ROW_SELECTOR, TREELIST_CELL_SELECTOR, viewItemSelectorMap, isMouseDown, isHiddenFocusing, focusedElementInfo;
var init_accessibility = __esm({
  "node_modules/devextreme/esm/ui/shared/accessibility.js"() {
    init_renderer();
    init_events_engine();
    init_utils2();
    init_extend();
    init_dom_adapter();
    init_common();
    FOCUS_STATE_CLASS = "dx-state-focused";
    FOCUS_DISABLED_CLASS = "dx-cell-focus-disabled";
    FOCUSED_ROW_SELECTOR = ".dx-row-focused";
    GRID_ROW_SELECTOR = ".dx-datagrid-rowsview .dx-row";
    GRID_CELL_SELECTOR = "".concat(GRID_ROW_SELECTOR, " > td");
    TREELIST_ROW_SELECTOR = ".dx-treelist-rowsview .dx-row";
    TREELIST_CELL_SELECTOR = "".concat(TREELIST_ROW_SELECTOR, " > td");
    viewItemSelectorMap = {
      groupPanel: [".dx-datagrid-group-panel .dx-group-panel-item[tabindex]"],
      columnHeaders: [".dx-datagrid-headers .dx-header-row > td.dx-datagrid-action", ".dx-treelist-headers .dx-header-row > td.dx-treelist-action"],
      filterRow: [".dx-datagrid-headers .dx-datagrid-filter-row .dx-editor-cell .dx-texteditor-input", ".dx-treelist-headers .dx-treelist-filter-row .dx-editor-cell .dx-texteditor-input"],
      rowsView: ["".concat(FOCUSED_ROW_SELECTOR), "".concat(GRID_ROW_SELECTOR, "[tabindex]"), "".concat(GRID_CELL_SELECTOR, "[tabindex]"), "".concat(GRID_CELL_SELECTOR), "".concat(TREELIST_ROW_SELECTOR, "[tabindex]"), "".concat(TREELIST_CELL_SELECTOR, "[tabindex]"), "".concat(TREELIST_CELL_SELECTOR)],
      footer: [".dx-datagrid-total-footer .dx-datagrid-summary-item", ".dx-treelist-total-footer .dx-treelist-summary-item"],
      filterPanel: [".dx-datagrid-filter-panel .dx-icon-filter", ".dx-treelist-filter-panel .dx-icon-filter"],
      pager: [".dx-datagrid-pager [tabindex]", ".dx-treelist-pager [tabindex]"]
    };
    isMouseDown = false;
    isHiddenFocusing = false;
    focusedElementInfo = null;
  }
});

// node_modules/devextreme/esm/ui/grid_core/ui.grid_core.accessibility.js
var registerKeyboardAction2;
var init_ui_grid_core_accessibility = __esm({
  "node_modules/devextreme/esm/ui/grid_core/ui.grid_core.accessibility.js"() {
    init_accessibility();
    registerKeyboardAction2 = function(viewName2, instance, $element, selector, action) {
      var keyboardController = instance.getController("keyboardNavigation");
      if (instance.option("useLegacyKeyboardNavigation") || keyboardController && !keyboardController.isKeyboardEnabled()) {
        return;
      }
      instance.createAction("onKeyDown");
      registerKeyboardAction(viewName2, instance, $element, selector, action, (args) => {
        instance.executeAction("onKeyDown", args);
      });
    };
  }
});

// node_modules/devextreme/esm/data/errors.js
var errors, errorHandler, handleError;
var init_errors2 = __esm({
  "node_modules/devextreme/esm/data/errors.js"() {
    init_error();
    init_errors();
    errors = error_default(errors_default.ERROR_MESSAGES, {
      E4000: "[DevExpress.data]: {0}",
      E4001: "Unknown aggregating function is detected: '{0}'",
      E4002: "Unsupported OData protocol version is used",
      E4003: "Unknown filter operation is used: {0}",
      E4004: "The thenby() method is called before the sortby() method",
      E4005: "Store requires a key expression for this operation",
      E4006: "ArrayStore 'data' option must be an array",
      E4007: "Compound keys cannot be auto-generated",
      E4008: "Attempt to insert an item with a duplicated key",
      E4009: "Data item cannot be found",
      E4010: "CustomStore does not support creating queries",
      E4011: "Custom Store method is not implemented or is not a function: {0}",
      E4012: "Custom Store method returns an invalid value: {0}",
      E4013: "Local Store requires the 'name' configuration option is specified",
      E4014: "Unknown data type is specified for ODataStore: {0}",
      E4015: "Unknown entity name or alias is used: {0}",
      E4016: "The compileSetter(expr) method is called with 'self' passed as a parameter",
      E4017: "Keys cannot be modified",
      E4018: "The server has returned a non-numeric value in a response to an item count request",
      E4019: "Mixing of group operators inside a single group of filter expression is not allowed",
      E4020: "Unknown store type is detected: {0}",
      E4021: "The server response does not provide the totalCount value",
      E4022: "The server response does not provide the groupCount value",
      E4023: "Could not parse the following XML: {0}",
      E4024: "String function {0} cannot be used with the data field {1} of type {2}.",
      W4000: "Data returned from the server has an incorrect structure",
      W4001: 'The {0} field is listed in both "keyType" and "fieldTypes". The value of "fieldTypes" is used.',
      W4002: "Data loading has failed for some cells due to the following error: {0}"
    });
    errorHandler = null;
    handleError = function(error) {
      var _errorHandler;
      null === (_errorHandler = errorHandler) || void 0 === _errorHandler ? void 0 : _errorHandler(error);
    };
  }
});

// node_modules/devextreme/esm/data/array_query.js
var Iterator, ArrayIterator, WrappedIterator, MapIterator, defaultCompare, SortIterator, compileCriteria, FilterIterator, GroupIterator, SelectIterator, SliceIterator, arrayQueryImpl, array_query_default;
var init_array_query = __esm({
  "node_modules/devextreme/esm/data/array_query.js"() {
    init_class();
    init_type();
    init_iterator();
    init_data();
    init_deferred();
    init_errors2();
    init_utils3();
    Iterator = class_default.inherit({
      toArray: function() {
        var result2 = [];
        this.reset();
        while (this.next()) {
          result2.push(this.current());
        }
        return result2;
      },
      countable: function() {
        return false;
      }
    });
    ArrayIterator = Iterator.inherit({
      ctor: function(array) {
        this.array = array;
        this.index = -1;
      },
      next: function() {
        if (this.index + 1 < this.array.length) {
          this.index++;
          return true;
        }
        return false;
      },
      current: function() {
        return this.array[this.index];
      },
      reset: function() {
        this.index = -1;
      },
      toArray: function() {
        return this.array.slice(0);
      },
      countable: function() {
        return true;
      },
      count: function() {
        return this.array.length;
      }
    });
    WrappedIterator = Iterator.inherit({
      ctor: function(iter) {
        this.iter = iter;
      },
      next: function() {
        return this.iter.next();
      },
      current: function() {
        return this.iter.current();
      },
      reset: function() {
        return this.iter.reset();
      }
    });
    MapIterator = WrappedIterator.inherit({
      ctor: function(iter, mapper) {
        this.callBase(iter);
        this.index = -1;
        this.mapper = mapper;
      },
      current: function() {
        return this.mapper(this.callBase(), this.index);
      },
      next: function() {
        var hasNext = this.callBase();
        if (hasNext) {
          this.index++;
        }
        return hasNext;
      }
    });
    defaultCompare = function(xValue, yValue) {
      xValue = toComparable(xValue);
      yValue = toComparable(yValue);
      if (null === xValue && null !== yValue) {
        return -1;
      }
      if (null !== xValue && null === yValue) {
        return 1;
      }
      if (void 0 === xValue && void 0 !== yValue) {
        return 1;
      }
      if (void 0 !== xValue && void 0 === yValue) {
        return -1;
      }
      if (xValue < yValue) {
        return -1;
      }
      if (xValue > yValue) {
        return 1;
      }
      return 0;
    };
    SortIterator = Iterator.inherit({
      ctor: function(iter, getter, desc, compare2) {
        if (!(iter instanceof MapIterator)) {
          iter = new MapIterator(iter, this._wrap);
        }
        this.iter = iter;
        this.rules = [{
          getter,
          desc,
          compare: compare2
        }];
      },
      thenBy: function(getter, desc, compare2) {
        var result2 = new SortIterator(this.sortedIter || this.iter, getter, desc, compare2);
        if (!this.sortedIter) {
          result2.rules = this.rules.concat(result2.rules);
        }
        return result2;
      },
      next: function() {
        this._ensureSorted();
        return this.sortedIter.next();
      },
      current: function() {
        this._ensureSorted();
        return this.sortedIter.current();
      },
      reset: function() {
        delete this.sortedIter;
      },
      countable: function() {
        return this.sortedIter || this.iter.countable();
      },
      count: function() {
        if (this.sortedIter) {
          return this.sortedIter.count();
        }
        return this.iter.count();
      },
      _ensureSorted: function() {
        var that = this;
        if (that.sortedIter) {
          return;
        }
        each(that.rules, function() {
          this.getter = compileGetter(this.getter);
        });
        that.sortedIter = new MapIterator(new ArrayIterator(this.iter.toArray().sort(function(x, y) {
          return that._compare(x, y);
        })), that._unwrap);
      },
      _wrap: function(record, index2) {
        return {
          index: index2,
          value: record
        };
      },
      _unwrap: function(wrappedItem) {
        return wrappedItem.value;
      },
      _compare: function(x, y) {
        var xIndex = x.index;
        var yIndex = y.index;
        x = x.value;
        y = y.value;
        if (x === y) {
          return xIndex - yIndex;
        }
        for (var i = 0, rulesCount = this.rules.length; i < rulesCount; i++) {
          var rule = this.rules[i];
          var xValue = rule.getter(x);
          var yValue = rule.getter(y);
          var compare2 = rule.compare || defaultCompare;
          var compareResult = compare2(xValue, yValue);
          if (compareResult) {
            return rule.desc ? -compareResult : compareResult;
          }
        }
        return xIndex - yIndex;
      }
    });
    compileCriteria = /* @__PURE__ */ function() {
      var toString = function(value2) {
        return isDefined(value2) ? value2.toString() : "";
      };
      function compileEquals(getter, value2, negate) {
        return function(obj) {
          obj = toComparable(getter(obj));
          var result2 = /* @__PURE__ */ function(value3) {
            return "" === value3 || 0 === value3 || false === value3;
          }(value2) ? obj === value2 : obj == value2;
          if (negate) {
            result2 = !result2;
          }
          return result2;
        };
      }
      return function(crit) {
        if (isFunction(crit)) {
          return crit;
        }
        if (isGroupCriterion(crit)) {
          return function(crit2) {
            var ops = [];
            var isConjunctiveOperator2 = false;
            var isConjunctiveNextOperator = false;
            each(crit2, function() {
              if (Array.isArray(this) || isFunction(this)) {
                if (ops.length > 1 && isConjunctiveOperator2 !== isConjunctiveNextOperator) {
                  throw new errors.Error("E4019");
                }
                ops.push(compileCriteria(this));
                isConjunctiveOperator2 = isConjunctiveNextOperator;
                isConjunctiveNextOperator = true;
              } else {
                isConjunctiveNextOperator = isConjunctiveOperator(this);
              }
            });
            return function(d) {
              var result2 = isConjunctiveOperator2;
              for (var i = 0; i < ops.length; i++) {
                if (ops[i](d) !== isConjunctiveOperator2) {
                  result2 = !isConjunctiveOperator2;
                  break;
                }
              }
              return result2;
            };
          }(crit);
        }
        if (isUnaryOperation(crit)) {
          return function(crit2) {
            var op = crit2[0];
            var criteria = compileCriteria(crit2[1]);
            if ("!" === op) {
              return function(obj) {
                return !criteria(obj);
              };
            }
            throw errors.Error("E4003", op);
          }(crit);
        }
        return function(crit2) {
          crit2 = normalizeBinaryCriterion(crit2);
          var getter = compileGetter(crit2[0]);
          var op = crit2[1];
          var value2 = crit2[2];
          value2 = toComparable(value2);
          switch (op.toLowerCase()) {
            case "=":
              return compileEquals(getter, value2);
            case "<>":
              return compileEquals(getter, value2, true);
            case ">":
              return function(obj) {
                return toComparable(getter(obj)) > value2;
              };
            case "<":
              return function(obj) {
                return toComparable(getter(obj)) < value2;
              };
            case ">=":
              return function(obj) {
                return toComparable(getter(obj)) >= value2;
              };
            case "<=":
              return function(obj) {
                return toComparable(getter(obj)) <= value2;
              };
            case "startswith":
              return function(obj) {
                return 0 === toComparable(toString(getter(obj))).indexOf(value2);
              };
            case "endswith":
              return function(obj) {
                var getterValue = toComparable(toString(getter(obj)));
                var searchValue = toString(value2);
                if (getterValue.length < searchValue.length) {
                  return false;
                }
                var index2 = getterValue.lastIndexOf(value2);
                return -1 !== index2 && index2 === getterValue.length - value2.length;
              };
            case "contains":
              return function(obj) {
                return toComparable(toString(getter(obj))).indexOf(value2) > -1;
              };
            case "notcontains":
              return function(obj) {
                return -1 === toComparable(toString(getter(obj))).indexOf(value2);
              };
          }
          throw errors.Error("E4003", op);
        }(crit);
      };
    }();
    FilterIterator = WrappedIterator.inherit({
      ctor: function(iter, criteria) {
        this.callBase(iter);
        this.criteria = compileCriteria(criteria);
      },
      next: function() {
        while (this.iter.next()) {
          if (this.criteria(this.current())) {
            return true;
          }
        }
        return false;
      }
    });
    GroupIterator = Iterator.inherit({
      ctor: function(iter, getter) {
        this.iter = iter;
        this.getter = getter;
      },
      next: function() {
        this._ensureGrouped();
        return this.groupedIter.next();
      },
      current: function() {
        this._ensureGrouped();
        return this.groupedIter.current();
      },
      reset: function() {
        delete this.groupedIter;
      },
      countable: function() {
        return !!this.groupedIter;
      },
      count: function() {
        return this.groupedIter.count();
      },
      _ensureGrouped: function() {
        if (this.groupedIter) {
          return;
        }
        var hash = {};
        var keys = [];
        var iter = this.iter;
        var getter = compileGetter(this.getter);
        iter.reset();
        while (iter.next()) {
          var current2 = iter.current();
          var key = getter(current2);
          if (key in hash) {
            hash[key].push(current2);
          } else {
            hash[key] = [current2];
            keys.push(key);
          }
        }
        this.groupedIter = new ArrayIterator(map(keys, function(key2) {
          return {
            key: key2,
            items: hash[key2]
          };
        }));
      }
    });
    SelectIterator = WrappedIterator.inherit({
      ctor: function(iter, getter) {
        this.callBase(iter);
        this.getter = compileGetter(getter);
      },
      current: function() {
        return this.getter(this.callBase());
      },
      countable: function() {
        return this.iter.countable();
      },
      count: function() {
        return this.iter.count();
      }
    });
    SliceIterator = WrappedIterator.inherit({
      ctor: function(iter, skip, take) {
        this.callBase(iter);
        this.skip = Math.max(0, skip);
        this.take = Math.max(0, take);
        this.pos = 0;
      },
      next: function() {
        if (this.pos >= this.skip + this.take) {
          return false;
        }
        while (this.pos < this.skip && this.iter.next()) {
          this.pos++;
        }
        this.pos++;
        return this.iter.next();
      },
      reset: function() {
        this.callBase();
        this.pos = 0;
      },
      countable: function() {
        return this.iter.countable();
      },
      count: function() {
        return Math.min(this.iter.count() - this.skip, this.take);
      }
    });
    arrayQueryImpl = function arrayQueryImpl2(iter, queryOptions) {
      queryOptions = queryOptions || {};
      if (!(iter instanceof Iterator)) {
        iter = new ArrayIterator(iter);
      }
      var handleError2 = function(error) {
        var handler = queryOptions.errorHandler;
        if (handler) {
          handler(error);
        }
        handleError(error);
      };
      var aggregateCore = function(aggregator) {
        var d = new Deferred().fail(handleError2);
        var seed;
        var step = aggregator.step;
        var finalize = aggregator.finalize;
        try {
          iter.reset();
          if ("seed" in aggregator) {
            seed = aggregator.seed;
          } else {
            seed = iter.next() ? iter.current() : NaN;
          }
          var accumulator = seed;
          while (iter.next()) {
            accumulator = step(accumulator, iter.current());
          }
          d.resolve(finalize ? finalize(accumulator) : accumulator);
        } catch (x) {
          d.reject(x);
        }
        return d.promise();
      };
      var standardAggregate = function(name2) {
        return aggregateCore(aggregators[name2]);
      };
      var select = function(getter) {
        if (!isFunction(getter) && !Array.isArray(getter)) {
          getter = [].slice.call(arguments);
        }
        return chainQuery(new SelectIterator(iter, getter));
      };
      var selectProp = function(name2) {
        return select(compileGetter(name2));
      };
      function chainQuery(iter2) {
        return arrayQueryImpl2(iter2, queryOptions);
      }
      return {
        toArray: function() {
          return iter.toArray();
        },
        enumerate: function() {
          var d = new Deferred().fail(handleError2);
          try {
            d.resolve(iter.toArray());
          } catch (x) {
            d.reject(x);
          }
          return d.promise();
        },
        sortBy: function(getter, desc, compare2) {
          return chainQuery(new SortIterator(iter, getter, desc, compare2));
        },
        thenBy: function(getter, desc, compare2) {
          if (iter instanceof SortIterator) {
            return chainQuery(iter.thenBy(getter, desc, compare2));
          }
          throw errors.Error("E4004");
        },
        filter: function(criteria) {
          if (!Array.isArray(criteria)) {
            criteria = [].slice.call(arguments);
          }
          return chainQuery(new FilterIterator(iter, criteria));
        },
        slice: function(skip, take) {
          if (void 0 === take) {
            take = Number.MAX_VALUE;
          }
          return chainQuery(new SliceIterator(iter, skip, take));
        },
        select,
        groupBy: function(getter) {
          return chainQuery(new GroupIterator(iter, getter));
        },
        aggregate: function(seed, step, finalize) {
          if (arguments.length < 2) {
            return aggregateCore({
              step: arguments[0]
            });
          }
          return aggregateCore({
            seed,
            step,
            finalize
          });
        },
        count: function() {
          if (iter.countable()) {
            var d = new Deferred().fail(handleError2);
            try {
              d.resolve(iter.count());
            } catch (x) {
              d.reject(x);
            }
            return d.promise();
          }
          return standardAggregate("count");
        },
        sum: function(getter) {
          if (getter) {
            return selectProp(getter).sum();
          }
          return standardAggregate("sum");
        },
        min: function(getter) {
          if (getter) {
            return selectProp(getter).min();
          }
          return standardAggregate("min");
        },
        max: function(getter) {
          if (getter) {
            return selectProp(getter).max();
          }
          return standardAggregate("max");
        },
        avg: function(getter) {
          if (getter) {
            return selectProp(getter).avg();
          }
          return standardAggregate("avg");
        }
      };
    };
    array_query_default = arrayQueryImpl;
  }
});

// node_modules/devextreme/esm/data/store_helper.js
function multiLevelGroup(query2, groupInfo) {
  query2 = query2.groupBy(groupInfo[0].selector);
  if (groupInfo.length > 1) {
    query2 = query2.select(function(g) {
      return extend2({}, g, {
        items: multiLevelGroup(array_query_default(g.items), groupInfo.slice(1)).toArray()
      });
    });
  }
  return query2;
}
function arrangeSortingInfo(groupInfo, sortInfo) {
  var filteredGroup = [];
  each(groupInfo, function(_2, group) {
    var collision = grep(sortInfo, function(sort) {
      return group.selector === sort.selector;
    });
    if (collision.length < 1) {
      filteredGroup.push(group);
    }
  });
  return filteredGroup.concat(sortInfo);
}
function queryByOptions(query2, options2, isCountQuery) {
  options2 = options2 || {};
  var filter = options2.filter;
  if (filter) {
    query2 = query2.filter(filter);
  }
  if (isCountQuery) {
    return query2;
  }
  var sort = options2.sort;
  var select = options2.select;
  var group = options2.group;
  var skip = options2.skip;
  var take = options2.take;
  if (group) {
    group = normalizeSortingInfo(group);
    group.keepInitialKeyOrder = !!options2.group.keepInitialKeyOrder;
  }
  if (sort || group) {
    sort = normalizeSortingInfo(sort || []);
    if (group && !group.keepInitialKeyOrder) {
      sort = arrangeSortingInfo(group, sort);
    }
    each(sort, function(index2) {
      query2 = query2[index2 ? "thenBy" : "sortBy"](this.selector, this.desc, this.compare);
    });
  }
  if (select) {
    query2 = query2.select(select);
  }
  if (group) {
    query2 = multiLevelGroup(query2, group);
  }
  if (take || skip) {
    query2 = query2.slice(skip || 0, take);
  }
  return query2;
}
var store_helper_default;
var init_store_helper = __esm({
  "node_modules/devextreme/esm/data/store_helper.js"() {
    init_common();
    init_extend();
    init_iterator();
    init_array_query();
    init_utils3();
    store_helper_default = {
      multiLevelGroup,
      arrangeSortingInfo,
      queryByOptions
    };
  }
});

// node_modules/devextreme/esm/data/query_adapters.js
var query_adapters_default;
var init_query_adapters = __esm({
  "node_modules/devextreme/esm/data/query_adapters.js"() {
    query_adapters_default = {};
  }
});

// node_modules/devextreme/esm/data/remote_query.js
var remoteQueryImpl, remote_query_default;
var init_remote_query = __esm({
  "node_modules/devextreme/esm/data/remote_query.js"() {
    init_query_adapters();
    init_errors2();
    init_iterator();
    init_type();
    init_deferred();
    init_array_query();
    remoteQueryImpl = function remoteQueryImpl2(url, queryOptions, tasks) {
      tasks = tasks || [];
      queryOptions = queryOptions || {};
      var createTask = function(name2, args) {
        return {
          name: name2,
          args
        };
      };
      var exec = function(executorTask) {
        var d = new Deferred();
        var _adapterFactory;
        var _adapter;
        var _taskQueue;
        var _currentTask;
        var _mergedSortArgs;
        var rejectWithNotify = function(error) {
          var handler = queryOptions.errorHandler;
          if (handler) {
            handler(error);
          }
          handleError(error);
          d.reject(error);
        };
        function mergeSortTask(task) {
          switch (task.name) {
            case "sortBy":
              _mergedSortArgs = [task.args];
              return true;
            case "thenBy":
              if (!_mergedSortArgs) {
                throw errors.Error("E4004");
              }
              _mergedSortArgs.push(task.args);
              return true;
          }
          return false;
        }
        try {
          _adapterFactory = queryOptions.adapter;
          if (!isFunction(_adapterFactory)) {
            _adapterFactory = query_adapters_default[_adapterFactory];
          }
          _adapter = _adapterFactory(queryOptions);
          _taskQueue = [].concat(tasks).concat(executorTask);
          var optimize = _adapter.optimize;
          if (optimize) {
            optimize(_taskQueue);
          }
          while (_taskQueue.length) {
            _currentTask = _taskQueue[0];
            if (!mergeSortTask(_currentTask)) {
              if (_mergedSortArgs) {
                _taskQueue.unshift(createTask("multiSort", [_mergedSortArgs]));
                _mergedSortArgs = null;
                continue;
              }
              if ("enumerate" !== String(_currentTask.name)) {
                if (!_adapter[_currentTask.name] || false === _adapter[_currentTask.name].apply(_adapter, _currentTask.args)) {
                  break;
                }
              }
            }
            _taskQueue.shift();
          }
          !function() {
            var head = _taskQueue[0];
            var unmergedTasks = [];
            if (head && "multiSort" === head.name) {
              _taskQueue.shift();
              each(head.args[0], function() {
                unmergedTasks.push(createTask(unmergedTasks.length ? "thenBy" : "sortBy", this));
              });
            }
            _taskQueue = unmergedTasks.concat(_taskQueue);
          }();
          _adapter.exec(url).done(function(result2, extra) {
            if (!_taskQueue.length) {
              d.resolve(result2, extra);
            } else {
              var clientChain = array_query_default(result2, {
                errorHandler: queryOptions.errorHandler
              });
              each(_taskQueue, function() {
                clientChain = clientChain[this.name].apply(clientChain, this.args);
              });
              clientChain.done(d.resolve).fail(d.reject);
            }
          }).fail(rejectWithNotify);
        } catch (x) {
          rejectWithNotify(x);
        }
        return d.promise();
      };
      var query2 = {};
      each(["sortBy", "thenBy", "filter", "slice", "select", "groupBy"], function() {
        var name2 = String(this);
        query2[name2] = function() {
          return remoteQueryImpl2(url, queryOptions, tasks.concat(createTask(name2, arguments)));
        };
      });
      each(["count", "min", "max", "sum", "avg", "aggregate", "enumerate"], function() {
        var name2 = String(this);
        query2[name2] = function() {
          return exec.call(this, createTask(name2, arguments));
        };
      });
      return query2;
    };
    remote_query_default = remoteQueryImpl;
  }
});

// node_modules/devextreme/esm/data/query_implementation.js
var queryImpl;
var init_query_implementation = __esm({
  "node_modules/devextreme/esm/data/query_implementation.js"() {
    init_array_query();
    init_remote_query();
    queryImpl = {
      array: array_query_default,
      remote: remote_query_default
    };
  }
});

// node_modules/devextreme/esm/data/query.js
var query, query_default;
var init_query = __esm({
  "node_modules/devextreme/esm/data/query.js"() {
    init_query_implementation();
    query = function() {
      var impl = Array.isArray(arguments[0]) ? "array" : "remote";
      return queryImpl[impl].apply(this, arguments);
    };
    query_default = query;
  }
});

// node_modules/devextreme/esm/ui/widget/utils.ink_ripple.js
function showWave(args, config2) {
  var $wave = getWaves(config2.element, args.wavesNumber).eq(config2.wave || DEFAULT_WAVE_INDEX);
  args.hidingTimeout && clearTimeout(args.hidingTimeout);
  hideSelectedWave($wave);
  $wave.css(getWaveStyleConfig(args, config2));
  args.showingTimeout = setTimeout(showingWaveHandler.bind(this, args, $wave), 0);
}
function showingWaveHandler(args, $wave) {
  var durationCss = args.durations.showingScale + "ms";
  $wave.addClass(INKRIPPLE_SHOWING_CLASS).css("transitionDuration", durationCss);
}
function getDurations(useHoldAnimation) {
  return {
    showingScale: useHoldAnimation ? HOLD_ANIMATION_DURATION : ANIMATION_DURATION,
    hidingScale: ANIMATION_DURATION,
    hidingOpacity: ANIMATION_DURATION
  };
}
function hideSelectedWave($wave) {
  $wave.removeClass(INKRIPPLE_HIDING_CLASS).css("transitionDuration", "");
}
function hideWave(args, config2) {
  args.showingTimeout && clearTimeout(args.showingTimeout);
  var $wave = getWaves(config2.element, config2.wavesNumber).eq(config2.wave || DEFAULT_WAVE_INDEX);
  var durations = args.durations;
  var durationCss = durations.hidingScale + "ms, " + durations.hidingOpacity + "ms";
  $wave.addClass(INKRIPPLE_HIDING_CLASS).removeClass(INKRIPPLE_SHOWING_CLASS).css("transitionDuration", durationCss);
  var animationDuration = Math.max(durations.hidingScale, durations.hidingOpacity);
  args.hidingTimeout = setTimeout(hideSelectedWave.bind(this, $wave), animationDuration);
}
var INKRIPPLE_CLASS, INKRIPPLE_WAVE_CLASS, INKRIPPLE_SHOWING_CLASS, INKRIPPLE_HIDING_CLASS, DEFAULT_WAVE_SIZE_COEFFICIENT, MAX_WAVE_SIZE, ANIMATION_DURATION, HOLD_ANIMATION_DURATION, DEFAULT_WAVE_INDEX, initConfig, render, getInkRipple, getWaves, getWaveStyleConfig;
var init_utils_ink_ripple = __esm({
  "node_modules/devextreme/esm/ui/widget/utils.ink_ripple.js"() {
    init_renderer();
    INKRIPPLE_CLASS = "dx-inkripple";
    INKRIPPLE_WAVE_CLASS = "dx-inkripple-wave";
    INKRIPPLE_SHOWING_CLASS = "dx-inkripple-showing";
    INKRIPPLE_HIDING_CLASS = "dx-inkripple-hiding";
    DEFAULT_WAVE_SIZE_COEFFICIENT = 2;
    MAX_WAVE_SIZE = 4e3;
    ANIMATION_DURATION = 300;
    HOLD_ANIMATION_DURATION = 1e3;
    DEFAULT_WAVE_INDEX = 0;
    initConfig = function() {
      var config2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
      var {
        useHoldAnimation,
        waveSizeCoefficient,
        isCentered,
        wavesNumber
      } = config2;
      return {
        waveSizeCoefficient: waveSizeCoefficient || DEFAULT_WAVE_SIZE_COEFFICIENT,
        isCentered: isCentered || false,
        wavesNumber: wavesNumber || 1,
        durations: getDurations(null !== useHoldAnimation && void 0 !== useHoldAnimation ? useHoldAnimation : true)
      };
    };
    render = function(args) {
      var config2 = initConfig(args);
      return {
        showWave: showWave.bind(this, config2),
        hideWave: hideWave.bind(this, config2)
      };
    };
    getInkRipple = function(element) {
      var result2 = element.children("." + INKRIPPLE_CLASS);
      if (0 === result2.length) {
        result2 = renderer_default("<div>").addClass(INKRIPPLE_CLASS).appendTo(element);
      }
      return result2;
    };
    getWaves = function(element, wavesNumber) {
      var inkRipple = getInkRipple(renderer_default(element));
      var result2 = inkRipple.children("." + INKRIPPLE_WAVE_CLASS).toArray();
      for (var i = result2.length; i < wavesNumber; i++) {
        var $currentWave = renderer_default("<div>").appendTo(inkRipple).addClass(INKRIPPLE_WAVE_CLASS);
        result2.push($currentWave[0]);
      }
      return renderer_default(result2);
    };
    getWaveStyleConfig = function(args, config2) {
      var element = renderer_default(config2.element);
      var elementWidth = element.outerWidth();
      var elementHeight = element.outerHeight();
      var elementDiagonal = parseInt(Math.sqrt(elementWidth * elementWidth + elementHeight * elementHeight));
      var waveSize = Math.min(MAX_WAVE_SIZE, parseInt(elementDiagonal * args.waveSizeCoefficient));
      var left;
      var top;
      if (args.isCentered) {
        left = (elementWidth - waveSize) / 2;
        top = (elementHeight - waveSize) / 2;
      } else {
        var event = config2.event;
        var position3 = element.offset();
        var x = event.pageX - position3.left;
        var y = event.pageY - position3.top;
        left = x - waveSize / 2;
        top = y - waveSize / 2;
      }
      return {
        left,
        top,
        height: waveSize,
        width: waveSize
      };
    };
  }
});

// node_modules/devextreme/esm/ui/validation_engine.js
var STATUS, BaseRuleValidator, RequiredRuleValidator, NumericRuleValidator, RangeRuleValidator, StringLengthRuleValidator, CustomRuleValidator, AsyncRuleValidator, CompareRuleValidator, PatternRuleValidator, EmailRuleValidator, rulesValidators, GroupConfig, ValidationEngine, validation_engine_default;
var init_validation_engine = __esm({
  "node_modules/devextreme/esm/ui/validation_engine.js"() {
    init_class();
    init_extend();
    init_array();
    init_iterator();
    init_events_strategy();
    init_errors();
    init_common();
    init_type();
    init_number3();
    init_message();
    init_promise();
    init_deferred();
    STATUS = {
      valid: "valid",
      invalid: "invalid",
      pending: "pending"
    };
    BaseRuleValidator = class {
      constructor() {
        this.NAME = "base";
      }
      defaultMessage(value2) {
        return message_default.getFormatter("validation-".concat(this.NAME))(value2);
      }
      defaultFormattedMessage(value2) {
        return message_default.getFormatter("validation-".concat(this.NAME, "-formatted"))(value2);
      }
      _isValueEmpty(value2) {
        return !rulesValidators.required.validate(value2, {});
      }
      validate(value2, rule) {
        var valueArray = Array.isArray(value2) ? value2 : [value2];
        var result2 = true;
        if (valueArray.length) {
          valueArray.every((itemValue) => {
            result2 = this._validate(itemValue, rule);
            return result2;
          });
        } else {
          result2 = this._validate(null, rule);
        }
        return result2;
      }
    };
    RequiredRuleValidator = class extends BaseRuleValidator {
      constructor() {
        super();
        this.NAME = "required";
      }
      _validate(value2, rule) {
        if (!isDefined(value2)) {
          return false;
        }
        if (false === value2) {
          return false;
        }
        value2 = String(value2);
        if (rule.trim || !isDefined(rule.trim)) {
          value2 = value2.trim();
        }
        return "" !== value2;
      }
    };
    NumericRuleValidator = class extends BaseRuleValidator {
      constructor() {
        super();
        this.NAME = "numeric";
      }
      _validate(value2, rule) {
        if (false !== rule.ignoreEmptyValue && this._isValueEmpty(value2)) {
          return true;
        }
        if (rule.useCultureSettings && isString2(value2)) {
          return !isNaN(number_default2.parse(value2));
        } else {
          return isNumeric(value2);
        }
      }
    };
    RangeRuleValidator = class extends BaseRuleValidator {
      constructor() {
        super();
        this.NAME = "range";
      }
      _validate(value2, rule) {
        if (false !== rule.ignoreEmptyValue && this._isValueEmpty(value2)) {
          return true;
        }
        var validNumber = rulesValidators.numeric.validate(value2, rule);
        var validValue = isDefined(value2) && "" !== value2;
        var number2 = validNumber ? parseFloat(value2) : validValue && value2.valueOf();
        var min = rule.min;
        var max = rule.max;
        if (!(validNumber || isDate(value2)) && !validValue) {
          return false;
        }
        if (isDefined(min)) {
          if (isDefined(max)) {
            return number2 >= min && number2 <= max;
          }
          return number2 >= min;
        } else if (isDefined(max)) {
          return number2 <= max;
        } else {
          throw errors_default.Error("E0101");
        }
      }
    };
    StringLengthRuleValidator = class extends BaseRuleValidator {
      constructor() {
        super();
        this.NAME = "stringLength";
      }
      _validate(value2, rule) {
        var _value;
        value2 = String(null !== (_value = value2) && void 0 !== _value ? _value : "");
        if (rule.trim || !isDefined(rule.trim)) {
          value2 = value2.trim();
        }
        if (rule.ignoreEmptyValue && this._isValueEmpty(value2)) {
          return true;
        }
        return rulesValidators.range.validate(value2.length, extend2({}, rule));
      }
    };
    CustomRuleValidator = class extends BaseRuleValidator {
      constructor() {
        super();
        this.NAME = "custom";
      }
      validate(value2, rule) {
        if (rule.ignoreEmptyValue && this._isValueEmpty(value2)) {
          return true;
        }
        var validator = rule.validator;
        var dataGetter = validator && isFunction(validator.option) && validator.option("dataGetter");
        var extraParams = isFunction(dataGetter) && dataGetter();
        var params = {
          value: value2,
          validator,
          rule
        };
        if (extraParams) {
          extend2(params, extraParams);
        }
        return rule.validationCallback(params);
      }
    };
    AsyncRuleValidator = class extends CustomRuleValidator {
      constructor() {
        super();
        this.NAME = "async";
      }
      validate(value2, rule) {
        if (!isDefined(rule.reevaluate)) {
          extend2(rule, {
            reevaluate: true
          });
        }
        if (rule.ignoreEmptyValue && this._isValueEmpty(value2)) {
          return true;
        }
        var validator = rule.validator;
        var dataGetter = validator && isFunction(validator.option) && validator.option("dataGetter");
        var extraParams = isFunction(dataGetter) && dataGetter();
        var params = {
          value: value2,
          validator,
          rule
        };
        if (extraParams) {
          extend2(params, extraParams);
        }
        var callbackResult = rule.validationCallback(params);
        if (!isPromise(callbackResult)) {
          throw errors_default.Error("E0103");
        }
        return this._getWrappedPromise(fromPromise(callbackResult).promise());
      }
      _getWrappedPromise(promise2) {
        var deferred = new Deferred();
        promise2.then(function(res) {
          deferred.resolve(res);
        }, function(err) {
          var res = {
            isValid: false
          };
          if (isDefined(err)) {
            if (isString2(err)) {
              res.message = err;
            } else if (isObject2(err) && isDefined(err.message) && isString2(err.message)) {
              res.message = err.message;
            }
          }
          deferred.resolve(res);
        });
        return deferred.promise();
      }
    };
    CompareRuleValidator = class extends BaseRuleValidator {
      constructor() {
        super();
        this.NAME = "compare";
      }
      _validate(value2, rule) {
        if (!rule.comparisonTarget) {
          throw errors_default.Error("E0102");
        }
        if (rule.ignoreEmptyValue && this._isValueEmpty(value2)) {
          return true;
        }
        extend2(rule, {
          reevaluate: true
        });
        var otherValue = rule.comparisonTarget();
        var type2 = rule.comparisonType || "==";
        switch (type2) {
          case "==":
            return value2 == otherValue;
          case "!=":
            return value2 != otherValue;
          case "===":
            return value2 === otherValue;
          case "!==":
            return value2 !== otherValue;
          case ">":
            return value2 > otherValue;
          case ">=":
            return value2 >= otherValue;
          case "<":
            return value2 < otherValue;
          case "<=":
            return value2 <= otherValue;
        }
      }
    };
    PatternRuleValidator = class extends BaseRuleValidator {
      constructor() {
        super();
        this.NAME = "pattern";
      }
      _validate(value2, rule) {
        if (false !== rule.ignoreEmptyValue && this._isValueEmpty(value2)) {
          return true;
        }
        var pattern = rule.pattern;
        if (isString2(pattern)) {
          pattern = new RegExp(pattern);
        }
        return pattern.test(value2);
      }
    };
    EmailRuleValidator = class extends BaseRuleValidator {
      constructor() {
        super();
        this.NAME = "email";
      }
      _validate(value2, rule) {
        if (false !== rule.ignoreEmptyValue && this._isValueEmpty(value2)) {
          return true;
        }
        return rulesValidators.pattern.validate(value2, extend2({}, rule, {
          pattern: /^[\d\w._-]+@[\d\w._-]+\.[\w]+$/i
        }));
      }
    };
    rulesValidators = {
      required: new RequiredRuleValidator(),
      numeric: new NumericRuleValidator(),
      range: new RangeRuleValidator(),
      stringLength: new StringLengthRuleValidator(),
      custom: new CustomRuleValidator(),
      async: new AsyncRuleValidator(),
      compare: new CompareRuleValidator(),
      pattern: new PatternRuleValidator(),
      email: new EmailRuleValidator()
    };
    GroupConfig = class_default.inherit({
      ctor(group) {
        this.group = group;
        this.validators = [];
        this._pendingValidators = [];
        this._onValidatorStatusChanged = this._onValidatorStatusChanged.bind(this);
        this._resetValidationInfo();
        this._eventsStrategy = new EventsStrategy(this);
      },
      validate() {
        var result2 = {
          isValid: true,
          brokenRules: [],
          validators: [],
          status: STATUS.valid,
          complete: null
        };
        this._unsubscribeFromAllChangeEvents();
        this._pendingValidators = [];
        this._resetValidationInfo();
        each(this.validators, (_2, validator) => {
          var validatorResult = validator.validate();
          result2.isValid = result2.isValid && validatorResult.isValid;
          if (validatorResult.brokenRules) {
            result2.brokenRules = result2.brokenRules.concat(validatorResult.brokenRules);
          }
          result2.validators.push(validator);
          if (validatorResult.status === STATUS.pending) {
            this._addPendingValidator(validator);
          }
          this._subscribeToChangeEvents(validator);
        });
        if (this._pendingValidators.length) {
          result2.status = STATUS.pending;
        } else {
          result2.status = result2.isValid ? STATUS.valid : STATUS.invalid;
          this._unsubscribeFromAllChangeEvents();
          this._raiseValidatedEvent(result2);
        }
        this._updateValidationInfo(result2);
        return extend2({}, this._validationInfo.result);
      },
      _subscribeToChangeEvents(validator) {
        validator.on("validating", this._onValidatorStatusChanged);
        validator.on("validated", this._onValidatorStatusChanged);
      },
      _unsubscribeFromChangeEvents(validator) {
        validator.off("validating", this._onValidatorStatusChanged);
        validator.off("validated", this._onValidatorStatusChanged);
      },
      _unsubscribeFromAllChangeEvents() {
        each(this.validators, (_2, validator) => {
          this._unsubscribeFromChangeEvents(validator);
        });
      },
      _updateValidationInfo(result2) {
        this._validationInfo.result = result2;
        if (result2.status !== STATUS.pending) {
          return;
        }
        if (!this._validationInfo.deferred) {
          this._validationInfo.deferred = new Deferred();
          this._validationInfo.result.complete = this._validationInfo.deferred.promise();
        }
      },
      _addPendingValidator(validator) {
        var foundValidator = grep(this._pendingValidators, function(val) {
          return val === validator;
        })[0];
        if (!foundValidator) {
          this._pendingValidators.push(validator);
        }
      },
      _removePendingValidator(validator) {
        var index2 = inArray(validator, this._pendingValidators);
        if (index2 >= 0) {
          this._pendingValidators.splice(index2, 1);
        }
      },
      _orderBrokenRules(brokenRules) {
        var orderedRules = [];
        each(this.validators, function(_2, validator) {
          var foundRules = grep(brokenRules, function(rule) {
            return rule.validator === validator;
          });
          if (foundRules.length) {
            orderedRules = orderedRules.concat(foundRules);
          }
        });
        return orderedRules;
      },
      _updateBrokenRules(result2) {
        if (!this._validationInfo.result) {
          return;
        }
        var brokenRules = this._validationInfo.result.brokenRules;
        var rules = grep(brokenRules, function(rule) {
          return rule.validator !== result2.validator;
        });
        if (result2.brokenRules) {
          brokenRules = rules.concat(result2.brokenRules);
        }
        this._validationInfo.result.brokenRules = this._orderBrokenRules(brokenRules);
      },
      _onValidatorStatusChanged(result2) {
        if (result2.status === STATUS.pending) {
          this._addPendingValidator(result2.validator);
          return;
        }
        this._resolveIfComplete(result2);
      },
      _resolveIfComplete(result2) {
        this._removePendingValidator(result2.validator);
        this._updateBrokenRules(result2);
        if (!this._pendingValidators.length) {
          this._unsubscribeFromAllChangeEvents();
          if (!this._validationInfo.result) {
            return;
          }
          this._validationInfo.result.status = 0 === this._validationInfo.result.brokenRules.length ? STATUS.valid : STATUS.invalid;
          this._validationInfo.result.isValid = this._validationInfo.result.status === STATUS.valid;
          var res = extend2({}, this._validationInfo.result, {
            complete: null
          });
          var deferred = this._validationInfo.deferred;
          this._validationInfo.deferred = null;
          this._raiseValidatedEvent(res);
          deferred && setTimeout(() => {
            deferred.resolve(res);
          });
        }
      },
      _raiseValidatedEvent(result2) {
        this._eventsStrategy.fireEvent("validated", [result2]);
      },
      _resetValidationInfo() {
        this._validationInfo = {
          result: null,
          deferred: null
        };
      },
      _synchronizeValidationInfo() {
        if (this._validationInfo.result) {
          this._validationInfo.result.validators = this.validators;
        }
      },
      removeRegisteredValidator(validator) {
        var index2 = inArray(validator, this.validators);
        if (index2 > -1) {
          this.validators.splice(index2, 1);
          this._synchronizeValidationInfo();
          this._resolveIfComplete({
            validator
          });
        }
      },
      registerValidator(validator) {
        if (inArray(validator, this.validators) < 0) {
          this.validators.push(validator);
          this._synchronizeValidationInfo();
        }
      },
      reset() {
        each(this.validators, function(_2, validator) {
          validator.reset();
        });
        this._pendingValidators = [];
        this._resetValidationInfo();
      },
      on(eventName, eventHandler) {
        this._eventsStrategy.on(eventName, eventHandler);
        return this;
      },
      off(eventName, eventHandler) {
        this._eventsStrategy.off(eventName, eventHandler);
        return this;
      }
    });
    ValidationEngine = {
      groups: [],
      getGroupConfig(group) {
        var result2 = grep(this.groups, function(config2) {
          return config2.group === group;
        });
        if (result2.length) {
          return result2[0];
        }
      },
      findGroup($element, model) {
        var $dxGroup = $element.parents(".dx-validationgroup").first();
        if ($dxGroup.length) {
          return $dxGroup.dxValidationGroup("instance");
        }
        return model;
      },
      initGroups() {
        this.groups = [];
        this.addGroup();
      },
      addGroup(group) {
        var config2 = this.getGroupConfig(group);
        if (!config2) {
          config2 = new GroupConfig(group);
          this.groups.push(config2);
        }
        return config2;
      },
      removeGroup(group) {
        var config2 = this.getGroupConfig(group);
        var index2 = inArray(config2, this.groups);
        if (index2 > -1) {
          this.groups.splice(index2, 1);
        }
        return config2;
      },
      _setDefaultMessage(info) {
        var {
          rule,
          validator,
          name: name2
        } = info;
        if (!isDefined(rule.message)) {
          if (validator.defaultFormattedMessage && isDefined(name2)) {
            rule.message = validator.defaultFormattedMessage(name2);
          } else {
            rule.message = validator.defaultMessage();
          }
        }
      },
      _addBrokenRule(info) {
        var {
          result: result2,
          rule
        } = info;
        if (!result2.brokenRule) {
          result2.brokenRule = rule;
        }
        if (!result2.brokenRules) {
          result2.brokenRules = [];
        }
        result2.brokenRules.push(rule);
      },
      validate(value2, rules, name2) {
        var _rules$;
        var result2 = {
          name: name2,
          value: value2,
          brokenRule: null,
          brokenRules: null,
          isValid: true,
          validationRules: rules,
          pendingRules: null,
          status: STATUS.valid,
          complete: null
        };
        var validator = null === rules || void 0 === rules ? void 0 : null === (_rules$ = rules[0]) || void 0 === _rules$ ? void 0 : _rules$.validator;
        var asyncRuleItems = [];
        each(rules || [], (_2, rule) => {
          var ruleValidator = rulesValidators[rule.type];
          var ruleValidationResult;
          if (ruleValidator) {
            if (isDefined(rule.isValid) && rule.value === value2 && !rule.reevaluate) {
              if (!rule.isValid) {
                result2.isValid = false;
                this._addBrokenRule({
                  result: result2,
                  rule
                });
                return false;
              }
              return true;
            }
            rule.value = value2;
            if ("async" === rule.type) {
              asyncRuleItems.push({
                rule,
                ruleValidator
              });
              return true;
            }
            ruleValidationResult = ruleValidator.validate(value2, rule);
            rule.isValid = ruleValidationResult;
            if (!ruleValidationResult) {
              result2.isValid = false;
              this._setDefaultMessage({
                rule,
                validator: ruleValidator,
                name: name2
              });
              this._addBrokenRule({
                result: result2,
                rule
              });
            }
            if (!rule.isValid) {
              return false;
            }
          } else {
            throw errors_default.Error("E0100");
          }
        });
        if (result2.isValid && !result2.brokenRules && asyncRuleItems.length) {
          result2 = this._validateAsyncRules({
            value: value2,
            items: asyncRuleItems,
            result: result2,
            name: name2
          });
        }
        this._synchronizeGroupValidationInfo(validator, result2);
        result2.status = result2.pendingRules ? STATUS.pending : result2.isValid ? STATUS.valid : STATUS.invalid;
        return result2;
      },
      _synchronizeGroupValidationInfo(validator, result2) {
        var _result$brokenRules;
        if (!validator) {
          return;
        }
        var groupConfig = ValidationEngine.getGroupConfig(validator._validationGroup);
        groupConfig._updateBrokenRules.call(groupConfig, {
          validator,
          brokenRules: null !== (_result$brokenRules = result2.brokenRules) && void 0 !== _result$brokenRules ? _result$brokenRules : []
        });
      },
      _validateAsyncRules(_ref) {
        var {
          result: result2,
          value: value2,
          items,
          name: name2
        } = _ref;
        var asyncResults = [];
        each(items, (_2, item) => {
          var validateResult = item.ruleValidator.validate(value2, item.rule);
          if (!isPromise(validateResult)) {
            this._updateRuleConfig({
              rule: item.rule,
              ruleResult: this._getPatchedRuleResult(validateResult),
              validator: item.ruleValidator,
              name: name2
            });
          } else {
            if (!result2.pendingRules) {
              result2.pendingRules = [];
            }
            result2.pendingRules.push(item.rule);
            var asyncResult = validateResult.then((res) => {
              var ruleResult = this._getPatchedRuleResult(res);
              this._updateRuleConfig({
                rule: item.rule,
                ruleResult,
                validator: item.ruleValidator,
                name: name2
              });
              return ruleResult;
            });
            asyncResults.push(asyncResult);
          }
        });
        if (asyncResults.length) {
          result2.complete = promise_default.all(asyncResults).then((values) => this._getAsyncRulesResult({
            result: result2,
            values
          }));
        }
        return result2;
      },
      _updateRuleConfig(_ref2) {
        var {
          rule,
          ruleResult,
          validator,
          name: name2
        } = _ref2;
        rule.isValid = ruleResult.isValid;
        if (!ruleResult.isValid) {
          if (isDefined(ruleResult.message) && isString2(ruleResult.message) && ruleResult.message.length) {
            rule.message = ruleResult.message;
          } else {
            this._setDefaultMessage({
              rule,
              validator,
              name: name2
            });
          }
        }
      },
      _getPatchedRuleResult(ruleResult) {
        var result2;
        if (isObject2(ruleResult)) {
          result2 = extend2({}, ruleResult);
          if (!isDefined(result2.isValid)) {
            result2.isValid = true;
          }
        } else {
          result2 = {
            isValid: isBoolean(ruleResult) ? ruleResult : true
          };
        }
        return result2;
      },
      _getAsyncRulesResult(_ref3) {
        var {
          values,
          result: result2
        } = _ref3;
        each(values, (index2, val) => {
          if (false === val.isValid) {
            result2.isValid = val.isValid;
            var rule = result2.pendingRules[index2];
            this._addBrokenRule({
              result: result2,
              rule
            });
          }
        });
        result2.pendingRules = null;
        result2.complete = null;
        result2.status = result2.isValid ? STATUS.valid : STATUS.invalid;
        return result2;
      },
      registerValidatorInGroup(group, validator) {
        var groupConfig = ValidationEngine.addGroup(group);
        groupConfig.registerValidator.call(groupConfig, validator);
      },
      _shouldRemoveGroup(group, validatorsInGroup) {
        var isDefaultGroup = void 0 === group;
        var isValidationGroupInstance = group && "dxValidationGroup" === group.NAME;
        return !isDefaultGroup && !isValidationGroupInstance && !validatorsInGroup.length;
      },
      removeRegisteredValidator(group, validator) {
        var config2 = ValidationEngine.getGroupConfig(group);
        if (config2) {
          config2.removeRegisteredValidator.call(config2, validator);
          var validatorsInGroup = config2.validators;
          if (this._shouldRemoveGroup(group, validatorsInGroup)) {
            this.removeGroup(group);
          }
        }
      },
      initValidationOptions(options2) {
        var initedOptions = {};
        if (options2) {
          ["isValid", "validationStatus", "validationError", "validationErrors"].forEach((prop) => {
            if (prop in options2) {
              extend2(initedOptions, this.synchronizeValidationOptions({
                name: prop,
                value: options2[prop]
              }, options2));
            }
          });
        }
        return initedOptions;
      },
      synchronizeValidationOptions(_ref4, options2) {
        var {
          name: name2,
          value: value2
        } = _ref4;
        switch (name2) {
          case "validationStatus":
            var isValid = value2 === STATUS.valid || value2 === STATUS.pending;
            return options2.isValid !== isValid ? {
              isValid
            } : {};
          case "isValid":
            var {
              validationStatus
            } = options2;
            var newStatus = validationStatus;
            if (value2 && validationStatus === STATUS.invalid) {
              newStatus = STATUS.valid;
            } else if (!value2 && validationStatus !== STATUS.invalid) {
              newStatus = STATUS.invalid;
            }
            return newStatus !== validationStatus ? {
              validationStatus: newStatus
            } : {};
          case "validationErrors":
            var validationError = !value2 || !value2.length ? null : value2[0];
            return options2.validationError !== validationError ? {
              validationError
            } : {};
          case "validationError":
            var {
              validationErrors
            } = options2;
            if (!value2 && validationErrors) {
              return {
                validationErrors: null
              };
            } else if (value2 && !validationErrors) {
              return {
                validationErrors: [value2]
              };
            } else if (value2 && validationErrors && value2 !== validationErrors[0]) {
              validationErrors[0] = value2;
              return {
                validationErrors: validationErrors.slice()
              };
            }
        }
        return {};
      },
      validateGroup(group) {
        var groupConfig = ValidationEngine.getGroupConfig(group);
        if (!groupConfig) {
          throw errors_default.Error("E0110");
        }
        return groupConfig.validate();
      },
      resetGroup(group) {
        var groupConfig = ValidationEngine.getGroupConfig(group);
        if (!groupConfig) {
          throw errors_default.Error("E0110");
        }
        return groupConfig.reset();
      }
    };
    ValidationEngine.initGroups();
    validation_engine_default = ValidationEngine;
  }
});

// node_modules/devextreme/esm/core/utils/icon.js
var ICON_CLASS, SVG_ICON_CLASS, getImageSourceType, getImageContainer;
var init_icon = __esm({
  "node_modules/devextreme/esm/core/utils/icon.js"() {
    init_renderer();
    ICON_CLASS = "dx-icon";
    SVG_ICON_CLASS = "dx-svg-icon";
    getImageSourceType = (source) => {
      if (!source || "string" !== typeof source) {
        return false;
      }
      if (/^\s*<svg[^>]*>(.|\r?\n)*?<\/svg>\s*$/i.test(source)) {
        return "svg";
      }
      if (/data:.*base64|\.|[^<\s]\//.test(source)) {
        return "image";
      }
      if (/^[\w-_]+$/.test(source)) {
        return "dxIcon";
      }
      if (/^\s?([\w-_]\s?)+$/.test(source)) {
        return "fontIcon";
      }
      return false;
    };
    getImageContainer = (source) => {
      switch (getImageSourceType(source)) {
        case "image":
          return renderer_default("<img>").attr("src", source).addClass(ICON_CLASS);
        case "fontIcon":
          return renderer_default("<i>").addClass("".concat(ICON_CLASS, " ").concat(source));
        case "dxIcon":
          return renderer_default("<i>").addClass("".concat(ICON_CLASS, " ").concat(ICON_CLASS, "-").concat(source));
        case "svg":
          return renderer_default("<i>").addClass("".concat(ICON_CLASS, " ").concat(SVG_ICON_CLASS)).append(source);
        default:
          return null;
      }
    };
  }
});

// node_modules/devextreme/esm/ui/button.js
var ANONYMOUS_TEMPLATE_NAME3, Button, button_default;
var init_button = __esm({
  "node_modules/devextreme/esm/ui/button.js"() {
    init_renderer();
    init_devices();
    init_utils_ink_ripple();
    init_component_registrator();
    init_themes();
    init_action();
    init_validation_engine();
    init_ui_widget();
    init_short();
    init_extend();
    init_function_template();
    init_icon();
    init_element();
    ANONYMOUS_TEMPLATE_NAME3 = "content";
    Button = class extends ui_widget_default {
      constructor() {
        super(...arguments);
        this._feedbackHideTimeout = 100;
      }
      _$content() {
        return this.$element().find(".dx-button-content");
      }
      _$submitInput() {
        return this.$element().find(".dx-button-submit-input");
      }
      _attachActiveEvents(active2, inactive) {
        var $el = this._eventBindingTarget();
        var selector = this._activeStateUnit;
        active.off($el, {
          namespace: "inkRipple",
          selector
        });
        active.on($el, new Action(active2), new Action(inactive, {
          excludeValidators: ["disabled", "readOnly"]
        }), {
          showTimeout: this._feedbackShowTimeout,
          hideTimeout: this._feedbackHideTimeout,
          selector,
          namespace: "inkRipple"
        });
      }
      _defaultOptionsRules() {
        return super._defaultOptionsRules().concat([{
          device: () => "desktop" === devices_default.real().deviceType && !devices_default.isSimulator(),
          options: {
            focusStateEnabled: true
          }
        }, {
          device: () => isMaterial(current()),
          options: {
            useInkRipple: true
          }
        }]);
      }
      _executeClickAction(event) {
        this._clickAction({
          validationGroup: this._validationGroupConfig,
          event
        });
      }
      _findGroup() {
        var $element = this.$element();
        var model = this._modelByElement($element);
        var {
          validationGroup
        } = this.option();
        return validationGroup || validation_engine_default.findGroup($element, model);
      }
      _getContentData() {
        var {
          icon,
          text,
          type: type2,
          _templateData
        } = this.option();
        return extend2({
          icon: "back" === type2 && !icon ? "back" : icon,
          text
        }, _templateData);
      }
      _getDefaultOptions() {
        return extend2(super._getDefaultOptions(), {
          hoverStateEnabled: true,
          onClick: null,
          type: "normal",
          text: "",
          icon: "",
          iconPosition: "left",
          validationGroup: void 0,
          activeStateEnabled: true,
          template: "content",
          useSubmitBehavior: false,
          useInkRipple: false,
          _templateData: {},
          stylingMode: "contained"
        });
      }
      _getSubmitAction() {
        var needValidate = true;
        var validationStatus = "valid";
        return this._createAction((_ref) => {
          var {
            event
          } = _ref;
          if (needValidate) {
            var validationGroup = this._validationGroupConfig;
            if (validationGroup) {
              var {
                status,
                complete
              } = validationGroup.validate();
              validationStatus = status;
              if ("pending" === status) {
                needValidate = false;
                this.option("disabled", true);
                complete.then((_ref2) => {
                  var {
                    status: status2
                  } = _ref2;
                  this.option("disabled", false);
                  validationStatus = status2;
                  "valid" === validationStatus && this._submitInput().click();
                  needValidate = true;
                });
              }
            }
          }
          "valid" !== validationStatus && event.preventDefault();
          event.stopPropagation();
        });
      }
      _initMarkup() {
        this.$element().addClass("dx-button");
        this._renderType();
        this._renderStylingMode();
        this._renderInkRipple();
        this._renderClick();
        this._updateAriaLabel();
        super._initMarkup();
        this._updateContent();
        this.setAria("role", "button");
      }
      _getAnonymousTemplateName() {
        return ANONYMOUS_TEMPLATE_NAME3;
      }
      _initTemplates() {
        this._templateManager.addDefaultTemplates({
          content: new FunctionTemplate((_ref3) => {
            var {
              model = {},
              container
            } = _ref3;
            var {
              text,
              icon
            } = model;
            var {
              iconPosition
            } = this.option();
            var $icon = getImageContainer(icon);
            var $textContainer = text && renderer_default("<span>").text(text).addClass("dx-button-text");
            var $container = renderer_default(container);
            $container.append($textContainer);
            if ("left" === iconPosition) {
              $container.prepend($icon);
            } else {
              $icon.addClass("dx-icon-right");
              $container.append($icon);
            }
          })
        });
        super._initTemplates();
      }
      _optionChanged(args) {
        var {
          name: name2
        } = args;
        switch (name2) {
          case "onClick":
            this._updateClick();
            break;
          case "icon":
          case "text":
            this._updateContent();
            this._updateAriaLabel();
            break;
          case "type":
            this._updateType();
            this._updateContent();
            break;
          case "_templateData":
            break;
          case "template":
          case "iconPosition":
            this._updateContent();
            break;
          case "stylingMode":
            this._updateStylingMode();
            break;
          case "useSubmitBehavior":
            this._updateSubmitInput();
            break;
          case "useInkRipple":
            this._invalidate();
            break;
          default:
            super._optionChanged(args);
        }
      }
      _renderClick() {
        var $el = this.$element();
        dxClick.off($el, {
          namespace: this.NAME
        });
        dxClick.on($el, (event) => this._executeClickAction(event), {
          namespace: this.NAME
        });
        this._updateClick();
      }
      _renderInkRipple() {
        var {
          text,
          icon,
          type: type2,
          useInkRipple
        } = this.option();
        if (useInkRipple) {
          var isOnlyIconButton = !text && icon || "back" === type2;
          var _inkRipple = render(isOnlyIconButton ? {
            waveSizeCoefficient: 1,
            useHoldAnimation: false,
            isCentered: true
          } : {});
          var changeWaveVisibility = (event, visible2) => {
            var {
              activeStateEnabled,
              useInkRipple: useInkRipple2
            } = this.option();
            if (useInkRipple2 && activeStateEnabled && !this._disposed) {
              var config2 = {
                element: this._$content(),
                event
              };
              visible2 ? _inkRipple.showWave(config2) : _inkRipple.hideWave(config2);
            }
          };
          this._attachActiveEvents((_ref4) => {
            var {
              event
            } = _ref4;
            return changeWaveVisibility(event, true);
          }, (_ref5) => {
            var {
              event
            } = _ref5;
            return changeWaveVisibility(event);
          });
        }
      }
      _renderStylingMode() {
        var $element = this.$element();
        var {
          stylingMode
        } = this.option();
        if (-1 === ["contained", "text", "outlined"].indexOf(stylingMode)) {
          stylingMode = this._getDefaultOptions().stylingMode;
        }
        $element.addClass("dx-button-mode-".concat(stylingMode));
      }
      _renderSubmitInput() {
        var {
          useSubmitBehavior
        } = this.option();
        if (useSubmitBehavior) {
          var submitAction = this._getSubmitAction();
          var $content = this._$content();
          renderer_default("<input>").attr("type", "submit").attr("tabindex", -1).addClass("dx-button-submit-input").appendTo($content);
          click.on(this._$submitInput(), (event) => submitAction({
            event
          }));
        }
      }
      _renderType() {
        var {
          type: type2
        } = this.option();
        var $element = this.$element();
        type2 && $element.addClass("dx-button-".concat(type2));
      }
      _submitInput() {
        return this._$submitInput().get(0);
      }
      _supportedKeys() {
        var click2 = (e) => {
          e.preventDefault();
          this._executeClickAction(e);
        };
        return extend2(super._supportedKeys(), {
          space: click2,
          enter: click2
        });
      }
      _updateAriaLabel() {
        var ariaTarget = this._getAriaTarget();
        var {
          icon,
          text
        } = this.option();
        if (!text) {
          if ("image" === getImageSourceType(icon)) {
            icon = -1 === icon.indexOf("base64") ? icon.replace(/.+\/([^.]+)\..+$/, "$1") : "Base64";
          }
          text = icon || "";
        }
        ariaTarget.attr("aria-label", text || null);
      }
      _updateClick() {
        this._clickAction = this._createActionByOption("onClick", {
          excludeValidators: ["readOnly"],
          afterExecute: () => {
            var {
              useSubmitBehavior
            } = this.option();
            useSubmitBehavior && setTimeout(() => this._submitInput().click());
          }
        });
      }
      _updateContent() {
        var $element = this.$element();
        var $content = this._$content();
        var data2 = this._getContentData();
        var {
          template,
          iconPosition
        } = this.option();
        var {
          icon,
          text
        } = data2;
        $content.length ? $content.empty() : $content = renderer_default("<div>").addClass("dx-button-content").appendTo($element);
        $element.toggleClass("dx-button-has-icon", !!icon).toggleClass("dx-button-icon-right", !!icon && "left" !== iconPosition).toggleClass("dx-button-has-text", !!text);
        var $template = renderer_default(this._getTemplateByOption("template").render({
          model: data2,
          container: getPublicElement($content),
          transclude: this._templateManager.anonymousTemplateName === template
        }));
        if ($template.hasClass("dx-template-wrapper")) {
          $template.addClass("dx-button-content");
          $content.replaceWith($template);
        }
        this._updateSubmitInput();
      }
      _updateSubmitInput() {
        var {
          useSubmitBehavior
        } = this.option();
        var $submitInput = this._$submitInput();
        if (!useSubmitBehavior && $submitInput.length) {
          $submitInput.remove();
        } else if (useSubmitBehavior && !$submitInput.length) {
          this._renderSubmitInput();
        }
      }
      _updateStylingMode() {
        var $element = this.$element();
        ["contained", "text", "outlined"].map((mode) => "dx-button-mode-".concat(mode)).forEach((className) => {
          $element.removeClass(className);
        });
        this._renderStylingMode();
      }
      _updateType() {
        var $element = this.$element();
        ["back", "danger", "default", "normal", "success"].map((type2) => "dx-button-".concat(type2)).forEach((className) => {
          $element.removeClass(className);
        });
        this._renderType();
      }
      get _validationGroupConfig() {
        return validation_engine_default.getGroupConfig(this._findGroup());
      }
    };
    component_registrator_default("dxButton", Button);
    button_default = Button;
  }
});

// node_modules/devextreme/esm/ui/text_box/utils.caret.js
var ios, mac, isFocusingOnCaretChange, getCaret, setCaret, caret, utils_caret_default;
var init_utils_caret = __esm({
  "node_modules/devextreme/esm/ui/text_box/utils.caret.js"() {
    init_renderer();
    init_type();
    init_browser();
    init_devices();
    init_dom_adapter();
    ({
      ios,
      mac
    } = devices_default.real());
    isFocusingOnCaretChange = browser_default.msie || ios || mac;
    getCaret = function(input) {
      var range;
      try {
        range = {
          start: input.selectionStart,
          end: input.selectionEnd
        };
      } catch (e) {
        range = {
          start: 0,
          end: 0
        };
      }
      return range;
    };
    setCaret = function(input, position3) {
      if (!dom_adapter_default.getBody().contains(input)) {
        return;
      }
      try {
        input.selectionStart = position3.start;
        input.selectionEnd = position3.end;
      } catch (e) {
      }
    };
    caret = function(input, position3) {
      var force = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : false;
      input = renderer_default(input).get(0);
      if (!isDefined(position3)) {
        return getCaret(input);
      }
      if (!force && isFocusingOnCaretChange && dom_adapter_default.getActiveElement() !== input) {
        return;
      }
      setCaret(input, position3);
    };
    utils_caret_default = caret;
  }
});

// node_modules/devextreme/esm/ui/text_box/utils.support.js
function isModernAndroidDevice() {
  var {
    android,
    version: version2
  } = devices_default.real();
  return android && version2[0] > 4;
}
function isInputEventsL2Supported() {
  return "onbeforeinput" in dom_adapter_default.createElement("input") || isModernAndroidDevice();
}
var init_utils_support = __esm({
  "node_modules/devextreme/esm/ui/text_box/utils.support.js"() {
    init_dom_adapter();
    init_devices();
  }
});

// node_modules/devextreme/esm/ui/text_box/ui.text_editor.mask.rule.js
var EMPTY_CHAR, BaseMaskRule, EmptyMaskRule, MaskRule, StubMaskRule;
var init_ui_text_editor_mask_rule = __esm({
  "node_modules/devextreme/esm/ui/text_box/ui.text_editor.mask.rule.js"() {
    init_class();
    init_extend();
    init_array();
    init_type();
    init_common();
    EMPTY_CHAR = " ";
    BaseMaskRule = class_default.inherit({
      ctor: function(config2) {
        this._value = EMPTY_CHAR;
        extend2(this, config2);
      },
      next: function(rule) {
        if (!arguments.length) {
          return this._next;
        }
        this._next = rule;
      },
      text: noop2,
      value: noop2,
      rawValue: noop2,
      handle: noop2,
      _prepareHandlingArgs: function(args, config2) {
        var _config$str, _config$start, _config$length;
        config2 = config2 || {};
        var handlingProperty = Object.prototype.hasOwnProperty.call(args, "value") ? "value" : "text";
        args[handlingProperty] = null !== (_config$str = config2.str) && void 0 !== _config$str ? _config$str : args[handlingProperty];
        args.start = null !== (_config$start = config2.start) && void 0 !== _config$start ? _config$start : args.start;
        args.length = null !== (_config$length = config2.length) && void 0 !== _config$length ? _config$length : args.length;
        args.index = args.index + 1;
        return args;
      },
      reset: noop2,
      clear: noop2,
      first: function(index2) {
        index2 = index2 || 0;
        return this.next().first(index2 + 1);
      },
      isAccepted: function() {
        return false;
      },
      adjustedCaret: function(caret3, isForwardDirection, char) {
        return isForwardDirection ? this._adjustedForward(caret3, 0, char) : this._adjustedBackward(caret3, 0, char);
      },
      _adjustedForward: noop2,
      _adjustedBackward: noop2,
      isValid: noop2
    });
    EmptyMaskRule = BaseMaskRule.inherit({
      next: noop2,
      handle: function() {
        return 0;
      },
      text: function() {
        return "";
      },
      value: function() {
        return "";
      },
      first: function() {
        return 0;
      },
      rawValue: function() {
        return "";
      },
      adjustedCaret: function() {
        return 0;
      },
      isValid: function() {
        return true;
      }
    });
    MaskRule = BaseMaskRule.inherit({
      text: function() {
        return (this._value !== EMPTY_CHAR ? this._value : this.maskChar) + this.next().text();
      },
      value: function() {
        return this._value + this.next().value();
      },
      rawValue: function() {
        return this._value + this.next().rawValue();
      },
      handle: function(args) {
        var str = Object.prototype.hasOwnProperty.call(args, "value") ? args.value : args.text;
        if (!str || !str.length || !args.length) {
          return 0;
        }
        if (args.start) {
          return this.next().handle(this._prepareHandlingArgs(args, {
            start: args.start - 1
          }));
        }
        var char = str[0];
        var rest = str.substring(1);
        this._tryAcceptChar(char, args);
        return this._accepted() ? this.next().handle(this._prepareHandlingArgs(args, {
          str: rest,
          length: args.length - 1
        })) + 1 : this.handle(this._prepareHandlingArgs(args, {
          str: rest,
          length: args.length - 1
        }));
      },
      clear: function(args) {
        this._tryAcceptChar(EMPTY_CHAR, args);
        this.next().clear(this._prepareHandlingArgs(args));
      },
      reset: function() {
        this._accepted(false);
        this.next().reset();
      },
      _tryAcceptChar: function(char, args) {
        this._accepted(false);
        if (!this._isAllowed(char, args)) {
          return;
        }
        var acceptedChar = char === EMPTY_CHAR ? this.maskChar : char;
        args.fullText = args.fullText.substring(0, args.index) + acceptedChar + args.fullText.substring(args.index + 1);
        this._accepted(true);
        this._value = char;
      },
      _accepted: function(value2) {
        if (!arguments.length) {
          return !!this._isAccepted;
        }
        this._isAccepted = !!value2;
      },
      first: function(index2) {
        return this._value === EMPTY_CHAR ? index2 || 0 : this.callBase(index2);
      },
      _isAllowed: function(char, args) {
        if (char === EMPTY_CHAR) {
          return true;
        }
        return this._isValid(char, args);
      },
      _isValid: function(char, args) {
        var allowedChars = this.allowedChars;
        if (allowedChars instanceof RegExp) {
          return allowedChars.test(char);
        }
        if (isFunction(allowedChars)) {
          return allowedChars(char, args.index, args.fullText);
        }
        if (Array.isArray(allowedChars)) {
          return inArray(char, allowedChars) > -1;
        }
        return allowedChars === char;
      },
      isAccepted: function(caret3) {
        return 0 === caret3 ? this._accepted() : this.next().isAccepted(caret3 - 1);
      },
      _adjustedForward: function(caret3, index2, char) {
        if (index2 >= caret3) {
          return index2;
        }
        return this.next()._adjustedForward(caret3, index2 + 1, char) || index2 + 1;
      },
      _adjustedBackward: function(caret3, index2) {
        if (index2 >= caret3 - 1) {
          return caret3;
        }
        return this.next()._adjustedBackward(caret3, index2 + 1) || index2 + 1;
      },
      isValid: function(args) {
        return this._isValid(this._value, args) && this.next().isValid(this._prepareHandlingArgs(args));
      }
    });
    StubMaskRule = MaskRule.inherit({
      value: function() {
        return this.next().value();
      },
      handle: function(args) {
        var hasValueProperty = Object.prototype.hasOwnProperty.call(args, "value");
        var str = hasValueProperty ? args.value : args.text;
        if (!str.length || !args.length) {
          return 0;
        }
        if (args.start || hasValueProperty) {
          return this.next().handle(this._prepareHandlingArgs(args, {
            start: args.start && args.start - 1
          }));
        }
        var char = str[0];
        var rest = str.substring(1);
        this._tryAcceptChar(char);
        var nextArgs = this._isAllowed(char) ? this._prepareHandlingArgs(args, {
          str: rest,
          length: args.length - 1
        }) : args;
        return this.next().handle(nextArgs) + 1;
      },
      clear: function(args) {
        this._accepted(false);
        this.next().clear(this._prepareHandlingArgs(args));
      },
      _tryAcceptChar: function(char) {
        this._accepted(this._isValid(char));
      },
      _isValid: function(char) {
        return char === this.maskChar;
      },
      first: function(index2) {
        index2 = index2 || 0;
        return this.next().first(index2 + 1);
      },
      _adjustedForward: function(caret3, index2, char) {
        if (index2 >= caret3 && char === this.maskChar) {
          return index2;
        }
        if (caret3 === index2 + 1 && this._accepted()) {
          return caret3;
        }
        return this.next()._adjustedForward(caret3, index2 + 1, char);
      },
      _adjustedBackward: function(caret3, index2) {
        if (index2 >= caret3 - 1) {
          return 0;
        }
        return this.next()._adjustedBackward(caret3, index2 + 1);
      },
      isValid: function(args) {
        return this.next().isValid(this._prepareHandlingArgs(args));
      }
    });
  }
});

// node_modules/devextreme/esm/ui/validation_message.js
var INVALID_MESSAGE, INVALID_MESSAGE_AUTO, INVALID_MESSAGE_ALWAYS, INVALID_MESSAGE_CONTENT, VALIDATION_MESSAGE_MIN_WIDTH, ValidationMessage, validation_message_default;
var init_validation_message = __esm({
  "node_modules/devextreme/esm/ui/validation_message.js"() {
    init_renderer();
    init_component_registrator();
    init_ui_overlay();
    init_extend();
    init_string();
    init_position();
    INVALID_MESSAGE = "dx-invalid-message";
    INVALID_MESSAGE_AUTO = "dx-invalid-message-auto";
    INVALID_MESSAGE_ALWAYS = "dx-invalid-message-always";
    INVALID_MESSAGE_CONTENT = "dx-invalid-message-content";
    VALIDATION_MESSAGE_MIN_WIDTH = 100;
    ValidationMessage = ui_overlay_default.inherit({
      _getDefaultOptions() {
        return extend2(this.callBase(), {
          integrationOptions: {},
          templatesRenderAsynchronously: false,
          shading: false,
          width: "auto",
          height: "auto",
          closeOnOutsideClick: false,
          closeOnTargetScroll: false,
          animation: null,
          visible: true,
          propagateOutsideClick: true,
          _checkParentVisibility: false,
          rtlEnabled: false,
          contentTemplate: this._renderInnerHtml,
          maxWidth: "100%",
          mode: "auto",
          validationErrors: void 0,
          positionRequest: void 0,
          describedElement: void 0,
          boundary: void 0,
          offset: {
            h: 0,
            v: 0
          }
        });
      },
      _init() {
        this.callBase();
        this.updateMaxWidth();
        this._updatePosition();
      },
      _initMarkup() {
        this.callBase();
        this._ensureMessageNotEmpty();
        this._toggleModeClass();
        this._updateContentId();
      },
      _ensureMessageNotEmpty: function() {
        this._textMarkup = this._getTextMarkup();
        var shouldShowMessage = this.option("visible") && this._textMarkup;
        this._toggleVisibilityClasses(shouldShowMessage);
      },
      _toggleVisibilityClasses: function(visible2) {
        if (visible2) {
          this.$element().addClass(INVALID_MESSAGE);
          this.$wrapper().addClass(INVALID_MESSAGE);
        } else {
          this.$element().removeClass(INVALID_MESSAGE);
          this.$wrapper().removeClass(INVALID_MESSAGE);
        }
      },
      _updateContentId() {
        var describedElement = this.option("describedElement") || this.option("container");
        var contentId = renderer_default(describedElement).attr("aria-describedby");
        this.$content().addClass(INVALID_MESSAGE_CONTENT).attr("id", contentId);
      },
      _renderInnerHtml(element) {
        var $element = element && renderer_default(element);
        null === $element || void 0 === $element ? void 0 : $element.html(this._textMarkup);
      },
      _getTextMarkup() {
        var _this$option;
        var validationErrors = null !== (_this$option = this.option("validationErrors")) && void 0 !== _this$option ? _this$option : [];
        var validationErrorMessage = "";
        validationErrors.forEach((err) => {
          var _err$message;
          var separator = validationErrorMessage ? "<br />" : "";
          validationErrorMessage += separator + encodeHtml(null !== (_err$message = null === err || void 0 === err ? void 0 : err.message) && void 0 !== _err$message ? _err$message : "");
        });
        return validationErrorMessage;
      },
      _toggleModeClass() {
        var mode = this.option("mode");
        this.$wrapper().toggleClass(INVALID_MESSAGE_AUTO, "auto" === mode).toggleClass(INVALID_MESSAGE_ALWAYS, "always" === mode);
      },
      updateMaxWidth() {
        var _target$outerWidth;
        var target = this.option("target");
        var targetWidth = (null === target || void 0 === target ? void 0 : null === (_target$outerWidth = target.outerWidth) || void 0 === _target$outerWidth ? void 0 : _target$outerWidth.call(target)) || renderer_default(target).outerWidth();
        var maxWidth = "100%";
        if (targetWidth) {
          maxWidth = Math.max(targetWidth, VALIDATION_MESSAGE_MIN_WIDTH);
        }
        this.option({
          maxWidth
        });
      },
      _updatePosition: function() {
        var {
          positionRequest,
          rtlEnabled,
          offset: offset2,
          boundary
        } = this.option();
        var positionSide = getDefaultAlignment(rtlEnabled);
        var verticalPositions = "below" === positionRequest ? [" top", " bottom"] : [" bottom", " top"];
        if (rtlEnabled) {
          offset2.h = -offset2.h;
        }
        if ("below" !== positionRequest) {
          offset2.v = -offset2.v;
        }
        this.option("position", {
          offset: offset2,
          boundary,
          my: positionSide + verticalPositions[0],
          at: positionSide + verticalPositions[1],
          collision: "none flip"
        });
      },
      _optionChanged(args) {
        var {
          name: name2,
          value: value2
        } = args;
        switch (name2) {
          case "target":
            this.updateMaxWidth();
            this.callBase(args);
            break;
          case "boundary":
            this.option("position.boundary", value2);
            break;
          case "mode":
            this._toggleModeClass(value2);
            break;
          case "rtlEnabled":
          case "offset":
          case "positionRequest":
            this._updatePosition();
            break;
          case "validationErrors":
            this._ensureMessageNotEmpty();
            this._renderInnerHtml(this.$content());
            break;
          default:
            this.callBase(args);
        }
      }
    });
    component_registrator_default("dxValidationMessage", ValidationMessage);
    validation_message_default = ValidationMessage;
  }
});

// node_modules/devextreme/esm/ui/editor/editor.js
var INVALID_MESSAGE_AUTO2, READONLY_STATE_CLASS, INVALID_CLASS, DX_INVALID_BADGE_CLASS, VALIDATION_TARGET, VALIDATION_STATUS_VALID, VALIDATION_STATUS_INVALID, READONLY_NAMESPACE, ALLOWED_STYLING_MODES, VALIDATION_MESSAGE_KEYS_MAP, Editor, editor_default;
var init_editor = __esm({
  "node_modules/devextreme/esm/ui/editor/editor.js"() {
    init_renderer();
    init_element_data();
    init_callbacks();
    init_window();
    init_utils2();
    init_extend();
    init_ui_widget();
    init_validation_engine();
    init_events_engine();
    init_validation_message();
    init_guid();
    init_common();
    init_dom();
    INVALID_MESSAGE_AUTO2 = "dx-invalid-message-auto";
    READONLY_STATE_CLASS = "dx-state-readonly";
    INVALID_CLASS = "dx-invalid";
    DX_INVALID_BADGE_CLASS = "dx-show-invalid-badge";
    VALIDATION_TARGET = "dx-validation-target";
    VALIDATION_STATUS_VALID = "valid";
    VALIDATION_STATUS_INVALID = "invalid";
    READONLY_NAMESPACE = "editorReadOnly";
    ALLOWED_STYLING_MODES = ["outlined", "filled", "underlined"];
    VALIDATION_MESSAGE_KEYS_MAP = {
      validationMessageMode: "mode",
      validationMessageOffset: "offset",
      validationBoundary: "boundary"
    };
    Editor = ui_widget_default.inherit({
      ctor: function() {
        this.showValidationMessageTimeout = null;
        this.validationRequest = callbacks_default();
        this.callBase.apply(this, arguments);
      },
      _createElement: function(element) {
        this.callBase(element);
        var $element = this.$element();
        if ($element) {
          data($element[0], VALIDATION_TARGET, this);
        }
      },
      _initOptions: function(options2) {
        this.callBase.apply(this, arguments);
        this.option(validation_engine_default.initValidationOptions(options2));
      },
      _init: function() {
        this.callBase();
        this._options.cache("validationTooltipOptions", this.option("validationTooltipOptions"));
        var $element = this.$element();
        $element.addClass(DX_INVALID_BADGE_CLASS);
      },
      _getDefaultOptions: function() {
        return extend2(this.callBase(), {
          value: null,
          name: "",
          onValueChanged: null,
          readOnly: false,
          isValid: true,
          validationError: null,
          validationErrors: null,
          validationStatus: VALIDATION_STATUS_VALID,
          validationMessageMode: "auto",
          validationBoundary: void 0,
          validationMessageOffset: {
            h: 0,
            v: 0
          },
          validationTooltipOptions: {}
        });
      },
      _attachKeyboardEvents: function() {
        if (!this.option("readOnly")) {
          this.callBase();
        }
      },
      _setOptionsByReference: function() {
        this.callBase();
        extend2(this._optionsByReference, {
          validationError: true
        });
      },
      _createValueChangeAction: function() {
        this._valueChangeAction = this._createActionByOption("onValueChanged", {
          excludeValidators: ["disabled", "readOnly"]
        });
      },
      _suppressValueChangeAction: function() {
        this._valueChangeActionSuppressed = true;
      },
      _resumeValueChangeAction: function() {
        this._valueChangeActionSuppressed = false;
      },
      _initMarkup: function() {
        var _this$option;
        this._toggleReadOnlyState();
        this._setSubmitElementName(this.option("name"));
        this.callBase();
        this._renderValidationState();
        null === (_this$option = this.option("_onMarkupRendered")) || void 0 === _this$option ? void 0 : _this$option();
      },
      _raiseValueChangeAction: function(value2, previousValue) {
        if (!this._valueChangeAction) {
          this._createValueChangeAction();
        }
        this._valueChangeAction(this._valueChangeArgs(value2, previousValue));
      },
      _valueChangeArgs: function(value2, previousValue) {
        return {
          value: value2,
          previousValue,
          event: this._valueChangeEventInstance
        };
      },
      _saveValueChangeEvent: function(e) {
        this._valueChangeEventInstance = e;
      },
      _focusInHandler: function(e) {
        var isValidationMessageShownOnFocus = "auto" === this.option("validationMessageMode");
        if (this._canValueBeChangedByClick() && isValidationMessageShownOnFocus) {
          var _this$_validationMess;
          var $validationMessageWrapper = null === (_this$_validationMess = this._validationMessage) || void 0 === _this$_validationMess ? void 0 : _this$_validationMess.$wrapper();
          null === $validationMessageWrapper || void 0 === $validationMessageWrapper ? void 0 : $validationMessageWrapper.removeClass(INVALID_MESSAGE_AUTO2);
          clearTimeout(this.showValidationMessageTimeout);
          this.showValidationMessageTimeout = setTimeout(() => null === $validationMessageWrapper || void 0 === $validationMessageWrapper ? void 0 : $validationMessageWrapper.addClass(INVALID_MESSAGE_AUTO2), 150);
        }
        return this.callBase(e);
      },
      _canValueBeChangedByClick: function() {
        return false;
      },
      _getStylingModePrefix: function() {
        return "dx-editor-";
      },
      _renderStylingMode: function() {
        var optionValue = this.option("stylingMode");
        var prefix = this._getStylingModePrefix();
        var allowedStylingClasses = ALLOWED_STYLING_MODES.map((mode) => prefix + mode);
        allowedStylingClasses.forEach((className) => this.$element().removeClass(className));
        var stylingModeClass = prefix + optionValue;
        if (-1 === allowedStylingClasses.indexOf(stylingModeClass)) {
          var defaultOptionValue = this._getDefaultOptions().stylingMode;
          var platformOptionValue = this._convertRulesToOptions(this._defaultOptionsRules()).stylingMode;
          stylingModeClass = prefix + (platformOptionValue || defaultOptionValue);
        }
        this.$element().addClass(stylingModeClass);
      },
      _getValidationErrors: function() {
        var validationErrors = this.option("validationErrors");
        if (!validationErrors && this.option("validationError")) {
          validationErrors = [this.option("validationError")];
        }
        return validationErrors;
      },
      _disposeValidationMessage: function() {
        if (this._$validationMessage) {
          this._$validationMessage.remove();
          this.setAria("describedby", null);
          this._$validationMessage = void 0;
          this._validationMessage = void 0;
        }
      },
      _toggleValidationClasses: function(isInvalid4) {
        this.$element().toggleClass(INVALID_CLASS, isInvalid4);
        this.setAria(VALIDATION_STATUS_INVALID, isInvalid4 || void 0);
      },
      _renderValidationState: function() {
        var isValid = this.option("isValid") && this.option("validationStatus") !== VALIDATION_STATUS_INVALID;
        var validationErrors = this._getValidationErrors();
        var $element = this.$element();
        this._toggleValidationClasses(!isValid);
        if (!hasWindow()) {
          return;
        }
        this._disposeValidationMessage();
        if (!isValid && validationErrors) {
          var {
            validationMessageMode,
            validationMessageOffset,
            validationBoundary,
            rtlEnabled
          } = this.option();
          this._$validationMessage = renderer_default("<div>").appendTo($element);
          this.setAria("describedby", "dx-" + new guid_default());
          this._validationMessage = new validation_message_default(this._$validationMessage, extend2({
            validationErrors,
            rtlEnabled,
            target: this._getValidationMessageTarget(),
            container: $element,
            mode: validationMessageMode,
            positionRequest: "below",
            offset: validationMessageOffset,
            boundary: validationBoundary,
            describedElement: this._focusTarget()
          }, this._options.cache("validationTooltipOptions")));
          this._bindInnerWidgetOptions(this._validationMessage, "validationTooltipOptions");
        }
      },
      _getValidationMessageTarget: function() {
        return this.$element();
      },
      _toggleReadOnlyState: function() {
        var readOnly = this.option("readOnly");
        this._toggleBackspaceHandler(readOnly);
        this.$element().toggleClass(READONLY_STATE_CLASS, !!readOnly);
        this.setAria("readonly", readOnly || void 0);
      },
      _toggleBackspaceHandler: function(isReadOnly) {
        var $eventTarget = this._keyboardEventBindingTarget();
        var eventName = addNamespace2("keydown", READONLY_NAMESPACE);
        events_engine_default.off($eventTarget, eventName);
        if (isReadOnly) {
          events_engine_default.on($eventTarget, eventName, (e) => {
            if ("backspace" === normalizeKeyName(e)) {
              e.preventDefault();
            }
          });
        }
      },
      _dispose: function() {
        var element = this.$element()[0];
        data(element, VALIDATION_TARGET, null);
        clearTimeout(this.showValidationMessageTimeout);
        this._disposeValidationMessage();
        this.callBase();
      },
      _setSubmitElementName: function(name2) {
        var $submitElement = this._getSubmitElement();
        if (!$submitElement) {
          return;
        }
        if (name2.length > 0) {
          $submitElement.attr("name", name2);
        } else {
          $submitElement.removeAttr("name");
        }
      },
      _getSubmitElement: function() {
        return null;
      },
      _setValidationMessageOption: function(_ref) {
        var _this$_validationMess2;
        var {
          name: name2,
          value: value2
        } = _ref;
        var optionKey = VALIDATION_MESSAGE_KEYS_MAP[name2] ? VALIDATION_MESSAGE_KEYS_MAP[name2] : name2;
        null === (_this$_validationMess2 = this._validationMessage) || void 0 === _this$_validationMess2 ? void 0 : _this$_validationMess2.option(optionKey, value2);
      },
      _hasActiveElement: noop2,
      _optionChanged: function(args) {
        var _this$_validationMess3;
        switch (args.name) {
          case "onValueChanged":
            this._createValueChangeAction();
            break;
          case "readOnly":
            this._toggleReadOnlyState();
            this._refreshFocusState();
            break;
          case "value":
            if (args.value != args.previousValue) {
              this.validationRequest.fire({
                value: args.value,
                editor: this
              });
            }
            if (!this._valueChangeActionSuppressed) {
              this._raiseValueChangeAction(args.value, args.previousValue);
              this._saveValueChangeEvent(void 0);
            }
            break;
          case "width":
            this.callBase(args);
            null === (_this$_validationMess3 = this._validationMessage) || void 0 === _this$_validationMess3 ? void 0 : _this$_validationMess3.updateMaxWidth();
            break;
          case "name":
            this._setSubmitElementName(args.value);
            break;
          case "isValid":
          case "validationError":
          case "validationErrors":
          case "validationStatus":
            this.option(validation_engine_default.synchronizeValidationOptions(args, this.option()));
            this._renderValidationState();
            break;
          case "validationBoundary":
          case "validationMessageMode":
          case "validationMessageOffset":
            this._setValidationMessageOption(args);
            break;
          case "rtlEnabled":
            this._setValidationMessageOption(args);
            this.callBase(args);
            break;
          case "validationTooltipOptions":
            this._innerWidgetOptionChanged(this._validationMessage, args);
            break;
          default:
            this.callBase(args);
        }
      },
      blur: function() {
        if (this._hasActiveElement()) {
          resetActiveElement();
        }
      },
      reset: function() {
        var defaultOptions = this._getDefaultOptions();
        this.option("value", defaultOptions.value);
      }
    });
    Editor.isEditor = (instance) => instance instanceof Editor;
    editor_default = Editor;
  }
});

// node_modules/devextreme/esm/ui/text_box/texteditor_button_collection/button.js
var TextEditorButton;
var init_button2 = __esm({
  "node_modules/devextreme/esm/ui/text_box/texteditor_button_collection/button.js"() {
    init_renderer();
    TextEditorButton = class {
      constructor(name2, editor, options2) {
        this.instance = null;
        this.$container = null;
        this.$placeMarker = null;
        this.editor = editor;
        this.name = name2;
        this.options = options2 || {};
      }
      _addPlaceMarker($container) {
        this.$placeMarker = renderer_default("<div>").appendTo($container);
      }
      _addToContainer($element) {
        var {
          $placeMarker,
          $container
        } = this;
        $placeMarker ? $placeMarker.replaceWith($element) : $element.appendTo($container);
      }
      _attachEvents() {
        throw "Not implemented";
      }
      _create() {
        throw "Not implemented";
      }
      _isRendered() {
        return !!this.instance;
      }
      _isVisible() {
        var {
          editor,
          options: options2
        } = this;
        return options2.visible || !editor.option("readOnly");
      }
      _isDisabled() {
        throw "Not implemented";
      }
      _shouldRender() {
        return this._isVisible() && !this._isRendered();
      }
      dispose() {
        var {
          instance,
          $placeMarker
        } = this;
        if (instance) {
          instance.dispose ? instance.dispose() : instance.remove();
          this.instance = null;
        }
        $placeMarker && $placeMarker.remove();
      }
      render() {
        var $container = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.$container;
        this.$container = $container;
        if (this._isVisible()) {
          var {
            instance,
            $element
          } = this._create();
          this.instance = instance;
          this._attachEvents(instance, $element);
        } else {
          this._addPlaceMarker($container);
        }
      }
      update() {
        if (this._shouldRender()) {
          this.render();
        }
        return !!this.instance;
      }
    };
  }
});

// node_modules/devextreme/esm/ui/text_box/ui.text_editor.clear.js
var pointerDown, STATE_INVISIBLE_CLASS, TEXTEDITOR_CLEAR_BUTTON_CLASS, TEXTEDITOR_CLEAR_ICON_CLASS, TEXTEDITOR_ICON_CLASS, TEXTEDITOR_SHOW_CLEAR_BUTTON_CLASS, ClearButton;
var init_ui_text_editor_clear = __esm({
  "node_modules/devextreme/esm/ui/text_box/ui.text_editor.clear.js"() {
    init_renderer();
    init_events_engine();
    init_button2();
    init_utils2();
    init_pointer();
    init_click();
    pointerDown = pointer_default.down;
    STATE_INVISIBLE_CLASS = "dx-state-invisible";
    TEXTEDITOR_CLEAR_BUTTON_CLASS = "dx-clear-button-area";
    TEXTEDITOR_CLEAR_ICON_CLASS = "dx-icon-clear";
    TEXTEDITOR_ICON_CLASS = "dx-icon";
    TEXTEDITOR_SHOW_CLEAR_BUTTON_CLASS = "dx-show-clear-button";
    ClearButton = class extends TextEditorButton {
      _create() {
        var $element = renderer_default("<span>").addClass(TEXTEDITOR_CLEAR_BUTTON_CLASS).append(renderer_default("<span>").addClass(TEXTEDITOR_ICON_CLASS).addClass(TEXTEDITOR_CLEAR_ICON_CLASS));
        this._addToContainer($element);
        this.update(true);
        return {
          instance: $element,
          $element
        };
      }
      _isVisible() {
        var {
          editor
        } = this;
        return editor._isClearButtonVisible();
      }
      _attachEvents(instance, $button) {
        var {
          editor
        } = this;
        var editorName = editor.NAME;
        events_engine_default.on($button, addNamespace2(pointerDown, editorName), (e) => {
          e.preventDefault();
          if ("mouse" !== e.pointerType) {
            editor._clearValueHandler(e);
          }
        });
        events_engine_default.on($button, addNamespace2(CLICK_EVENT_NAME, editorName), (e) => editor._clearValueHandler(e));
      }
      _legacyRender($editor, isVisible2) {
        $editor.toggleClass(TEXTEDITOR_SHOW_CLEAR_BUTTON_CLASS, isVisible2);
      }
      update() {
        var rendered = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : false;
        !rendered && super.update();
        var {
          editor,
          instance
        } = this;
        var $editor = editor.$element();
        var isVisible2 = this._isVisible();
        instance && instance.toggleClass(STATE_INVISIBLE_CLASS, !isVisible2);
        this._legacyRender($editor, isVisible2);
      }
    };
  }
});

// node_modules/devextreme/esm/ui/text_box/texteditor_button_collection/custom.js
var CUSTOM_BUTTON_HOVERED_CLASS, CustomButton;
var init_custom = __esm({
  "node_modules/devextreme/esm/ui/text_box/texteditor_button_collection/custom.js"() {
    init_renderer();
    init_button2();
    init_button();
    init_extend();
    init_events_engine();
    init_hover();
    init_click();
    CUSTOM_BUTTON_HOVERED_CLASS = "dx-custom-button-hovered";
    CustomButton = class extends TextEditorButton {
      _attachEvents(instance, $element) {
        var {
          editor
        } = this;
        events_engine_default.on($element, HOVERSTART, () => {
          editor.$element().addClass(CUSTOM_BUTTON_HOVERED_CLASS);
        });
        events_engine_default.on($element, HOVEREND, () => {
          editor.$element().removeClass(CUSTOM_BUTTON_HOVERED_CLASS);
        });
        events_engine_default.on($element, CLICK_EVENT_NAME, (e) => {
          e.stopPropagation();
        });
      }
      _create() {
        var {
          editor
        } = this;
        var $element = renderer_default("<div>");
        this._addToContainer($element);
        var instance = editor._createComponent($element, button_default, extend2({}, this.options, {
          ignoreParentReadOnly: true,
          disabled: this._isDisabled(),
          integrationOptions: this._prepareIntegrationOptions(editor)
        }));
        return {
          $element,
          instance
        };
      }
      _prepareIntegrationOptions(editor) {
        return extend2({}, editor.option("integrationOptions"), {
          skipTemplates: ["content"]
        });
      }
      update() {
        var isUpdated = super.update();
        if (this.instance) {
          this.instance.option("disabled", this._isDisabled());
        }
        return isUpdated;
      }
      _isVisible() {
        var {
          editor
        } = this;
        return editor.option("visible");
      }
      _isDisabled() {
        var isDefinedByUser = void 0 !== this.options.disabled;
        if (isDefinedByUser) {
          return this.instance ? this.instance.option("disabled") : this.options.disabled;
        } else {
          return this.editor.option("readOnly");
        }
      }
    };
  }
});

// node_modules/devextreme/esm/ui/text_box/texteditor_button_collection/index.js
function checkButtonInfo(buttonInfo) {
  (() => {
    if (!buttonInfo || "object" !== typeof buttonInfo || Array.isArray(buttonInfo)) {
      throw ui_errors_default.Error("E1053");
    }
  })();
  (() => {
    if (!("name" in buttonInfo)) {
      throw ui_errors_default.Error("E1054");
    }
  })();
  (() => {
    var {
      name: name2
    } = buttonInfo;
    if ("string" !== typeof name2) {
      throw ui_errors_default.Error("E1055");
    }
  })();
  (() => {
    var {
      location
    } = buttonInfo;
    if ("location" in buttonInfo && "after" !== location && "before" !== location) {
      buttonInfo.location = "after";
    }
  })();
}
function checkNamesUniqueness(existingNames, newName) {
  if (-1 !== existingNames.indexOf(newName)) {
    throw ui_errors_default.Error("E1055", newName);
  }
  existingNames.push(newName);
}
function isPredefinedButtonName(name2, predefinedButtonsInfo) {
  return !!find(predefinedButtonsInfo, (info) => info.name === name2);
}
var TEXTEDITOR_BUTTONS_CONTAINER_CLASS, TextEditorButtonCollection;
var init_texteditor_button_collection = __esm({
  "node_modules/devextreme/esm/ui/text_box/texteditor_button_collection/index.js"() {
    init_renderer();
    init_custom();
    init_extend();
    init_array();
    init_ui_errors();
    TEXTEDITOR_BUTTONS_CONTAINER_CLASS = "dx-texteditor-buttons-container";
    TextEditorButtonCollection = class {
      constructor(editor, defaultButtonsInfo) {
        this.buttons = [];
        this.defaultButtonsInfo = defaultButtonsInfo;
        this.editor = editor;
      }
      _compileButtonInfo(buttons) {
        var names = [];
        return buttons.map((button) => {
          var isStringButton = "string" === typeof button;
          if (!isStringButton) {
            checkButtonInfo(button);
          }
          var isDefaultButton = isStringButton || isPredefinedButtonName(button.name, this.defaultButtonsInfo);
          if (isDefaultButton) {
            var defaultButtonInfo = find(this.defaultButtonsInfo, (_ref) => {
              var {
                name: name3
              } = _ref;
              return name3 === button || name3 === button.name;
            });
            if (!defaultButtonInfo) {
              throw ui_errors_default.Error("E1056", this.editor.NAME, button);
            }
            checkNamesUniqueness(names, button);
            return defaultButtonInfo;
          } else {
            var {
              name: name2
            } = button;
            checkNamesUniqueness(names, name2);
            return extend2(button, {
              Ctor: CustomButton
            });
          }
        });
      }
      _createButton(buttonsInfo) {
        var {
          Ctor,
          options: options2,
          name: name2
        } = buttonsInfo;
        var button = new Ctor(name2, this.editor, options2);
        this.buttons.push(button);
        return button;
      }
      _renderButtons(buttons, $container, targetLocation) {
        var $buttonsContainer = null;
        var buttonsInfo = buttons ? this._compileButtonInfo(buttons) : this.defaultButtonsInfo;
        buttonsInfo.forEach((buttonsInfo2) => {
          var {
            location = "after"
          } = buttonsInfo2;
          if (location === targetLocation) {
            this._createButton(buttonsInfo2).render((() => {
              $buttonsContainer = $buttonsContainer || renderer_default("<div>").addClass(TEXTEDITOR_BUTTONS_CONTAINER_CLASS);
              "before" === targetLocation ? $container.prepend($buttonsContainer) : $container.append($buttonsContainer);
              return $buttonsContainer;
            })());
          }
        });
        return $buttonsContainer;
      }
      clean() {
        this.buttons.forEach((button) => button.dispose());
        this.buttons = [];
      }
      getButton(buttonName) {
        var button = find(this.buttons, (_ref2) => {
          var {
            name: name2
          } = _ref2;
          return name2 === buttonName;
        });
        return button && button.instance;
      }
      renderAfterButtons(buttons, $container) {
        return this._renderButtons(buttons, $container, "after");
      }
      renderBeforeButtons(buttons, $container) {
        return this._renderButtons(buttons, $container, "before");
      }
      updateButtons(names) {
        this.buttons.forEach((button) => {
          if (!names || -1 !== names.indexOf(button.name)) {
            button.update();
          }
        });
      }
    };
  }
});

// node_modules/devextreme/esm/ui/text_box/ui.text_editor.base.js
function checkButtonsOptionType(buttons) {
  if (isDefined(buttons) && !Array.isArray(buttons)) {
    throw ui_errors_default.Error("E1053");
  }
}
var TEXTEDITOR_CLASS, TEXTEDITOR_INPUT_CONTAINER_CLASS, TEXTEDITOR_INPUT_CLASS, TEXTEDITOR_INPUT_SELECTOR, TEXTEDITOR_CONTAINER_CLASS, TEXTEDITOR_BUTTONS_CONTAINER_CLASS2, TEXTEDITOR_PLACEHOLDER_CLASS, TEXTEDITOR_EMPTY_INPUT_CLASS, STATE_INVISIBLE_CLASS2, TEXTEDITOR_PENDING_INDICATOR_CLASS, TEXTEDITOR_VALIDATION_PENDING_CLASS, TEXTEDITOR_VALID_CLASS, EVENTS_LIST, CONTROL_KEYS, TextEditorBase, ui_text_editor_base_default;
var init_ui_text_editor_base = __esm({
  "node_modules/devextreme/esm/ui/text_box/ui.text_editor.base.js"() {
    init_renderer();
    init_dom_adapter();
    init_events_engine();
    init_selectors();
    init_type();
    init_extend();
    init_array();
    init_iterator();
    init_themes();
    init_devices();
    init_editor();
    init_utils2();
    init_pointer();
    init_ui_text_editor_clear();
    init_texteditor_button_collection();
    init_config();
    init_ui_errors();
    init_deferred();
    init_load_indicator();
    TEXTEDITOR_CLASS = "dx-texteditor";
    TEXTEDITOR_INPUT_CONTAINER_CLASS = "dx-texteditor-input-container";
    TEXTEDITOR_INPUT_CLASS = "dx-texteditor-input";
    TEXTEDITOR_INPUT_SELECTOR = "." + TEXTEDITOR_INPUT_CLASS;
    TEXTEDITOR_CONTAINER_CLASS = "dx-texteditor-container";
    TEXTEDITOR_BUTTONS_CONTAINER_CLASS2 = "dx-texteditor-buttons-container";
    TEXTEDITOR_PLACEHOLDER_CLASS = "dx-placeholder";
    TEXTEDITOR_EMPTY_INPUT_CLASS = "dx-texteditor-empty";
    STATE_INVISIBLE_CLASS2 = "dx-state-invisible";
    TEXTEDITOR_PENDING_INDICATOR_CLASS = "dx-pending-indicator";
    TEXTEDITOR_VALIDATION_PENDING_CLASS = "dx-validation-pending";
    TEXTEDITOR_VALID_CLASS = "dx-valid";
    EVENTS_LIST = ["KeyDown", "KeyPress", "KeyUp", "Change", "Cut", "Copy", "Paste", "Input"];
    CONTROL_KEYS = ["tab", "enter", "shift", "control", "alt", "escape", "pageUp", "pageDown", "end", "home", "leftArrow", "upArrow", "rightArrow", "downArrow"];
    TextEditorBase = editor_default.inherit({
      ctor: function(_2, options2) {
        if (options2) {
          checkButtonsOptionType(options2.buttons);
        }
        this._buttonCollection = new TextEditorButtonCollection(this, this._getDefaultButtons());
        this._$beforeButtonsContainer = null;
        this._$afterButtonsContainer = null;
        this.callBase.apply(this, arguments);
      },
      _getDefaultOptions: function() {
        return extend2(this.callBase(), {
          buttons: void 0,
          value: "",
          spellcheck: false,
          showClearButton: false,
          valueChangeEvent: "change",
          placeholder: "",
          inputAttr: {},
          onFocusIn: null,
          onFocusOut: null,
          onKeyDown: null,
          onKeyPress: null,
          onKeyUp: null,
          onChange: null,
          onInput: null,
          onCut: null,
          onCopy: null,
          onPaste: null,
          onEnterKey: null,
          mode: "text",
          hoverStateEnabled: true,
          focusStateEnabled: true,
          text: void 0,
          displayValueFormatter: function(value2) {
            return isDefined(value2) && false !== value2 ? value2 : "";
          },
          stylingMode: config_default().editorStylingMode || "outlined",
          showValidationMark: true
        });
      },
      _defaultOptionsRules: function() {
        var themeName = current();
        return this.callBase().concat([{
          device: function() {
            return isMaterial(themeName);
          },
          options: {
            stylingMode: config_default().editorStylingMode || "underlined"
          }
        }]);
      },
      _setDeprecatedOptions: function() {
        this.callBase();
        extend2(this._deprecatedOptions, {
          onKeyPress: {
            since: "20.1",
            message: "This event is removed from the web standards and will be deprecated in modern browsers soon."
          }
        });
      },
      _getDefaultButtons: function() {
        return [{
          name: "clear",
          Ctor: ClearButton
        }];
      },
      _isClearButtonVisible: function() {
        return this.option("showClearButton") && !this.option("readOnly");
      },
      _input: function() {
        return this.$element().find(TEXTEDITOR_INPUT_SELECTOR).first();
      },
      _isFocused: function() {
        return focused(this._input()) || this.callBase();
      },
      _inputWrapper: function() {
        return this.$element();
      },
      _buttonsContainer: function() {
        return this._inputWrapper().find("." + TEXTEDITOR_BUTTONS_CONTAINER_CLASS2).eq(0);
      },
      _isControlKey: function(key) {
        return -1 !== CONTROL_KEYS.indexOf(key);
      },
      _renderStylingMode: function() {
        this.callBase();
        this._updateButtonsStyling(this.option("stylingMode"));
      },
      _initMarkup: function() {
        this.$element().addClass(TEXTEDITOR_CLASS);
        this._renderInput();
        this._renderStylingMode();
        this._renderInputType();
        this._renderPlaceholder();
        this._renderProps();
        this.callBase();
        this._renderValue();
      },
      _render: function() {
        this.callBase();
        this._refreshValueChangeEvent();
        this._renderEvents();
        this._renderEnterKeyAction();
        this._renderEmptinessEvent();
      },
      _renderInput: function() {
        this._$buttonsContainer = this._$textEditorContainer = renderer_default("<div>").addClass(TEXTEDITOR_CONTAINER_CLASS).appendTo(this.$element());
        this._$textEditorInputContainer = renderer_default("<div>").addClass(TEXTEDITOR_INPUT_CONTAINER_CLASS).appendTo(this._$textEditorContainer);
        this._$textEditorInputContainer.append(this._createInput());
        this._renderButtonContainers();
      },
      _getInputContainer() {
        return this._$textEditorInputContainer;
      },
      _renderPendingIndicator: function() {
        this.$element().addClass(TEXTEDITOR_VALIDATION_PENDING_CLASS);
        var $inputContainer = this._getInputContainer();
        var $indicatorElement = renderer_default("<div>").addClass(TEXTEDITOR_PENDING_INDICATOR_CLASS).appendTo($inputContainer);
        this._pendingIndicator = this._createComponent($indicatorElement, load_indicator_default);
      },
      _disposePendingIndicator: function() {
        if (!this._pendingIndicator) {
          return;
        }
        this._pendingIndicator.dispose();
        this._pendingIndicator.$element().remove();
        this._pendingIndicator = null;
        this.$element().removeClass(TEXTEDITOR_VALIDATION_PENDING_CLASS);
      },
      _renderValidationState: function() {
        this.callBase();
        var isPending2 = "pending" === this.option("validationStatus");
        var $element = this.$element();
        if (isPending2) {
          !this._pendingIndicator && this._renderPendingIndicator();
          this._showValidMark = false;
        } else {
          if ("invalid" === this.option("validationStatus")) {
            this._showValidMark = false;
          }
          if (!this._showValidMark && true === this.option("showValidationMark")) {
            this._showValidMark = "valid" === this.option("validationStatus") && !!this._pendingIndicator;
          }
          this._disposePendingIndicator();
        }
        $element.toggleClass(TEXTEDITOR_VALID_CLASS, !!this._showValidMark);
      },
      _renderButtonContainers: function() {
        var buttons = this.option("buttons");
        this._$beforeButtonsContainer = this._buttonCollection.renderBeforeButtons(buttons, this._$buttonsContainer);
        this._$afterButtonsContainer = this._buttonCollection.renderAfterButtons(buttons, this._$buttonsContainer);
      },
      _cleanButtonContainers: function() {
        var _this$_$beforeButtons, _this$_$afterButtonsC;
        null === (_this$_$beforeButtons = this._$beforeButtonsContainer) || void 0 === _this$_$beforeButtons ? void 0 : _this$_$beforeButtons.remove();
        null === (_this$_$afterButtonsC = this._$afterButtonsContainer) || void 0 === _this$_$afterButtonsC ? void 0 : _this$_$afterButtonsC.remove();
        this._buttonCollection.clean();
      },
      _clean() {
        this._buttonCollection.clean();
        this._disposePendingIndicator();
        this._$beforeButtonsContainer = null;
        this._$afterButtonsContainer = null;
        this._$textEditorContainer = null;
        this._$buttonsContainer = null;
        this.callBase();
      },
      _createInput: function() {
        var $input = renderer_default("<input>");
        this._applyInputAttributes($input, this.option("inputAttr"));
        return $input;
      },
      _setSubmitElementName: function(name2) {
        var inputAttrName = this.option("inputAttr.name");
        return this.callBase(name2 || inputAttrName || "");
      },
      _applyInputAttributes: function($input, customAttributes) {
        var inputAttributes = extend2(this._getDefaultAttributes(), customAttributes);
        $input.attr(inputAttributes).addClass(TEXTEDITOR_INPUT_CLASS).css("minHeight", this.option("height") ? "0" : "");
      },
      _getDefaultAttributes: function() {
        var defaultAttributes = {
          autocomplete: "off"
        };
        var {
          ios: ios2,
          mac: mac2
        } = devices_default.real();
        if (ios2 || mac2) {
          defaultAttributes.placeholder = " ";
        }
        return defaultAttributes;
      },
      _updateButtons: function(names) {
        this._buttonCollection.updateButtons(names);
      },
      _updateButtonsStyling: function(editorStylingMode) {
        each(this.option("buttons"), (_2, _ref) => {
          var {
            options: options2,
            name: buttonName
          } = _ref;
          if (options2 && !options2.stylingMode && this.option("visible")) {
            var buttonInstance = this.getButton(buttonName);
            buttonInstance.option && buttonInstance.option("stylingMode", "underlined" === editorStylingMode ? "text" : "contained");
          }
        });
      },
      _renderValue: function() {
        var renderInputPromise = this._renderInputValue();
        return renderInputPromise.promise();
      },
      _renderInputValue: function(value2) {
        var _value;
        value2 = null !== (_value = value2) && void 0 !== _value ? _value : this.option("value");
        var text = this.option("text");
        var displayValue = this.option("displayValue");
        var displayValueFormatter = this.option("displayValueFormatter");
        if (void 0 !== displayValue && null !== value2) {
          text = displayValueFormatter(displayValue);
        } else if (!isDefined(text)) {
          text = displayValueFormatter(value2);
        }
        this.option("text", text);
        if (this._input().val() !== (isDefined(text) ? text : "")) {
          this._renderDisplayText(text);
        } else {
          this._toggleEmptinessEventHandler();
        }
        return new Deferred().resolve();
      },
      _renderDisplayText: function(text) {
        this._input().val(text);
        this._toggleEmptinessEventHandler();
      },
      _isValueValid: function() {
        if (this._input().length) {
          var validity = this._input().get(0).validity;
          if (validity) {
            return validity.valid;
          }
        }
        return true;
      },
      _toggleEmptiness: function(isEmpty3) {
        this.$element().toggleClass(TEXTEDITOR_EMPTY_INPUT_CLASS, isEmpty3);
        this._togglePlaceholder(isEmpty3);
      },
      _togglePlaceholder: function(isEmpty3) {
        this.$element().find(".".concat(TEXTEDITOR_PLACEHOLDER_CLASS)).eq(0).toggleClass(STATE_INVISIBLE_CLASS2, !isEmpty3);
      },
      _renderProps: function() {
        this._toggleReadOnlyState();
        this._toggleSpellcheckState();
        this._toggleTabIndex();
      },
      _toggleDisabledState: function(value2) {
        this.callBase.apply(this, arguments);
        var $input = this._input();
        $input.prop("disabled", value2);
      },
      _toggleTabIndex: function() {
        var $input = this._input();
        var disabled = this.option("disabled");
        var focusStateEnabled = this.option("focusStateEnabled");
        if (disabled || !focusStateEnabled) {
          $input.attr("tabIndex", -1);
        } else {
          $input.removeAttr("tabIndex");
        }
      },
      _toggleReadOnlyState: function() {
        this._input().prop("readOnly", this._readOnlyPropValue());
        this.callBase();
      },
      _readOnlyPropValue: function() {
        return this.option("readOnly");
      },
      _toggleSpellcheckState: function() {
        this._input().prop("spellcheck", this.option("spellcheck"));
      },
      _renderPlaceholder: function() {
        this._renderPlaceholderMarkup();
        this._attachPlaceholderEvents();
      },
      _renderPlaceholderMarkup: function() {
        if (this._$placeholder) {
          this._$placeholder.remove();
          this._$placeholder = null;
        }
        var $input = this._input();
        var placeholderText = this.option("placeholder");
        var $placeholder = this._$placeholder = renderer_default("<div>").attr("data-dx_placeholder", placeholderText);
        $placeholder.insertAfter($input);
        $placeholder.addClass(TEXTEDITOR_PLACEHOLDER_CLASS);
      },
      _attachPlaceholderEvents: function() {
        var startEvent = addNamespace2(pointer_default.up, this.NAME);
        events_engine_default.on(this._$placeholder, startEvent, () => {
          events_engine_default.trigger(this._input(), "focus");
        });
        this._toggleEmptinessEventHandler();
      },
      _placeholder: function() {
        return this._$placeholder || renderer_default();
      },
      _clearValueHandler: function(e) {
        var $input = this._input();
        e.stopPropagation();
        this._saveValueChangeEvent(e);
        this._clearValue();
        !this._isFocused() && events_engine_default.trigger($input, "focus");
        events_engine_default.trigger($input, "input");
      },
      _clearValue: function() {
        this.reset();
      },
      _renderEvents: function() {
        var $input = this._input();
        each(EVENTS_LIST, (_2, event) => {
          if (this.hasActionSubscription("on" + event)) {
            var action = this._createActionByOption("on" + event, {
              excludeValidators: ["readOnly"]
            });
            events_engine_default.on($input, addNamespace2(event.toLowerCase(), this.NAME), (e) => {
              if (this._disposed) {
                return;
              }
              action({
                event: e
              });
            });
          }
        });
      },
      _refreshEvents: function() {
        var $input = this._input();
        each(EVENTS_LIST, (_2, event) => {
          events_engine_default.off($input, addNamespace2(event.toLowerCase(), this.NAME));
        });
        this._renderEvents();
      },
      _keyPressHandler: function() {
        this.option("text", this._input().val());
      },
      _keyDownHandler: function(e) {
        var $input = this._input();
        var isCtrlEnter = e.ctrlKey && "enter" === normalizeKeyName(e);
        var isNewValue = $input.val() !== this.option("value");
        if (isCtrlEnter && isNewValue) {
          events_engine_default.trigger($input, "change");
        }
      },
      _renderValueChangeEvent: function() {
        var keyPressEvent = addNamespace2(this._renderValueEventName(), "".concat(this.NAME, "TextChange"));
        var valueChangeEvent = addNamespace2(this.option("valueChangeEvent"), "".concat(this.NAME, "ValueChange"));
        var keyDownEvent = addNamespace2("keydown", "".concat(this.NAME, "TextChange"));
        var $input = this._input();
        events_engine_default.on($input, keyPressEvent, this._keyPressHandler.bind(this));
        events_engine_default.on($input, valueChangeEvent, this._valueChangeEventHandler.bind(this));
        events_engine_default.on($input, keyDownEvent, this._keyDownHandler.bind(this));
      },
      _cleanValueChangeEvent: function() {
        var valueChangeNamespace = ".".concat(this.NAME, "ValueChange");
        var textChangeNamespace = ".".concat(this.NAME, "TextChange");
        events_engine_default.off(this._input(), valueChangeNamespace);
        events_engine_default.off(this._input(), textChangeNamespace);
      },
      _refreshValueChangeEvent: function() {
        this._cleanValueChangeEvent();
        this._renderValueChangeEvent();
      },
      _renderValueEventName: function() {
        return "input change keypress";
      },
      _focusTarget: function() {
        return this._input();
      },
      _focusEventTarget: function() {
        return this.element();
      },
      _isInput: function(element) {
        return element === this._input().get(0);
      },
      _preventNestedFocusEvent: function(event) {
        if (event.isDefaultPrevented()) {
          return true;
        }
        var shouldPrevent = this._isNestedTarget(event.relatedTarget);
        if ("focusin" === event.type) {
          shouldPrevent = shouldPrevent && this._isNestedTarget(event.target) && !this._isInput(event.target);
        } else if (!shouldPrevent) {
          this._toggleFocusClass(false, this.$element());
        }
        shouldPrevent && event.preventDefault();
        return shouldPrevent;
      },
      _isNestedTarget: function(target) {
        return !!this.$element().find(target).length;
      },
      _focusClassTarget: function() {
        return this.$element();
      },
      _focusInHandler: function(event) {
        this._preventNestedFocusEvent(event);
        this.callBase.apply(this, arguments);
      },
      _focusOutHandler: function(event) {
        this._preventNestedFocusEvent(event);
        this.callBase.apply(this, arguments);
      },
      _toggleFocusClass: function(isFocused, $element) {
        this.callBase(isFocused, this._focusClassTarget($element));
      },
      _hasFocusClass: function(element) {
        return this.callBase(renderer_default(element || this.$element()));
      },
      _renderEmptinessEvent: function() {
        var $input = this._input();
        events_engine_default.on($input, "input blur", this._toggleEmptinessEventHandler.bind(this));
      },
      _toggleEmptinessEventHandler: function() {
        var text = this._input().val();
        var isEmpty3 = ("" === text || null === text) && this._isValueValid();
        this._toggleEmptiness(isEmpty3);
      },
      _valueChangeEventHandler: function(e, formattedValue) {
        if (this.option("readOnly")) {
          return;
        }
        this._saveValueChangeEvent(e);
        this.option("value", arguments.length > 1 ? formattedValue : this._input().val());
        this._saveValueChangeEvent(void 0);
      },
      _renderEnterKeyAction: function() {
        this._enterKeyAction = this._createActionByOption("onEnterKey", {
          excludeValidators: ["readOnly"]
        });
        events_engine_default.off(this._input(), "keyup.onEnterKey.dxTextEditor");
        events_engine_default.on(this._input(), "keyup.onEnterKey.dxTextEditor", this._enterKeyHandlerUp.bind(this));
      },
      _enterKeyHandlerUp: function(e) {
        if (this._disposed) {
          return;
        }
        if ("enter" === normalizeKeyName(e)) {
          this._enterKeyAction({
            event: e
          });
        }
      },
      _updateValue: function() {
        this._options.silent("text", null);
        this._renderValue();
      },
      _dispose: function() {
        this._enterKeyAction = void 0;
        this.callBase();
      },
      _getSubmitElement: function() {
        return this._input();
      },
      _hasActiveElement: function() {
        return this._input().is(dom_adapter_default.getActiveElement());
      },
      _optionChanged: function(args) {
        var {
          name: name2,
          fullName,
          value: value2
        } = args;
        if (inArray(name2.replace("on", ""), EVENTS_LIST) > -1) {
          this._refreshEvents();
          return;
        }
        switch (name2) {
          case "valueChangeEvent":
            this._refreshValueChangeEvent();
            this._refreshFocusEvent();
            this._refreshEvents();
            break;
          case "onValueChanged":
            this._createValueChangeAction();
            break;
          case "focusStateEnabled":
            this.callBase(args);
            this._toggleTabIndex();
            break;
          case "spellcheck":
            this._toggleSpellcheckState();
            break;
          case "mode":
            this._renderInputType();
            break;
          case "onEnterKey":
            this._renderEnterKeyAction();
            break;
          case "placeholder":
            this._renderPlaceholder();
            break;
          case "readOnly":
          case "disabled":
            this._updateButtons();
            this.callBase(args);
            break;
          case "showClearButton":
            this._updateButtons(["clear"]);
            break;
          case "text":
            break;
          case "value":
            this._updateValue();
            this.callBase(args);
            break;
          case "inputAttr":
            this._applyInputAttributes(this._input(), this.option(name2));
            break;
          case "stylingMode":
            this._renderStylingMode();
            break;
          case "buttons":
            if (fullName === name2) {
              checkButtonsOptionType(value2);
            }
            this._cleanButtonContainers();
            this._renderButtonContainers();
            this._updateButtonsStyling(this.option("stylingMode"));
            break;
          case "visible":
            this.callBase(args);
            if (value2 && this.option("buttons")) {
              this._cleanButtonContainers();
              this._renderButtonContainers();
              this._updateButtonsStyling(this.option("stylingMode"));
            }
            break;
          case "displayValueFormatter":
            this._invalidate();
            break;
          case "showValidationMark":
            break;
          default:
            this.callBase(args);
        }
      },
      _renderInputType: function() {
        this._setInputType(this.option("mode"));
      },
      _setInputType: function(type2) {
        var input = this._input();
        if ("search" === type2) {
          type2 = "text";
        }
        try {
          input.prop("type", type2);
        } catch (e) {
          input.prop("type", "text");
        }
      },
      getButton(name2) {
        return this._buttonCollection.getButton(name2);
      },
      focus: function() {
        events_engine_default.trigger(this._input(), "focus");
      },
      reset: function() {
        if (this._showValidMark) {
          this._showValidMark = false;
          this._renderValidationState();
        }
        var defaultOptions = this._getDefaultOptions();
        if (this.option("value") === defaultOptions.value) {
          this._options.silent("text", "");
          this._renderValue();
        } else {
          this.option("value", defaultOptions.value);
        }
      },
      on: function(eventName, eventHandler) {
        var result2 = this.callBase(eventName, eventHandler);
        var event = eventName.charAt(0).toUpperCase() + eventName.substr(1);
        if (EVENTS_LIST.indexOf(event) >= 0) {
          this._refreshEvents();
        }
        return result2;
      }
    });
    ui_text_editor_base_default = TextEditorBase;
  }
});

// node_modules/devextreme/esm/ui/text_box/ui.text_editor.mask.strategy.base.js
var MASK_EVENT_NAMESPACE, BLUR_EVENT, EMPTY_CHAR2, BaseMaskStrategy;
var init_ui_text_editor_mask_strategy_base = __esm({
  "node_modules/devextreme/esm/ui/text_box/ui.text_editor.mask.strategy.base.js"() {
    init_events_engine();
    init_utils2();
    init_browser();
    init_array();
    init_dom();
    MASK_EVENT_NAMESPACE = "dxMask";
    BLUR_EVENT = "blur beforedeactivate";
    EMPTY_CHAR2 = " ";
    BaseMaskStrategy = class {
      constructor(editor) {
        this.editor = editor;
        this.DIRECTION = {
          FORWARD: "forward",
          BACKWARD: "backward"
        };
        this.NAME = this._getStrategyName();
      }
      _getStrategyName() {
        return "base";
      }
      editorOption() {
        return this.editor.option(...arguments);
      }
      editorInput() {
        return this.editor._input();
      }
      editorCaret(newCaret) {
        if (!newCaret) {
          return this.editor._caret();
        }
        this.editor._caret(newCaret);
      }
      getHandler(handlerName) {
        var handler = this["_".concat(handlerName, "Handler")] || function() {
        };
        return handler.bind(this);
      }
      attachEvents() {
        var $input = this.editorInput();
        this.getHandleEventNames().forEach((eventName) => {
          var subscriptionName = addNamespace2(eventName.toLowerCase(), MASK_EVENT_NAMESPACE);
          events_engine_default.on($input, subscriptionName, this.getEventHandler(eventName));
        });
        this._attachChangeEventHandlers();
      }
      getHandleEventNames() {
        return ["focusIn", "focusOut", "keyDown", "input", "paste", "cut", "drop"];
      }
      getEventHandler(eventName) {
        return this["_".concat(eventName, "Handler")].bind(this);
      }
      detachEvents() {
        events_engine_default.off(this.editorInput(), ".".concat(MASK_EVENT_NAMESPACE));
      }
      _attachChangeEventHandlers() {
        if (-1 === inArray("change", this.editorOption("valueChangeEvent").split(" "))) {
          return;
        }
        events_engine_default.on(this.editorInput(), addNamespace2(BLUR_EVENT, MASK_EVENT_NAMESPACE), (function(e) {
          this._suppressCaretChanging(this._changeHandler, [e]);
          this._changeHandler(e);
        }).bind(this.editor));
      }
      _focusInHandler() {
        this.editor._showMaskPlaceholder();
        this.editor._direction(this.DIRECTION.FORWARD);
        if (!this.editor._isValueEmpty() && this.editorOption("isValid")) {
          this.editor._adjustCaret();
        } else {
          var caret3 = this.editor._maskRulesChain.first();
          this._caretTimeout = setTimeout((function() {
            this._caret({
              start: caret3,
              end: caret3
            });
          }).bind(this.editor), 0);
        }
      }
      _focusOutHandler(event) {
        this.editor._changeHandler(event);
        if ("onFocus" === this.editorOption("showMaskMode") && this.editor._isValueEmpty()) {
          this.editorOption("text", "");
          this.editor._renderDisplayText("");
        }
      }
      _cutHandler(event) {
        var caret3 = this.editorCaret();
        var selectedText = this.editorInput().val().substring(caret3.start, caret3.end);
        this.editor._maskKeyHandler(event, () => clipboardText(event, selectedText));
      }
      _dropHandler() {
        this._clearDragTimer();
        this._dragTimer = setTimeout((function() {
          this.option("value", this._convertToValue(this._input().val()));
        }).bind(this.editor));
      }
      _clearDragTimer() {
        clearTimeout(this._dragTimer);
      }
      _keyDownHandler() {
        this._keyPressHandled = false;
      }
      _pasteHandler(event) {
        var {
          editor
        } = this;
        this._keyPressHandled = true;
        var caret3 = this.editorCaret();
        editor._maskKeyHandler(event, () => {
          var pastedText = clipboardText(event);
          var restText = editor._maskRulesChain.text().substring(caret3.end);
          var accepted = editor._handleChain({
            text: pastedText,
            start: caret3.start,
            length: pastedText.length
          });
          var newCaret = caret3.start + accepted;
          editor._handleChain({
            text: restText,
            start: newCaret,
            length: restText.length
          });
          editor._caret({
            start: newCaret,
            end: newCaret
          });
        });
      }
      _autoFillHandler(event) {
        var {
          editor
        } = this;
        var inputVal = this.editorInput().val();
        this._inputHandlerTimer = setTimeout(() => {
          this._keyPressHandled = true;
          if (this._isAutoFill()) {
            this._keyPressHandled = true;
            editor._maskKeyHandler(event, () => {
              editor._handleChain({
                text: inputVal,
                start: 0,
                length: inputVal.length
              });
            });
            editor._validateMask();
          }
        });
      }
      _isAutoFill() {
        var $input = this.editor._input();
        var result2 = false;
        if (browser_default.msie && browser_default.version > 11) {
          result2 = $input.hasClass("edge-autofilled");
        } else if (browser_default.webkit) {
          var input = $input.get(0);
          result2 = input && input.matches(":-webkit-autofill");
        }
        return result2;
      }
      runWithoutEventProcessing(action) {
        var keyPressHandled = this._keyPressHandled;
        this._keyPressHandled = true;
        action();
        this._keyPressHandled = keyPressHandled;
      }
      _backspaceHandler() {
      }
      _delHandler(event) {
        var {
          editor
        } = this;
        this._keyPressHandled = true;
        editor._maskKeyHandler(event, () => !editor._hasSelection() && editor._handleKey(EMPTY_CHAR2));
      }
      clean() {
        this._clearDragTimer();
        clearTimeout(this._backspaceHandlerTimeout);
        clearTimeout(this._caretTimeout);
        clearTimeout(this._inputHandlerTimer);
      }
    };
  }
});

// node_modules/devextreme/esm/ui/text_box/ui.text_editor.mask.strategy.default.js
var BACKSPACE_INPUT_TYPE, EMPTY_CHAR3, DefaultMaskStrategy, ui_text_editor_mask_strategy_default_default;
var init_ui_text_editor_mask_strategy_default = __esm({
  "node_modules/devextreme/esm/ui/text_box/ui.text_editor.mask.strategy.default.js"() {
    init_ui_text_editor_mask_strategy_base();
    init_utils2();
    init_promise();
    BACKSPACE_INPUT_TYPE = "deleteContentBackward";
    EMPTY_CHAR3 = " ";
    DefaultMaskStrategy = class extends BaseMaskStrategy {
      _getStrategyName() {
        return "default";
      }
      getHandleEventNames() {
        return [...super.getHandleEventNames(), "keyPress"];
      }
      _keyPressHandler(event) {
        if (this._keyPressHandled) {
          return;
        }
        this._keyPressHandled = true;
        if (this.editor._isControlKeyFired(event)) {
          return;
        }
        var {
          editor
        } = this;
        editor._maskKeyHandler(event, () => editor._handleKey(getChar(event)));
      }
      _inputHandler(event) {
        if (this._backspaceInputHandled(event.originalEvent && event.originalEvent.inputType)) {
          this._handleBackspaceInput(event);
        }
        if (event.originalEvent) {
          this._autoFillHandler(event);
        }
        if (this._keyPressHandled) {
          return;
        }
        this._keyPressHandled = true;
        var inputValue = this.editorInput().val();
        var caret3 = this.editorCaret();
        if (!caret3.end) {
          return;
        }
        caret3.start = caret3.end - 1;
        var oldValue = inputValue.substring(0, caret3.start) + inputValue.substring(caret3.end);
        var char = inputValue[caret3.start];
        var {
          editor
        } = this;
        this.editorInput().val(oldValue);
        editor._caret({
          start: caret3.start,
          end: caret3.start
        });
        editor._maskKeyHandler(event, () => editor._handleKey(char));
      }
      _backspaceHandler(event) {
        var {
          editor
        } = this;
        this._keyPressHandled = true;
        var afterBackspaceHandler = (needAdjustCaret, callBack) => {
          if (needAdjustCaret) {
            editor._direction(this.DIRECTION.FORWARD);
            editor._adjustCaret();
          }
          var currentCaret = this.editorCaret();
          return new promise_default((resolve) => {
            clearTimeout(this._backspaceHandlerTimeout);
            this._backspaceHandlerTimeout = setTimeout(function() {
              callBack(currentCaret);
              resolve();
            });
          });
        };
        editor._maskKeyHandler(event, () => {
          if (editor._hasSelection()) {
            return afterBackspaceHandler(true, (currentCaret) => {
              editor._displayMask(currentCaret);
              editor._maskRulesChain.reset();
            });
          }
          if (editor._tryMoveCaretBackward()) {
            return afterBackspaceHandler(false, (currentCaret) => {
              this.editorCaret(currentCaret);
            });
          }
          editor._handleKey(EMPTY_CHAR3, this.DIRECTION.BACKWARD);
          return afterBackspaceHandler(true, (currentCaret) => {
            editor._displayMask(currentCaret);
            editor._maskRulesChain.reset();
          });
        });
      }
      _backspaceInputHandled(inputType2) {
        return inputType2 === BACKSPACE_INPUT_TYPE && !this._keyPressHandled;
      }
      _handleBackspaceInput(event) {
        var {
          start,
          end
        } = this.editorCaret();
        this.editorCaret({
          start: start + 1,
          end: end + 1
        });
        this._backspaceHandler(event);
      }
    };
    ui_text_editor_mask_strategy_default_default = DefaultMaskStrategy;
  }
});

// node_modules/devextreme/esm/ui/text_box/ui.text_editor.mask.strategy.input_events.js
var DELETE_INPUT_TYPE, InputEventsMaskStrategy, ui_text_editor_mask_strategy_input_events_default;
var init_ui_text_editor_mask_strategy_input_events = __esm({
  "node_modules/devextreme/esm/ui/text_box/ui.text_editor.mask.strategy.input_events.js"() {
    init_ui_text_editor_mask_strategy_base();
    DELETE_INPUT_TYPE = "deleteContentBackward";
    InputEventsMaskStrategy = class extends BaseMaskStrategy {
      _getStrategyName() {
        return "inputEvents";
      }
      getHandleEventNames() {
        return [...super.getHandleEventNames(), "beforeInput"];
      }
      _beforeInputHandler() {
        this._prevCaret = this.editorCaret();
      }
      _inputHandler(_ref) {
        var {
          originalEvent
        } = _ref;
        if (!originalEvent) {
          return;
        }
        var {
          inputType: inputType2,
          data: data2
        } = originalEvent;
        var currentCaret = this.editorCaret();
        if (inputType2 === DELETE_INPUT_TYPE) {
          var length = this._prevCaret.end - this._prevCaret.start || 1;
          this.editor.setBackwardDirection();
          this._updateEditorMask({
            start: currentCaret.start,
            length,
            text: this._getEmptyString(length)
          });
        } else {
          var _this$_prevCaret, _this$_prevCaret2, _this$_prevCaret3;
          if (!currentCaret.end) {
            return;
          }
          this._autoFillHandler(originalEvent);
          this.editorCaret(currentCaret);
          var _length = (null === (_this$_prevCaret = this._prevCaret) || void 0 === _this$_prevCaret ? void 0 : _this$_prevCaret.end) - (null === (_this$_prevCaret2 = this._prevCaret) || void 0 === _this$_prevCaret2 ? void 0 : _this$_prevCaret2.start);
          var newData = data2 + (_length ? this._getEmptyString(_length - data2.length) : "");
          this.editor.setForwardDirection();
          var hasValidChars = this._updateEditorMask({
            start: null === (_this$_prevCaret3 = this._prevCaret) || void 0 === _this$_prevCaret3 ? void 0 : _this$_prevCaret3.start,
            length: _length || newData.length,
            text: newData
          });
          if (!hasValidChars) {
            this.editorCaret(this._prevCaret);
          }
        }
      }
      _getEmptyString(length) {
        return Array(length + 1).join(" ");
      }
      _updateEditorMask(args) {
        var textLength = args.text.length;
        var updatedCharsCount = this.editor._handleChain(args);
        if (this.editor.isForwardDirection()) {
          var {
            start,
            end
          } = this.editorCaret();
          var correction = updatedCharsCount - textLength;
          if (start <= updatedCharsCount && updatedCharsCount > 1) {
            this.editorCaret({
              start: start + correction,
              end: end + correction
            });
          }
          this.editor.isForwardDirection() && this.editor._adjustCaret();
        }
        this.editor._displayMask();
        return !!updatedCharsCount;
      }
    };
    ui_text_editor_mask_strategy_input_events_default = InputEventsMaskStrategy;
  }
});

// node_modules/devextreme/esm/ui/text_box/ui.text_editor.mask.js
function isNumericChar(char) {
  return /[0-9]/.test(char);
}
function isLiteralChar(char) {
  var code = char.charCodeAt();
  return 64 < code && code < 91 || 96 < code && code < 123 || code > 127;
}
function isSpaceChar(char) {
  return " " === char;
}
var stubCaret, caret2, EMPTY_CHAR4, ESCAPED_CHAR, TEXTEDITOR_MASKED_CLASS, FORWARD_DIRECTION, BACKWARD_DIRECTION, buildInMaskRules, TextEditorMask, ui_text_editor_mask_default;
var init_ui_text_editor_mask = __esm({
  "node_modules/devextreme/esm/ui/text_box/ui.text_editor.mask.js"() {
    init_renderer();
    init_utils_caret();
    init_utils_support();
    init_iterator();
    init_utils2();
    init_events_engine();
    init_extend();
    init_selectors();
    init_type();
    init_message();
    init_common();
    init_string();
    init_wheel();
    init_ui_text_editor_mask_rule();
    init_ui_text_editor_base();
    init_ui_text_editor_mask_strategy_default();
    init_ui_text_editor_mask_strategy_input_events();
    stubCaret = function() {
      return {};
    };
    caret2 = utils_caret_default;
    EMPTY_CHAR4 = " ";
    ESCAPED_CHAR = "\\";
    TEXTEDITOR_MASKED_CLASS = "dx-texteditor-masked";
    FORWARD_DIRECTION = "forward";
    BACKWARD_DIRECTION = "backward";
    buildInMaskRules = {
      0: /[0-9]/,
      9: /[0-9\s]/,
      "#": /[-+0-9\s]/,
      L: function(char) {
        return isLiteralChar(char);
      },
      l: function(char) {
        return isLiteralChar(char) || isSpaceChar(char);
      },
      C: /\S/,
      c: /./,
      A: function(char) {
        return isLiteralChar(char) || isNumericChar(char);
      },
      a: function(char) {
        return isLiteralChar(char) || isNumericChar(char) || isSpaceChar(char);
      }
    };
    TextEditorMask = ui_text_editor_base_default.inherit({
      _getDefaultOptions: function() {
        return extend2(this.callBase(), {
          mask: "",
          maskChar: "_",
          maskRules: {},
          maskInvalidMessage: message_default.format("validation-mask"),
          useMaskedValue: false,
          showMaskMode: "always"
        });
      },
      _supportedKeys: function() {
        var that = this;
        var keyHandlerMap = {
          backspace: that._maskStrategy.getHandler("backspace"),
          del: that._maskStrategy.getHandler("del"),
          enter: that._changeHandler
        };
        var result2 = that.callBase();
        each(keyHandlerMap, function(key, callback) {
          var parentHandler = result2[key];
          result2[key] = function(e) {
            that.option("mask") && callback.call(that, e);
            parentHandler && parentHandler(e);
          };
        });
        return result2;
      },
      _getSubmitElement: function() {
        return !this.option("mask") ? this.callBase() : this._$hiddenElement;
      },
      _init: function() {
        this.callBase();
        this._initMaskStrategy();
      },
      _initMaskStrategy: function() {
        this._maskStrategy = isInputEventsL2Supported() ? new ui_text_editor_mask_strategy_input_events_default(this) : new ui_text_editor_mask_strategy_default_default(this);
      },
      _initMarkup: function() {
        this._renderHiddenElement();
        this.callBase();
      },
      _attachMouseWheelEventHandlers: function() {
        var hasMouseWheelHandler = this._onMouseWheel !== noop2;
        if (!hasMouseWheelHandler) {
          return;
        }
        var input = this._input();
        var eventName = addNamespace2(EVENT_NAME, this.NAME);
        var mouseWheelAction = this._createAction((function(e) {
          var {
            event
          } = e;
          if (focused(input) && !isCommandKeyPressed(event)) {
            this._onMouseWheel(event);
            event.preventDefault();
            event.stopPropagation();
          }
        }).bind(this));
        events_engine_default.off(input, eventName);
        events_engine_default.on(input, eventName, function(e) {
          mouseWheelAction({
            event: e
          });
        });
      },
      _onMouseWheel: noop2,
      _render: function() {
        this._renderMask();
        this.callBase();
        this._attachMouseWheelEventHandlers();
      },
      _renderHiddenElement: function() {
        if (this.option("mask")) {
          this._$hiddenElement = renderer_default("<input>").attr("type", "hidden").appendTo(this._inputWrapper());
        }
      },
      _removeHiddenElement: function() {
        this._$hiddenElement && this._$hiddenElement.remove();
      },
      _renderMask: function() {
        this.$element().removeClass(TEXTEDITOR_MASKED_CLASS);
        this._maskRulesChain = null;
        this._maskStrategy.detachEvents();
        if (!this.option("mask")) {
          return;
        }
        this.$element().addClass(TEXTEDITOR_MASKED_CLASS);
        this._maskStrategy.attachEvents();
        this._parseMask();
        this._renderMaskedValue();
      },
      _suppressCaretChanging: function(callback, args) {
        caret2 = stubCaret;
        try {
          callback.apply(this, args);
        } finally {
          caret2 = utils_caret_default;
        }
      },
      _changeHandler: function(e) {
        var $input = this._input();
        var inputValue = $input.val();
        if (inputValue === this._changedValue) {
          return;
        }
        this._changedValue = inputValue;
        var changeEvent = createEvent(e, {
          type: "change"
        });
        events_engine_default.trigger($input, changeEvent);
      },
      _parseMask: function() {
        this._maskRules = extend2({}, buildInMaskRules, this.option("maskRules"));
        this._maskRulesChain = this._parseMaskRule(0);
      },
      _parseMaskRule: function(index2) {
        var mask = this.option("mask");
        if (index2 >= mask.length) {
          return new EmptyMaskRule();
        }
        var currentMaskChar = mask[index2];
        var isEscapedChar = currentMaskChar === ESCAPED_CHAR;
        var result2 = isEscapedChar ? new StubMaskRule({
          maskChar: mask[index2 + 1]
        }) : this._getMaskRule(currentMaskChar);
        result2.next(this._parseMaskRule(index2 + 1 + isEscapedChar));
        return result2;
      },
      _getMaskRule: function(pattern) {
        var ruleConfig;
        each(this._maskRules, function(rulePattern, allowedChars) {
          if (rulePattern === pattern) {
            ruleConfig = {
              pattern: rulePattern,
              allowedChars
            };
            return false;
          }
        });
        return isDefined(ruleConfig) ? new MaskRule(extend2({
          maskChar: this.option("maskChar")
        }, ruleConfig)) : new StubMaskRule({
          maskChar: pattern
        });
      },
      _renderMaskedValue: function() {
        if (!this._maskRulesChain) {
          return;
        }
        var value2 = this.option("value") || "";
        this._maskRulesChain.clear(this._normalizeChainArguments());
        var chainArgs = {
          length: value2.length
        };
        chainArgs[this._isMaskedValueMode() ? "text" : "value"] = value2;
        this._handleChain(chainArgs);
        this._displayMask();
      },
      _replaceSelectedText: function(text, selection, char) {
        if (void 0 === char) {
          return text;
        }
        var textBefore = text.slice(0, selection.start);
        var textAfter = text.slice(selection.end);
        var edited = textBefore + char + textAfter;
        return edited;
      },
      _isMaskedValueMode: function() {
        return this.option("useMaskedValue");
      },
      _displayMask: function(caret3) {
        caret3 = caret3 || this._caret();
        this._renderValue();
        this._caret(caret3);
      },
      _isValueEmpty: function() {
        return isEmpty(this._value);
      },
      _shouldShowMask: function() {
        var showMaskMode = this.option("showMaskMode");
        if ("onFocus" === showMaskMode) {
          return focused(this._input()) || !this._isValueEmpty();
        }
        return true;
      },
      _showMaskPlaceholder: function() {
        if (this._shouldShowMask()) {
          var text = this._maskRulesChain.text();
          this.option("text", text);
          if ("onFocus" === this.option("showMaskMode")) {
            this._renderDisplayText(text);
          }
        }
      },
      _renderValue: function() {
        if (this._maskRulesChain) {
          this._showMaskPlaceholder();
          if (this._$hiddenElement) {
            var value2 = this._maskRulesChain.value();
            var submitElementValue = !isEmpty(value2) ? this._getPreparedValue() : "";
            this._$hiddenElement.val(submitElementValue);
          }
        }
        return this.callBase();
      },
      _getPreparedValue: function() {
        return this._convertToValue().replace(/\s+$/, "");
      },
      _valueChangeEventHandler: function(e) {
        if (!this._maskRulesChain) {
          this.callBase.apply(this, arguments);
          return;
        }
        this._saveValueChangeEvent(e);
        this.option("value", this._getPreparedValue());
      },
      _isControlKeyFired: function(e) {
        return this._isControlKey(normalizeKeyName(e)) || isCommandKeyPressed(e);
      },
      _handleChain: function(args) {
        var handledCount = this._maskRulesChain.handle(this._normalizeChainArguments(args));
        this._value = this._maskRulesChain.value();
        this._textValue = this._maskRulesChain.text();
        return handledCount;
      },
      _normalizeChainArguments: function(args) {
        args = args || {};
        args.index = 0;
        args.fullText = this._maskRulesChain.text();
        return args;
      },
      _convertToValue: function(text) {
        if (this._isMaskedValueMode()) {
          text = this._replaceMaskCharWithEmpty(text || this._textValue || "");
        } else {
          text = text || this._value || "";
        }
        return text;
      },
      _replaceMaskCharWithEmpty: function(text) {
        return text.replace(new RegExp(this.option("maskChar"), "g"), EMPTY_CHAR4);
      },
      _maskKeyHandler: function(e, keyHandler) {
        if (this.option("readOnly")) {
          return;
        }
        this.setForwardDirection();
        e.preventDefault();
        this._handleSelection();
        var previousText = this._input().val();
        var raiseInputEvent = () => {
          if (previousText !== this._input().val()) {
            this._maskStrategy.runWithoutEventProcessing(() => events_engine_default.trigger(this._input(), "input"));
          }
        };
        var handled = keyHandler();
        if (handled) {
          handled.then(raiseInputEvent);
        } else {
          this.setForwardDirection();
          this._adjustCaret();
          this._displayMask();
          this._maskRulesChain.reset();
          raiseInputEvent();
        }
      },
      _handleKey: function(key, direction) {
        this._direction(direction || FORWARD_DIRECTION);
        this._adjustCaret(key);
        this._handleKeyChain(key);
        this._moveCaret();
      },
      _handleSelection: function() {
        if (!this._hasSelection()) {
          return;
        }
        var caret3 = this._caret();
        var emptyChars = new Array(caret3.end - caret3.start + 1).join(EMPTY_CHAR4);
        this._handleKeyChain(emptyChars);
      },
      _handleKeyChain: function(chars) {
        var caret3 = this._caret();
        var start = this.isForwardDirection() ? caret3.start : caret3.start - 1;
        var end = this.isForwardDirection() ? caret3.end : caret3.end - 1;
        var length = start === end ? 1 : end - start;
        this._handleChain({
          text: chars,
          start,
          length
        });
      },
      _tryMoveCaretBackward: function() {
        this.setBackwardDirection();
        var currentCaret = this._caret().start;
        this._adjustCaret();
        return !currentCaret || currentCaret !== this._caret().start;
      },
      _adjustCaret: function(char) {
        var caretStart = this._caret().start;
        var isForwardDirection = this.isForwardDirection();
        var caret3 = this._maskRulesChain.adjustedCaret(caretStart, isForwardDirection, char);
        this._caret({
          start: caret3,
          end: caret3
        });
      },
      _moveCaret: function() {
        var currentCaret = this._caret().start;
        var maskRuleIndex = currentCaret + (this.isForwardDirection() ? 0 : -1);
        var caret3 = this._maskRulesChain.isAccepted(maskRuleIndex) ? currentCaret + (this.isForwardDirection() ? 1 : -1) : currentCaret;
        this._caret({
          start: caret3,
          end: caret3
        });
      },
      _caret: function(position3, force) {
        var $input = this._input();
        if (!$input.length) {
          return;
        }
        if (!arguments.length) {
          return caret2($input);
        }
        caret2($input, position3, force);
      },
      _hasSelection: function() {
        var caret3 = this._caret();
        return caret3.start !== caret3.end;
      },
      _direction: function(direction) {
        if (!arguments.length) {
          return this._typingDirection;
        }
        this._typingDirection = direction;
      },
      setForwardDirection: function() {
        this._direction(FORWARD_DIRECTION);
      },
      setBackwardDirection: function() {
        this._direction(BACKWARD_DIRECTION);
      },
      isForwardDirection: function() {
        return this._direction() === FORWARD_DIRECTION;
      },
      _clean: function() {
        this._maskStrategy && this._maskStrategy.clean();
        this.callBase();
      },
      _validateMask: function() {
        if (!this._maskRulesChain) {
          return;
        }
        var isValid = isEmpty(this.option("value")) || this._maskRulesChain.isValid(this._normalizeChainArguments());
        this.option({
          isValid,
          validationError: isValid ? null : {
            editorSpecific: true,
            message: this.option("maskInvalidMessage")
          }
        });
      },
      _updateHiddenElement: function() {
        this._removeHiddenElement();
        if (this.option("mask")) {
          this._input().removeAttr("name");
          this._renderHiddenElement();
        }
        this._setSubmitElementName(this.option("name"));
      },
      _updateMaskOption: function() {
        this._updateHiddenElement();
        this._renderMask();
        this._validateMask();
      },
      _processEmptyMask: function(mask) {
        if (mask) {
          return;
        }
        var value2 = this.option("value");
        this.option({
          text: value2,
          isValid: true
        });
        this.validationRequest.fire({
          value: value2,
          editor: this
        });
        this._renderValue();
      },
      _optionChanged: function(args) {
        switch (args.name) {
          case "mask":
            this._updateMaskOption();
            this._processEmptyMask(args.value);
            break;
          case "maskChar":
          case "maskRules":
          case "useMaskedValue":
            this._updateMaskOption();
            break;
          case "value":
            this._renderMaskedValue();
            this._validateMask();
            this.callBase(args);
            this._changedValue = this._input().val();
            break;
          case "maskInvalidMessage":
            break;
          case "showMaskMode":
            this.option("text", "");
            this._renderValue();
            break;
          default:
            this.callBase(args);
        }
      }
    });
    ui_text_editor_mask_default = TextEditorMask;
  }
});

// node_modules/devextreme/esm/ui/text_box/ui.text_editor.js
var ui_text_editor_default;
var init_ui_text_editor = __esm({
  "node_modules/devextreme/esm/ui/text_box/ui.text_editor.js"() {
    init_component_registrator();
    init_ui_text_editor_mask();
    component_registrator_default("dxTextEditor", ui_text_editor_mask_default);
    ui_text_editor_default = ui_text_editor_mask_default;
  }
});

// node_modules/devextreme/esm/ui/text_box/text_box.js
var window13, navigator4, ua, ignoreKeys, TEXTBOX_CLASS, SEARCHBOX_CLASS, ICON_CLASS2, SEARCH_ICON_CLASS, TextBox, text_box_default;
var init_text_box = __esm({
  "node_modules/devextreme/esm/ui/text_box/text_box.js"() {
    init_renderer();
    init_window();
    init_browser();
    init_events_engine();
    init_devices();
    init_array();
    init_extend();
    init_component_registrator();
    init_ui_text_editor();
    init_utils2();
    window13 = getWindow();
    navigator4 = getNavigator();
    ua = navigator4.userAgent;
    ignoreKeys = ["backspace", "tab", "enter", "pageUp", "pageDown", "end", "home", "leftArrow", "rightArrow", "downArrow", "upArrow", "del"];
    TEXTBOX_CLASS = "dx-textbox";
    SEARCHBOX_CLASS = "dx-searchbox";
    ICON_CLASS2 = "dx-icon";
    SEARCH_ICON_CLASS = "dx-icon-search";
    TextBox = ui_text_editor_default.inherit({
      ctor: function(element, options2) {
        if (options2) {
          this._showClearButton = options2.showClearButton;
        }
        this.callBase.apply(this, arguments);
      },
      _getDefaultOptions: function() {
        return extend2(this.callBase(), {
          value: "",
          mode: "text",
          maxLength: null
        });
      },
      _initMarkup: function() {
        this.$element().addClass(TEXTBOX_CLASS);
        this.callBase();
        this.setAria("role", "textbox");
      },
      _renderContentImpl: function() {
        this._renderMaxLengthHandlers();
        this.callBase();
      },
      _renderInputType: function() {
        this.callBase();
        this._renderSearchMode();
      },
      _renderMaxLengthHandlers: function() {
        if (this._isAndroidOrIE()) {
          events_engine_default.on(this._input(), addNamespace2("keydown", this.NAME), this._onKeyDownCutOffHandler.bind(this));
          events_engine_default.on(this._input(), addNamespace2("change", this.NAME), this._onChangeCutOffHandler.bind(this));
        }
      },
      _useTemplates: function() {
        return false;
      },
      _renderProps: function() {
        this.callBase();
        this._toggleMaxLengthProp();
      },
      _toggleMaxLengthProp: function() {
        var maxLength = this._getMaxLength();
        if (maxLength && maxLength > 0) {
          this._input().attr("maxLength", maxLength);
        } else {
          this._input().removeAttr("maxLength");
        }
      },
      _renderSearchMode: function() {
        var $element = this._$element;
        if ("search" === this.option("mode")) {
          $element.addClass(SEARCHBOX_CLASS);
          this._renderSearchIcon();
          if (void 0 === this._showClearButton) {
            this._showClearButton = this.option("showClearButton");
            this.option("showClearButton", true);
          }
        } else {
          $element.removeClass(SEARCHBOX_CLASS);
          this._$searchIcon && this._$searchIcon.remove();
          this.option("showClearButton", void 0 === this._showClearButton ? this.option("showClearButton") : this._showClearButton);
          delete this._showClearButton;
        }
      },
      _renderSearchIcon: function() {
        var $searchIcon = renderer_default("<div>").addClass(ICON_CLASS2).addClass(SEARCH_ICON_CLASS);
        $searchIcon.prependTo(this._input().parent());
        this._$searchIcon = $searchIcon;
      },
      _optionChanged: function(args) {
        switch (args.name) {
          case "maxLength":
            this._toggleMaxLengthProp();
            this._renderMaxLengthHandlers();
            break;
          case "mask":
            this.callBase(args);
            this._toggleMaxLengthProp();
            break;
          default:
            this.callBase(args);
        }
      },
      _onKeyDownCutOffHandler: function(e) {
        var actualMaxLength = this._getMaxLength();
        if (actualMaxLength && !e.ctrlKey && !this._hasSelection()) {
          var $input = renderer_default(e.target);
          var key = normalizeKeyName(e);
          this._cutOffExtraChar($input);
          return $input.val().length < actualMaxLength || -1 !== inArray(key, ignoreKeys) || "" !== window13.getSelection().toString();
        } else {
          return true;
        }
      },
      _onChangeCutOffHandler: function(e) {
        var $input = renderer_default(e.target);
        if (this.option("maxLength")) {
          this._cutOffExtraChar($input);
        }
      },
      _cutOffExtraChar: function($input) {
        var actualMaxLength = this._getMaxLength();
        var textInput = $input.val();
        if (actualMaxLength && textInput.length > actualMaxLength) {
          $input.val(textInput.substr(0, actualMaxLength));
        }
      },
      _getMaxLength: function() {
        var isMaskSpecified = !!this.option("mask");
        return isMaskSpecified ? null : this.option("maxLength");
      },
      _isAndroidOrIE: function() {
        var realDevice4 = devices_default.real();
        var version2 = realDevice4.version.join(".");
        return browser_default.msie || "android" === realDevice4.platform && version2 && /^(2\.|4\.1)/.test(version2) && !/chrome/i.test(ua);
      }
    });
    component_registrator_default("dxTextBox", TextBox);
    text_box_default = TextBox;
  }
});

// node_modules/devextreme/esm/ui/text_box.js
var text_box_default2;
var init_text_box2 = __esm({
  "node_modules/devextreme/esm/ui/text_box.js"() {
    init_text_box();
    text_box_default2 = text_box_default;
  }
});

// node_modules/devextreme/esm/ui/widget/ui.search_box_mixin.js
var ui_search_box_mixin_default;
var init_ui_search_box_mixin = __esm({
  "node_modules/devextreme/esm/ui/widget/ui.search_box_mixin.js"() {
    init_renderer();
    init_extend();
    init_message();
    init_text_box2();
    init_ui_errors();
    init_deferred();
    ui_search_box_mixin_default = {
      _getDefaultOptions: function() {
        return extend2(this.callBase(), {
          searchMode: "",
          searchExpr: null,
          searchValue: "",
          searchEnabled: false,
          searchEditorOptions: {}
        });
      },
      _initMarkup: function() {
        this._renderSearch();
        this.callBase();
      },
      _renderSearch: function() {
        var $element = this.$element();
        var searchEnabled = this.option("searchEnabled");
        var searchBoxClassName = this._addWidgetPrefix("search");
        var rootElementClassName = this._addWidgetPrefix("with-search");
        if (!searchEnabled) {
          $element.removeClass(rootElementClassName);
          this._removeSearchBox();
          return;
        }
        var editorOptions = this._getSearchEditorOptions();
        if (this._searchEditor) {
          this._searchEditor.option(editorOptions);
        } else {
          $element.addClass(rootElementClassName);
          this._$searchEditorElement = renderer_default("<div>").addClass(searchBoxClassName).prependTo($element);
          this._searchEditor = this._createComponent(this._$searchEditorElement, text_box_default2, editorOptions);
        }
      },
      _removeSearchBox: function() {
        this._$searchEditorElement && this._$searchEditorElement.remove();
        delete this._$searchEditorElement;
        delete this._searchEditor;
      },
      _getSearchEditorOptions: function() {
        var that = this;
        var userEditorOptions = that.option("searchEditorOptions");
        var searchText = message_default.format("Search");
        return extend2({
          mode: "search",
          placeholder: searchText,
          tabIndex: that.option("tabIndex"),
          value: that.option("searchValue"),
          valueChangeEvent: "input",
          inputAttr: {
            "aria-label": searchText
          },
          onValueChanged: function(e) {
            var searchTimeout = that.option("searchTimeout");
            that._valueChangeDeferred = new Deferred();
            clearTimeout(that._valueChangeTimeout);
            that._valueChangeDeferred.done((function() {
              this.option("searchValue", e.value);
            }).bind(that));
            if (e.event && "input" === e.event.type && searchTimeout) {
              that._valueChangeTimeout = setTimeout(function() {
                that._valueChangeDeferred.resolve();
              }, searchTimeout);
            } else {
              that._valueChangeDeferred.resolve();
            }
          }
        }, userEditorOptions);
      },
      _getAriaTarget: function() {
        if (this.option("searchEnabled")) {
          return this._itemContainer(true);
        }
        return this.$element();
      },
      _focusTarget: function() {
        if (this.option("searchEnabled")) {
          return this._itemContainer(true);
        }
        return this.callBase();
      },
      _updateFocusState: function(e, isFocused) {
        if (this.option("searchEnabled")) {
          this._toggleFocusClass(isFocused, this.$element());
        }
        this.callBase(e, isFocused);
      },
      getOperationBySearchMode: function(searchMode) {
        return "equals" === searchMode ? "=" : searchMode;
      },
      _cleanAria: function($target) {
        this.setAria({
          role: null,
          activedescendant: null
        }, $target);
        $target.attr("tabIndex", null);
      },
      _optionChanged: function(args) {
        switch (args.name) {
          case "searchEnabled":
          case "searchEditorOptions":
            this._cleanAria(this.option("searchEnabled") ? this.$element() : this._itemContainer());
            this._invalidate();
            break;
          case "searchExpr":
          case "searchMode":
          case "searchValue":
            if (!this._dataSource) {
              ui_errors_default.log("W1009");
              return;
            }
            if ("searchMode" === args.name) {
              this._dataSource.searchOperation(this.getOperationBySearchMode(args.value));
            } else {
              this._dataSource[args.name](args.value);
            }
            this._dataSource.load();
            break;
          case "searchTimeout":
            break;
          default:
            this.callBase(args);
        }
      },
      focus: function() {
        if (!this.option("focusedElement") && this.option("searchEnabled")) {
          this._searchEditor && this._searchEditor.focus();
          return;
        }
        this.callBase();
      },
      _refresh: function() {
        if (this._valueChangeDeferred) {
          this._valueChangeDeferred.resolve();
        }
        this.callBase();
      }
    };
  }
});

// node_modules/devextreme/esm/ui/hierarchical_collection/ui.data_converter.js
var DataConverter, ui_data_converter_default;
var init_ui_data_converter = __esm({
  "node_modules/devextreme/esm/ui/hierarchical_collection/ui.data_converter.js"() {
    init_class();
    init_extend();
    init_ui_errors();
    init_iterator();
    init_type();
    DataConverter = class_default.inherit({
      ctor: function() {
        this._dataStructure = [];
        this._itemsCount = 0;
        this._visibleItemsCount = 0;
      },
      _indexByKey: {},
      _convertItemsToNodes: function(items, parentKey) {
        var that = this;
        each(items, function(_2, item) {
          var parentId = isDefined(parentKey) ? parentKey : that._getParentId(item);
          var node = that._convertItemToNode(item, parentId);
          that._dataStructure.push(node);
          that._checkForDuplicateId(node.internalFields.key);
          that._indexByKey[node.internalFields.key] = that._dataStructure.length - 1;
          if (that._itemHasChildren(item)) {
            that._convertItemsToNodes(that._dataAccessors.getters.items(item), node.internalFields.key);
          }
        });
      },
      _checkForDuplicateId: function(key) {
        if (isDefined(this._indexByKey[key])) {
          throw ui_errors_default.Error("E1040", key);
        }
      },
      _getParentId: function(item) {
        return "plain" === this._dataType ? this._dataAccessors.getters.parentKey(item) : void 0;
      },
      _itemHasChildren: function(item) {
        if ("plain" === this._dataType) {
          return;
        }
        var items = this._dataAccessors.getters.items(item);
        return items && items.length;
      },
      _getUniqueKey: function(item) {
        var keyGetter = this._dataAccessors.getters.key;
        var itemKey = keyGetter(item);
        var isCorrectKey = keyGetter && (itemKey || 0 === itemKey) && isPrimitive(itemKey);
        return isCorrectKey ? itemKey : this.getItemsCount();
      },
      _convertItemToNode: function(item, parentKey) {
        this._itemsCount++;
        false !== item.visible && this._visibleItemsCount++;
        var node = {
          internalFields: {
            disabled: this._dataAccessors.getters.disabled(item, {
              defaultValue: false
            }),
            expanded: this._dataAccessors.getters.expanded(item, {
              defaultValue: false
            }),
            selected: this._dataAccessors.getters.selected(item, {
              defaultValue: false
            }),
            key: this._getUniqueKey(item),
            parentKey: isDefined(parentKey) ? parentKey : this._rootValue,
            item: this._makeObjectFromPrimitive(item),
            childrenKeys: []
          }
        };
        extend2(node, item);
        delete node.items;
        return node;
      },
      setChildrenKeys: function() {
        var that = this;
        each(this._dataStructure, function(_2, node) {
          if (node.internalFields.parentKey === that._rootValue) {
            return;
          }
          var parent = that.getParentNode(node);
          parent && parent.internalFields.childrenKeys.push(node.internalFields.key);
        });
      },
      _makeObjectFromPrimitive: function(item) {
        if (isPrimitive(item)) {
          var key = item;
          item = {};
          this._dataAccessors.setters.key(item, key);
        }
        return item;
      },
      _convertToPublicNode: function(node, parent) {
        if (!node) {
          return null;
        }
        var publicNode = {
          text: this._dataAccessors.getters.display(node),
          key: node.internalFields.key,
          selected: node.internalFields.selected,
          expanded: node.internalFields.expanded,
          disabled: node.internalFields.disabled,
          parent: parent || null,
          itemData: node.internalFields.item,
          children: [],
          items: []
        };
        if (publicNode.parent) {
          publicNode.parent.children.push(publicNode);
          publicNode.parent.items.push(publicNode);
        }
        return publicNode;
      },
      convertToPublicNodes: function(data2, parent) {
        if (!data2.length) {
          return [];
        }
        var that = this;
        var publicNodes = [];
        each(data2, function(_2, node) {
          node = isPrimitive(node) ? that._getByKey(node) : node;
          var publicNode = that._convertToPublicNode(node, parent);
          publicNode.children = that.convertToPublicNodes(node.internalFields.childrenKeys, publicNode);
          publicNodes.push(publicNode);
          node.internalFields.publicNode = publicNode;
        });
        return publicNodes;
      },
      setDataAccessors: function(accessors) {
        this._dataAccessors = accessors;
      },
      _getByKey: function(key) {
        return this._dataStructure[this.getIndexByKey(key)] || null;
      },
      getParentNode: function(node) {
        return this._getByKey(node.internalFields.parentKey);
      },
      getByKey: function(data2, key) {
        if (null === key || void 0 === key) {
          return null;
        }
        var result2 = null;
        var that = this;
        var getByKey = function(data3, key2) {
          each(data3, function(_2, element) {
            var currentElementKey = element.internalFields && element.internalFields.key || that._dataAccessors.getters.key(element);
            if (currentElementKey.toString() === key2.toString()) {
              result2 = element;
              return false;
            }
          });
          return result2;
        };
        return getByKey(data2, key);
      },
      getItemsCount: function() {
        return this._itemsCount;
      },
      getVisibleItemsCount: function() {
        return this._visibleItemsCount;
      },
      updateIndexByKey: function() {
        var that = this;
        this._indexByKey = {};
        each(this._dataStructure, function(index2, node) {
          that._checkForDuplicateId(node.internalFields.key);
          that._indexByKey[node.internalFields.key] = index2;
        });
      },
      updateChildrenKeys: function() {
        this._indexByKey = {};
        this.removeChildrenKeys();
        this.updateIndexByKey();
        this.setChildrenKeys();
      },
      removeChildrenKeys: function() {
        this._indexByKey = {};
        each(this._dataStructure, function(index2, node) {
          node.internalFields.childrenKeys = [];
        });
      },
      getIndexByKey: function(key) {
        return this._indexByKey[key];
      },
      createPlainStructure: function(items, rootValue, dataType) {
        this._itemsCount = 0;
        this._visibleItemsCount = 0;
        this._rootValue = rootValue;
        this._dataType = dataType;
        this._indexByKey = {};
        this._convertItemsToNodes(items);
        this.setChildrenKeys();
        return this._dataStructure;
      }
    });
    ui_data_converter_default = DataConverter;
  }
});

// node_modules/devextreme/esm/ui/hierarchical_collection/ui.data_adapter.js
var EXPANDED, SELECTED, DISABLED, DataAdapter, ui_data_adapter_default;
var init_ui_data_adapter = __esm({
  "node_modules/devextreme/esm/ui/hierarchical_collection/ui.data_adapter.js"() {
    init_class();
    init_common();
    init_iterator();
    init_type();
    init_extend();
    init_ui_errors();
    init_ui_search_box_mixin();
    init_array();
    init_query();
    init_store_helper();
    init_ui_data_converter();
    EXPANDED = "expanded";
    SELECTED = "selected";
    DISABLED = "disabled";
    DataAdapter = class_default.inherit({
      ctor: function(options2) {
        this.options = {};
        extend2(this.options, this._defaultOptions(), options2);
        this.options.dataConverter.setDataAccessors(this.options.dataAccessors);
        this._selectedNodesKeys = [];
        this._expandedNodesKeys = [];
        this._dataStructure = [];
        this._createInternalDataStructure();
        this.getTreeNodes();
      },
      setOption: function(name2, value2) {
        this.options[name2] = value2;
        if ("recursiveSelection" === name2) {
          this._updateSelection();
        }
      },
      _defaultOptions: function() {
        return {
          dataAccessors: void 0,
          items: [],
          multipleSelection: true,
          recursiveSelection: false,
          recursiveExpansion: false,
          rootValue: 0,
          searchValue: "",
          dataType: "tree",
          searchMode: "contains",
          dataConverter: new ui_data_converter_default(),
          onNodeChanged: noop2,
          sort: null
        };
      },
      _createInternalDataStructure: function() {
        this._initialDataStructure = this.options.dataConverter.createPlainStructure(this.options.items, this.options.rootValue, this.options.dataType);
        this._dataStructure = this.options.searchValue.length ? this.search(this.options.searchValue) : this._initialDataStructure;
        this.options.dataConverter._dataStructure = this._dataStructure;
        this._updateSelection();
        this._updateExpansion();
      },
      _updateSelection: function() {
        if (this.options.recursiveSelection) {
          this._setChildrenSelection();
          this._setParentSelection();
        }
        this._selectedNodesKeys = this._updateNodesKeysArray(SELECTED);
      },
      _updateExpansion: function(key) {
        if (this.options.recursiveExpansion) {
          key ? this._updateOneBranch(key) : this._setParentExpansion();
        }
        this._expandedNodesKeys = this._updateNodesKeysArray(EXPANDED);
      },
      _updateNodesKeysArray: function(property) {
        var that = this;
        var array = [];
        each(that._getDataBySelectionMode(), function(_2, node) {
          if (!that._isNodeVisible(node)) {
            return;
          }
          if (node.internalFields[property]) {
            if (property === EXPANDED || that.options.multipleSelection) {
              array.push(node.internalFields.key);
            } else {
              array.length && that.toggleSelection(array[0], false, true);
              array = [node.internalFields.key];
            }
          }
        });
        return array;
      },
      _getDataBySelectionMode: function() {
        return this.options.multipleSelection ? this.getData() : this.getFullData();
      },
      _isNodeVisible: function(node) {
        return false !== node.internalFields.item.visible;
      },
      _getByKey: function(data2, key) {
        return data2 === this._dataStructure ? this.options.dataConverter._getByKey(key) : this.options.dataConverter.getByKey(data2, key);
      },
      _setChildrenSelection: function() {
        var that = this;
        each(this._dataStructure, function(_2, node) {
          if (!node.internalFields.childrenKeys.length) {
            return;
          }
          var isSelected = node.internalFields.selected;
          true === isSelected && that._toggleChildrenSelection(node, isSelected);
        });
      },
      _setParentSelection: function() {
        var that = this;
        each(this._dataStructure, function(_2, node) {
          var parent = that.options.dataConverter.getParentNode(node);
          if (parent && node.internalFields.parentKey !== that.options.rootValue) {
            that._iterateParents(node, function(parent2) {
              var newParentState = that._calculateSelectedState(parent2);
              that._setFieldState(parent2, SELECTED, newParentState);
            });
          }
        });
      },
      _setParentExpansion: function() {
        var that = this;
        each(this._dataStructure, function(_2, node) {
          if (!node.internalFields.expanded) {
            return;
          }
          that._updateOneBranch(node.internalFields.key);
        });
      },
      _updateOneBranch: function(key) {
        var that = this;
        var node = this.getNodeByKey(key);
        that._iterateParents(node, function(parent) {
          that._setFieldState(parent, EXPANDED, true);
        });
      },
      _iterateChildren: function(node, recursive, callback, processedKeys) {
        if (!isFunction(callback)) {
          return;
        }
        var that = this;
        var nodeKey = node.internalFields.key;
        processedKeys = processedKeys || [];
        if (-1 === processedKeys.indexOf(nodeKey)) {
          processedKeys.push(nodeKey);
          each(node.internalFields.childrenKeys, function(_2, key) {
            var child = that.getNodeByKey(key);
            callback(child);
            if (child.internalFields.childrenKeys.length && recursive) {
              that._iterateChildren(child, recursive, callback, processedKeys);
            }
          });
        }
      },
      _iterateParents: function(node, callback, processedKeys) {
        if (node.internalFields.parentKey === this.options.rootValue || !isFunction(callback)) {
          return;
        }
        processedKeys = processedKeys || [];
        var key = node.internalFields.key;
        if (-1 === processedKeys.indexOf(key)) {
          processedKeys.push(key);
          var parent = this.options.dataConverter.getParentNode(node);
          if (parent) {
            callback(parent);
            if (parent.internalFields.parentKey !== this.options.rootValue) {
              this._iterateParents(parent, callback, processedKeys);
            }
          }
        }
      },
      _calculateSelectedState: function(node) {
        var itemsCount = node.internalFields.childrenKeys.length;
        var selectedItemsCount = 0;
        var invisibleItemsCount = 0;
        var result2 = false;
        for (var i = 0; i <= itemsCount - 1; i++) {
          var childNode = this.getNodeByKey(node.internalFields.childrenKeys[i]);
          var isChildInvisible = false === childNode.internalFields.item.visible;
          var childState = childNode.internalFields.selected;
          if (isChildInvisible) {
            invisibleItemsCount++;
            continue;
          }
          if (childState) {
            selectedItemsCount++;
          } else if (void 0 === childState) {
            selectedItemsCount += 0.5;
          }
        }
        if (selectedItemsCount) {
          result2 = selectedItemsCount === itemsCount - invisibleItemsCount ? true : void 0;
        }
        return result2;
      },
      _toggleChildrenSelection: function(node, state) {
        var that = this;
        this._iterateChildren(node, true, function(child) {
          if (that._isNodeVisible(child)) {
            that._setFieldState(child, SELECTED, state);
          }
        });
      },
      _setFieldState: function(node, field, state) {
        if (node.internalFields[field] === state) {
          return;
        }
        node.internalFields[field] = state;
        if (node.internalFields.publicNode) {
          node.internalFields.publicNode[field] = state;
        }
        this.options.dataAccessors.setters[field](node.internalFields.item, state);
        this.options.onNodeChanged(node);
      },
      _markChildren: function(keys) {
        var that = this;
        each(keys, function(_2, key) {
          var index2 = that.getIndexByKey(key);
          var node = that.getNodeByKey(key);
          that._dataStructure[index2] = 0;
          node.internalFields.childrenKeys.length && that._markChildren(node.internalFields.childrenKeys);
        });
      },
      _removeNode: function(key) {
        var node = this.getNodeByKey(key);
        this._dataStructure[this.getIndexByKey(key)] = 0;
        this._markChildren(node.internalFields.childrenKeys);
        var that = this;
        var counter = 0;
        var items = extend2([], this._dataStructure);
        each(items, function(index2, item) {
          if (!item) {
            that._dataStructure.splice(index2 - counter, 1);
            counter++;
          }
        });
      },
      _addNode: function(item) {
        var dataConverter = this.options.dataConverter;
        var node = dataConverter._convertItemToNode(item, this.options.dataAccessors.getters.parentKey(item));
        this._dataStructure = this._dataStructure.concat(node);
        this._initialDataStructure = this._initialDataStructure.concat(node);
        dataConverter._dataStructure = dataConverter._dataStructure.concat(node);
      },
      _updateFields: function() {
        this.options.dataConverter.updateChildrenKeys();
        this._updateSelection();
        this._updateExpansion();
      },
      getSelectedNodesKeys: function() {
        return this._selectedNodesKeys;
      },
      getExpandedNodesKeys: function() {
        return this._expandedNodesKeys;
      },
      getData: function() {
        return this._dataStructure;
      },
      getFullData: function() {
        return this._initialDataStructure;
      },
      getNodeByItem: function(item) {
        var result2 = null;
        each(this._dataStructure, function(_2, node) {
          if (node.internalFields.item === item) {
            result2 = node;
            return false;
          }
        });
        return result2;
      },
      getNodesByItems: function(items) {
        var that = this;
        var nodes = [];
        each(items, function(_2, item) {
          var node = that.getNodeByItem(item);
          node && nodes.push(node);
        });
        return nodes;
      },
      getNodeByKey: function(key, data2) {
        return this._getByKey(data2 || this._getDataBySelectionMode(), key);
      },
      getTreeNodes: function() {
        return this.options.dataConverter.convertToPublicNodes(this.getRootNodes());
      },
      getItemsCount: function() {
        return this.options.dataConverter.getItemsCount();
      },
      getVisibleItemsCount: function() {
        return this.options.dataConverter.getVisibleItemsCount();
      },
      getPublicNode: function(node) {
        return node.internalFields.publicNode;
      },
      getRootNodes: function() {
        return this.getChildrenNodes(this.options.rootValue);
      },
      getChildrenNodes: function(parentKey) {
        return query_default(this._dataStructure).filter(["internalFields.parentKey", parentKey]).toArray();
      },
      getIndexByKey: function(key) {
        return this.options.dataConverter.getIndexByKey(key);
      },
      addItem: function(item) {
        this._addNode(item);
        this._updateFields();
      },
      removeItem: function(key) {
        this._removeNode(key);
        this._updateFields();
      },
      toggleSelection: function(key, state, selectRecursive) {
        var isSingleModeUnselect = this._isSingleModeUnselect(state);
        var node = this._getByKey(selectRecursive || isSingleModeUnselect ? this._initialDataStructure : this._dataStructure, key);
        this._setFieldState(node, SELECTED, state);
        if (this.options.recursiveSelection && !selectRecursive) {
          state ? this._setChildrenSelection() : this._toggleChildrenSelection(node, state);
          this._setParentSelection();
        }
        this._selectedNodesKeys = this._updateNodesKeysArray(SELECTED);
      },
      _isSingleModeUnselect: function(selectionState) {
        return !this.options.multipleSelection && !selectionState;
      },
      toggleNodeDisabledState: function(key, state) {
        var node = this.getNodeByKey(key);
        this._setFieldState(node, DISABLED, state);
      },
      toggleSelectAll: function(state) {
        if (!isDefined(state)) {
          return;
        }
        var that = this;
        var lastSelectedKey = that._selectedNodesKeys[that._selectedNodesKeys.length - 1];
        var dataStructure = that._isSingleModeUnselect(state) ? this._initialDataStructure : this._dataStructure;
        each(dataStructure, function(index2, node) {
          if (!that._isNodeVisible(node)) {
            return;
          }
          that._setFieldState(node, SELECTED, state);
        });
        that._selectedNodesKeys = that._updateNodesKeysArray(SELECTED);
        if (!state && that.options.selectionRequired) {
          that.toggleSelection(lastSelectedKey, true);
        }
      },
      isAllSelected: function() {
        if (this.getSelectedNodesKeys().length) {
          return this.getSelectedNodesKeys().length === this.getVisibleItemsCount() ? true : void 0;
        } else {
          return false;
        }
      },
      toggleExpansion: function(key, state) {
        var node = this.getNodeByKey(key);
        this._setFieldState(node, EXPANDED, state);
        if (state) {
          this._updateExpansion(key);
        }
        this._expandedNodesKeys = this._updateNodesKeysArray(EXPANDED);
      },
      isFiltered: function(item) {
        return !this.options.searchValue.length || !!this._filterDataStructure(this.options.searchValue, [item]).length;
      },
      _createCriteria: function(selector, value2, operation) {
        var searchFilter = [];
        if (!Array.isArray(selector)) {
          return [selector, operation, value2];
        }
        each(selector, function(i, item) {
          searchFilter.push([item, operation, value2], "or");
        });
        searchFilter.pop();
        return searchFilter;
      },
      _filterDataStructure: function(filterValue, dataStructure) {
        var selector = this.options.searchExpr || this.options.dataAccessors.getters.display;
        var operation = ui_search_box_mixin_default.getOperationBySearchMode(this.options.searchMode);
        var criteria = this._createCriteria(selector, filterValue, operation);
        dataStructure = dataStructure || this._initialDataStructure;
        return query_default(dataStructure).filter(criteria).toArray();
      },
      search: function(searchValue) {
        var that = this;
        var matches = this._filterDataStructure(searchValue);
        var dataConverter = this.options.dataConverter;
        !function lookForParents(matches2, index2) {
          var length = matches2.length;
          while (index2 < length) {
            var node = matches2[index2];
            if (node.internalFields.parentKey === that.options.rootValue) {
              index2++;
              continue;
            }
            var parent = dataConverter.getParentNode(node);
            if (!parent) {
              ui_errors_default.log("W1007", node.internalFields.parentKey, node.internalFields.key);
              index2++;
              continue;
            }
            if (!parent.internalFields.expanded) {
              that._setFieldState(parent, EXPANDED, true);
            }
            if (inArray(parent, matches2) > -1) {
              index2++;
              continue;
            }
            matches2.splice(index2, 0, parent);
            lookForParents(matches2, index2);
          }
        }(matches, 0);
        if (this.options.sort) {
          matches = store_helper_default.queryByOptions(query_default(matches), {
            sort: this.options.sort
          }).toArray();
        }
        dataConverter._indexByKey = {};
        each(matches, function(index2, node) {
          node.internalFields.childrenKeys = [];
          dataConverter._indexByKey[node.internalFields.key] = index2;
        });
        dataConverter._dataStructure = matches;
        dataConverter.setChildrenKeys();
        return dataConverter._dataStructure;
      }
    });
    ui_data_adapter_default = DataAdapter;
  }
});

// node_modules/devextreme/esm/data/array_utils.js
function hasKey(target, keyOrKeys) {
  var key;
  var keys = "string" === typeof keyOrKeys ? keyOrKeys.split() : keyOrKeys.slice();
  while (keys.length) {
    key = keys.shift();
    if (key in target) {
      return true;
    }
  }
  return false;
}
function findItems(keyInfo, items, key, groupCount) {
  var childItems;
  var result2;
  if (groupCount) {
    for (var i = 0; i < items.length; i++) {
      childItems = items[i].items || items[i].collapsedItems || [];
      result2 = findItems(keyInfo, childItems || [], key, groupCount - 1);
      if (result2) {
        return result2;
      }
    }
  } else if (indexByKey(keyInfo, items, key) >= 0) {
    return items;
  }
}
function getItems(keyInfo, items, key, groupCount) {
  if (groupCount) {
    return findItems(keyInfo, items, key, groupCount) || [];
  }
  return items;
}
function generateDataByKeyMap(keyInfo, array) {
  if (keyInfo.key() && (!array._dataByKeyMap || array._dataByKeyMapLength !== array.length)) {
    var dataByKeyMap = {};
    var arrayLength = array.length;
    for (var i = 0; i < arrayLength; i++) {
      dataByKeyMap[JSON.stringify(keyInfo.keyOf(array[i]))] = array[i];
    }
    array._dataByKeyMap = dataByKeyMap;
    array._dataByKeyMapLength = arrayLength;
  }
}
function getCacheValue(array, key) {
  if (array._dataByKeyMap) {
    return array._dataByKeyMap[JSON.stringify(key)];
  }
}
function getHasKeyCacheValue(array, key) {
  if (array._dataByKeyMap) {
    return array._dataByKeyMap[JSON.stringify(key)];
  }
  return true;
}
function setDataByKeyMapValue(array, key, data2) {
  if (array._dataByKeyMap) {
    array._dataByKeyMap[JSON.stringify(key)] = data2;
    array._dataByKeyMapLength += data2 ? 1 : -1;
  }
}
function cloneInstance(instance, clonedInstances) {
  clonedInstances = clonedInstances || /* @__PURE__ */ new WeakMap();
  var result2 = instance ? Object.create(Object.getPrototypeOf(instance)) : {};
  if (instance) {
    clonedInstances.set(instance, result2);
  }
  var instanceWithoutPrototype = extendFromObject({}, instance);
  for (var name2 in instanceWithoutPrototype) {
    var prop = instanceWithoutPrototype[name2];
    if (isObject2(prop) && !isPlainObject(prop) && !clonedInstances.has(prop)) {
      instanceWithoutPrototype[name2] = cloneInstance(prop, clonedInstances);
    }
  }
  deepExtendArraySafe(result2, instanceWithoutPrototype, true, true);
  for (var _name in result2) {
    var _prop = result2[_name];
    if (isObject2(_prop) && clonedInstances.has(_prop)) {
      result2[_name] = clonedInstances.get(_prop);
    }
  }
  return result2;
}
function createObjectWithChanges(target, changes) {
  var result2 = cloneInstance(target);
  return deepExtendArraySafe(result2, changes, true, true);
}
function applyBatch(_ref) {
  var {
    keyInfo,
    data: data2,
    changes,
    groupCount,
    useInsertIndex,
    immutable,
    disableCache,
    logError
  } = _ref;
  var resultItems = true === immutable ? [...data2] : data2;
  changes.forEach((item) => {
    var items = "insert" === item.type ? resultItems : getItems(keyInfo, resultItems, item.key, groupCount);
    !disableCache && generateDataByKeyMap(keyInfo, items);
    switch (item.type) {
      case "update":
        update(keyInfo, items, item.key, item.data, true, immutable, logError);
        break;
      case "insert":
        insert(keyInfo, items, item.data, useInsertIndex && isDefined(item.index) ? item.index : -1, true, logError);
        break;
      case "remove":
        remove2(keyInfo, items, item.key, true, logError);
    }
  });
  return resultItems;
}
function getErrorResult(isBatch, logError, errorCode) {
  return !isBatch ? rejectedPromise(errors.Error(errorCode)) : logError && errors.log(errorCode);
}
function update(keyInfo, array, key, data2, isBatch, immutable, logError) {
  var target;
  var keyExpr = keyInfo.key();
  if (keyExpr) {
    if (hasKey(data2, keyExpr) && !keysEqual(keyExpr, key, keyInfo.keyOf(data2))) {
      return getErrorResult(isBatch, logError, "E4017");
    }
    target = getCacheValue(array, key);
    if (!target) {
      var index2 = indexByKey(keyInfo, array, key);
      if (index2 < 0) {
        return getErrorResult(isBatch, logError, "E4009");
      }
      target = array[index2];
      if (true === immutable && isDefined(target)) {
        var newTarget = createObjectWithChanges(target, data2);
        array[index2] = newTarget;
        return !isBatch && trivialPromise(newTarget, key);
      }
    }
  } else {
    target = key;
  }
  deepExtendArraySafe(target, data2, true);
  if (!isBatch) {
    if (config_default().useLegacyStoreResult) {
      return trivialPromise(key, data2);
    } else {
      return trivialPromise(target, key);
    }
  }
}
function insert(keyInfo, array, data2, index2, isBatch, logError) {
  var keyValue;
  var keyExpr = keyInfo.key();
  var obj = isPlainObject(data2) ? extend2({}, data2) : data2;
  if (keyExpr) {
    keyValue = keyInfo.keyOf(obj);
    if (void 0 === keyValue || "object" === typeof keyValue && isEmptyObject(keyValue)) {
      if (Array.isArray(keyExpr)) {
        throw errors.Error("E4007");
      }
      keyValue = obj[keyExpr] = String(new guid_default());
    } else if (void 0 !== array[indexByKey(keyInfo, array, keyValue)]) {
      return getErrorResult(isBatch, logError, "E4008");
    }
  } else {
    keyValue = obj;
  }
  if (index2 >= 0) {
    array.splice(index2, 0, obj);
  } else {
    array.push(obj);
  }
  setDataByKeyMapValue(array, keyValue, obj);
  if (!isBatch) {
    return trivialPromise(config_default().useLegacyStoreResult ? data2 : obj, keyValue);
  }
}
function remove2(keyInfo, array, key, isBatch, logError) {
  var index2 = indexByKey(keyInfo, array, key);
  if (index2 > -1) {
    array.splice(index2, 1);
    setDataByKeyMapValue(array, key, null);
  }
  if (!isBatch) {
    return trivialPromise(key);
  } else if (index2 < 0) {
    return getErrorResult(isBatch, logError, "E4009");
  }
}
function indexByKey(keyInfo, array, key) {
  var keyExpr = keyInfo.key();
  if (!getHasKeyCacheValue(array, key)) {
    return -1;
  }
  for (var i = 0, arrayLength = array.length; i < arrayLength; i++) {
    if (keysEqual(keyExpr, keyInfo.keyOf(array[i]), key)) {
      return i;
    }
  }
  return -1;
}
var init_array_utils = __esm({
  "node_modules/devextreme/esm/data/array_utils.js"() {
    init_type();
    init_config();
    init_guid();
    init_extend();
    init_errors2();
    init_object();
    init_data();
    init_utils3();
  }
});

// node_modules/devextreme/esm/data/abstract_store.js
var abstract3, queryByOptions2, storeImpl, Store, abstract_store_default;
var init_abstract_store = __esm({
  "node_modules/devextreme/esm/data/abstract_store.js"() {
    init_class();
    init_events_strategy();
    init_iterator();
    init_errors2();
    init_utils3();
    init_data();
    init_store_helper();
    init_deferred();
    init_common();
    abstract3 = class_default.abstract;
    queryByOptions2 = store_helper_default.queryByOptions;
    storeImpl = {};
    Store = class_default.inherit({
      ctor: function(options2) {
        var that = this;
        options2 = options2 || {};
        this._eventsStrategy = new EventsStrategy(this);
        each(["onLoaded", "onLoading", "onInserted", "onInserting", "onUpdated", "onUpdating", "onPush", "onRemoved", "onRemoving", "onModified", "onModifying"], function(_2, optionName) {
          if (optionName in options2) {
            that.on(optionName.slice(2).toLowerCase(), options2[optionName]);
          }
        });
        this._key = options2.key;
        this._errorHandler = options2.errorHandler;
        this._useDefaultSearch = true;
      },
      _customLoadOptions: function() {
        return null;
      },
      key: function() {
        return this._key;
      },
      keyOf: function(obj) {
        if (!this._keyGetter) {
          this._keyGetter = compileGetter(this.key());
        }
        return this._keyGetter(obj);
      },
      _requireKey: function() {
        if (!this.key()) {
          throw errors.Error("E4005");
        }
      },
      load: function(options2) {
        var that = this;
        options2 = options2 || {};
        this._eventsStrategy.fireEvent("loading", [options2]);
        return this._withLock(this._loadImpl(options2)).done(function(result2) {
          that._eventsStrategy.fireEvent("loaded", [result2, options2]);
        });
      },
      _loadImpl: function(options2) {
        return queryByOptions2(this.createQuery(options2), options2).enumerate();
      },
      _withLock: function(task) {
        var result2 = new Deferred();
        task.done(function() {
          var that = this;
          var args = arguments;
          processRequestResultLock.promise().done(function() {
            result2.resolveWith(that, args);
          });
        }).fail(function() {
          result2.rejectWith(this, arguments);
        });
        return result2;
      },
      createQuery: abstract3,
      totalCount: function(options2) {
        return this._totalCountImpl(options2);
      },
      _totalCountImpl: function(options2) {
        return queryByOptions2(this.createQuery(options2), options2, true).count();
      },
      byKey: function(key, extraOptions) {
        return this._addFailHandlers(this._withLock(this._byKeyImpl(key, extraOptions)));
      },
      _byKeyImpl: abstract3,
      insert: function(values) {
        var that = this;
        that._eventsStrategy.fireEvent("modifying");
        that._eventsStrategy.fireEvent("inserting", [values]);
        return that._addFailHandlers(that._insertImpl(values).done(function(callbackValues, callbackKey) {
          that._eventsStrategy.fireEvent("inserted", [callbackValues, callbackKey]);
          that._eventsStrategy.fireEvent("modified");
        }));
      },
      _insertImpl: abstract3,
      update: function(key, values) {
        var that = this;
        that._eventsStrategy.fireEvent("modifying");
        that._eventsStrategy.fireEvent("updating", [key, values]);
        return that._addFailHandlers(that._updateImpl(key, values).done(function() {
          that._eventsStrategy.fireEvent("updated", [key, values]);
          that._eventsStrategy.fireEvent("modified");
        }));
      },
      _updateImpl: abstract3,
      push: function(changes) {
        var beforePushArgs = {
          changes,
          waitFor: []
        };
        this._eventsStrategy.fireEvent("beforePush", [beforePushArgs]);
        when(...beforePushArgs.waitFor).done(() => {
          this._pushImpl(changes);
          this._eventsStrategy.fireEvent("push", [changes]);
        });
      },
      _pushImpl: noop2,
      remove: function(key) {
        var that = this;
        that._eventsStrategy.fireEvent("modifying");
        that._eventsStrategy.fireEvent("removing", [key]);
        return that._addFailHandlers(that._removeImpl(key).done(function(callbackKey) {
          that._eventsStrategy.fireEvent("removed", [callbackKey]);
          that._eventsStrategy.fireEvent("modified");
        }));
      },
      _removeImpl: abstract3,
      _addFailHandlers: function(deferred) {
        return deferred.fail(this._errorHandler).fail(handleError);
      },
      on(eventName, eventHandler) {
        this._eventsStrategy.on(eventName, eventHandler);
        return this;
      },
      off(eventName, eventHandler) {
        this._eventsStrategy.off(eventName, eventHandler);
        return this;
      }
    });
    Store.create = function(alias, options2) {
      if (!(alias in storeImpl)) {
        throw errors.Error("E4020", alias);
      }
      return new storeImpl[alias](options2);
    };
    Store.registerClass = function(type2, alias) {
      if (alias) {
        storeImpl[alias] = type2;
      }
      return type2;
    };
    Store.inherit = /* @__PURE__ */ function(inheritor) {
      return function(members, alias) {
        var type2 = inheritor.apply(this, [members]);
        Store.registerClass(type2, alias);
        return type2;
      };
    }(Store.inherit);
    abstract_store_default = Store;
  }
});

// node_modules/devextreme/esm/data/custom_store.js
function isPromise2(obj) {
  return obj && isFunction(obj.then);
}
function trivialPromise2(value2) {
  return new Deferred().resolve(value2).promise();
}
function ensureRequiredFuncOption(name2, obj) {
  if (!isFunction(obj)) {
    throw errors.Error("E4011", name2);
  }
}
function throwInvalidUserFuncResult(name2) {
  throw errors.Error("E4012", name2);
}
function createUserFuncFailureHandler(pendingDeferred) {
  function errorMessageFromXhr2(promiseArguments) {
    var xhr = promiseArguments[0];
    var textStatus = promiseArguments[1];
    if (!xhr || !xhr.getResponseHeader) {
      return null;
    }
    return errorMessageFromXhr(xhr, textStatus);
  }
  return function(arg) {
    var error;
    if (arg instanceof Error) {
      error = arg;
    } else {
      error = new Error(errorMessageFromXhr2(arguments) || arg && String(arg) || "Unknown error");
    }
    if (error.message !== XHR_ERROR_UNLOAD) {
      pendingDeferred.reject(error);
    }
  };
}
function invokeUserLoad(store, options2) {
  var userFunc = store._loadFunc;
  var userResult;
  ensureRequiredFuncOption(LOAD, userFunc);
  userResult = userFunc.apply(store, [options2]);
  if (Array.isArray(userResult)) {
    userResult = trivialPromise2(userResult);
  } else if (null === userResult || void 0 === userResult) {
    userResult = trivialPromise2([]);
  } else if (!isPromise2(userResult)) {
    throwInvalidUserFuncResult(LOAD);
  }
  return fromPromise(userResult);
}
function invokeUserTotalCountFunc(store, options2) {
  var userFunc = store._totalCountFunc;
  var userResult;
  if (!isFunction(userFunc)) {
    throw errors.Error("E4021");
  }
  userResult = userFunc.apply(store, [options2]);
  if (!isPromise2(userResult)) {
    userResult = Number(userResult);
    if (!isFinite(userResult)) {
      throwInvalidUserFuncResult(TOTAL_COUNT);
    }
    userResult = trivialPromise2(userResult);
  }
  return fromPromise(userResult);
}
function invokeUserByKeyFunc(store, key, extraOptions) {
  var userFunc = store._byKeyFunc;
  var userResult;
  ensureRequiredFuncOption(BY_KEY, userFunc);
  userResult = userFunc.apply(store, [key, extraOptions]);
  if (!isPromise2(userResult)) {
    userResult = trivialPromise2(userResult);
  }
  return fromPromise(userResult);
}
function runRawLoad(pendingDeferred, store, userFuncOptions, continuation) {
  if (store.__rawData) {
    continuation(store.__rawData);
  } else {
    var loadPromise = store.__rawDataPromise || invokeUserLoad(store, userFuncOptions);
    if (store._cacheRawData) {
      store.__rawDataPromise = loadPromise;
    }
    loadPromise.always(function() {
      delete store.__rawDataPromise;
    }).done(function(rawData) {
      if (store._cacheRawData) {
        store.__rawData = rawData;
      }
      continuation(rawData);
    }).fail(createUserFuncFailureHandler(pendingDeferred));
  }
}
function runRawLoadWithQuery(pendingDeferred, store, options2, countOnly) {
  options2 = options2 || {};
  var userFuncOptions = {};
  if ("userData" in options2) {
    userFuncOptions.userData = options2.userData;
  }
  runRawLoad(pendingDeferred, store, userFuncOptions, function(rawData) {
    var rawDataQuery = array_query_default(rawData, {
      errorHandler: store._errorHandler
    });
    var itemsQuery;
    var totalCountQuery;
    var waitList = [];
    var items;
    var totalCount;
    if (!countOnly) {
      itemsQuery = store_helper_default.queryByOptions(rawDataQuery, options2);
      if (itemsQuery === rawDataQuery) {
        items = rawData.slice(0);
      } else {
        waitList.push(itemsQuery.enumerate().done(function(asyncResult) {
          items = asyncResult;
        }));
      }
    }
    if (options2.requireTotalCount || countOnly) {
      totalCountQuery = store_helper_default.queryByOptions(rawDataQuery, options2, true);
      if (totalCountQuery === rawDataQuery) {
        totalCount = rawData.length;
      } else {
        waitList.push(totalCountQuery.count().done(function(asyncResult) {
          totalCount = asyncResult;
        }));
      }
    }
    when.apply(renderer_default, waitList).done(function() {
      if (countOnly) {
        pendingDeferred.resolve(totalCount);
      } else if (options2.requireTotalCount) {
        pendingDeferred.resolve(items, {
          totalCount
        });
      } else {
        pendingDeferred.resolve(items);
      }
    }).fail(function(x) {
      pendingDeferred.reject(x);
    });
  });
}
function runRawLoadWithKey(pendingDeferred, store, key) {
  runRawLoad(pendingDeferred, store, {}, function(rawData) {
    var keyExpr = store.key();
    var item;
    for (var i = 0, len = rawData.length; i < len; i++) {
      item = rawData[i];
      if (keysEqual(keyExpr, store.keyOf(rawData[i]), key)) {
        pendingDeferred.resolve(item);
        return;
      }
    }
    pendingDeferred.reject(errors.Error("E4009"));
  });
}
var TOTAL_COUNT, LOAD, BY_KEY, INSERT, UPDATE, REMOVE, CustomStore, custom_store_default;
var init_custom_store = __esm({
  "node_modules/devextreme/esm/data/custom_store.js"() {
    init_renderer();
    init_utils3();
    init_array_utils();
    init_type();
    init_config();
    init_errors2();
    init_abstract_store();
    init_array_query();
    init_store_helper();
    init_deferred();
    TOTAL_COUNT = "totalCount";
    LOAD = "load";
    BY_KEY = "byKey";
    INSERT = "insert";
    UPDATE = "update";
    REMOVE = "remove";
    CustomStore = abstract_store_default.inherit({
      ctor: function(options2) {
        options2 = options2 || {};
        this.callBase(options2);
        this._useDefaultSearch = !!options2.useDefaultSearch || "raw" === options2.loadMode;
        this._loadMode = options2.loadMode;
        this._cacheRawData = false !== options2.cacheRawData;
        this._loadFunc = options2[LOAD];
        this._totalCountFunc = options2[TOTAL_COUNT];
        this._byKeyFunc = options2[BY_KEY];
        this._insertFunc = options2[INSERT];
        this._updateFunc = options2[UPDATE];
        this._removeFunc = options2[REMOVE];
      },
      createQuery: function() {
        throw errors.Error("E4010");
      },
      clearRawDataCache: function() {
        delete this.__rawData;
      },
      _totalCountImpl: function(options2) {
        var d = new Deferred();
        if ("raw" === this._loadMode && !this._totalCountFunc) {
          runRawLoadWithQuery(d, this, options2, true);
        } else {
          invokeUserTotalCountFunc(this, options2).done(function(count) {
            d.resolve(Number(count));
          }).fail(createUserFuncFailureHandler(d));
          d = this._addFailHandlers(d);
        }
        return d.promise();
      },
      _pushImpl: function(changes) {
        if (this.__rawData) {
          applyBatch({
            keyInfo: this,
            data: this.__rawData,
            changes
          });
        }
      },
      _loadImpl: function(options2) {
        var d = new Deferred();
        if ("raw" === this._loadMode) {
          runRawLoadWithQuery(d, this, options2, false);
        } else {
          invokeUserLoad(this, options2).done(function(data2, extra) {
            d.resolve(data2, extra);
          }).fail(createUserFuncFailureHandler(d));
          d = this._addFailHandlers(d);
        }
        return d.promise();
      },
      _byKeyImpl: function(key, extraOptions) {
        var d = new Deferred();
        if (this._byKeyViaLoad()) {
          this._requireKey();
          runRawLoadWithKey(d, this, key);
        } else {
          invokeUserByKeyFunc(this, key, extraOptions).done(function(obj) {
            d.resolve(obj);
          }).fail(createUserFuncFailureHandler(d));
        }
        return d.promise();
      },
      _byKeyViaLoad: function() {
        return "raw" === this._loadMode && !this._byKeyFunc;
      },
      _insertImpl: function(values) {
        var that = this;
        var userFunc = that._insertFunc;
        var userResult;
        var d = new Deferred();
        ensureRequiredFuncOption(INSERT, userFunc);
        userResult = userFunc.apply(that, [values]);
        if (!isPromise2(userResult)) {
          userResult = trivialPromise2(userResult);
        }
        fromPromise(userResult).done(function(serverResponse) {
          if (config_default().useLegacyStoreResult) {
            d.resolve(values, serverResponse);
          } else {
            d.resolve(serverResponse || values, that.keyOf(serverResponse));
          }
        }).fail(createUserFuncFailureHandler(d));
        return d.promise();
      },
      _updateImpl: function(key, values) {
        var userFunc = this._updateFunc;
        var userResult;
        var d = new Deferred();
        ensureRequiredFuncOption(UPDATE, userFunc);
        userResult = userFunc.apply(this, [key, values]);
        if (!isPromise2(userResult)) {
          userResult = trivialPromise2(userResult);
        }
        fromPromise(userResult).done(function(serverResponse) {
          if (config_default().useLegacyStoreResult) {
            d.resolve(key, values);
          } else {
            d.resolve(serverResponse || values, key);
          }
        }).fail(createUserFuncFailureHandler(d));
        return d.promise();
      },
      _removeImpl: function(key) {
        var userFunc = this._removeFunc;
        var userResult;
        var d = new Deferred();
        ensureRequiredFuncOption(REMOVE, userFunc);
        userResult = userFunc.apply(this, [key]);
        if (!isPromise2(userResult)) {
          userResult = trivialPromise2();
        }
        fromPromise(userResult).done(function() {
          d.resolve(key);
        }).fail(createUserFuncFailureHandler(d));
        return d.promise();
      }
    });
    custom_store_default = CustomStore;
  }
});

// node_modules/devextreme/esm/core/utils/queue.js
function createQueue(discardPendingTasks) {
  var _tasks = [];
  var _busy = false;
  function exec() {
    while (_tasks.length) {
      _busy = true;
      var task = _tasks.shift();
      var result2 = task();
      if (void 0 === result2) {
        continue;
      }
      if (result2.then) {
        when(result2).always(exec);
        return;
      }
      throw errors_default.Error("E0015");
    }
    _busy = false;
  }
  return {
    add: function(task, removeTaskCallback) {
      if (!discardPendingTasks) {
        _tasks.push(task);
      } else {
        if (_tasks[0] && removeTaskCallback) {
          removeTaskCallback(_tasks[0]);
        }
        _tasks = [task];
      }
      if (!_busy) {
        exec();
      }
    },
    busy: function() {
      return _busy;
    }
  };
}
var enqueue;
var init_queue = __esm({
  "node_modules/devextreme/esm/core/utils/queue.js"() {
    init_errors();
    init_deferred();
    enqueue = createQueue().add;
  }
});

// node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
var init_objectWithoutPropertiesLoose = __esm({
  "node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js"() {
  }
});

// node_modules/devextreme/esm/core/http_request.js
var window14, nativeXMLHttpRequest, http_request_default;
var init_http_request = __esm({
  "node_modules/devextreme/esm/core/http_request.js"() {
    init_window();
    init_dependency_injector();
    window14 = getWindow();
    nativeXMLHttpRequest = {
      getXhr: function() {
        return new window14.XMLHttpRequest();
      }
    };
    http_request_default = dependency_injector_default(nativeXMLHttpRequest);
  }
});

// node_modules/devextreme/esm/core/utils/ajax.js
function getMethod(options2) {
  return (options2.method || "GET").toUpperCase();
}
var window15, SUCCESS, ERROR, TIMEOUT, NO_CONTENT, PARSER_ERROR, isStatusSuccess, hasContent, paramsConvert, createScript, removeScript, appendToHead, evalScript, evalCrossDomainScript, getAcceptHeader, getContentTypeHeader, getDataFromResponse, postProcess, isCrossDomain, setHttpTimeout, getJsonpOptions, getRequestOptions, getRequestHeaders, sendRequest, ajax_default;
var init_ajax = __esm({
  "node_modules/devextreme/esm/core/utils/ajax.js"() {
    init_deferred();
    init_dom_adapter();
    init_http_request();
    init_window();
    init_extend();
    init_type();
    init_promise();
    init_dependency_injector();
    window15 = getWindow();
    SUCCESS = "success";
    ERROR = "error";
    TIMEOUT = "timeout";
    NO_CONTENT = "nocontent";
    PARSER_ERROR = "parsererror";
    isStatusSuccess = function(status) {
      return 200 <= status && status < 300;
    };
    hasContent = function(status) {
      return 204 !== status;
    };
    paramsConvert = function(params) {
      var result2 = [];
      for (var name2 in params) {
        var value2 = params[name2];
        if (void 0 === value2) {
          continue;
        }
        if (null === value2) {
          value2 = "";
        }
        if ("function" === typeof value2) {
          value2 = value2();
        }
        result2.push(encodeURIComponent(name2) + "=" + encodeURIComponent(value2));
      }
      return result2.join("&");
    };
    createScript = function(options2) {
      var script = dom_adapter_default.createElement("script");
      for (var name2 in options2) {
        script[name2] = options2[name2];
      }
      return script;
    };
    removeScript = function(scriptNode) {
      scriptNode.parentNode.removeChild(scriptNode);
    };
    appendToHead = function(element) {
      return dom_adapter_default.getHead().appendChild(element);
    };
    evalScript = function(code) {
      var script = createScript({
        text: code
      });
      appendToHead(script);
      removeScript(script);
    };
    evalCrossDomainScript = function(url) {
      var script = createScript({
        src: url
      });
      return new promise_default(function(resolve, reject) {
        var events = {
          load: resolve,
          error: reject
        };
        var loadHandler = function(e) {
          events[e.type]();
          removeScript(script);
        };
        for (var event in events) {
          dom_adapter_default.listen(script, event, loadHandler);
        }
        appendToHead(script);
      });
    };
    getAcceptHeader = function(options2) {
      var dataType = options2.dataType || "*";
      var scriptAccept = "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript";
      var accepts = {
        "*": "*/*",
        text: "text/plain",
        html: "text/html",
        xml: "application/xml, text/xml",
        json: "application/json, text/javascript",
        jsonp: scriptAccept,
        script: scriptAccept
      };
      extendFromObject(accepts, options2.accepts, true);
      return accepts[dataType] ? accepts[dataType] + ("*" !== dataType ? ", */*; q=0.01" : "") : accepts["*"];
    };
    getContentTypeHeader = function(options2) {
      var defaultContentType;
      if (options2.data && !options2.upload && "GET" !== getMethod(options2)) {
        defaultContentType = "application/x-www-form-urlencoded;charset=utf-8";
      }
      return options2.contentType || defaultContentType;
    };
    getDataFromResponse = function(xhr) {
      return xhr.responseType && "text" !== xhr.responseType || "string" !== typeof xhr.responseText ? xhr.response : xhr.responseText;
    };
    postProcess = function(deferred, xhr, dataType) {
      var data2 = getDataFromResponse(xhr);
      switch (dataType) {
        case "jsonp":
          evalScript(data2);
          break;
        case "script":
          evalScript(data2);
          deferred.resolve(data2, SUCCESS, xhr);
          break;
        case "json":
          try {
            deferred.resolve(JSON.parse(data2), SUCCESS, xhr);
          } catch (e) {
            deferred.reject(xhr, PARSER_ERROR, e);
          }
          break;
        default:
          deferred.resolve(data2, SUCCESS, xhr);
      }
    };
    isCrossDomain = function(url) {
      if (!hasWindow()) {
        return true;
      }
      var crossDomain = false;
      var originAnchor = dom_adapter_default.createElement("a");
      var urlAnchor = dom_adapter_default.createElement("a");
      originAnchor.href = window15.location.href;
      try {
        urlAnchor.href = url;
        urlAnchor.href = urlAnchor.href;
        crossDomain = originAnchor.protocol + "//" + originAnchor.host !== urlAnchor.protocol + "//" + urlAnchor.host;
      } catch (e) {
        crossDomain = true;
      }
      return crossDomain;
    };
    setHttpTimeout = function(timeout, xhr) {
      return timeout && setTimeout(function() {
        xhr.customStatus = TIMEOUT;
        xhr.abort();
      }, timeout);
    };
    getJsonpOptions = function(options2) {
      if ("jsonp" === options2.dataType) {
        var random = Math.random().toString().replace(/\D/g, "");
        var callbackName = options2.jsonpCallback || "dxCallback" + Date.now() + "_" + random;
        var callbackParameter = options2.jsonp || "callback";
        options2.data = options2.data || {};
        options2.data[callbackParameter] = callbackName;
        return callbackName;
      }
    };
    getRequestOptions = function(options2, headers) {
      var params = options2.data;
      var paramsAlreadyString = "string" === typeof params;
      var url = options2.url || window15.location.href;
      if (!paramsAlreadyString && !options2.cache) {
        params = params || {};
        params._ = Date.now();
      }
      if (params && !options2.upload) {
        if (!paramsAlreadyString) {
          params = paramsConvert(params);
        }
        if ("GET" === getMethod(options2)) {
          if ("" !== params) {
            url += (url.indexOf("?") > -1 ? "&" : "?") + params;
          }
          params = null;
        } else if (headers["Content-Type"] && headers["Content-Type"].indexOf("application/x-www-form-urlencoded") > -1) {
          params = params.replace(/%20/g, "+");
        }
      }
      return {
        url,
        parameters: params
      };
    };
    getRequestHeaders = function(options2) {
      var headers = options2.headers || {};
      headers["Content-Type"] = headers["Content-Type"] || getContentTypeHeader(options2);
      headers.Accept = headers.Accept || getAcceptHeader(options2);
      if (!options2.crossDomain && !headers["X-Requested-With"]) {
        headers["X-Requested-With"] = "XMLHttpRequest";
      }
      return headers;
    };
    sendRequest = function(options2) {
      var xhr = http_request_default.getXhr();
      var d = new Deferred();
      var result2 = d.promise();
      var async = isDefined(options2.async) ? options2.async : true;
      var dataType = options2.dataType;
      var timeout = options2.timeout || 0;
      var timeoutId;
      options2.crossDomain = isCrossDomain(options2.url);
      var needScriptEvaluation = "jsonp" === dataType || "script" === dataType;
      if (void 0 === options2.cache) {
        options2.cache = !needScriptEvaluation;
      }
      var callbackName = getJsonpOptions(options2);
      var headers = getRequestHeaders(options2);
      var requestOptions = getRequestOptions(options2, headers);
      var url = requestOptions.url;
      var parameters = requestOptions.parameters;
      if (callbackName) {
        window15[callbackName] = function(data2) {
          d.resolve(data2, SUCCESS, xhr);
        };
      }
      if (options2.crossDomain && needScriptEvaluation) {
        evalCrossDomainScript(url).then(function() {
          if ("jsonp" === dataType) {
            return;
          }
          d.resolve(null, SUCCESS, xhr);
        }, function() {
          d.reject(xhr, ERROR);
        });
        return result2;
      }
      if (options2.crossDomain && !("withCredentials" in xhr)) {
        d.reject(xhr, ERROR);
        return result2;
      }
      xhr.open(getMethod(options2), url, async, options2.username, options2.password);
      if (async) {
        xhr.timeout = timeout;
        timeoutId = setHttpTimeout(timeout, xhr, d);
      }
      xhr.onreadystatechange = function(e) {
        if (4 === xhr.readyState) {
          clearTimeout(timeoutId);
          if (isStatusSuccess(xhr.status)) {
            if (hasContent(xhr.status)) {
              postProcess(d, xhr, dataType);
            } else {
              d.resolve(null, NO_CONTENT, xhr);
            }
          } else {
            d.reject(xhr, xhr.customStatus || ERROR);
          }
        }
      };
      if (options2.upload) {
        xhr.upload.onprogress = options2.upload.onprogress;
        xhr.upload.onloadstart = options2.upload.onloadstart;
        xhr.upload.onabort = options2.upload.onabort;
      }
      if (options2.xhrFields) {
        for (var field in options2.xhrFields) {
          xhr[field] = options2.xhrFields[field];
        }
      }
      if ("arraybuffer" === options2.responseType) {
        xhr.responseType = options2.responseType;
      }
      for (var name2 in headers) {
        if (Object.prototype.hasOwnProperty.call(headers, name2) && isDefined(headers[name2])) {
          xhr.setRequestHeader(name2, headers[name2]);
        }
      }
      if (options2.beforeSend) {
        options2.beforeSend(xhr);
      }
      xhr.send(parameters);
      result2.abort = function() {
        xhr.abort();
      };
      return result2;
    };
    ajax_default = dependency_injector_default({
      sendRequest
    });
  }
});

// node_modules/devextreme/esm/data/array_store.js
var ArrayStore, array_store_default;
var init_array_store = __esm({
  "node_modules/devextreme/esm/data/array_store.js"() {
    init_utils3();
    init_query();
    init_errors2();
    init_abstract_store();
    init_array_utils();
    ArrayStore = abstract_store_default.inherit({
      ctor: function(options2) {
        if (Array.isArray(options2)) {
          options2 = {
            data: options2
          };
        } else {
          options2 = options2 || {};
        }
        this.callBase(options2);
        var initialArray = options2.data;
        if (initialArray && !Array.isArray(initialArray)) {
          throw errors.Error("E4006");
        }
        this._array = initialArray || [];
      },
      createQuery: function() {
        return query_default(this._array, {
          errorHandler: this._errorHandler
        });
      },
      _byKeyImpl: function(key) {
        var index2 = indexByKey(this, this._array, key);
        if (-1 === index2) {
          return rejectedPromise(errors.Error("E4009"));
        }
        return trivialPromise(this._array[index2]);
      },
      _insertImpl: function(values) {
        return insert(this, this._array, values);
      },
      _pushImpl: function(changes) {
        applyBatch({
          keyInfo: this,
          data: this._array,
          changes
        });
      },
      _updateImpl: function(key, values) {
        return update(this, this._array, key, values);
      },
      _removeImpl: function(key) {
        return remove2(this, this._array, key);
      },
      clear: function() {
        this._eventsStrategy.fireEvent("modifying");
        this._array = [];
        this._eventsStrategy.fireEvent("modified");
      }
    }, "array");
    array_store_default = ArrayStore;
  }
});

// node_modules/devextreme/esm/data/data_source/utils.js
var _excluded, CANCELED_TOKEN, isPending, normalizeStoreLoadOptionAccessorArguments, mapGroup, mapRecursive, mapDataRespectingGrouping, normalizeLoadResult, createCustomStoreFromLoadFunc, createStoreFromConfig, createCustomStoreFromUrl, normalizeDataSourceOptions;
var init_utils5 = __esm({
  "node_modules/devextreme/esm/data/data_source/utils.js"() {
    init_extends();
    init_objectWithoutPropertiesLoose();
    init_ajax();
    init_abstract_store();
    init_array_store();
    init_iterator();
    init_custom_store();
    init_extend();
    init_type();
    init_utils3();
    _excluded = ["items"];
    CANCELED_TOKEN = "canceled";
    isPending = (deferred) => "pending" === deferred.state();
    normalizeStoreLoadOptionAccessorArguments = (originalArguments) => {
      switch (originalArguments.length) {
        case 0:
          return;
        case 1:
          return originalArguments[0];
      }
      return [].slice.call(originalArguments);
    };
    mapGroup = (group, level, mapper) => map(group, (item) => {
      var restItem = _objectWithoutPropertiesLoose(item, _excluded);
      return _extends({}, restItem, {
        items: mapRecursive(item.items, level - 1, mapper)
      });
    });
    mapRecursive = (items, level, mapper) => {
      if (!Array.isArray(items)) {
        return items;
      }
      return level ? mapGroup(items, level, mapper) : map(items, mapper);
    };
    mapDataRespectingGrouping = (items, mapper, groupInfo) => {
      var level = groupInfo ? normalizeSortingInfo(groupInfo).length : 0;
      return mapRecursive(items, level, mapper);
    };
    normalizeLoadResult = (data2, extra) => {
      var _data;
      if (null !== (_data = data2) && void 0 !== _data && _data.data) {
        extra = data2;
        data2 = data2.data;
      }
      if (!Array.isArray(data2)) {
        data2 = [data2];
      }
      return {
        data: data2,
        extra
      };
    };
    createCustomStoreFromLoadFunc = (options2) => {
      var storeConfig = {};
      each(["useDefaultSearch", "key", "load", "loadMode", "cacheRawData", "byKey", "lookup", "totalCount", "insert", "update", "remove"], function() {
        storeConfig[this] = options2[this];
        delete options2[this];
      });
      return new custom_store_default(storeConfig);
    };
    createStoreFromConfig = (storeConfig) => {
      var alias = storeConfig.type;
      delete storeConfig.type;
      return abstract_store_default.create(alias, storeConfig);
    };
    createCustomStoreFromUrl = (url, normalizationOptions) => new custom_store_default({
      load: () => ajax_default.sendRequest({
        url,
        dataType: "json"
      }),
      loadMode: null === normalizationOptions || void 0 === normalizationOptions ? void 0 : normalizationOptions.fromUrlLoadMode
    });
    normalizeDataSourceOptions = (options2, normalizationOptions) => {
      var store;
      if ("string" === typeof options2) {
        options2 = {
          paginate: false,
          store: createCustomStoreFromUrl(options2, normalizationOptions)
        };
      }
      if (void 0 === options2) {
        options2 = [];
      }
      if (Array.isArray(options2) || options2 instanceof abstract_store_default) {
        options2 = {
          store: options2
        };
      } else {
        options2 = extend2({}, options2);
      }
      if (void 0 === options2.store) {
        options2.store = [];
      }
      store = options2.store;
      if ("load" in options2) {
        store = createCustomStoreFromLoadFunc(options2);
      } else if (Array.isArray(store)) {
        store = new array_store_default(store);
      } else if (isPlainObject(store)) {
        store = createStoreFromConfig(extend2({}, store));
      }
      options2.store = store;
      return options2;
    };
  }
});

// node_modules/devextreme/esm/data/data_source/operation_manager.js
var OperationManager;
var init_operation_manager = __esm({
  "node_modules/devextreme/esm/data/data_source/operation_manager.js"() {
    init_utils5();
    OperationManager = class {
      constructor() {
        this._counter = -1;
        this._deferreds = {};
      }
      add(deferred) {
        this._counter++;
        this._deferreds[this._counter] = deferred;
        return this._counter;
      }
      remove(operationId) {
        return delete this._deferreds[operationId];
      }
      cancel(operationId) {
        if (operationId in this._deferreds) {
          this._deferreds[operationId].reject(CANCELED_TOKEN);
          return true;
        }
        return false;
      }
      cancelAll() {
        while (this._counter > -1) {
          this.cancel(this._counter);
          this._counter--;
        }
      }
    };
  }
});

// node_modules/devextreme/esm/data/data_source/data_source.js
var DataSource;
var init_data_source = __esm({
  "node_modules/devextreme/esm/data/data_source/data_source.js"() {
    init_class();
    init_extend();
    init_common();
    init_iterator();
    init_type();
    init_utils3();
    init_array_utils();
    init_custom_store();
    init_events_strategy();
    init_errors2();
    init_array();
    init_queue();
    init_deferred();
    init_operation_manager();
    init_utils5();
    DataSource = class_default.inherit({
      ctor(options2) {
        var _options$reshapeOnPus;
        options2 = normalizeDataSourceOptions(options2);
        this._eventsStrategy = new EventsStrategy(this, {
          syncStrategy: true
        });
        this._store = options2.store;
        this._changedTime = 0;
        var needThrottling = 0 !== options2.pushAggregationTimeout;
        if (needThrottling) {
          var throttlingTimeout = void 0 === options2.pushAggregationTimeout ? () => 5 * this._changedTime : options2.pushAggregationTimeout;
          var pushDeferred;
          var lastPushWaiters;
          var throttlingPushHandler = throttleChanges((changes) => {
            pushDeferred.resolve();
            var storePushPending = when(...lastPushWaiters);
            storePushPending.done(() => this._onPush(changes));
            lastPushWaiters = void 0;
            pushDeferred = void 0;
          }, throttlingTimeout);
          this._onPushHandler = (args) => {
            this._aggregationTimeoutId = throttlingPushHandler(args.changes);
            if (!pushDeferred) {
              pushDeferred = new Deferred();
            }
            lastPushWaiters = args.waitFor;
            args.waitFor.push(pushDeferred.promise());
          };
          this._store.on("beforePush", this._onPushHandler);
        } else {
          this._onPushHandler = (changes) => this._onPush(changes);
          this._store.on("push", this._onPushHandler);
        }
        this._storeLoadOptions = this._extractLoadOptions(options2);
        this._mapFunc = options2.map;
        this._postProcessFunc = options2.postProcess;
        this._pageIndex = void 0 !== options2.pageIndex ? options2.pageIndex : 0;
        this._pageSize = void 0 !== options2.pageSize ? options2.pageSize : 20;
        this._loadingCount = 0;
        this._loadQueue = this._createLoadQueue();
        this._searchValue = "searchValue" in options2 ? options2.searchValue : null;
        this._searchOperation = options2.searchOperation || "contains";
        this._searchExpr = options2.searchExpr;
        this._paginate = options2.paginate;
        this._reshapeOnPush = null !== (_options$reshapeOnPus = options2.reshapeOnPush) && void 0 !== _options$reshapeOnPus ? _options$reshapeOnPus : false;
        each(["onChanged", "onLoadError", "onLoadingChanged", "onCustomizeLoadResult", "onCustomizeStoreLoadOptions"], (_2, optionName) => {
          if (optionName in options2) {
            this.on(optionName.substr(2, 1).toLowerCase() + optionName.substr(3), options2[optionName]);
          }
        });
        this._operationManager = new OperationManager();
        this._init();
      },
      _init() {
        this._items = [];
        this._userData = {};
        this._totalCount = -1;
        this._isLoaded = false;
        if (!isDefined(this._paginate)) {
          this._paginate = !this.group();
        }
        this._isLastPage = !this._paginate;
      },
      dispose() {
        var _this$_delayedLoadTas;
        this._store.off("beforePush", this._onPushHandler);
        this._store.off("push", this._onPushHandler);
        this._eventsStrategy.dispose();
        clearTimeout(this._aggregationTimeoutId);
        delete this._store;
        delete this._items;
        null === (_this$_delayedLoadTas = this._delayedLoadTask) || void 0 === _this$_delayedLoadTas ? void 0 : _this$_delayedLoadTas.abort();
        this._operationManager.cancelAll();
        this._disposed = true;
      },
      _extractLoadOptions(options2) {
        var result2 = {};
        var names = ["sort", "filter", "select", "group", "requireTotalCount"];
        var customNames = this._store._customLoadOptions();
        if (customNames) {
          names = names.concat(customNames);
        }
        each(names, function() {
          result2[this] = options2[this];
        });
        return result2;
      },
      loadOptions() {
        return this._storeLoadOptions;
      },
      items() {
        return this._items;
      },
      pageIndex(newIndex) {
        if (!isNumeric(newIndex)) {
          return this._pageIndex;
        }
        this._pageIndex = newIndex;
        this._isLastPage = !this._paginate;
      },
      paginate(value2) {
        if (!isBoolean(value2)) {
          return this._paginate;
        }
        if (this._paginate !== value2) {
          this._paginate = value2;
          this.pageIndex(0);
        }
      },
      pageSize(value2) {
        if (!isNumeric(value2)) {
          return this._pageSize;
        }
        this._pageSize = value2;
      },
      isLastPage() {
        return this._isLastPage;
      },
      generateStoreLoadOptionAccessor(optionName) {
        return (args) => {
          var normalizedArgs = normalizeStoreLoadOptionAccessorArguments(args);
          if (void 0 === normalizedArgs) {
            return this._storeLoadOptions[optionName];
          }
          this._storeLoadOptions[optionName] = normalizedArgs;
        };
      },
      sort() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return this.generateStoreLoadOptionAccessor("sort")(args);
      },
      filter() {
        var newFilter = normalizeStoreLoadOptionAccessorArguments(arguments);
        if (void 0 === newFilter) {
          return this._storeLoadOptions.filter;
        }
        this._storeLoadOptions.filter = newFilter;
        this.pageIndex(0);
      },
      group() {
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }
        return this.generateStoreLoadOptionAccessor("group")(args);
      },
      select() {
        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          args[_key3] = arguments[_key3];
        }
        return this.generateStoreLoadOptionAccessor("select")(args);
      },
      requireTotalCount(value2) {
        if (!isBoolean(value2)) {
          return this._storeLoadOptions.requireTotalCount;
        }
        this._storeLoadOptions.requireTotalCount = value2;
      },
      searchValue(value2) {
        if (arguments.length < 1) {
          return this._searchValue;
        }
        this._searchValue = value2;
        this.pageIndex(0);
      },
      searchOperation(op) {
        if (!isString2(op)) {
          return this._searchOperation;
        }
        this._searchOperation = op;
        this.pageIndex(0);
      },
      searchExpr(expr) {
        var argc = arguments.length;
        if (0 === argc) {
          return this._searchExpr;
        }
        if (argc > 1) {
          expr = [].slice.call(arguments);
        }
        this._searchExpr = expr;
        this.pageIndex(0);
      },
      store() {
        return this._store;
      },
      key() {
        var _this$_store;
        return null === (_this$_store = this._store) || void 0 === _this$_store ? void 0 : _this$_store.key();
      },
      totalCount() {
        return this._totalCount;
      },
      isLoaded() {
        return this._isLoaded;
      },
      isLoading() {
        return this._loadingCount > 0;
      },
      beginLoading() {
        this._changeLoadingCount(1);
      },
      endLoading() {
        this._changeLoadingCount(-1);
      },
      _createLoadQueue: () => createQueue(),
      _changeLoadingCount(increment) {
        var oldLoading = this.isLoading();
        this._loadingCount += increment;
        var newLoading = this.isLoading();
        if (oldLoading ^ newLoading) {
          this._eventsStrategy.fireEvent("loadingChanged", [newLoading]);
        }
      },
      _scheduleLoadCallbacks(deferred) {
        this.beginLoading();
        deferred.always(() => {
          this.endLoading();
        });
      },
      _scheduleFailCallbacks(deferred) {
        var _this = this;
        deferred.fail(function() {
          for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
            args[_key4] = arguments[_key4];
          }
          if (args[0] === CANCELED_TOKEN) {
            return;
          }
          _this._eventsStrategy.fireEvent("loadError", args);
        });
      },
      _fireChanged(args) {
        var date = /* @__PURE__ */ new Date();
        this._eventsStrategy.fireEvent("changed", args);
        this._changedTime = /* @__PURE__ */ new Date() - date;
      },
      _scheduleChangedCallbacks(deferred) {
        deferred.done(() => this._fireChanged());
      },
      loadSingle(propName, propValue) {
        var d = new Deferred();
        var key = this.key();
        var store = this._store;
        var options2 = this._createStoreLoadOptions();
        this._scheduleFailCallbacks(d);
        if (arguments.length < 2) {
          propValue = propName;
          propName = key;
        }
        delete options2.skip;
        delete options2.group;
        delete options2.refresh;
        delete options2.pageIndex;
        delete options2.searchString;
        (() => {
          if (propName === key || store instanceof custom_store_default && !store._byKeyViaLoad()) {
            return store.byKey(propValue, options2);
          }
          options2.take = 1;
          options2.filter = options2.filter ? [options2.filter, [propName, propValue]] : [propName, propValue];
          return store.load(options2);
        })().fail(d.reject).done((data2) => {
          if (!isDefined(data2) || isEmpty2(data2)) {
            d.reject(new errors.Error("E4009"));
          } else {
            if (!Array.isArray(data2)) {
              data2 = [data2];
            }
            d.resolve(this._applyMapFunction(data2)[0]);
          }
        });
        return d.promise();
      },
      load() {
        var d = new Deferred();
        var loadTask = () => {
          if (this._disposed) {
            return;
          }
          if (!isPending(d)) {
            return;
          }
          return this._loadFromStore(loadOperation, d);
        };
        this._scheduleLoadCallbacks(d);
        this._scheduleFailCallbacks(d);
        this._scheduleChangedCallbacks(d);
        var loadOperation = this._createLoadOperation(d);
        this._eventsStrategy.fireEvent("customizeStoreLoadOptions", [loadOperation]);
        this._loadQueue.add(() => {
          if ("number" === typeof loadOperation.delay) {
            this._delayedLoadTask = executeAsync(loadTask, loadOperation.delay);
          } else {
            loadTask();
          }
          return d.promise();
        });
        return d.promise({
          operationId: loadOperation.operationId
        });
      },
      _onPush(changes) {
        if (this._reshapeOnPush) {
          this.load();
        } else {
          this._eventsStrategy.fireEvent("changing", [{
            changes
          }]);
          var group = this.group();
          var items = this.items();
          var groupLevel = 0;
          var dataSourceChanges = this.paginate() || group ? changes.filter((item) => "update" === item.type) : changes;
          if (group) {
            groupLevel = Array.isArray(group) ? group.length : 1;
          }
          if (this._mapFunc) {
            dataSourceChanges.forEach((item) => {
              if ("insert" === item.type) {
                item.data = this._mapFunc(item.data);
              }
            });
          }
          applyBatch({
            keyInfo: this.store(),
            data: items,
            changes: dataSourceChanges,
            groupCount: groupLevel,
            useInsertIndex: true
          });
          this._fireChanged([{
            changes
          }]);
        }
      },
      _createLoadOperation(deferred) {
        var operationId = this._operationManager.add(deferred);
        var storeLoadOptions = this._createStoreLoadOptions();
        deferred.always(() => this._operationManager.remove(operationId));
        return {
          operationId,
          storeLoadOptions
        };
      },
      reload() {
        var store = this.store();
        if (store instanceof custom_store_default) {
          store.clearRawDataCache();
        }
        this._init();
        return this.load();
      },
      cancel(operationId) {
        return this._operationManager.cancel(operationId);
      },
      cancelAll() {
        return this._operationManager.cancelAll();
      },
      _addSearchOptions(storeLoadOptions) {
        if (this._disposed) {
          return;
        }
        if (this.store()._useDefaultSearch) {
          this._addSearchFilter(storeLoadOptions);
        } else {
          storeLoadOptions.searchOperation = this._searchOperation;
          storeLoadOptions.searchValue = this._searchValue;
          storeLoadOptions.searchExpr = this._searchExpr;
        }
      },
      _createStoreLoadOptions() {
        var result2 = extend2({}, this._storeLoadOptions);
        this._addSearchOptions(result2);
        if (this._paginate) {
          if (this._pageSize) {
            result2.skip = this._pageIndex * this._pageSize;
            result2.take = this._pageSize;
          }
        }
        result2.userData = this._userData;
        return result2;
      },
      _addSearchFilter(storeLoadOptions) {
        var value2 = this._searchValue;
        var op = this._searchOperation;
        var selector = this._searchExpr;
        var searchFilter = [];
        if (!value2) {
          return;
        }
        if (!selector) {
          selector = "this";
        }
        if (!Array.isArray(selector)) {
          selector = [selector];
        }
        each(selector, function(i, item) {
          if (searchFilter.length) {
            searchFilter.push("or");
          }
          searchFilter.push([item, op, value2]);
        });
        if (storeLoadOptions.filter) {
          storeLoadOptions.filter = [searchFilter, storeLoadOptions.filter];
        } else {
          storeLoadOptions.filter = searchFilter;
        }
      },
      _loadFromStore(loadOptions, pendingDeferred) {
        var handleSuccess = (data2, extra) => {
          if (this._disposed) {
            return;
          }
          if (!isPending(pendingDeferred)) {
            return;
          }
          var loadResult = extend2(normalizeLoadResult(data2, extra), loadOptions);
          this._eventsStrategy.fireEvent("customizeLoadResult", [loadResult]);
          when(loadResult.data).done((data3) => {
            loadResult.data = data3;
            this._processStoreLoadResult(loadResult, pendingDeferred);
          }).fail(pendingDeferred.reject);
        };
        if (loadOptions.data) {
          return new Deferred().resolve(loadOptions.data).done(handleSuccess);
        }
        return this.store().load(loadOptions.storeLoadOptions).done(handleSuccess).fail(pendingDeferred.reject);
      },
      _processStoreLoadResult(loadResult, pendingDeferred) {
        var data2 = loadResult.data;
        var extra = loadResult.extra;
        var storeLoadOptions = loadResult.storeLoadOptions;
        var resolvePendingDeferred = () => {
          this._isLoaded = true;
          this._totalCount = isFinite(extra.totalCount) ? extra.totalCount : -1;
          return pendingDeferred.resolve(data2, extra);
        };
        if (this._disposed) {
          return;
        }
        data2 = this._applyPostProcessFunction(this._applyMapFunction(data2));
        if (!isPlainObject(extra)) {
          extra = {};
        }
        this._items = data2;
        if (!data2.length || !this._paginate || this._pageSize && data2.length < this._pageSize) {
          this._isLastPage = true;
        }
        if (storeLoadOptions.requireTotalCount && !isFinite(extra.totalCount)) {
          (() => {
            this.store().totalCount(storeLoadOptions).done(function(count) {
              extra.totalCount = count;
              resolvePendingDeferred();
            }).fail(pendingDeferred.reject);
          })();
        } else {
          resolvePendingDeferred();
        }
      },
      _applyMapFunction(data2) {
        if (this._mapFunc) {
          return mapDataRespectingGrouping(data2, this._mapFunc, this.group());
        }
        return data2;
      },
      _applyPostProcessFunction(data2) {
        if (this._postProcessFunc) {
          return this._postProcessFunc(data2);
        }
        return data2;
      },
      on(eventName, eventHandler) {
        this._eventsStrategy.on(eventName, eventHandler);
        return this;
      },
      off(eventName, eventHandler) {
        this._eventsStrategy.off(eventName, eventHandler);
        return this;
      }
    });
  }
});

// node_modules/devextreme/esm/data_helper.js
var DATA_SOURCE_OPTIONS_METHOD, DATA_SOURCE_CHANGED_METHOD, DATA_SOURCE_LOAD_ERROR_METHOD, DATA_SOURCE_LOADING_CHANGED_METHOD, DATA_SOURCE_FROM_URL_LOAD_MODE_METHOD, SPECIFIC_DATA_SOURCE_OPTION, NORMALIZE_DATA_SOURCE, DataHelperMixin, data_helper_default;
var init_data_helper = __esm({
  "node_modules/devextreme/esm/data_helper.js"() {
    init_data_source();
    init_extend();
    init_utils5();
    DATA_SOURCE_OPTIONS_METHOD = "_dataSourceOptions";
    DATA_SOURCE_CHANGED_METHOD = "_dataSourceChangedHandler";
    DATA_SOURCE_LOAD_ERROR_METHOD = "_dataSourceLoadErrorHandler";
    DATA_SOURCE_LOADING_CHANGED_METHOD = "_dataSourceLoadingChangedHandler";
    DATA_SOURCE_FROM_URL_LOAD_MODE_METHOD = "_dataSourceFromUrlLoadMode";
    SPECIFIC_DATA_SOURCE_OPTION = "_getSpecificDataSourceOption";
    NORMALIZE_DATA_SOURCE = "_normalizeDataSource";
    DataHelperMixin = {
      postCtor: function() {
        this.on("disposing", (function() {
          this._disposeDataSource();
        }).bind(this));
      },
      _refreshDataSource: function() {
        this._initDataSource();
        this._loadDataSource();
      },
      _initDataSource: function() {
        var dataSourceOptions = SPECIFIC_DATA_SOURCE_OPTION in this ? this[SPECIFIC_DATA_SOURCE_OPTION]() : this.option("dataSource");
        var widgetDataSourceOptions;
        var dataSourceType;
        this._disposeDataSource();
        if (dataSourceOptions) {
          if (dataSourceOptions instanceof DataSource) {
            this._isSharedDataSource = true;
            this._dataSource = dataSourceOptions;
          } else {
            widgetDataSourceOptions = DATA_SOURCE_OPTIONS_METHOD in this ? this[DATA_SOURCE_OPTIONS_METHOD]() : {};
            dataSourceType = this._dataSourceType ? this._dataSourceType() : DataSource;
            dataSourceOptions = normalizeDataSourceOptions(dataSourceOptions, {
              fromUrlLoadMode: DATA_SOURCE_FROM_URL_LOAD_MODE_METHOD in this && this[DATA_SOURCE_FROM_URL_LOAD_MODE_METHOD]()
            });
            this._dataSource = new dataSourceType(extend2(true, {}, widgetDataSourceOptions, dataSourceOptions));
          }
          if (NORMALIZE_DATA_SOURCE in this) {
            this._dataSource = this[NORMALIZE_DATA_SOURCE](this._dataSource);
          }
          this._addDataSourceHandlers();
        }
      },
      _addDataSourceHandlers: function() {
        if (DATA_SOURCE_CHANGED_METHOD in this) {
          this._addDataSourceChangeHandler();
        }
        if (DATA_SOURCE_LOAD_ERROR_METHOD in this) {
          this._addDataSourceLoadErrorHandler();
        }
        if (DATA_SOURCE_LOADING_CHANGED_METHOD in this) {
          this._addDataSourceLoadingChangedHandler();
        }
        this._addReadyWatcher();
      },
      _addReadyWatcher: function() {
        this._dataSource.on("loadingChanged", (function(isLoading) {
          this._ready && this._ready(!isLoading);
        }).bind(this));
      },
      _addDataSourceChangeHandler: function() {
        var dataSource = this._dataSource;
        this._proxiedDataSourceChangedHandler = (function(e) {
          this[DATA_SOURCE_CHANGED_METHOD](dataSource.items(), e);
        }).bind(this);
        dataSource.on("changed", this._proxiedDataSourceChangedHandler);
      },
      _addDataSourceLoadErrorHandler: function() {
        this._proxiedDataSourceLoadErrorHandler = this[DATA_SOURCE_LOAD_ERROR_METHOD].bind(this);
        this._dataSource.on("loadError", this._proxiedDataSourceLoadErrorHandler);
      },
      _addDataSourceLoadingChangedHandler: function() {
        this._proxiedDataSourceLoadingChangedHandler = this[DATA_SOURCE_LOADING_CHANGED_METHOD].bind(this);
        this._dataSource.on("loadingChanged", this._proxiedDataSourceLoadingChangedHandler);
      },
      _loadDataSource: function() {
        if (this._dataSource) {
          var dataSource = this._dataSource;
          if (dataSource.isLoaded()) {
            this._proxiedDataSourceChangedHandler && this._proxiedDataSourceChangedHandler();
          } else {
            dataSource.load();
          }
        }
      },
      _loadSingle: function(key, value2) {
        key = "this" === key ? this._dataSource.key() || "this" : key;
        return this._dataSource.loadSingle(key, value2);
      },
      _isLastPage: function() {
        return !this._dataSource || this._dataSource.isLastPage() || !this._dataSource._pageSize;
      },
      _isDataSourceLoading: function() {
        return this._dataSource && this._dataSource.isLoading();
      },
      _disposeDataSource: function() {
        if (this._dataSource) {
          if (this._isSharedDataSource) {
            delete this._isSharedDataSource;
            this._proxiedDataSourceChangedHandler && this._dataSource.off("changed", this._proxiedDataSourceChangedHandler);
            this._proxiedDataSourceLoadErrorHandler && this._dataSource.off("loadError", this._proxiedDataSourceLoadErrorHandler);
            this._proxiedDataSourceLoadingChangedHandler && this._dataSource.off("loadingChanged", this._proxiedDataSourceLoadingChangedHandler);
          } else {
            this._dataSource.dispose();
          }
          delete this._dataSource;
          delete this._proxiedDataSourceChangedHandler;
          delete this._proxiedDataSourceLoadErrorHandler;
          delete this._proxiedDataSourceLoadingChangedHandler;
        }
      },
      getDataSource: function() {
        return this._dataSource || null;
      }
    };
    data_helper_default = DataHelperMixin;
  }
});

// node_modules/devextreme/esm/ui/collection/item.js
var INVISIBLE_STATE_CLASS2, DISABLED_STATE_CLASS, ITEM_CONTENT_PLACEHOLDER_CLASS, forcibleWatcher, CollectionItem, item_default;
var init_item = __esm({
  "node_modules/devextreme/esm/ui/collection/item.js"() {
    init_renderer();
    init_class();
    init_iterator();
    init_public_component();
    INVISIBLE_STATE_CLASS2 = "dx-state-invisible";
    DISABLED_STATE_CLASS = "dx-state-disabled";
    ITEM_CONTENT_PLACEHOLDER_CLASS = "dx-item-content-placeholder";
    forcibleWatcher = function(watchMethod, fn, callback) {
      var filteredCallback = function(value2) {
        if (oldValue !== value2) {
          callback(value2, oldValue);
          oldValue = value2;
        }
      };
      var oldValue;
      return {
        dispose: watchMethod(fn, filteredCallback),
        force: function() {
          filteredCallback(fn());
        }
      };
    };
    CollectionItem = class_default.inherit({
      ctor: function($element, options2, rawData) {
        this._$element = $element;
        this._options = options2;
        this._rawData = rawData;
        attachInstanceToElement($element, this, this._dispose);
        this._render();
      },
      _render: function() {
        var $placeholder = renderer_default("<div>").addClass(ITEM_CONTENT_PLACEHOLDER_CLASS);
        this._$element.append($placeholder);
        this._watchers = [];
        this._renderWatchers();
      },
      _renderWatchers: function() {
        this._startWatcher("disabled", this._renderDisabled.bind(this));
        this._startWatcher("visible", this._renderVisible.bind(this));
      },
      _startWatcher: function(field, render4) {
        var rawData = this._rawData;
        var exprGetter = this._options.fieldGetter(field);
        var watcher = forcibleWatcher(this._options.watchMethod(), function() {
          return exprGetter(rawData);
        }, (function(value2, oldValue) {
          this._dirty = true;
          render4(value2, oldValue);
        }).bind(this));
        this._watchers.push(watcher);
      },
      setDataField: function() {
        this._dirty = false;
        each(this._watchers, function(_2, watcher) {
          watcher.force();
        });
        if (this._dirty) {
          return true;
        }
      },
      _renderDisabled: function(value2, oldValue) {
        this._$element.toggleClass(DISABLED_STATE_CLASS, !!value2);
        this._updateOwnerFocus(value2);
      },
      _updateOwnerFocus: function(isDisabled) {
        var ownerComponent = this._options.owner;
        if (ownerComponent && isDisabled) {
          ownerComponent._resetItemFocus(this._$element);
        }
      },
      _renderVisible: function(value2, oldValue) {
        this._$element.toggleClass(INVISIBLE_STATE_CLASS2, void 0 !== value2 && !value2);
      },
      _dispose: function() {
        each(this._watchers, function(_2, watcher) {
          watcher.dispose();
        });
      }
    });
    CollectionItem.getInstance = function($element) {
      return getInstanceByElement($element, this);
    };
    item_default = CollectionItem;
  }
});

// node_modules/devextreme/esm/events/hold.js
var abs3, HOLD_EVENT_NAME, HOLD_TIMEOUT, TOUCH_BOUNDARY3, HoldEmitter, hold_default;
var init_hold = __esm({
  "node_modules/devextreme/esm/events/hold.js"() {
    init_utils2();
    init_emitter();
    init_emitter_registrator();
    abs3 = Math.abs;
    HOLD_EVENT_NAME = "dxhold";
    HOLD_TIMEOUT = 750;
    TOUCH_BOUNDARY3 = 5;
    HoldEmitter = emitter_default.inherit({
      start: function(e) {
        this._startEventData = eventData(e);
        this._startTimer(e);
      },
      _startTimer: function(e) {
        var holdTimeout = "timeout" in this ? this.timeout : HOLD_TIMEOUT;
        this._holdTimer = setTimeout((function() {
          this._requestAccept(e);
          this._fireEvent(HOLD_EVENT_NAME, e, {
            target: e.target
          });
          this._forgetAccept();
        }).bind(this), holdTimeout);
      },
      move: function(e) {
        if (this._touchWasMoved(e)) {
          this._cancel(e);
        }
      },
      _touchWasMoved: function(e) {
        var delta = eventDelta(this._startEventData, eventData(e));
        return abs3(delta.x) > TOUCH_BOUNDARY3 || abs3(delta.y) > TOUCH_BOUNDARY3;
      },
      end: function() {
        this._stopTimer();
      },
      _stopTimer: function() {
        clearTimeout(this._holdTimer);
      },
      cancel: function() {
        this._stopTimer();
      },
      dispose: function() {
        this._stopTimer();
      }
    });
    emitter_registrator_default({
      emitter: HoldEmitter,
      bubble: true,
      events: [HOLD_EVENT_NAME]
    });
    hold_default = {
      name: HOLD_EVENT_NAME
    };
  }
});

// node_modules/devextreme/esm/events/contextmenu.js
var CONTEXTMENU_NAMESPACE, CONTEXTMENU_NAMESPACED_EVENT_NAME, HOLD_NAMESPACED_EVENT_NAME, CONTEXTMENU_EVENT_NAME, ContextMenu, name;
var init_contextmenu = __esm({
  "node_modules/devextreme/esm/events/contextmenu.js"() {
    init_renderer();
    init_events_engine();
    init_support();
    init_devices();
    init_class();
    init_event_registrator();
    init_utils2();
    init_hold();
    CONTEXTMENU_NAMESPACE = "dxContexMenu";
    CONTEXTMENU_NAMESPACED_EVENT_NAME = addNamespace2("contextmenu", CONTEXTMENU_NAMESPACE);
    HOLD_NAMESPACED_EVENT_NAME = addNamespace2(hold_default.name, CONTEXTMENU_NAMESPACE);
    CONTEXTMENU_EVENT_NAME = "dxcontextmenu";
    ContextMenu = class_default.inherit({
      setup: function(element) {
        var $element = renderer_default(element);
        events_engine_default.on($element, CONTEXTMENU_NAMESPACED_EVENT_NAME, this._contextMenuHandler.bind(this));
        if (touch || devices_default.isSimulator()) {
          events_engine_default.on($element, HOLD_NAMESPACED_EVENT_NAME, this._holdHandler.bind(this));
        }
      },
      _holdHandler: function(e) {
        if (isMouseEvent(e) && !devices_default.isSimulator()) {
          return;
        }
        this._fireContextMenu(e);
      },
      _contextMenuHandler: function(e) {
        this._fireContextMenu(e);
      },
      _fireContextMenu: function(e) {
        return fireEvent({
          type: CONTEXTMENU_EVENT_NAME,
          originalEvent: e
        });
      },
      teardown: function(element) {
        events_engine_default.off(element, "." + CONTEXTMENU_NAMESPACE);
      }
    });
    event_registrator_default(CONTEXTMENU_EVENT_NAME, new ContextMenu());
    name = CONTEXTMENU_EVENT_NAME;
  }
});

// node_modules/devextreme/esm/core/templates/bindable_template.js
var watchChanges, BindableTemplate;
var init_bindable_template = __esm({
  "node_modules/devextreme/esm/core/templates/bindable_template.js"() {
    init_renderer();
    init_template_base();
    init_events_engine();
    init_remove();
    init_type();
    watchChanges = function(rawData, watchMethod, fields, fieldsMap, callback) {
      var fieldsDispose;
      var globalDispose = ((data2, watchMethod2, callback2) => watchMethod2(() => data2, callback2))(rawData, watchMethod, function(dataWithRawFields) {
        fieldsDispose && fieldsDispose();
        if (isPrimitive(dataWithRawFields)) {
          callback(dataWithRawFields);
          return;
        }
        fieldsDispose = function(data2, watchMethod2, fields2, fieldsMap2, callback2) {
          var resolvedData = {};
          var missedFields = fields2.slice();
          var watchHandlers = fields2.map(function(name2) {
            var fieldGetter = fieldsMap2[name2];
            return watchMethod2(fieldGetter ? () => fieldGetter(data2) : () => data2[name2], function(value2) {
              resolvedData[name2] = value2;
              if (missedFields.length) {
                var index2 = missedFields.indexOf(name2);
                if (index2 >= 0) {
                  missedFields.splice(index2, 1);
                }
              }
              if (!missedFields.length) {
                callback2(resolvedData);
              }
            });
          });
          return function() {
            watchHandlers.forEach((dispose) => dispose());
          };
        }(dataWithRawFields, watchMethod, fields, fieldsMap, callback);
      });
      return function() {
        fieldsDispose && fieldsDispose();
        globalDispose && globalDispose();
      };
    };
    BindableTemplate = class extends TemplateBase {
      constructor(render4, fields, watchMethod, fieldsMap) {
        super();
        this._render = render4;
        this._fields = fields;
        this._fieldsMap = fieldsMap || {};
        this._watchMethod = watchMethod;
      }
      _renderCore(options2) {
        var $container = renderer_default(options2.container);
        var dispose = watchChanges(options2.model, this._watchMethod, this._fields, this._fieldsMap, (data2) => {
          $container.empty();
          this._render($container, data2, options2.model);
        });
        events_engine_default.on($container, removeEvent, dispose);
        return $container.contents();
      }
    };
  }
});

// node_modules/devextreme/esm/ui/collection/ui.collection_widget.base.js
var COLLECTION_CLASS, ITEM_CLASS, CONTENT_CLASS_POSTFIX, ITEM_CONTENT_PLACEHOLDER_CLASS2, ITEM_DATA_KEY, ITEM_INDEX_KEY, ITEM_TEMPLATE_ID_PREFIX, ITEMS_OPTIONS_NAME, SELECTED_ITEM_CLASS, ITEM_RESPONSE_WAIT_CLASS, EMPTY_COLLECTION, TEMPLATE_WRAPPER_CLASS2, ITEM_PATH_REGEX, ANONYMOUS_TEMPLATE_NAME4, FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, FOCUS_RIGHT, FOCUS_PAGE_UP, FOCUS_PAGE_DOWN, FOCUS_LAST, FOCUS_FIRST, CollectionWidget, ui_collection_widget_base_default;
var init_ui_collection_widget_base = __esm({
  "node_modules/devextreme/esm/ui/collection/ui.collection_widget.base.js"() {
    init_renderer();
    init_events_engine();
    init_common();
    init_template_manager();
    init_element();
    init_dom_adapter();
    init_type();
    init_deferred();
    init_extend();
    init_array();
    init_iterator();
    init_action();
    init_guid();
    init_ui_widget();
    init_utils2();
    init_pointer();
    init_data_helper();
    init_item();
    init_selectors();
    init_message();
    init_hold();
    init_data();
    init_click();
    init_contextmenu();
    init_bindable_template();
    COLLECTION_CLASS = "dx-collection";
    ITEM_CLASS = "dx-item";
    CONTENT_CLASS_POSTFIX = "-content";
    ITEM_CONTENT_PLACEHOLDER_CLASS2 = "dx-item-content-placeholder";
    ITEM_DATA_KEY = "dxItemData";
    ITEM_INDEX_KEY = "dxItemIndex";
    ITEM_TEMPLATE_ID_PREFIX = "tmpl-";
    ITEMS_OPTIONS_NAME = "dxItem";
    SELECTED_ITEM_CLASS = "dx-item-selected";
    ITEM_RESPONSE_WAIT_CLASS = "dx-item-response-wait";
    EMPTY_COLLECTION = "dx-empty-collection";
    TEMPLATE_WRAPPER_CLASS2 = "dx-template-wrapper";
    ITEM_PATH_REGEX = /^([^.]+\[\d+\]\.)+([\w.]+)$/;
    ANONYMOUS_TEMPLATE_NAME4 = "item";
    FOCUS_UP = "up";
    FOCUS_DOWN = "down";
    FOCUS_LEFT = "left";
    FOCUS_RIGHT = "right";
    FOCUS_PAGE_UP = "pageup";
    FOCUS_PAGE_DOWN = "pagedown";
    FOCUS_LAST = "last";
    FOCUS_FIRST = "first";
    CollectionWidget = ui_widget_default.inherit({
      _activeStateUnit: "." + ITEM_CLASS,
      _supportedKeys: function() {
        var enter = function(e) {
          var $itemElement = renderer_default(this.option("focusedElement"));
          if (!$itemElement.length) {
            return;
          }
          this._itemClickHandler(extend2({}, e, {
            target: $itemElement.get(0),
            currentTarget: $itemElement.get(0)
          }));
        };
        var move2 = function(location, e) {
          if (!isCommandKeyPressed(e)) {
            e.preventDefault();
            e.stopPropagation();
            this._moveFocus(location, e);
          }
        };
        return extend2(this.callBase(), {
          space: function(e) {
            e.preventDefault();
            enter.call(this, e);
          },
          enter,
          leftArrow: move2.bind(this, FOCUS_LEFT),
          rightArrow: move2.bind(this, FOCUS_RIGHT),
          upArrow: move2.bind(this, FOCUS_UP),
          downArrow: move2.bind(this, FOCUS_DOWN),
          pageUp: move2.bind(this, FOCUS_UP),
          pageDown: move2.bind(this, FOCUS_DOWN),
          home: move2.bind(this, FOCUS_FIRST),
          end: move2.bind(this, FOCUS_LAST)
        });
      },
      _getDefaultOptions: function() {
        return extend2(this.callBase(), {
          selectOnFocus: false,
          loopItemFocus: true,
          items: [],
          itemTemplate: "item",
          onItemRendered: null,
          onItemClick: null,
          onItemHold: null,
          itemHoldTimeout: 750,
          onItemContextMenu: null,
          onFocusedItemChanged: null,
          noDataText: message_default.format("dxCollectionWidget-noDataText"),
          dataSource: null,
          _itemAttributes: {},
          itemTemplateProperty: "template",
          focusOnSelectedItem: true,
          focusedElement: null,
          displayExpr: void 0,
          disabledExpr: function(data2) {
            return data2 ? data2.disabled : void 0;
          },
          visibleExpr: function(data2) {
            return data2 ? data2.visible : void 0;
          }
        });
      },
      _init: function() {
        this._compileDisplayGetter();
        this.callBase();
        this._cleanRenderedItems();
        this._refreshDataSource();
      },
      _compileDisplayGetter: function() {
        var displayExpr = this.option("displayExpr");
        this._displayGetter = displayExpr ? compileGetter(this.option("displayExpr")) : void 0;
      },
      _initTemplates: function() {
        this._initItemsFromMarkup();
        this._initDefaultItemTemplate();
        this.callBase();
      },
      _getAnonymousTemplateName: function() {
        return ANONYMOUS_TEMPLATE_NAME4;
      },
      _initDefaultItemTemplate: function() {
        var fieldsMap = this._getFieldsMap();
        this._templateManager.addDefaultTemplates({
          item: new BindableTemplate((function($container, data2) {
            if (isPlainObject(data2)) {
              this._prepareDefaultItemTemplate(data2, $container);
            } else {
              if (fieldsMap && isFunction(fieldsMap.text)) {
                data2 = fieldsMap.text(data2);
              }
              $container.text(String(ensureDefined(data2, "")));
            }
          }).bind(this), this._getBindableFields(), this.option("integrationOptions.watchMethod"), fieldsMap)
        });
      },
      _getBindableFields: function() {
        return ["text", "html"];
      },
      _getFieldsMap: function() {
        if (this._displayGetter) {
          return {
            text: this._displayGetter
          };
        }
      },
      _prepareDefaultItemTemplate: function(data2, $container) {
        if (isDefined(data2.text)) {
          $container.text(data2.text);
        }
        if (isDefined(data2.html)) {
          $container.html(data2.html);
        }
      },
      _initItemsFromMarkup: function() {
        var rawItems = findTemplates(this.$element(), ITEMS_OPTIONS_NAME);
        if (!rawItems.length || this.option("items").length) {
          return;
        }
        var items = rawItems.map((_ref) => {
          var {
            element,
            options: options2
          } = _ref;
          var isTemplateRequired = /\S/.test(element.innerHTML) && !options2.template;
          if (isTemplateRequired) {
            options2.template = this._prepareItemTemplate(element);
          } else {
            renderer_default(element).remove();
          }
          return options2;
        });
        this.option("items", items);
      },
      _prepareItemTemplate: function(item) {
        var templateId = ITEM_TEMPLATE_ID_PREFIX + new guid_default();
        var $template = renderer_default(item).detach().clone().removeAttr("data-options").addClass(TEMPLATE_WRAPPER_CLASS2);
        this._saveTemplate(templateId, $template);
        return templateId;
      },
      _dataSourceOptions: function() {
        return {
          paginate: false
        };
      },
      _cleanRenderedItems: function() {
        this._renderedItemsCount = 0;
      },
      _focusTarget: function() {
        return this.$element();
      },
      _focusInHandler: function(e) {
        this.callBase.apply(this, arguments);
        if (-1 === inArray(e.target, this._focusTarget())) {
          return;
        }
        var $focusedElement = renderer_default(this.option("focusedElement"));
        if ($focusedElement.length) {
          this._setFocusedItem($focusedElement);
        } else {
          var $activeItem = this._getActiveItem();
          if ($activeItem.length) {
            this.option("focusedElement", getPublicElement($activeItem));
          }
        }
      },
      _focusOutHandler: function() {
        this.callBase.apply(this, arguments);
        var $target = renderer_default(this.option("focusedElement"));
        this._updateFocusedItemState($target, false);
      },
      _getActiveItem: function(last) {
        var $focusedElement = renderer_default(this.option("focusedElement"));
        if ($focusedElement.length) {
          return $focusedElement;
        }
        var index2 = this.option("focusOnSelectedItem") ? this.option("selectedIndex") : 0;
        var activeElements = this._getActiveElement();
        var lastIndex = activeElements.length - 1;
        if (index2 < 0) {
          index2 = last ? lastIndex : 0;
        }
        return activeElements.eq(index2);
      },
      _moveFocus: function(location) {
        var $items = this._getAvailableItems();
        var $newTarget;
        switch (location) {
          case FOCUS_PAGE_UP:
          case FOCUS_UP:
            $newTarget = this._prevItem($items);
            break;
          case FOCUS_PAGE_DOWN:
          case FOCUS_DOWN:
            $newTarget = this._nextItem($items);
            break;
          case FOCUS_RIGHT:
            $newTarget = this.option("rtlEnabled") ? this._prevItem($items) : this._nextItem($items);
            break;
          case FOCUS_LEFT:
            $newTarget = this.option("rtlEnabled") ? this._nextItem($items) : this._prevItem($items);
            break;
          case FOCUS_FIRST:
            $newTarget = $items.first();
            break;
          case FOCUS_LAST:
            $newTarget = $items.last();
            break;
          default:
            return false;
        }
        if (0 !== $newTarget.length) {
          this.option("focusedElement", getPublicElement($newTarget));
        }
      },
      _getVisibleItems: function($itemElements) {
        $itemElements = $itemElements || this._itemElements();
        return $itemElements.filter(":visible");
      },
      _getAvailableItems: function($itemElements) {
        return this._getVisibleItems($itemElements).not(".dx-state-disabled");
      },
      _prevItem: function($items) {
        var $target = this._getActiveItem();
        var targetIndex = $items.index($target);
        var $last = $items.last();
        var $item = renderer_default($items[targetIndex - 1]);
        var loop = this.option("loopItemFocus");
        if (0 === $item.length && loop) {
          $item = $last;
        }
        return $item;
      },
      _nextItem: function($items) {
        var $target = this._getActiveItem(true);
        var targetIndex = $items.index($target);
        var $first = $items.first();
        var $item = renderer_default($items[targetIndex + 1]);
        var loop = this.option("loopItemFocus");
        if (0 === $item.length && loop) {
          $item = $first;
        }
        return $item;
      },
      _selectFocusedItem: function($target) {
        this.selectItem($target);
      },
      _updateFocusedItemState: function(target, isFocused, needCleanItemId) {
        var $target = renderer_default(target);
        if ($target.length) {
          this._refreshActiveDescendant();
          this._refreshItemId($target, needCleanItemId);
          this._toggleFocusClass(isFocused, $target);
        }
        this._updateParentActiveDescendant();
      },
      _refreshActiveDescendant: function($target) {
        this.setAria("activedescendant", isDefined(this.option("focusedElement")) ? this.getFocusedItemId() : null, $target);
      },
      _refreshItemId: function($target, needCleanItemId) {
        if (!needCleanItemId && this.option("focusedElement")) {
          this.setAria("id", this.getFocusedItemId(), $target);
        } else {
          this.setAria("id", null, $target);
        }
      },
      _setFocusedItem: function($target) {
        if (!$target || !$target.length) {
          return;
        }
        this._updateFocusedItemState($target, true);
        this.onFocusedItemChanged(this.getFocusedItemId());
        if (this.option("selectOnFocus")) {
          this._selectFocusedItem($target);
        }
      },
      _findItemElementByItem: function(item) {
        var result2 = renderer_default();
        var that = this;
        this.itemElements().each(function() {
          var $item = renderer_default(this);
          if ($item.data(that._itemDataKey()) === item) {
            result2 = $item;
            return false;
          }
        });
        return result2;
      },
      _getIndexByItem: function(item) {
        return this.option("items").indexOf(item);
      },
      _itemOptionChanged: function(item, property, value2, oldValue) {
        var $item = this._findItemElementByItem(item);
        if (!$item.length) {
          return;
        }
        if (!this.constructor.ItemClass.getInstance($item).setDataField(property, value2)) {
          this._refreshItem($item, item);
        }
        var isDisabling = "disabled" === property && value2;
        if (isDisabling) {
          this._resetItemFocus($item);
        }
      },
      _resetItemFocus($item) {
        if ($item.is(this.option("focusedElement"))) {
          this.option("focusedElement", null);
        }
      },
      _refreshItem: function($item) {
        var itemData = this._getItemData($item);
        var index2 = $item.data(this._itemIndexKey());
        this._renderItem(this._renderedItemsCount + index2, itemData, null, $item);
      },
      _updateParentActiveDescendant: noop2,
      _optionChanged: function(args) {
        if ("items" === args.name) {
          var matches = args.fullName.match(ITEM_PATH_REGEX);
          if (matches && matches.length) {
            var property = matches[matches.length - 1];
            var itemPath = args.fullName.replace("." + property, "");
            var item = this.option(itemPath);
            this._itemOptionChanged(item, property, args.value, args.previousValue);
            return;
          }
        }
        switch (args.name) {
          case "items":
          case "_itemAttributes":
          case "itemTemplateProperty":
          case "useItemTextAsTitle":
            this._cleanRenderedItems();
            this._invalidate();
            break;
          case "dataSource":
            this._refreshDataSource();
            this._renderEmptyMessage();
            break;
          case "noDataText":
            this._renderEmptyMessage();
            break;
          case "itemTemplate":
            this._invalidate();
            break;
          case "onItemRendered":
            this._createItemRenderAction();
            break;
          case "onItemClick":
            break;
          case "onItemHold":
          case "itemHoldTimeout":
            this._attachHoldEvent();
            break;
          case "onItemContextMenu":
            this._attachContextMenuEvent();
            break;
          case "onFocusedItemChanged":
            this.onFocusedItemChanged = this._createActionByOption("onFocusedItemChanged");
            break;
          case "selectOnFocus":
          case "loopItemFocus":
          case "focusOnSelectedItem":
            break;
          case "focusedElement":
            this._updateFocusedItemState(args.previousValue, false, true);
            this._setFocusedItem(renderer_default(args.value));
            break;
          case "displayExpr":
            this._compileDisplayGetter();
            this._initDefaultItemTemplate();
            this._invalidate();
            break;
          case "visibleExpr":
          case "disabledExpr":
            this._invalidate();
            break;
          default:
            this.callBase(args);
        }
      },
      _invalidate: function() {
        this.option("focusedElement", null);
        return this.callBase.apply(this, arguments);
      },
      _loadNextPage: function() {
        var dataSource = this._dataSource;
        this._expectNextPageLoading();
        dataSource.pageIndex(1 + dataSource.pageIndex());
        return dataSource.load();
      },
      _expectNextPageLoading: function() {
        this._startIndexForAppendedItems = 0;
      },
      _expectLastItemLoading: function() {
        this._startIndexForAppendedItems = -1;
      },
      _forgetNextPageLoading: function() {
        this._startIndexForAppendedItems = null;
      },
      _dataSourceChangedHandler: function(newItems) {
        var items = this.option("items");
        if (this._initialized && items && this._shouldAppendItems()) {
          this._renderedItemsCount = items.length;
          if (!this._isLastPage() || -1 !== this._startIndexForAppendedItems) {
            this.option().items = items.concat(newItems.slice(this._startIndexForAppendedItems));
          }
          this._forgetNextPageLoading();
          this._refreshContent();
        } else {
          this.option("items", newItems.slice());
        }
      },
      _refreshContent: function() {
        this._prepareContent();
        this._renderContent();
      },
      _dataSourceLoadErrorHandler: function() {
        this._forgetNextPageLoading();
        this.option("items", this.option("items"));
      },
      _shouldAppendItems: function() {
        return null != this._startIndexForAppendedItems && this._allowDynamicItemsAppend();
      },
      _allowDynamicItemsAppend: function() {
        return false;
      },
      _clean: function() {
        this._cleanFocusState();
        this._cleanItemContainer();
      },
      _cleanItemContainer: function() {
        renderer_default(this._itemContainer()).empty();
      },
      _dispose: function() {
        this.callBase();
        clearTimeout(this._itemFocusTimeout);
      },
      _refresh: function() {
        this._cleanRenderedItems();
        this.callBase.apply(this, arguments);
      },
      _itemContainer: function() {
        return this.$element();
      },
      _itemClass: function() {
        return ITEM_CLASS;
      },
      _itemContentClass: function() {
        return this._itemClass() + CONTENT_CLASS_POSTFIX;
      },
      _selectedItemClass: function() {
        return SELECTED_ITEM_CLASS;
      },
      _itemResponseWaitClass: function() {
        return ITEM_RESPONSE_WAIT_CLASS;
      },
      _itemSelector: function() {
        return "." + this._itemClass();
      },
      _itemDataKey: function() {
        return ITEM_DATA_KEY;
      },
      _itemIndexKey: function() {
        return ITEM_INDEX_KEY;
      },
      _itemElements: function() {
        return this._itemContainer().find(this._itemSelector());
      },
      _initMarkup: function() {
        this.callBase();
        this.onFocusedItemChanged = this._createActionByOption("onFocusedItemChanged");
        this.$element().addClass(COLLECTION_CLASS);
        this._prepareContent();
      },
      _prepareContent: deferRenderer(function() {
        this._renderContentImpl();
      }),
      _renderContent: function() {
        this._fireContentReadyAction();
      },
      _render: function() {
        this.callBase();
        this._attachClickEvent();
        this._attachHoldEvent();
        this._attachContextMenuEvent();
      },
      _attachClickEvent: function() {
        var itemSelector = this._itemSelector();
        var clickEventNamespace = addNamespace2(CLICK_EVENT_NAME, this.NAME);
        var pointerDownEventNamespace = addNamespace2(pointer_default.down, this.NAME);
        var that = this;
        var pointerDownAction = new Action(function(args) {
          var event = args.event;
          that._itemPointerDownHandler(event);
        });
        events_engine_default.off(this._itemContainer(), clickEventNamespace, itemSelector);
        events_engine_default.off(this._itemContainer(), pointerDownEventNamespace, itemSelector);
        events_engine_default.on(this._itemContainer(), clickEventNamespace, itemSelector, (function(e) {
          this._itemClickHandler(e);
        }).bind(this));
        events_engine_default.on(this._itemContainer(), pointerDownEventNamespace, itemSelector, function(e) {
          pointerDownAction.execute({
            element: renderer_default(e.target),
            event: e
          });
        });
      },
      _itemClickHandler: function(e, args, config2) {
        this._itemDXEventHandler(e, "onItemClick", args, config2);
      },
      _itemPointerDownHandler: function(e) {
        if (!this.option("focusStateEnabled")) {
          return;
        }
        this._itemFocusHandler = (function() {
          clearTimeout(this._itemFocusTimeout);
          this._itemFocusHandler = null;
          if (e.isDefaultPrevented()) {
            return;
          }
          var $target = renderer_default(e.target);
          var $closestItem = $target.closest(this._itemElements());
          var $closestFocusable = this._closestFocusable($target);
          if ($closestItem.length && $closestFocusable && -1 !== inArray($closestFocusable.get(0), this._focusTarget())) {
            this.option("focusedElement", getPublicElement($closestItem));
          }
        }).bind(this);
        this._itemFocusTimeout = setTimeout(this._forcePointerDownFocus.bind(this));
      },
      _closestFocusable: function($target) {
        if ($target.is(focusable)) {
          return $target;
        } else {
          $target = $target.parent();
          while ($target.length && !dom_adapter_default.isDocument($target.get(0))) {
            if ($target.is(focusable)) {
              return $target;
            }
            $target = $target.parent();
          }
        }
      },
      _forcePointerDownFocus: function() {
        this._itemFocusHandler && this._itemFocusHandler();
      },
      _updateFocusState: function() {
        this.callBase.apply(this, arguments);
        this._forcePointerDownFocus();
      },
      _attachHoldEvent: function() {
        var $itemContainer = this._itemContainer();
        var itemSelector = this._itemSelector();
        var eventName = addNamespace2(hold_default.name, this.NAME);
        events_engine_default.off($itemContainer, eventName, itemSelector);
        events_engine_default.on($itemContainer, eventName, itemSelector, {
          timeout: this._getHoldTimeout()
        }, this._itemHoldHandler.bind(this));
      },
      _getHoldTimeout: function() {
        return this.option("itemHoldTimeout");
      },
      _shouldFireHoldEvent: function() {
        return this.hasActionSubscription("onItemHold");
      },
      _itemHoldHandler: function(e) {
        if (this._shouldFireHoldEvent()) {
          this._itemDXEventHandler(e, "onItemHold");
        } else {
          e.cancel = true;
        }
      },
      _attachContextMenuEvent: function() {
        var $itemContainer = this._itemContainer();
        var itemSelector = this._itemSelector();
        var eventName = addNamespace2(name, this.NAME);
        events_engine_default.off($itemContainer, eventName, itemSelector);
        events_engine_default.on($itemContainer, eventName, itemSelector, this._itemContextMenuHandler.bind(this));
      },
      _shouldFireContextMenuEvent: function() {
        return this.hasActionSubscription("onItemContextMenu");
      },
      _itemContextMenuHandler: function(e) {
        if (this._shouldFireContextMenuEvent()) {
          this._itemDXEventHandler(e, "onItemContextMenu");
        } else {
          e.cancel = true;
        }
      },
      _renderContentImpl: function() {
        var items = this.option("items") || [];
        if (this._renderedItemsCount) {
          this._renderItems(items.slice(this._renderedItemsCount));
        } else {
          this._renderItems(items);
        }
      },
      _renderItems: function(items) {
        if (items.length) {
          each(items, (function(index2, itemData) {
            this._renderItem(this._renderedItemsCount + index2, itemData);
          }).bind(this));
        }
        this._renderEmptyMessage();
      },
      _renderItem: function(index2, itemData, $container, $itemToReplace) {
        var _index$item;
        var itemIndex = null !== (_index$item = null === index2 || void 0 === index2 ? void 0 : index2.item) && void 0 !== _index$item ? _index$item : index2;
        $container = $container || this._itemContainer();
        var $itemFrame = this._renderItemFrame(itemIndex, itemData, $container, $itemToReplace);
        this._setElementData($itemFrame, itemData, itemIndex);
        $itemFrame.attr(this.option("_itemAttributes"));
        this._attachItemClickEvent(itemData, $itemFrame);
        var $itemContent = this._getItemContent($itemFrame);
        var renderContentPromise = this._renderItemContent({
          index: itemIndex,
          itemData,
          container: getPublicElement($itemContent),
          contentClass: this._itemContentClass(),
          defaultTemplateName: this.option("itemTemplate")
        });
        var that = this;
        when(renderContentPromise).done(function($itemContent2) {
          that._postprocessRenderItem({
            itemElement: $itemFrame,
            itemContent: $itemContent2,
            itemData,
            itemIndex
          });
          that._executeItemRenderAction(index2, itemData, getPublicElement($itemFrame));
        });
        return $itemFrame;
      },
      _getItemContent: function($itemFrame) {
        var $itemContent = $itemFrame.find("." + ITEM_CONTENT_PLACEHOLDER_CLASS2);
        $itemContent.removeClass(ITEM_CONTENT_PLACEHOLDER_CLASS2);
        return $itemContent;
      },
      _attachItemClickEvent: function(itemData, $itemElement) {
        if (!itemData || !itemData.onClick) {
          return;
        }
        events_engine_default.on($itemElement, CLICK_EVENT_NAME, (function(e) {
          this._itemEventHandlerByHandler($itemElement, itemData.onClick, {
            event: e
          });
        }).bind(this));
      },
      _renderItemContent: function(args) {
        var itemTemplateName = this._getItemTemplateName(args);
        var itemTemplate = this._getTemplate(itemTemplateName);
        this._addItemContentClasses(args);
        var $templateResult = renderer_default(this._createItemByTemplate(itemTemplate, args));
        if (!$templateResult.hasClass(TEMPLATE_WRAPPER_CLASS2)) {
          return args.container;
        }
        return this._renderItemContentByNode(args, $templateResult);
      },
      _renderItemContentByNode: function(args, $node) {
        renderer_default(args.container).replaceWith($node);
        args.container = getPublicElement($node);
        this._addItemContentClasses(args);
        return $node;
      },
      _addItemContentClasses: function(args) {
        var classes = [ITEM_CLASS + CONTENT_CLASS_POSTFIX, args.contentClass];
        renderer_default(args.container).addClass(classes.join(" "));
      },
      _appendItemToContainer: function($container, $itemFrame, index2) {
        $itemFrame.appendTo($container);
      },
      _renderItemFrame: function(index2, itemData, $container, $itemToReplace) {
        var $itemFrame = renderer_default("<div>");
        new this.constructor.ItemClass($itemFrame, this._itemOptions(), itemData || {});
        if ($itemToReplace && $itemToReplace.length) {
          $itemToReplace.replaceWith($itemFrame);
        } else {
          this._appendItemToContainer.call(this, $container, $itemFrame, index2);
        }
        if (this.option("useItemTextAsTitle")) {
          var displayValue = this._displayGetter ? this._displayGetter(itemData) : itemData;
          $itemFrame.attr("title", displayValue);
        }
        return $itemFrame;
      },
      _itemOptions: function() {
        var that = this;
        return {
          watchMethod: function() {
            return that.option("integrationOptions.watchMethod");
          },
          owner: that,
          fieldGetter: function(field) {
            var expr = that.option(field + "Expr");
            var getter = compileGetter(expr);
            return getter;
          }
        };
      },
      _postprocessRenderItem: noop2,
      _executeItemRenderAction: function(index2, itemData, itemElement) {
        this._getItemRenderAction()({
          itemElement,
          itemIndex: index2,
          itemData
        });
      },
      _setElementData: function(element, data2, index2) {
        element.addClass([ITEM_CLASS, this._itemClass()].join(" ")).data(this._itemDataKey(), data2).data(this._itemIndexKey(), index2);
      },
      _createItemRenderAction: function() {
        return this._itemRenderAction = this._createActionByOption("onItemRendered", {
          element: this.element(),
          excludeValidators: ["disabled", "readOnly"],
          category: "rendering"
        });
      },
      _getItemRenderAction: function() {
        return this._itemRenderAction || this._createItemRenderAction();
      },
      _getItemTemplateName: function(args) {
        var data2 = args.itemData;
        var templateProperty = args.templateProperty || this.option("itemTemplateProperty");
        var template = data2 && data2[templateProperty];
        return template || args.defaultTemplateName;
      },
      _createItemByTemplate: function(itemTemplate, renderArgs) {
        return itemTemplate.render({
          model: renderArgs.itemData,
          container: renderArgs.container,
          index: renderArgs.index
        });
      },
      _emptyMessageContainer: function() {
        return this._itemContainer();
      },
      _renderEmptyMessage: function(items) {
        items = items || this.option("items");
        var noDataText = this.option("noDataText");
        var hideNoData = !noDataText || items && items.length || this._isDataSourceLoading();
        if (hideNoData && this._$noData) {
          this._$noData.remove();
          this._$noData = null;
          this.setAria("label", void 0);
        }
        if (!hideNoData) {
          this._$noData = this._$noData || renderer_default("<div>").addClass("dx-empty-message");
          this._$noData.appendTo(this._emptyMessageContainer()).html(noDataText);
          this.setAria("label", noDataText);
        }
        this.$element().toggleClass(EMPTY_COLLECTION, !hideNoData);
      },
      _itemDXEventHandler: function(dxEvent, handlerOptionName, actionArgs, actionConfig) {
        this._itemEventHandler(dxEvent.target, handlerOptionName, extend2(actionArgs, {
          event: dxEvent
        }), actionConfig);
      },
      _itemEventHandler: function(initiator, handlerOptionName, actionArgs, actionConfig) {
        var action = this._createActionByOption(handlerOptionName, extend2({
          validatingTargetName: "itemElement"
        }, actionConfig));
        return this._itemEventHandlerImpl(initiator, action, actionArgs);
      },
      _itemEventHandlerByHandler: function(initiator, handler, actionArgs, actionConfig) {
        var action = this._createAction(handler, extend2({
          validatingTargetName: "itemElement"
        }, actionConfig));
        return this._itemEventHandlerImpl(initiator, action, actionArgs);
      },
      _itemEventHandlerImpl: function(initiator, action, actionArgs) {
        var $itemElement = this._closestItemElement(renderer_default(initiator));
        var args = extend2({}, actionArgs);
        return action(extend2(actionArgs, this._extendActionArgs($itemElement), args));
      },
      _extendActionArgs: function($itemElement) {
        return {
          itemElement: getPublicElement($itemElement),
          itemIndex: this._itemElements().index($itemElement),
          itemData: this._getItemData($itemElement)
        };
      },
      _closestItemElement: function($element) {
        return renderer_default($element).closest(this._itemSelector());
      },
      _getItemData: function(itemElement) {
        return renderer_default(itemElement).data(this._itemDataKey());
      },
      _getSummaryItemsWidth: function(items, includeMargin) {
        var result2 = 0;
        if (items) {
          each(items, function(_2, item) {
            result2 += renderer_default(item).outerWidth(includeMargin || false);
          });
        }
        return result2;
      },
      getFocusedItemId: function() {
        if (!this._focusedItemId) {
          this._focusedItemId = "dx-" + new guid_default();
        }
        return this._focusedItemId;
      },
      itemElements: function() {
        return this._itemElements();
      },
      itemsContainer: function() {
        return this._itemContainer();
      }
    }).include(data_helper_default);
    CollectionWidget.ItemClass = item_default;
    ui_collection_widget_base_default = CollectionWidget;
  }
});

// node_modules/devextreme/esm/ui/collection/ui.collection_widget.edit.strategy.js
var abstract4, EditStrategy, ui_collection_widget_edit_strategy_default;
var init_ui_collection_widget_edit_strategy = __esm({
  "node_modules/devextreme/esm/ui/collection/ui.collection_widget.edit.strategy.js"() {
    init_renderer();
    init_class();
    init_common();
    init_dom_adapter();
    init_type();
    abstract4 = class_default.abstract;
    EditStrategy = class_default.inherit({
      ctor: function(collectionWidget) {
        this._collectionWidget = collectionWidget;
      },
      getIndexByItemData: abstract4,
      getItemDataByIndex: abstract4,
      getKeysByItems: abstract4,
      getItemsByKeys: abstract4,
      itemsGetter: abstract4,
      getKeyByIndex: function(index2) {
        var resultIndex = this._denormalizeItemIndex(index2);
        return this.getKeysByItems([this.getItemDataByIndex(resultIndex)])[0];
      },
      _equalKeys: function(key1, key2) {
        if (this._collectionWidget._isKeySpecified()) {
          return equalByValue(key1, key2);
        } else {
          return key1 === key2;
        }
      },
      beginCache: function() {
        this._cache = {};
      },
      endCache: function() {
        this._cache = null;
      },
      getIndexByKey: abstract4,
      getNormalizedIndex: function(value2) {
        if (this._isNormalizedItemIndex(value2)) {
          return value2;
        }
        if (this._isItemIndex(value2)) {
          return this._normalizeItemIndex(value2);
        }
        if (this._isNode(value2)) {
          return this._getNormalizedItemIndex(value2);
        }
        return this._normalizeItemIndex(this.getIndexByItemData(value2));
      },
      getIndex: function(value2) {
        if (this._isNormalizedItemIndex(value2)) {
          return this._denormalizeItemIndex(value2);
        }
        if (this._isItemIndex(value2)) {
          return value2;
        }
        if (this._isNode(value2)) {
          return this._denormalizeItemIndex(this._getNormalizedItemIndex(value2));
        }
        return this.getIndexByItemData(value2);
      },
      getItemElement: function(value2) {
        if (this._isNormalizedItemIndex(value2)) {
          return this._getItemByNormalizedIndex(value2);
        }
        if (this._isItemIndex(value2)) {
          return this._getItemByNormalizedIndex(this._normalizeItemIndex(value2));
        }
        if (this._isNode(value2)) {
          return renderer_default(value2);
        }
        var normalizedItemIndex = this._normalizeItemIndex(this.getIndexByItemData(value2));
        return this._getItemByNormalizedIndex(normalizedItemIndex);
      },
      _isNode: (el) => dom_adapter_default.isNode(el && isRenderer(el) ? el.get(0) : el),
      deleteItemAtIndex: abstract4,
      itemPlacementFunc: function(movingIndex, destinationIndex) {
        return this._itemsFromSameParent(movingIndex, destinationIndex) && movingIndex < destinationIndex ? "after" : "before";
      },
      moveItemAtIndexToIndex: abstract4,
      _isNormalizedItemIndex: function(index2) {
        return "number" === typeof index2 && Math.round(index2) === index2;
      },
      _isItemIndex: abstract4,
      _getNormalizedItemIndex: abstract4,
      _normalizeItemIndex: abstract4,
      _denormalizeItemIndex: abstract4,
      _getItemByNormalizedIndex: abstract4,
      _itemsFromSameParent: abstract4
    });
    ui_collection_widget_edit_strategy_default = EditStrategy;
  }
});

// node_modules/devextreme/esm/ui/collection/ui.collection_widget.edit.strategy.plain.js
var PlainEditStrategy, ui_collection_widget_edit_strategy_plain_default;
var init_ui_collection_widget_edit_strategy_plain = __esm({
  "node_modules/devextreme/esm/ui/collection/ui.collection_widget.edit.strategy.plain.js"() {
    init_array();
    init_ui_collection_widget_edit_strategy();
    PlainEditStrategy = ui_collection_widget_edit_strategy_default.inherit({
      _getPlainItems: function() {
        return this._collectionWidget.option("items") || [];
      },
      getIndexByItemData: function(itemData) {
        var keyOf = this._collectionWidget.keyOf.bind(this._collectionWidget);
        if (keyOf) {
          return this.getIndexByKey(keyOf(itemData));
        } else {
          return inArray(itemData, this._getPlainItems());
        }
      },
      getItemDataByIndex: function(index2) {
        return this._getPlainItems()[index2];
      },
      deleteItemAtIndex: function(index2) {
        this._getPlainItems().splice(index2, 1);
      },
      itemsGetter: function() {
        return this._getPlainItems();
      },
      getKeysByItems: function(items) {
        var keyOf = this._collectionWidget.keyOf.bind(this._collectionWidget);
        var result2 = items;
        if (keyOf) {
          result2 = [];
          for (var i = 0; i < items.length; i++) {
            result2.push(keyOf(items[i]));
          }
        }
        return result2;
      },
      getIndexByKey: function(key) {
        var cache = this._cache;
        var keys = cache && cache.keys || this.getKeysByItems(this._getPlainItems());
        if (cache && !cache.keys) {
          cache.keys = keys;
        }
        if ("object" === typeof key) {
          for (var i = 0, length = keys.length; i < length; i++) {
            if (this._equalKeys(key, keys[i])) {
              return i;
            }
          }
        } else {
          return keys.indexOf(key);
        }
        return -1;
      },
      getItemsByKeys: function(keys, items) {
        return (items || keys).slice();
      },
      moveItemAtIndexToIndex: function(movingIndex, destinationIndex) {
        var items = this._getPlainItems();
        var movedItemData = items[movingIndex];
        items.splice(movingIndex, 1);
        items.splice(destinationIndex, 0, movedItemData);
      },
      _isItemIndex: function(index2) {
        return "number" === typeof index2 && Math.round(index2) === index2;
      },
      _getNormalizedItemIndex: function(itemElement) {
        return this._collectionWidget._itemElements().index(itemElement);
      },
      _normalizeItemIndex: function(index2) {
        return index2;
      },
      _denormalizeItemIndex: function(index2) {
        return index2;
      },
      _getItemByNormalizedIndex: function(index2) {
        return index2 > -1 ? this._collectionWidget._itemElements().eq(index2) : null;
      },
      _itemsFromSameParent: function() {
        return true;
      }
    });
    ui_collection_widget_edit_strategy_plain_default = PlainEditStrategy;
  }
});

// node_modules/devextreme/esm/ui/selection/selection.strategy.js
var selection_strategy_default;
var init_selection_strategy = __esm({
  "node_modules/devextreme/esm/ui/selection/selection.strategy.js"() {
    init_query();
    init_common();
    init_type();
    init_class();
    init_deferred();
    selection_strategy_default = class_default.inherit({
      ctor: function(options2) {
        this.options = options2;
        this._setOption("disabledItemKeys", []);
        this._clearItemKeys();
      },
      _clearItemKeys: function() {
        this._setOption("addedItemKeys", []);
        this._setOption("removedItemKeys", []);
        this._setOption("removedItems", []);
        this._setOption("addedItems", []);
      },
      validate: noop2,
      _setOption: function(name2, value2) {
        this.options[name2] = value2;
      },
      onSelectionChanged: function() {
        var addedItemKeys = this.options.addedItemKeys;
        var removedItemKeys = this.options.removedItemKeys;
        var addedItems = this.options.addedItems;
        var removedItems = this.options.removedItems;
        var selectedItems = this.options.selectedItems;
        var selectedItemKeys = this.options.selectedItemKeys;
        var onSelectionChanged = this.options.onSelectionChanged || noop2;
        this._clearItemKeys();
        onSelectionChanged({
          selectedItems,
          selectedItemKeys,
          addedItemKeys,
          removedItemKeys,
          addedItems,
          removedItems
        });
      },
      equalKeys: function(key1, key2) {
        if (this.options.equalByReference) {
          if (isObject2(key1) && isObject2(key2)) {
            return key1 === key2;
          }
        }
        return equalByValue(key1, key2);
      },
      getSelectableItems: function(items) {
        return items.filter(function(item) {
          return !(null !== item && void 0 !== item && item.disabled);
        });
      },
      _clearSelection: function(keys, preserve, isDeselect, isSelectAll) {
        keys = keys || [];
        keys = Array.isArray(keys) ? keys : [keys];
        this.validate();
        return this.selectedItemKeys(keys, preserve, isDeselect, isSelectAll);
      },
      _removeTemplateProperty: function(remoteFilter) {
        if (Array.isArray(remoteFilter)) {
          return remoteFilter.map((f) => this._removeTemplateProperty(f));
        }
        if (isObject2(remoteFilter)) {
          delete remoteFilter.template;
        }
        return remoteFilter;
      },
      _loadFilteredData: function(remoteFilter, localFilter, select, isSelectAll) {
        var filterLength = encodeURI(JSON.stringify(this._removeTemplateProperty(remoteFilter))).length;
        var needLoadAllData = this.options.maxFilterLengthInRequest && filterLength > this.options.maxFilterLengthInRequest;
        var deferred = new Deferred();
        var loadOptions = {
          filter: needLoadAllData ? void 0 : remoteFilter,
          select: needLoadAllData ? this.options.dataFields() : select || this.options.dataFields()
        };
        if (remoteFilter && 0 === remoteFilter.length) {
          deferred.resolve([]);
        } else {
          this.options.load(loadOptions).done(function(items) {
            var filteredItems = isPlainObject(items) ? items.data : items;
            if (localFilter && !isSelectAll) {
              filteredItems = filteredItems.filter(localFilter);
            } else if (needLoadAllData) {
              filteredItems = query_default(filteredItems).filter(remoteFilter).toArray();
            }
            deferred.resolve(filteredItems);
          }).fail(deferred.reject.bind(deferred));
        }
        return deferred;
      },
      updateSelectedItemKeyHash: function(keys) {
        for (var i = 0; i < keys.length; i++) {
          var keyHash = getKeyHash(keys[i]);
          if (!isObject2(keyHash)) {
            this.options.keyHashIndices[keyHash] = this.options.keyHashIndices[keyHash] || [];
            var keyIndices = this.options.keyHashIndices[keyHash];
            keyIndices.push(i);
          }
        }
      },
      _isAnyItemSelected: function(items) {
        for (var i = 0; i < items.length; i++) {
          if (this.options.isItemSelected(items[i])) {
            return;
          }
        }
        return false;
      },
      _getFullSelectAllState: function() {
        var items = this.options.plainItems();
        var dataFilter = this.options.filter();
        var selectedItems = this.options.ignoreDisabledItems ? this.options.selectedItems : this.options.selectedItems.filter((item) => !(null !== item && void 0 !== item && item.disabled));
        if (dataFilter) {
          selectedItems = query_default(selectedItems).filter(dataFilter).toArray();
        }
        var selectedItemsLength = selectedItems.length;
        var disabledItemsLength = items.length - this.getSelectableItems(items).length;
        if (!selectedItemsLength) {
          return this._isAnyItemSelected(items);
        }
        if (selectedItemsLength >= this.options.totalCount() - disabledItemsLength) {
          return true;
        }
        return;
      },
      _getVisibleSelectAllState: function() {
        var items = this.getSelectableItems(this.options.plainItems());
        var hasSelectedItems = false;
        var hasUnselectedItems = false;
        for (var i = 0; i < items.length; i++) {
          var item = items[i];
          var itemData = this.options.getItemData(item);
          var key = this.options.keyOf(itemData);
          if (this.options.isSelectableItem(item)) {
            if (this.isItemKeySelected(key)) {
              hasSelectedItems = true;
            } else {
              hasUnselectedItems = true;
            }
          }
        }
        if (hasSelectedItems) {
          return !hasUnselectedItems ? true : void 0;
        } else {
          return false;
        }
      }
    });
  }
});

// node_modules/devextreme/esm/ui/selection/selection.strategy.deferred.js
var selection_strategy_deferred_default;
var init_selection_strategy_deferred = __esm({
  "node_modules/devextreme/esm/ui/selection/selection.strategy.deferred.js"() {
    init_type();
    init_selection_strategy();
    init_ui_errors();
    init_query();
    init_deferred();
    selection_strategy_deferred_default = selection_strategy_default.inherit({
      getSelectedItems: function() {
        return this._loadFilteredData(this.options.selectionFilter);
      },
      getSelectedItemKeys: function() {
        var d = new Deferred();
        var that = this;
        var key = this.options.key();
        var select = isString2(key) ? [key] : key;
        this._loadFilteredData(this.options.selectionFilter, null, select).done(function(items) {
          var keys = items.map(function(item) {
            return that.options.keyOf(item);
          });
          d.resolve(keys);
        }).fail(d.reject);
        return d.promise();
      },
      selectedItemKeys: function(keys, preserve, isDeselect, isSelectAll) {
        if (isSelectAll) {
          var filter = this.options.filter();
          var needResetSelectionFilter = !filter || JSON.stringify(filter) === JSON.stringify(this.options.selectionFilter) && isDeselect;
          if (needResetSelectionFilter) {
            this._setOption("selectionFilter", isDeselect ? [] : null);
          } else {
            this._addSelectionFilter(isDeselect, filter, isSelectAll);
          }
        } else {
          if (!preserve) {
            this._setOption("selectionFilter", []);
          }
          for (var i = 0; i < keys.length; i++) {
            if (isDeselect) {
              this.removeSelectedItem(keys[i]);
            } else {
              this.addSelectedItem(keys[i]);
            }
          }
        }
        this.onSelectionChanged();
        return new Deferred().resolve();
      },
      setSelectedItems: function(keys) {
        this._setOption("selectionFilter", null);
        for (var i = 0; i < keys.length; i++) {
          this.addSelectedItem(keys[i]);
        }
      },
      isItemDataSelected: function(itemData) {
        return this.isItemKeySelected(itemData);
      },
      isItemKeySelected: function(itemData) {
        var selectionFilter = this.options.selectionFilter;
        if (!selectionFilter) {
          return true;
        }
        return !!query_default([itemData]).filter(selectionFilter).toArray().length;
      },
      _getKeyExpr: function() {
        var keyField = this.options.key();
        if (Array.isArray(keyField) && 1 === keyField.length) {
          return keyField[0];
        }
        return keyField;
      },
      _normalizeKey: function(key) {
        var keyExpr = this.options.key();
        if (Array.isArray(keyExpr) && 1 === keyExpr.length) {
          return key[keyExpr[0]];
        }
        return key;
      },
      _getFilterByKey: function(key) {
        var keyField = this._getKeyExpr();
        var filter = [keyField, "=", this._normalizeKey(key)];
        if (Array.isArray(keyField)) {
          filter = [];
          for (var i = 0; i < keyField.length; i++) {
            filter.push([keyField[i], "=", key[keyField[i]]]);
            if (i !== keyField.length - 1) {
              filter.push("and");
            }
          }
        }
        return filter;
      },
      addSelectedItem: function(key) {
        var filter = this._getFilterByKey(key);
        this._addSelectionFilter(false, filter);
      },
      removeSelectedItem: function(key) {
        var filter = this._getFilterByKey(key);
        this._addSelectionFilter(true, filter);
      },
      validate: function() {
        var key = this.options.key;
        if (key && void 0 === key()) {
          throw ui_errors_default.Error("E1042", "Deferred selection");
        }
      },
      _findSubFilter: function(selectionFilter, filter) {
        if (!selectionFilter) {
          return -1;
        }
        var filterString = JSON.stringify(filter);
        for (var index2 = 0; index2 < selectionFilter.length; index2++) {
          var subFilter = selectionFilter[index2];
          if (subFilter && JSON.stringify(subFilter) === filterString) {
            return index2;
          }
        }
        return -1;
      },
      _isLastSubFilter: function(selectionFilter, filter) {
        if (selectionFilter && filter) {
          return this._findSubFilter(selectionFilter, filter) === selectionFilter.length - 1 || 0 === this._findSubFilter([selectionFilter], filter);
        }
        return false;
      },
      _addFilterOperator: function(selectionFilter, filterOperator) {
        if (selectionFilter.length > 1 && isString2(selectionFilter[1]) && selectionFilter[1] !== filterOperator) {
          selectionFilter = [selectionFilter];
        }
        if (selectionFilter.length) {
          selectionFilter.push(filterOperator);
        }
        return selectionFilter;
      },
      _denormalizeFilter: function(filter) {
        if (filter && isString2(filter[0])) {
          filter = [filter];
        }
        return filter;
      },
      _isOnlyNegativeFiltersLeft: function(filters) {
        return filters.every((filterItem, i) => {
          if (i % 2 === 0) {
            return Array.isArray(filterItem) && "!" === filterItem[0];
          } else {
            return "and" === filterItem;
          }
        });
      },
      _addSelectionFilter: function(isDeselect, filter, isSelectAll) {
        var currentFilter = isDeselect ? ["!", filter] : filter;
        var currentOperation = isDeselect ? "and" : "or";
        var needAddFilter = true;
        var selectionFilter = this.options.selectionFilter || [];
        selectionFilter = this._denormalizeFilter(selectionFilter);
        if (selectionFilter && selectionFilter.length) {
          var removedIndex = this._removeSameFilter(selectionFilter, filter, isDeselect, isSelectAll);
          var filterIndex = this._removeSameFilter(selectionFilter, filter, !isDeselect);
          var shouldCleanFilter = isDeselect && (-1 !== removedIndex || -1 !== filterIndex) && this._isOnlyNegativeFiltersLeft(selectionFilter);
          if (shouldCleanFilter) {
            selectionFilter = [];
          }
          var isKeyOperatorsAfterRemoved = this._isKeyFilter(filter) && this._hasKeyFiltersOnlyStartingFromIndex(selectionFilter, filterIndex);
          needAddFilter = filter.length && !isKeyOperatorsAfterRemoved;
          if (needAddFilter) {
            selectionFilter = this._addFilterOperator(selectionFilter, currentOperation);
          }
        }
        if (needAddFilter) {
          selectionFilter.push(currentFilter);
        }
        selectionFilter = this._normalizeFilter(selectionFilter);
        this._setOption("selectionFilter", !isDeselect && !selectionFilter.length ? null : selectionFilter);
      },
      _normalizeFilter: function(filter) {
        if (filter && 1 === filter.length) {
          filter = filter[0];
        }
        return filter;
      },
      _removeFilterByIndex: function(filter, filterIndex, isSelectAll) {
        var operation = filter[1];
        if (filterIndex > 0) {
          filter.splice(filterIndex - 1, 2);
        } else {
          filter.splice(filterIndex, 2);
        }
        if (isSelectAll && "and" === operation) {
          filter.splice(0, filter.length);
        }
      },
      _isSimpleKeyFilter: function(filter, key) {
        return 3 === filter.length && filter[0] === key && "=" === filter[1];
      },
      _isKeyFilter: function(filter) {
        if (2 === filter.length && "!" === filter[0]) {
          return this._isKeyFilter(filter[1]);
        }
        var keyField = this._getKeyExpr();
        if (Array.isArray(keyField)) {
          if (filter.length !== 2 * keyField.length - 1) {
            return false;
          }
          for (var i = 0; i < keyField.length; i++) {
            if (i > 0 && "and" !== filter[2 * i - 1]) {
              return false;
            }
            if (!this._isSimpleKeyFilter(filter[2 * i], keyField[i])) {
              return false;
            }
          }
          return true;
        }
        return this._isSimpleKeyFilter(filter, keyField);
      },
      _hasKeyFiltersOnlyStartingFromIndex: function(selectionFilter, filterIndex) {
        if (filterIndex >= 0) {
          for (var i = filterIndex; i < selectionFilter.length; i++) {
            if ("string" !== typeof selectionFilter[i] && !this._isKeyFilter(selectionFilter[i])) {
              return false;
            }
          }
          return true;
        }
        return false;
      },
      _removeSameFilter: function(selectionFilter, filter, inverted, isSelectAll) {
        filter = inverted ? ["!", filter] : filter;
        if (JSON.stringify(filter) === JSON.stringify(selectionFilter)) {
          selectionFilter.splice(0, selectionFilter.length);
          return 0;
        }
        var filterIndex = this._findSubFilter(selectionFilter, filter);
        if (filterIndex >= 0) {
          this._removeFilterByIndex(selectionFilter, filterIndex, isSelectAll);
          return filterIndex;
        } else {
          for (var i = 0; i < selectionFilter.length; i++) {
            if (Array.isArray(selectionFilter[i]) && selectionFilter[i].length > 2) {
              var _filterIndex = this._removeSameFilter(selectionFilter[i], filter, false, isSelectAll);
              if (_filterIndex >= 0) {
                if (!selectionFilter[i].length) {
                  this._removeFilterByIndex(selectionFilter, i, isSelectAll);
                } else if (1 === selectionFilter[i].length) {
                  selectionFilter[i] = selectionFilter[i][0];
                }
                return _filterIndex;
              }
            }
          }
          return -1;
        }
      },
      getSelectAllState: function() {
        var filter = this.options.filter();
        var selectionFilter = this.options.selectionFilter;
        if (!selectionFilter) {
          return true;
        }
        if (!selectionFilter.length) {
          return false;
        }
        if (!filter || !filter.length) {
          return;
        }
        selectionFilter = this._denormalizeFilter(selectionFilter);
        if (this._isLastSubFilter(selectionFilter, filter)) {
          return true;
        }
        if (this._isLastSubFilter(selectionFilter, ["!", filter])) {
          return false;
        }
        return;
      }
    });
  }
});

// node_modules/devextreme/esm/core/utils/array_compare.js
var getKeyWrapper, getSameNewByOld, isKeysEqual, findChanges;
var init_array_compare = __esm({
  "node_modules/devextreme/esm/core/utils/array_compare.js"() {
    init_type();
    getKeyWrapper = function(item, getKey) {
      var key = getKey(item);
      if (isObject2(key)) {
        try {
          return JSON.stringify(key);
        } catch (e) {
          return key;
        }
      }
      return key;
    };
    getSameNewByOld = function(oldItem, newItems, newIndexByKey, getKey) {
      var key = getKeyWrapper(oldItem, getKey);
      return newItems[newIndexByKey[key]];
    };
    isKeysEqual = function(oldKeys, newKeys) {
      if (oldKeys.length !== newKeys.length) {
        return false;
      }
      for (var i = 0; i < newKeys.length; i++) {
        if (oldKeys[i] !== newKeys[i]) {
          return false;
        }
      }
      return true;
    };
    findChanges = function(oldItems, newItems, getKey, isItemEquals) {
      var oldIndexByKey = {};
      var newIndexByKey = {};
      var addedCount = 0;
      var removeCount = 0;
      var result2 = [];
      oldItems.forEach(function(item, index3) {
        var key2 = getKeyWrapper(item, getKey);
        oldIndexByKey[key2] = index3;
      });
      newItems.forEach(function(item, index3) {
        var key2 = getKeyWrapper(item, getKey);
        newIndexByKey[key2] = index3;
      });
      var itemCount = Math.max(oldItems.length, newItems.length);
      for (var index2 = 0; index2 < itemCount + addedCount; index2++) {
        var newItem = newItems[index2];
        var oldNextIndex = index2 - addedCount + removeCount;
        var nextOldItem = oldItems[oldNextIndex];
        var isRemoved = !newItem || nextOldItem && !getSameNewByOld(nextOldItem, newItems, newIndexByKey, getKey);
        if (isRemoved) {
          if (nextOldItem) {
            result2.push({
              type: "remove",
              key: getKey(nextOldItem),
              index: index2,
              oldItem: nextOldItem
            });
            removeCount++;
            index2--;
          }
        } else {
          var key = getKeyWrapper(newItem, getKey);
          var oldIndex = oldIndexByKey[key];
          var oldItem = oldItems[oldIndex];
          if (!oldItem) {
            addedCount++;
            result2.push({
              type: "insert",
              data: newItem,
              index: index2
            });
          } else if (oldIndex === oldNextIndex) {
            if (!isItemEquals(oldItem, newItem)) {
              result2.push({
                type: "update",
                data: newItem,
                key: getKey(newItem),
                index: index2,
                oldItem
              });
            }
          } else {
            return;
          }
        }
      }
      return result2;
    };
  }
});

// node_modules/devextreme/esm/core/utils/selection_filter.js
var SelectionFilterCreator;
var init_selection_filter = __esm({
  "node_modules/devextreme/esm/core/utils/selection_filter.js"() {
    init_common();
    init_type();
    SelectionFilterCreator = function(selectedItemKeys, isSelectAll) {
      this.getLocalFilter = function(keyGetter, equalKeys, equalByReference, keyExpr) {
        equalKeys = void 0 === equalKeys ? equalByValue : equalKeys;
        return functionFilter.bind(this, equalKeys, keyGetter, equalByReference, keyExpr);
      };
      this.getExpr = function(keyExpr) {
        if (!keyExpr) {
          return;
        }
        var filterExpr;
        selectedItemKeys.forEach(function(key, index2) {
          filterExpr = filterExpr || [];
          var filterExprPart;
          if (index2 > 0) {
            filterExpr.push(isSelectAll ? "and" : "or");
          }
          if (isString2(keyExpr)) {
            filterExprPart = getFilterForPlainKey(keyExpr, key);
          } else {
            filterExprPart = function(keyExpr2, itemKeyValue) {
              var filterExpr2 = [];
              for (var i = 0, length = keyExpr2.length; i < length; i++) {
                var currentKeyExpr = keyExpr2[i];
                var currentKeyValue = itemKeyValue && itemKeyValue[currentKeyExpr];
                var filterExprPart2 = getFilterForPlainKey(currentKeyExpr, currentKeyValue);
                if (!filterExprPart2) {
                  break;
                }
                if (i > 0) {
                  filterExpr2.push(isSelectAll ? "or" : "and");
                }
                filterExpr2.push(filterExprPart2);
              }
              return filterExpr2;
            }(keyExpr, key);
          }
          filterExpr.push(filterExprPart);
        });
        if (filterExpr && 1 === filterExpr.length) {
          filterExpr = filterExpr[0];
        }
        return filterExpr;
      };
      this.getCombinedFilter = function(keyExpr, dataSourceFilter) {
        var filterExpr = this.getExpr(keyExpr);
        var combinedFilter = filterExpr;
        if (isSelectAll && dataSourceFilter) {
          if (filterExpr) {
            combinedFilter = [];
            combinedFilter.push(filterExpr);
            combinedFilter.push(dataSourceFilter);
          } else {
            combinedFilter = dataSourceFilter;
          }
        }
        return combinedFilter;
      };
      var selectedItemKeyHashesMap;
      var normalizeKeys = function(keys, keyOf, keyExpr) {
        return Array.isArray(keyExpr) ? keys.map((key) => keyOf(key)) : keys;
      };
      function functionFilter(equalKeys, keyOf, equalByReference, keyExpr, item) {
        var key = keyOf(item);
        var keyHash;
        var i;
        if (!equalByReference) {
          keyHash = getKeyHash(key);
          if (!isObject2(keyHash)) {
            var selectedKeyHashesMap = function(keyOf2, keyExpr2) {
              if (!selectedItemKeyHashesMap) {
                selectedItemKeyHashesMap = {};
                var normalizedKeys = normalizeKeys(selectedItemKeys, keyOf2, keyExpr2);
                for (var i2 = 0; i2 < normalizedKeys.length; i2++) {
                  selectedItemKeyHashesMap[getKeyHash(normalizedKeys[i2])] = true;
                }
              }
              return selectedItemKeyHashesMap;
            }(keyOf, keyExpr);
            if (selectedKeyHashesMap[keyHash]) {
              return !isSelectAll;
            }
            return !!isSelectAll;
          }
        }
        for (i = 0; i < selectedItemKeys.length; i++) {
          if (equalKeys(selectedItemKeys[i], key)) {
            return !isSelectAll;
          }
        }
        return !!isSelectAll;
      }
      function getFilterForPlainKey(keyExpr, keyValue) {
        if (void 0 === keyValue) {
          return;
        }
        return [keyExpr, isSelectAll ? "<>" : "=", keyValue];
      }
    };
  }
});

// node_modules/devextreme/esm/ui/selection/selection.strategy.standard.js
var selection_strategy_standard_default;
var init_selection_strategy_standard = __esm({
  "node_modules/devextreme/esm/ui/selection/selection.strategy.standard.js"() {
    init_common();
    init_type();
    init_array();
    init_array_compare();
    init_query();
    init_deferred();
    init_selection_filter();
    init_ui_errors();
    init_selection_strategy();
    selection_strategy_standard_default = selection_strategy_default.inherit({
      ctor: function(options2) {
        this.callBase(options2);
        this._initSelectedItemKeyHash();
      },
      _initSelectedItemKeyHash: function() {
        this._setOption("keyHashIndices", this.options.equalByReference ? null : {});
      },
      getSelectedItemKeys: function() {
        return this.options.selectedItemKeys.slice(0);
      },
      getSelectedItems: function() {
        return this.options.selectedItems.slice(0);
      },
      _preserveSelectionUpdate: function(items, isDeselect) {
        var keyOf = this.options.keyOf;
        var keyIndicesToRemoveMap;
        var keyIndex;
        var i;
        if (!keyOf) {
          return;
        }
        var isBatchDeselect = isDeselect && items.length > 1 && !this.options.equalByReference;
        if (isBatchDeselect) {
          keyIndicesToRemoveMap = {};
        }
        for (i = 0; i < items.length; i++) {
          var item = items[i];
          var key = keyOf(item);
          if (isDeselect) {
            keyIndex = this.removeSelectedItem(key, keyIndicesToRemoveMap, null === item || void 0 === item ? void 0 : item.disabled);
            if (keyIndicesToRemoveMap && keyIndex >= 0) {
              keyIndicesToRemoveMap[keyIndex] = true;
            }
          } else {
            this.addSelectedItem(key, item);
          }
        }
        if (isBatchDeselect) {
          this._batchRemoveSelectedItems(keyIndicesToRemoveMap);
        }
      },
      _batchRemoveSelectedItems: function(keyIndicesToRemoveMap) {
        var selectedItemKeys = this.options.selectedItemKeys.slice(0);
        var selectedItems = this.options.selectedItems.slice(0);
        this.options.selectedItemKeys.length = 0;
        this.options.selectedItems.length = 0;
        for (var i = 0; i < selectedItemKeys.length; i++) {
          if (!keyIndicesToRemoveMap[i]) {
            this.options.selectedItemKeys.push(selectedItemKeys[i]);
            this.options.selectedItems.push(selectedItems[i]);
          }
        }
        this._initSelectedItemKeyHash();
        this.updateSelectedItemKeyHash(this.options.selectedItemKeys);
      },
      _loadSelectedItemsCore: function(keys, isDeselect, isSelectAll, filter) {
        var deferred = new Deferred();
        var key = this.options.key();
        if (!keys.length && !isSelectAll) {
          deferred.resolve([]);
          return deferred;
        }
        if (isSelectAll && isDeselect && !filter) {
          deferred.resolve(this.getSelectedItems());
          return deferred;
        }
        var selectionFilterCreator = new SelectionFilterCreator(keys, isSelectAll);
        var combinedFilter = selectionFilterCreator.getCombinedFilter(key, filter);
        var deselectedItems = [];
        if (isDeselect) {
          var selectedItems = this.options.selectedItems;
          deselectedItems = combinedFilter && keys.length !== selectedItems.length ? query_default(selectedItems).filter(combinedFilter).toArray() : selectedItems.slice(0);
        }
        var filteredItems = deselectedItems.length ? deselectedItems : this.options.plainItems(true).filter(this.options.isSelectableItem).map(this.options.getItemData);
        var localFilter = selectionFilterCreator.getLocalFilter(this.options.keyOf, this.equalKeys.bind(this), this.options.equalByReference, key);
        filteredItems = filteredItems.filter(localFilter);
        if (deselectedItems.length || !isSelectAll && filteredItems.length === keys.length) {
          deferred.resolve(filteredItems);
        } else {
          deferred = this._loadFilteredData(combinedFilter, localFilter, null, isSelectAll);
        }
        return deferred;
      },
      _replaceSelectionUpdate: function(items) {
        var internalKeys = [];
        var keyOf = this.options.keyOf;
        if (!keyOf) {
          return;
        }
        for (var i = 0; i < items.length; i++) {
          var item = items[i];
          var key = keyOf(item);
          internalKeys.push(key);
        }
        this.setSelectedItems(internalKeys, items);
      },
      _warnOnIncorrectKeys: function(keys) {
        var allowNullValue = this.options.allowNullValue;
        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];
          if ((!allowNullValue || null !== key) && !this.isItemKeySelected(key)) {
            ui_errors_default.log("W1002", key);
          }
        }
      },
      _isMultiSelectEnabled: function() {
        var mode = this.options.mode;
        return "all" === mode || "multiple" === mode;
      },
      _requestInProgress: function() {
        var _this$_lastLoadDeferr;
        return "pending" === (null === (_this$_lastLoadDeferr = this._lastLoadDeferred) || void 0 === _this$_lastLoadDeferr ? void 0 : _this$_lastLoadDeferr.state());
      },
      _concatRequestsItems: function(keys, isDeselect, oldRequestItems, updatedKeys) {
        var selectedItems;
        var deselectedItems = isDeselect ? keys : [];
        if (updatedKeys) {
          selectedItems = updatedKeys;
        } else {
          selectedItems = removeDuplicates(keys, this.options.selectedItemKeys);
        }
        return {
          addedItems: oldRequestItems.added.concat(selectedItems),
          removedItems: oldRequestItems.removed.concat(deselectedItems),
          keys
        };
      },
      _collectLastRequestData: function(keys, isDeselect, isSelectAll, updatedKeys) {
        var isDeselectAll = isDeselect && isSelectAll;
        var oldRequestItems = {
          added: [],
          removed: []
        };
        var multiSelectEnabled = this._isMultiSelectEnabled();
        var lastRequestData = multiSelectEnabled ? this._lastRequestData : {};
        if (multiSelectEnabled) {
          if (this._shouldMergeWithLastRequest) {
            if (isDeselectAll) {
              this._lastLoadDeferred.reject();
              lastRequestData = {};
            } else if (!isKeysEqual(keys, this.options.selectedItemKeys)) {
              oldRequestItems.added = lastRequestData.addedItems;
              oldRequestItems.removed = lastRequestData.removedItems;
              if (!isDeselect) {
                this._lastLoadDeferred.reject();
              }
            }
          }
          lastRequestData = this._concatRequestsItems(keys, isDeselect, oldRequestItems, this._shouldMergeWithLastRequest ? void 0 : updatedKeys);
        }
        return lastRequestData;
      },
      _updateKeysByLastRequestData: function(keys, isDeselect, isSelectAll) {
        var currentKeys = keys;
        if (this._isMultiSelectEnabled() && this._shouldMergeWithLastRequest && !isDeselect && !isSelectAll) {
          var _this$_lastRequestDat, _this$_lastRequestDat2;
          currentKeys = removeDuplicates(keys.concat(null === (_this$_lastRequestDat = this._lastRequestData) || void 0 === _this$_lastRequestDat ? void 0 : _this$_lastRequestDat.addedItems), null === (_this$_lastRequestDat2 = this._lastRequestData) || void 0 === _this$_lastRequestDat2 ? void 0 : _this$_lastRequestDat2.removedItems);
          currentKeys = uniqueValues(currentKeys);
        }
        return currentKeys;
      },
      _loadSelectedItems: function(keys, isDeselect, isSelectAll, updatedKeys) {
        var that = this;
        var deferred = new Deferred();
        var filter = that.options.filter();
        this._shouldMergeWithLastRequest = this._requestInProgress();
        this._lastRequestData = this._collectLastRequestData(keys, isDeselect, isSelectAll, updatedKeys);
        when(that._lastLoadDeferred).always(function() {
          var currentKeys = that._updateKeysByLastRequestData(keys, isDeselect, isSelectAll);
          that._shouldMergeWithLastRequest = false;
          that._loadSelectedItemsCore(currentKeys, isDeselect, isSelectAll, filter).done(deferred.resolve).fail(deferred.reject);
        });
        that._lastLoadDeferred = deferred;
        return deferred;
      },
      selectedItemKeys: function(keys, preserve, isDeselect, isSelectAll, updatedKeys) {
        var that = this;
        var deferred = that._loadSelectedItems(keys, isDeselect, isSelectAll, updatedKeys);
        deferred.done(function(items) {
          if (preserve) {
            that._preserveSelectionUpdate(items, isDeselect);
          } else {
            that._replaceSelectionUpdate(items);
          }
          that.onSelectionChanged();
        });
        return deferred;
      },
      addSelectedItem: function(key, itemData) {
        if (isDefined(itemData) && !this.options.ignoreDisabledItems && itemData.disabled) {
          if (-1 === this.options.disabledItemKeys.indexOf(key)) {
            this.options.disabledItemKeys.push(key);
          }
          return;
        }
        var keyHash = this._getKeyHash(key);
        if (-1 === this._indexOfSelectedItemKey(keyHash)) {
          if (!isObject2(keyHash) && this.options.keyHashIndices) {
            this.options.keyHashIndices[keyHash] = [this.options.selectedItemKeys.length];
          }
          this.options.selectedItemKeys.push(key);
          this.options.addedItemKeys.push(key);
          this.options.addedItems.push(itemData);
          this.options.selectedItems.push(itemData);
        }
      },
      _getSelectedIndexByKey: function(key, ignoreIndicesMap) {
        var selectedItemKeys = this.options.selectedItemKeys;
        for (var index2 = 0; index2 < selectedItemKeys.length; index2++) {
          if ((!ignoreIndicesMap || !ignoreIndicesMap[index2]) && this.equalKeys(selectedItemKeys[index2], key)) {
            return index2;
          }
        }
        return -1;
      },
      _getSelectedIndexByHash: function(key, ignoreIndicesMap) {
        var indices = this.options.keyHashIndices[key];
        if (indices && indices.length > 1 && ignoreIndicesMap) {
          indices = indices.filter(function(index2) {
            return !ignoreIndicesMap[index2];
          });
        }
        return indices && indices[0] >= 0 ? indices[0] : -1;
      },
      _indexOfSelectedItemKey: function(key, ignoreIndicesMap) {
        var selectedIndex;
        if (this.options.equalByReference) {
          selectedIndex = this.options.selectedItemKeys.indexOf(key);
        } else if (isObject2(key)) {
          selectedIndex = this._getSelectedIndexByKey(key, ignoreIndicesMap);
        } else {
          selectedIndex = this._getSelectedIndexByHash(key, ignoreIndicesMap);
        }
        return selectedIndex;
      },
      _shiftSelectedKeyIndices: function(keyIndex) {
        for (var currentKeyIndex = keyIndex; currentKeyIndex < this.options.selectedItemKeys.length; currentKeyIndex++) {
          var currentKey = this.options.selectedItemKeys[currentKeyIndex];
          var currentKeyHash = getKeyHash(currentKey);
          var currentKeyIndices = this.options.keyHashIndices[currentKeyHash];
          if (!currentKeyIndices) {
            continue;
          }
          for (var i = 0; i < currentKeyIndices.length; i++) {
            if (currentKeyIndices[i] > keyIndex) {
              currentKeyIndices[i]--;
            }
          }
        }
      },
      removeSelectedItem: function(key, keyIndicesToRemoveMap, isDisabled) {
        if (!this.options.ignoreDisabledItems && isDisabled) {
          return;
        }
        var keyHash = this._getKeyHash(key);
        var isBatchDeselect = !!keyIndicesToRemoveMap;
        var keyIndex = this._indexOfSelectedItemKey(keyHash, keyIndicesToRemoveMap);
        if (keyIndex < 0) {
          return keyIndex;
        }
        this.options.removedItemKeys.push(key);
        this.options.removedItems.push(this.options.selectedItems[keyIndex]);
        if (isBatchDeselect) {
          return keyIndex;
        }
        this.options.selectedItemKeys.splice(keyIndex, 1);
        this.options.selectedItems.splice(keyIndex, 1);
        if (isObject2(keyHash) || !this.options.keyHashIndices) {
          return keyIndex;
        }
        var keyIndices = this.options.keyHashIndices[keyHash];
        if (!keyIndices) {
          return keyIndex;
        }
        keyIndices.shift();
        if (!keyIndices.length) {
          delete this.options.keyHashIndices[keyHash];
        }
        this._shiftSelectedKeyIndices(keyIndex);
        return keyIndex;
      },
      _updateAddedItemKeys: function(keys, items) {
        for (var i = 0; i < keys.length; i++) {
          if (!this.isItemKeySelected(keys[i])) {
            this.options.addedItemKeys.push(keys[i]);
            this.options.addedItems.push(items[i]);
          }
        }
      },
      _updateRemovedItemKeys: function(keys, oldSelectedKeys, oldSelectedItems) {
        for (var i = 0; i < oldSelectedKeys.length; i++) {
          if (!this.isItemKeySelected(oldSelectedKeys[i])) {
            this.options.removedItemKeys.push(oldSelectedKeys[i]);
            this.options.removedItems.push(oldSelectedItems[i]);
          }
        }
      },
      _isItemSelectionInProgress: function(key, checkPending) {
        var shouldCheckPending = checkPending && this._lastRequestData && this._requestInProgress();
        if (shouldCheckPending) {
          var _this$_lastRequestDat3;
          var addedItems = null !== (_this$_lastRequestDat3 = this._lastRequestData.addedItems) && void 0 !== _this$_lastRequestDat3 ? _this$_lastRequestDat3 : [];
          return addedItems.indexOf(key) > -1;
        } else {
          return false;
        }
      },
      _getKeyHash: function(key) {
        return this.options.equalByReference ? key : getKeyHash(key);
      },
      setSelectedItems: function(keys, items) {
        this._updateAddedItemKeys(keys, items);
        var oldSelectedKeys = this.options.selectedItemKeys;
        var oldSelectedItems = this.options.selectedItems;
        if (!this.options.equalByReference) {
          this._initSelectedItemKeyHash();
          this.updateSelectedItemKeyHash(keys);
        }
        this._setOption("selectedItemKeys", keys);
        this._setOption("selectedItems", items);
        this._updateRemovedItemKeys(keys, oldSelectedKeys, oldSelectedItems);
      },
      isItemDataSelected: function(itemData) {
        var options2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        var key = this.options.keyOf(itemData);
        return this.isItemKeySelected(key, options2);
      },
      isItemKeySelected: function(key) {
        var options2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        var result2 = this._isItemSelectionInProgress(key, options2.checkPending);
        if (!result2) {
          var keyHash = this._getKeyHash(key);
          var index2 = this._indexOfSelectedItemKey(keyHash);
          result2 = -1 !== index2;
        }
        return result2;
      },
      getSelectAllState: function(visibleOnly) {
        if (visibleOnly) {
          return this._getVisibleSelectAllState();
        } else {
          return this._getFullSelectAllState();
        }
      }
    });
  }
});

// node_modules/devextreme/esm/ui/selection/selection.js
var selection_default;
var init_selection = __esm({
  "node_modules/devextreme/esm/ui/selection/selection.js"() {
    init_class();
    init_selection_strategy_deferred();
    init_selection_strategy_standard();
    init_extend();
    init_common();
    init_type();
    init_deferred();
    selection_default = class_default.inherit({
      ctor: function(options2) {
        this.options = extend2(this._getDefaultOptions(), options2, {
          selectedItemKeys: options2.selectedKeys || []
        });
        this._selectionStrategy = this.options.deferred ? new selection_strategy_deferred_default(this.options) : new selection_strategy_standard_default(this.options);
        this._focusedItemIndex = -1;
        if (!this.options.equalByReference) {
          this._selectionStrategy.updateSelectedItemKeyHash(this.options.selectedItemKeys);
        }
      },
      _getDefaultOptions: function() {
        return {
          allowNullValue: false,
          deferred: false,
          equalByReference: false,
          mode: "multiple",
          selectedItems: [],
          selectionFilter: [],
          maxFilterLengthInRequest: 0,
          onSelectionChanged: noop2,
          key: noop2,
          keyOf: function(item) {
            return item;
          },
          load: function() {
            return new Deferred().resolve([]);
          },
          totalCount: function() {
            return -1;
          },
          isSelectableItem: function() {
            return true;
          },
          isItemSelected: function() {
            return false;
          },
          getItemData: function(item) {
            return item;
          },
          dataFields: noop2,
          filter: noop2
        };
      },
      validate: function() {
        this._selectionStrategy.validate();
      },
      getSelectedItemKeys: function() {
        return this._selectionStrategy.getSelectedItemKeys();
      },
      getSelectedItems: function() {
        return this._selectionStrategy.getSelectedItems();
      },
      selectionFilter: function(value2) {
        if (void 0 === value2) {
          return this.options.selectionFilter;
        }
        var filterIsChanged = this.options.selectionFilter !== value2 && JSON.stringify(this.options.selectionFilter) !== JSON.stringify(value2);
        this.options.selectionFilter = value2;
        filterIsChanged && this.onSelectionChanged();
      },
      setSelection: function(keys, updatedKeys) {
        return this.selectedItemKeys(keys, false, false, false, updatedKeys);
      },
      select: function(keys) {
        return this.selectedItemKeys(keys, true);
      },
      deselect: function(keys) {
        return this.selectedItemKeys(keys, true, true);
      },
      selectedItemKeys: function(keys, preserve, isDeselect, isSelectAll, updatedKeys) {
        var _keys;
        keys = null !== (_keys = keys) && void 0 !== _keys ? _keys : [];
        keys = Array.isArray(keys) ? keys : [keys];
        this.validate();
        return this._selectionStrategy.selectedItemKeys(keys, preserve, isDeselect, isSelectAll, updatedKeys);
      },
      clearSelection: function() {
        return this.selectedItemKeys([]);
      },
      _addSelectedItem: function(itemData, key) {
        this._selectionStrategy.addSelectedItem(key, itemData);
      },
      _removeSelectedItem: function(key) {
        this._selectionStrategy.removeSelectedItem(key);
      },
      _setSelectedItems: function(keys, items) {
        this._selectionStrategy.setSelectedItems(keys, items);
      },
      onSelectionChanged: function() {
        this._selectionStrategy.onSelectionChanged();
      },
      changeItemSelection: function(itemIndex, keys, setFocusOnly) {
        var isSelectedItemsChanged;
        var items = this.options.plainItems();
        var item = items[itemIndex];
        if (!this.isSelectable() || !this.isDataItem(item)) {
          return false;
        }
        var itemData = this.options.getItemData(item);
        var itemKey = this.options.keyOf(itemData);
        keys = keys || {};
        if (keys.shift && "multiple" === this.options.mode && this._focusedItemIndex >= 0) {
          isSelectedItemsChanged = this.changeItemSelectionWhenShiftKeyPressed(itemIndex, items);
        } else if (keys.control) {
          this._resetItemSelectionWhenShiftKeyPressed();
          if (!setFocusOnly) {
            var isSelected = this._selectionStrategy.isItemDataSelected(itemData);
            if ("single" === this.options.mode) {
              this.clearSelectedItems();
            }
            if (isSelected) {
              this._removeSelectedItem(itemKey);
            } else {
              this._addSelectedItem(itemData, itemKey);
            }
          }
          isSelectedItemsChanged = true;
        } else {
          this._resetItemSelectionWhenShiftKeyPressed();
          var isKeysEqual2 = this._selectionStrategy.equalKeys(this.options.selectedItemKeys[0], itemKey);
          if (1 !== this.options.selectedItemKeys.length || !isKeysEqual2) {
            this._setSelectedItems([itemKey], [itemData]);
            isSelectedItemsChanged = true;
          }
        }
        if (isSelectedItemsChanged) {
          this._focusedItemIndex = itemIndex;
          !setFocusOnly && this.onSelectionChanged();
          return true;
        }
      },
      isDataItem: function(item) {
        return this.options.isSelectableItem(item);
      },
      isSelectable: function() {
        return "single" === this.options.mode || "multiple" === this.options.mode;
      },
      isItemDataSelected: function(data2) {
        return this._selectionStrategy.isItemDataSelected(data2, {
          checkPending: true
        });
      },
      isItemSelected: function(arg, options2) {
        return this._selectionStrategy.isItemKeySelected(arg, options2);
      },
      _resetItemSelectionWhenShiftKeyPressed: function() {
        delete this._shiftFocusedItemIndex;
      },
      _resetFocusedItemIndex: function() {
        this._focusedItemIndex = -1;
      },
      changeItemSelectionWhenShiftKeyPressed: function(itemIndex, items) {
        var isSelectedItemsChanged = false;
        var itemIndexStep;
        var index2;
        var keyOf = this.options.keyOf;
        var focusedItem = items[this._focusedItemIndex];
        var focusedData = this.options.getItemData(focusedItem);
        var focusedKey = keyOf(focusedData);
        var isFocusedItemSelected = focusedItem && this.isItemDataSelected(focusedData);
        if (!isDefined(this._shiftFocusedItemIndex)) {
          this._shiftFocusedItemIndex = this._focusedItemIndex;
        }
        var data2;
        var itemKey;
        if (this._shiftFocusedItemIndex !== this._focusedItemIndex) {
          itemIndexStep = this._focusedItemIndex < this._shiftFocusedItemIndex ? 1 : -1;
          for (index2 = this._focusedItemIndex; index2 !== this._shiftFocusedItemIndex; index2 += itemIndexStep) {
            if (this.isDataItem(items[index2])) {
              itemKey = keyOf(this.options.getItemData(items[index2]));
              this._removeSelectedItem(itemKey);
              isSelectedItemsChanged = true;
            }
          }
        }
        if (itemIndex !== this._shiftFocusedItemIndex) {
          itemIndexStep = itemIndex < this._shiftFocusedItemIndex ? 1 : -1;
          for (index2 = itemIndex; index2 !== this._shiftFocusedItemIndex; index2 += itemIndexStep) {
            if (this.isDataItem(items[index2])) {
              data2 = this.options.getItemData(items[index2]);
              itemKey = keyOf(data2);
              this._addSelectedItem(data2, itemKey);
              isSelectedItemsChanged = true;
            }
          }
        }
        if (this.isDataItem(focusedItem) && !isFocusedItemSelected) {
          this._addSelectedItem(focusedData, focusedKey);
          isSelectedItemsChanged = true;
        }
        return isSelectedItemsChanged;
      },
      clearSelectedItems: function() {
        this._setSelectedItems([], []);
      },
      selectAll: function(isOnePage) {
        this._resetFocusedItemIndex();
        if (isOnePage) {
          return this._onePageSelectAll(false);
        } else {
          return this.selectedItemKeys([], true, false, true);
        }
      },
      deselectAll: function(isOnePage) {
        this._resetFocusedItemIndex();
        if (isOnePage) {
          return this._onePageSelectAll(true);
        } else {
          return this.selectedItemKeys([], true, true, true);
        }
      },
      _onePageSelectAll: function(isDeselect) {
        var items = this._selectionStrategy.getSelectableItems(this.options.plainItems());
        for (var i = 0; i < items.length; i++) {
          var item = items[i];
          if (this.isDataItem(item)) {
            var itemData = this.options.getItemData(item);
            var itemKey = this.options.keyOf(itemData);
            var isSelected = this.isItemSelected(itemKey);
            if (!isSelected && !isDeselect) {
              this._addSelectedItem(itemData, itemKey);
            }
            if (isSelected && isDeselect) {
              this._removeSelectedItem(itemKey);
            }
          }
        }
        this.onSelectionChanged();
        return new Deferred().resolve();
      },
      getSelectAllState: function(visibleOnly) {
        return this._selectionStrategy.getSelectAllState(visibleOnly);
      }
    });
  }
});

// node_modules/devextreme/esm/ui/collection/ui.collection_widget.edit.js
var ITEM_DELETING_DATA_KEY, NOT_EXISTING_INDEX, indexExists, CollectionWidget2, ui_collection_widget_edit_default;
var init_ui_collection_widget_edit = __esm({
  "node_modules/devextreme/esm/ui/collection/ui.collection_widget.edit.js"() {
    init_renderer();
    init_events_engine();
    init_ui_collection_widget_base();
    init_ui_errors();
    init_extend();
    init_iterator();
    init_common();
    init_type();
    init_ui_collection_widget_edit_strategy_plain();
    init_data();
    init_data_source();
    init_utils5();
    init_selection();
    init_deferred();
    ITEM_DELETING_DATA_KEY = "dxItemDeleting";
    NOT_EXISTING_INDEX = -1;
    indexExists = function(index2) {
      return index2 !== NOT_EXISTING_INDEX;
    };
    CollectionWidget2 = ui_collection_widget_base_default.inherit({
      _setOptionsByReference: function() {
        this.callBase();
        extend2(this._optionsByReference, {
          selectedItem: true
        });
      },
      _getDefaultOptions: function() {
        return extend2(this.callBase(), {
          selectionMode: "none",
          selectionRequired: false,
          selectionByClick: true,
          selectedItems: [],
          selectedItemKeys: [],
          maxFilterLengthInRequest: 1500,
          keyExpr: null,
          selectedIndex: NOT_EXISTING_INDEX,
          selectedItem: null,
          onSelectionChanged: null,
          onItemReordered: null,
          onItemDeleting: null,
          onItemDeleted: null
        });
      },
      ctor: function(element, options2) {
        this._userOptions = options2 || {};
        this.callBase(element, options2);
      },
      _init: function() {
        this._initEditStrategy();
        this.callBase();
        this._initKeyGetter();
        this._initSelectionModule();
      },
      _initKeyGetter: function() {
        this._keyGetter = compileGetter(this.option("keyExpr"));
      },
      _getKeysByItems: function(selectedItems) {
        return this._editStrategy.getKeysByItems(selectedItems);
      },
      _getItemsByKeys: function(selectedItemKeys, selectedItems) {
        return this._editStrategy.getItemsByKeys(selectedItemKeys, selectedItems);
      },
      _getKeyByIndex: function(index2) {
        return this._editStrategy.getKeyByIndex(index2);
      },
      _getIndexByKey: function(key) {
        return this._editStrategy.getIndexByKey(key);
      },
      _getIndexByItemData: function(itemData) {
        return this._editStrategy.getIndexByItemData(itemData);
      },
      _isKeySpecified: function() {
        return !!(this._dataSource && this._dataSource.key());
      },
      _getCombinedFilter: function() {
        return this._dataSource && this._dataSource.filter();
      },
      key: function() {
        if (this.option("keyExpr")) {
          return this.option("keyExpr");
        }
        return this._dataSource && this._dataSource.key();
      },
      keyOf: function(item) {
        var key = item;
        var store = this._dataSource && this._dataSource.store();
        if (this.option("keyExpr")) {
          key = this._keyGetter(item);
        } else if (store) {
          key = store.keyOf(item);
        }
        return key;
      },
      _nullValueSelectionSupported: function() {
        return false;
      },
      _initSelectionModule: function() {
        var that = this;
        var itemsGetter = that._editStrategy.itemsGetter;
        this._selection = new selection_default({
          allowNullValue: this._nullValueSelectionSupported(),
          mode: this.option("selectionMode"),
          maxFilterLengthInRequest: this.option("maxFilterLengthInRequest"),
          equalByReference: !this._isKeySpecified(),
          onSelectionChanged: function(args) {
            if (args.addedItemKeys.length || args.removedItemKeys.length) {
              that.option("selectedItems", that._getItemsByKeys(args.selectedItemKeys, args.selectedItems));
              that._updateSelectedItems(args);
            }
          },
          filter: that._getCombinedFilter.bind(that),
          totalCount: function() {
            var items = that.option("items");
            var dataSource = that._dataSource;
            return dataSource && dataSource.totalCount() >= 0 ? dataSource.totalCount() : that._getItemsCount(items);
          },
          key: that.key.bind(that),
          keyOf: that.keyOf.bind(that),
          load: function(options2) {
            if (that._dataSource) {
              var loadOptions = that._dataSource.loadOptions();
              options2.customQueryParams = loadOptions.customQueryParams;
              options2.userData = that._dataSource._userData;
            }
            var store = that._dataSource && that._dataSource.store();
            if (store) {
              return store.load(options2).done(function(loadResult) {
                if (that._disposed) {
                  return;
                }
                var items = normalizeLoadResult(loadResult).data;
                that._dataSource._applyMapFunction(items);
              });
            } else {
              return new Deferred().resolve(this.plainItems());
            }
          },
          dataFields: function() {
            return that._dataSource && that._dataSource.select();
          },
          plainItems: itemsGetter.bind(that._editStrategy)
        });
      },
      _getItemsCount: function(items) {
        return items.reduce((itemsCount, item) => itemsCount + (item.items ? this._getItemsCount(item.items) : 1), 0);
      },
      _initEditStrategy: function() {
        var Strategy = ui_collection_widget_edit_strategy_plain_default;
        this._editStrategy = new Strategy(this);
      },
      _getSelectedItemIndices: function(keys) {
        var that = this;
        var indices = [];
        keys = keys || this._selection.getSelectedItemKeys();
        that._editStrategy.beginCache();
        each(keys, function(_2, key) {
          var selectedIndex = that._getIndexByKey(key);
          if (indexExists(selectedIndex)) {
            indices.push(selectedIndex);
          }
        });
        that._editStrategy.endCache();
        return indices;
      },
      _initMarkup: function() {
        this._rendering = true;
        if (!this._dataSource || !this._dataSource.isLoading()) {
          this._syncSelectionOptions().done(() => this._normalizeSelectedItems());
        }
        this.callBase();
      },
      _render: function() {
        this.callBase();
        this._rendering = false;
      },
      _fireContentReadyAction: function() {
        this._rendering = false;
        this._rendered = true;
        this.callBase.apply(this, arguments);
      },
      _syncSelectionOptions: function(byOption) {
        byOption = byOption || this._chooseSelectOption();
        var selectedItem;
        var selectedIndex;
        var selectedItemKeys;
        var selectedItems;
        switch (byOption) {
          case "selectedIndex":
            selectedItem = this._editStrategy.getItemDataByIndex(this.option("selectedIndex"));
            if (isDefined(selectedItem)) {
              this._setOptionWithoutOptionChange("selectedItems", [selectedItem]);
              this._setOptionWithoutOptionChange("selectedItem", selectedItem);
              this._setOptionWithoutOptionChange("selectedItemKeys", this._editStrategy.getKeysByItems([selectedItem]));
            } else {
              this._setOptionWithoutOptionChange("selectedItems", []);
              this._setOptionWithoutOptionChange("selectedItemKeys", []);
              this._setOptionWithoutOptionChange("selectedItem", null);
            }
            break;
          case "selectedItems":
            selectedItems = this.option("selectedItems") || [];
            selectedIndex = selectedItems.length ? this._editStrategy.getIndexByItemData(selectedItems[0]) : NOT_EXISTING_INDEX;
            if (this.option("selectionRequired") && !indexExists(selectedIndex)) {
              return this._syncSelectionOptions("selectedIndex");
            }
            this._setOptionWithoutOptionChange("selectedItem", selectedItems[0]);
            this._setOptionWithoutOptionChange("selectedIndex", selectedIndex);
            this._setOptionWithoutOptionChange("selectedItemKeys", this._editStrategy.getKeysByItems(selectedItems));
            break;
          case "selectedItem":
            selectedItem = this.option("selectedItem");
            selectedIndex = this._editStrategy.getIndexByItemData(selectedItem);
            if (this.option("selectionRequired") && !indexExists(selectedIndex)) {
              return this._syncSelectionOptions("selectedIndex");
            }
            if (isDefined(selectedItem)) {
              this._setOptionWithoutOptionChange("selectedItems", [selectedItem]);
              this._setOptionWithoutOptionChange("selectedIndex", selectedIndex);
              this._setOptionWithoutOptionChange("selectedItemKeys", this._editStrategy.getKeysByItems([selectedItem]));
            } else {
              this._setOptionWithoutOptionChange("selectedItems", []);
              this._setOptionWithoutOptionChange("selectedItemKeys", []);
              this._setOptionWithoutOptionChange("selectedIndex", NOT_EXISTING_INDEX);
            }
            break;
          case "selectedItemKeys":
            selectedItemKeys = this.option("selectedItemKeys");
            if (this.option("selectionRequired")) {
              var selectedItemIndex = this._getIndexByKey(selectedItemKeys[0]);
              if (!indexExists(selectedItemIndex)) {
                return this._syncSelectionOptions("selectedIndex");
              }
            }
            return this._selection.setSelection(selectedItemKeys);
        }
        return new Deferred().resolve().promise();
      },
      _chooseSelectOption: function() {
        var optionName = "selectedIndex";
        var isOptionDefined = (function(optionName2) {
          var optionValue = this.option(optionName2);
          var length = isDefined(optionValue) && optionValue.length;
          return length || optionName2 in this._userOptions;
        }).bind(this);
        if (isOptionDefined("selectedItems")) {
          optionName = "selectedItems";
        } else if (isOptionDefined("selectedItem")) {
          optionName = "selectedItem";
        } else if (isOptionDefined("selectedItemKeys")) {
          optionName = "selectedItemKeys";
        }
        return optionName;
      },
      _compareKeys: function(oldKeys, newKeys) {
        if (oldKeys.length !== newKeys.length) {
          return false;
        }
        for (var i = 0; i < newKeys.length; i++) {
          if (oldKeys[i] !== newKeys[i]) {
            return false;
          }
        }
        return true;
      },
      _normalizeSelectedItems: function() {
        if ("none" === this.option("selectionMode")) {
          this._setOptionWithoutOptionChange("selectedItems", []);
          this._syncSelectionOptions("selectedItems");
        } else if ("single" === this.option("selectionMode")) {
          var newSelection = this.option("selectedItems");
          if (newSelection.length > 1 || !newSelection.length && this.option("selectionRequired") && this.option("items") && this.option("items").length) {
            var currentSelection = this._selection.getSelectedItems();
            var normalizedSelection = void 0 === newSelection[0] ? currentSelection[0] : newSelection[0];
            if (void 0 === normalizedSelection) {
              normalizedSelection = this._editStrategy.itemsGetter()[0];
            }
            if (this.option("grouped") && normalizedSelection && normalizedSelection.items) {
              normalizedSelection.items = [normalizedSelection.items[0]];
            }
            this._selection.setSelection(this._getKeysByItems([normalizedSelection]));
            this._setOptionWithoutOptionChange("selectedItems", [normalizedSelection]);
            return this._syncSelectionOptions("selectedItems");
          } else {
            this._selection.setSelection(this._getKeysByItems(newSelection));
          }
        } else {
          var newKeys = this._getKeysByItems(this.option("selectedItems"));
          var oldKeys = this._selection.getSelectedItemKeys();
          if (!this._compareKeys(oldKeys, newKeys)) {
            this._selection.setSelection(newKeys);
          }
        }
        return new Deferred().resolve().promise();
      },
      _itemClickHandler: function(e) {
        var itemSelectPromise = new Deferred().resolve();
        var callBase = this.callBase;
        this._createAction((function(e2) {
          var _this$_itemSelectHand;
          itemSelectPromise = null !== (_this$_itemSelectHand = this._itemSelectHandler(e2.event)) && void 0 !== _this$_itemSelectHand ? _this$_itemSelectHand : itemSelectPromise;
        }).bind(this), {
          validatingTargetName: "itemElement"
        })({
          itemElement: renderer_default(e.currentTarget),
          event: e
        });
        itemSelectPromise.always(() => {
          callBase.apply(this, arguments);
        });
      },
      _itemSelectHandler: function(e) {
        var _itemSelectPromise;
        var itemSelectPromise;
        if (!this.option("selectionByClick")) {
          return;
        }
        var $itemElement = e.currentTarget;
        if (this.isItemSelected($itemElement)) {
          this.unselectItem(e.currentTarget);
        } else {
          itemSelectPromise = this.selectItem(e.currentTarget);
        }
        return null === (_itemSelectPromise = itemSelectPromise) || void 0 === _itemSelectPromise ? void 0 : _itemSelectPromise.promise();
      },
      _selectedItemElement: function(index2) {
        return this._itemElements().eq(index2);
      },
      _postprocessRenderItem: function(args) {
        if ("none" !== this.option("selectionMode")) {
          var $itemElement = renderer_default(args.itemElement);
          var normalizedItemIndex = this._editStrategy.getNormalizedIndex($itemElement);
          var isItemSelected = this._isItemSelected(normalizedItemIndex);
          this._processSelectableItem($itemElement, isItemSelected);
        }
      },
      _processSelectableItem: function($itemElement, isSelected) {
        $itemElement.toggleClass(this._selectedItemClass(), isSelected);
        this._setAriaSelected($itemElement, String(isSelected));
      },
      _updateSelectedItems: function(args) {
        var that = this;
        var addedItemKeys = args.addedItemKeys;
        var removedItemKeys = args.removedItemKeys;
        if (that._rendered && (addedItemKeys.length || removedItemKeys.length)) {
          var selectionChangePromise = that._selectionChangePromise;
          if (!that._rendering) {
            var addedSelection = [];
            var normalizedIndex;
            var removedSelection = [];
            that._editStrategy.beginCache();
            for (var i = 0; i < addedItemKeys.length; i++) {
              normalizedIndex = that._getIndexByKey(addedItemKeys[i]);
              addedSelection.push(normalizedIndex);
              that._addSelection(normalizedIndex);
            }
            for (var _i = 0; _i < removedItemKeys.length; _i++) {
              normalizedIndex = that._getIndexByKey(removedItemKeys[_i]);
              removedSelection.push(normalizedIndex);
              that._removeSelection(normalizedIndex);
            }
            that._editStrategy.endCache();
            that._updateSelection(addedSelection, removedSelection);
          }
          when(selectionChangePromise).done(function() {
            that._fireSelectionChangeEvent(args.addedItems, args.removedItems);
          });
        }
      },
      _fireSelectionChangeEvent: function(addedItems, removedItems) {
        this._createActionByOption("onSelectionChanged", {
          excludeValidators: ["disabled", "readOnly"]
        })({
          addedItems,
          removedItems
        });
      },
      _updateSelection: noop2,
      _setAriaSelected: function($target, value2) {
        this.setAria("selected", value2, $target);
      },
      _removeSelection: function(normalizedIndex) {
        var $itemElement = this._editStrategy.getItemElement(normalizedIndex);
        if (indexExists(normalizedIndex)) {
          this._processSelectableItem($itemElement, false);
          events_engine_default.triggerHandler($itemElement, "stateChanged", false);
        }
      },
      _addSelection: function(normalizedIndex) {
        var $itemElement = this._editStrategy.getItemElement(normalizedIndex);
        if (indexExists(normalizedIndex)) {
          this._processSelectableItem($itemElement, true);
          events_engine_default.triggerHandler($itemElement, "stateChanged", true);
        }
      },
      _isItemSelected: function(index2) {
        var key = this._getKeyByIndex(index2);
        return this._selection.isItemSelected(key, {
          checkPending: true
        });
      },
      _optionChanged: function(args) {
        switch (args.name) {
          case "selectionMode":
            this._invalidate();
            break;
          case "dataSource":
            if (!args.value || Array.isArray(args.value) && !args.value.length) {
              this.option("selectedItemKeys", []);
            }
            this.callBase(args);
            break;
          case "selectedIndex":
          case "selectedItem":
          case "selectedItems":
          case "selectedItemKeys":
            this._syncSelectionOptions(args.name).done(() => this._normalizeSelectedItems());
            break;
          case "keyExpr":
            this._initKeyGetter();
            break;
          case "selectionRequired":
            this._normalizeSelectedItems();
            break;
          case "selectionByClick":
          case "onSelectionChanged":
          case "onItemDeleting":
          case "onItemDeleted":
          case "onItemReordered":
          case "maxFilterLengthInRequest":
            break;
          default:
            this.callBase(args);
        }
      },
      _clearSelectedItems: function() {
        this._setOptionWithoutOptionChange("selectedItems", []);
        this._syncSelectionOptions("selectedItems");
      },
      _waitDeletingPrepare: function($itemElement) {
        if ($itemElement.data(ITEM_DELETING_DATA_KEY)) {
          return new Deferred().resolve().promise();
        }
        $itemElement.data(ITEM_DELETING_DATA_KEY, true);
        var deferred = new Deferred();
        var deletingActionArgs = {
          cancel: false
        };
        var deletePromise = this._itemEventHandler($itemElement, "onItemDeleting", deletingActionArgs, {
          excludeValidators: ["disabled", "readOnly"]
        });
        when(deletePromise).always((function(value2) {
          var deletePromiseExists = !deletePromise;
          var deletePromiseResolved = !deletePromiseExists && "resolved" === deletePromise.state();
          var argumentsSpecified = !!arguments.length;
          var shouldDelete = deletePromiseExists || deletePromiseResolved && !argumentsSpecified || deletePromiseResolved && value2;
          when(fromPromise(deletingActionArgs.cancel)).always(function() {
            $itemElement.data(ITEM_DELETING_DATA_KEY, false);
          }).done(function(cancel2) {
            shouldDelete && !cancel2 ? deferred.resolve() : deferred.reject();
          }).fail(deferred.reject);
        }).bind(this));
        return deferred.promise();
      },
      _deleteItemFromDS: function($item) {
        if (!this._dataSource) {
          return new Deferred().resolve().promise();
        }
        var deferred = new Deferred();
        var disabledState = this.option("disabled");
        var dataStore = this._dataSource.store();
        this.option("disabled", true);
        if (!dataStore.remove) {
          throw ui_errors_default.Error("E1011");
        }
        dataStore.remove(dataStore.keyOf(this._getItemData($item))).done(function(key) {
          if (void 0 !== key) {
            deferred.resolve();
          } else {
            deferred.reject();
          }
        }).fail(function() {
          deferred.reject();
        });
        deferred.always((function() {
          this.option("disabled", disabledState);
        }).bind(this));
        return deferred;
      },
      _tryRefreshLastPage: function() {
        var deferred = new Deferred();
        if (this._isLastPage() || this.option("grouped")) {
          deferred.resolve();
        } else {
          this._refreshLastPage().done(function() {
            deferred.resolve();
          });
        }
        return deferred.promise();
      },
      _refreshLastPage: function() {
        this._expectLastItemLoading();
        return this._dataSource.load();
      },
      _updateSelectionAfterDelete: function(index2) {
        var key = this._getKeyByIndex(index2);
        this._selection.deselect([key]);
      },
      _updateIndicesAfterIndex: function(index2) {
        var itemElements = this._itemElements();
        for (var i = index2 + 1; i < itemElements.length; i++) {
          renderer_default(itemElements[i]).data(this._itemIndexKey(), i - 1);
        }
      },
      _simulateOptionChange: function(optionName) {
        var optionValue = this.option(optionName);
        if (optionValue instanceof DataSource) {
          return;
        }
        this._optionChangedAction({
          name: optionName,
          fullName: optionName,
          value: optionValue
        });
      },
      isItemSelected: function(itemElement) {
        return this._isItemSelected(this._editStrategy.getNormalizedIndex(itemElement));
      },
      selectItem: function(itemElement) {
        if ("none" === this.option("selectionMode")) {
          return;
        }
        var itemIndex = this._editStrategy.getNormalizedIndex(itemElement);
        if (!indexExists(itemIndex)) {
          return;
        }
        var key = this._getKeyByIndex(itemIndex);
        if (this._selection.isItemSelected(key)) {
          return;
        }
        if ("single" === this.option("selectionMode")) {
          return this._selection.setSelection([key]);
        } else {
          var selectedItemKeys = this.option("selectedItemKeys") || [];
          return this._selection.setSelection([...selectedItemKeys, key], [key]);
        }
      },
      unselectItem: function(itemElement) {
        var itemIndex = this._editStrategy.getNormalizedIndex(itemElement);
        if (!indexExists(itemIndex)) {
          return;
        }
        var selectedItemKeys = this._selection.getSelectedItemKeys();
        if (this.option("selectionRequired") && selectedItemKeys.length <= 1) {
          return;
        }
        var key = this._getKeyByIndex(itemIndex);
        if (!this._selection.isItemSelected(key, {
          checkPending: true
        })) {
          return;
        }
        this._selection.deselect([key]);
      },
      _deleteItemElementByIndex: function(index2) {
        this._updateSelectionAfterDelete(index2);
        this._updateIndicesAfterIndex(index2);
        this._editStrategy.deleteItemAtIndex(index2);
      },
      _afterItemElementDeleted: function($item, deletedActionArgs) {
        var changingOption = this._dataSource ? "dataSource" : "items";
        this._simulateOptionChange(changingOption);
        this._itemEventHandler($item, "onItemDeleted", deletedActionArgs, {
          beforeExecute: function() {
            $item.remove();
          },
          excludeValidators: ["disabled", "readOnly"]
        });
        this._renderEmptyMessage();
      },
      deleteItem: function(itemElement) {
        var that = this;
        var deferred = new Deferred();
        var $item = this._editStrategy.getItemElement(itemElement);
        var index2 = this._editStrategy.getNormalizedIndex(itemElement);
        var itemResponseWaitClass = this._itemResponseWaitClass();
        if (indexExists(index2)) {
          this._waitDeletingPrepare($item).done(function() {
            $item.addClass(itemResponseWaitClass);
            var deletedActionArgs = that._extendActionArgs($item);
            that._deleteItemFromDS($item).done(function() {
              that._deleteItemElementByIndex(index2);
              that._afterItemElementDeleted($item, deletedActionArgs);
              that._tryRefreshLastPage().done(function() {
                deferred.resolveWith(that);
              });
            }).fail(function() {
              $item.removeClass(itemResponseWaitClass);
              deferred.rejectWith(that);
            });
          }).fail(function() {
            deferred.rejectWith(that);
          });
        } else {
          deferred.rejectWith(that);
        }
        return deferred.promise();
      },
      reorderItem: function(itemElement, toItemElement) {
        var deferred = new Deferred();
        var that = this;
        var strategy3 = this._editStrategy;
        var $movingItem = strategy3.getItemElement(itemElement);
        var $destinationItem = strategy3.getItemElement(toItemElement);
        var movingIndex = strategy3.getNormalizedIndex(itemElement);
        var destinationIndex = strategy3.getNormalizedIndex(toItemElement);
        var changingOption = this._dataSource ? "dataSource" : "items";
        var canMoveItems = indexExists(movingIndex) && indexExists(destinationIndex) && movingIndex !== destinationIndex;
        if (canMoveItems) {
          deferred.resolveWith(this);
        } else {
          deferred.rejectWith(this);
        }
        return deferred.promise().done(function() {
          $destinationItem[strategy3.itemPlacementFunc(movingIndex, destinationIndex)]($movingItem);
          strategy3.moveItemAtIndexToIndex(movingIndex, destinationIndex);
          this._updateIndicesAfterIndex(movingIndex);
          that.option("selectedItems", that._getItemsByKeys(that._selection.getSelectedItemKeys(), that._selection.getSelectedItems()));
          if ("items" === changingOption) {
            that._simulateOptionChange(changingOption);
          }
          that._itemEventHandler($movingItem, "onItemReordered", {
            fromIndex: strategy3.getIndex(movingIndex),
            toIndex: strategy3.getIndex(destinationIndex)
          }, {
            excludeValidators: ["disabled", "readOnly"]
          });
        });
      }
    });
    ui_collection_widget_edit_default = CollectionWidget2;
  }
});

// node_modules/devextreme/esm/ui/hierarchical_collection/ui.hierarchical_collection_widget.js
var DISABLED_STATE_CLASS2, HierarchicalCollectionWidget, ui_hierarchical_collection_widget_default;
var init_ui_hierarchical_collection_widget = __esm({
  "node_modules/devextreme/esm/ui/hierarchical_collection/ui.hierarchical_collection_widget.js"() {
    init_renderer();
    init_data();
    init_extend();
    init_iterator();
    init_devices();
    init_icon();
    init_ui_data_adapter();
    init_ui_collection_widget_edit();
    init_bindable_template();
    init_type();
    init_common();
    DISABLED_STATE_CLASS2 = "dx-state-disabled";
    HierarchicalCollectionWidget = ui_collection_widget_edit_default.inherit({
      _getDefaultOptions: function() {
        return extend2(this.callBase(), {
          keyExpr: "id",
          displayExpr: "text",
          selectedExpr: "selected",
          disabledExpr: "disabled",
          itemsExpr: "items",
          hoverStateEnabled: true,
          parentIdExpr: "parentId",
          expandedExpr: "expanded"
        });
      },
      _defaultOptionsRules: function() {
        return this.callBase().concat([{
          device: function() {
            return "desktop" === devices_default.real().deviceType && !devices_default.isSimulator();
          },
          options: {
            focusStateEnabled: true
          }
        }]);
      },
      _init: function() {
        this.callBase();
        this._initAccessors();
        this._initDataAdapter();
        this._initDynamicTemplates();
      },
      _initDataSource: function() {
        this.callBase();
        this._dataSource && this._dataSource.paginate(false);
      },
      _initDataAdapter: function() {
        var accessors = this._createDataAdapterAccessors();
        this._dataAdapter = new ui_data_adapter_default(extend2({
          dataAccessors: {
            getters: accessors.getters,
            setters: accessors.setters
          },
          items: this.option("items")
        }, this._getDataAdapterOptions()));
      },
      _getDataAdapterOptions: noop2,
      _initDynamicTemplates: function() {
        var that = this;
        this._templateManager.addDefaultTemplates({
          item: new BindableTemplate((function($container, itemData) {
            $container.html(itemData.html).append(this._getIconContainer(itemData)).append(this._getTextContainer(itemData)).append(this._getPopoutContainer(itemData));
            that._addContentClasses(itemData, $container.parent());
          }).bind(this), ["text", "html", "items", "icon"], this.option("integrationOptions.watchMethod"), {
            text: this._displayGetter,
            items: this._itemsGetter
          })
        });
      },
      _getIconContainer: function(itemData) {
        return itemData.icon ? getImageContainer(itemData.icon) : void 0;
      },
      _getTextContainer: function(itemData) {
        return renderer_default("<span>").text(itemData.text);
      },
      _getPopoutContainer: noop2,
      _addContentClasses: noop2,
      _initAccessors: function() {
        var that = this;
        each(this._getAccessors(), function(_2, accessor) {
          that._compileAccessor(accessor);
        });
        this._compileDisplayGetter();
      },
      _getAccessors: function() {
        return ["key", "selected", "items", "disabled", "parentId", "expanded"];
      },
      _getChildNodes: function(node) {
        var that = this;
        var arr = [];
        each(node.internalFields.childrenKeys, function(_2, key) {
          var childNode = that._dataAdapter.getNodeByKey(key);
          arr.push(childNode);
        });
        return arr;
      },
      _hasChildren: function(node) {
        return node && node.internalFields.childrenKeys.length;
      },
      _compileAccessor: function(optionName) {
        var getter = "_" + optionName + "Getter";
        var setter = "_" + optionName + "Setter";
        var optionExpr = this.option(optionName + "Expr");
        if (!optionExpr) {
          this[getter] = noop2;
          this[setter] = noop2;
          return;
        } else if (isFunction(optionExpr)) {
          this[setter] = function(obj, value2) {
            obj[optionExpr()] = value2;
          };
          this[getter] = function(obj) {
            return obj[optionExpr()];
          };
          return;
        }
        this[getter] = compileGetter(optionExpr);
        this[setter] = compileSetter(optionExpr);
      },
      _createDataAdapterAccessors: function() {
        var that = this;
        var accessors = {
          getters: {},
          setters: {}
        };
        each(this._getAccessors(), function(_2, accessor) {
          var getterName = "_" + accessor + "Getter";
          var setterName = "_" + accessor + "Setter";
          var newAccessor = "parentId" === accessor ? "parentKey" : accessor;
          accessors.getters[newAccessor] = that[getterName];
          accessors.setters[newAccessor] = that[setterName];
        });
        accessors.getters.display = !this._displayGetter ? (itemData) => itemData.text : this._displayGetter;
        return accessors;
      },
      _initMarkup: function() {
        this.callBase();
        this._addWidgetClass();
      },
      _addWidgetClass: function() {
        this._focusTarget().addClass(this._widgetClass());
      },
      _widgetClass: noop2,
      _renderItemFrame: function(index2, itemData) {
        var $itemFrame = this.callBase.apply(this, arguments);
        $itemFrame.toggleClass(DISABLED_STATE_CLASS2, !!this._disabledGetter(itemData));
        return $itemFrame;
      },
      _optionChanged: function(args) {
        switch (args.name) {
          case "displayExpr":
          case "keyExpr":
            this._initAccessors();
            this._initDynamicTemplates();
            this.repaint();
            break;
          case "itemsExpr":
          case "selectedExpr":
          case "disabledExpr":
          case "expandedExpr":
          case "parentIdExpr":
            this._initAccessors();
            this._initDataAdapter();
            this.repaint();
            break;
          case "items":
            this._initDataAdapter();
            this.callBase(args);
            break;
          default:
            this.callBase(args);
        }
      }
    });
    ui_hierarchical_collection_widget_default = HierarchicalCollectionWidget;
  }
});

// node_modules/devextreme/esm/ui/context_menu/ui.menu_base.edit.strategy.js
var MenuBaseEditStrategy, ui_menu_base_edit_strategy_default;
var init_ui_menu_base_edit_strategy = __esm({
  "node_modules/devextreme/esm/ui/context_menu/ui.menu_base.edit.strategy.js"() {
    init_renderer();
    init_iterator();
    init_ui_collection_widget_edit_strategy_plain();
    MenuBaseEditStrategy = class extends ui_collection_widget_edit_strategy_plain_default {
      _getPlainItems() {
        return map(this._collectionWidget.option("items"), function getMenuItems(item) {
          return item.items ? [item].concat(map(item.items, getMenuItems)) : item;
        });
      }
      _stringifyItem(item) {
        return JSON.stringify(item, (key, value2) => {
          if ("template" === key) {
            return this._getTemplateString(value2);
          }
          return value2;
        });
      }
      _getTemplateString(template) {
        var result2;
        if ("object" === typeof template) {
          result2 = renderer_default(template).text();
        } else {
          result2 = template.toString();
        }
        return result2;
      }
    };
    ui_menu_base_edit_strategy_default = MenuBaseEditStrategy;
  }
});

// node_modules/devextreme/esm/ui/context_menu/ui.menu_base.js
var DX_MENU_CLASS, DX_MENU_NO_ICONS_CLASS, DX_MENU_BASE_CLASS, ITEM_CLASS2, DX_ITEM_CONTENT_CLASS, DX_MENU_SELECTED_ITEM_CLASS, DX_MENU_ITEM_WRAPPER_CLASS, DX_MENU_ITEMS_CONTAINER_CLASS, DX_MENU_ITEM_EXPANDED_CLASS, DX_MENU_SEPARATOR_CLASS, DX_MENU_ITEM_LAST_GROUP_ITEM, DX_ITEM_HAS_TEXT, DX_ITEM_HAS_ICON, DX_ITEM_HAS_SUBMENU, DX_MENU_ITEM_POPOUT_CLASS, DX_MENU_ITEM_POPOUT_CONTAINER_CLASS, DX_MENU_ITEM_CAPTION_CLASS, SINGLE_SELECTION_MODE, DEFAULT_DELAY, MenuBase, ui_menu_base_default;
var init_ui_menu_base = __esm({
  "node_modules/devextreme/esm/ui/context_menu/ui.menu_base.js"() {
    init_renderer();
    init_common();
    init_type();
    init_iterator();
    init_extend();
    init_utils_ink_ripple();
    init_ui_hierarchical_collection_widget();
    init_ui_menu_base_edit_strategy();
    init_devices();
    init_item();
    DX_MENU_CLASS = "dx-menu";
    DX_MENU_NO_ICONS_CLASS = DX_MENU_CLASS + "-no-icons";
    DX_MENU_BASE_CLASS = "dx-menu-base";
    ITEM_CLASS2 = DX_MENU_CLASS + "-item";
    DX_ITEM_CONTENT_CLASS = ITEM_CLASS2 + "-content";
    DX_MENU_SELECTED_ITEM_CLASS = ITEM_CLASS2 + "-selected";
    DX_MENU_ITEM_WRAPPER_CLASS = ITEM_CLASS2 + "-wrapper";
    DX_MENU_ITEMS_CONTAINER_CLASS = DX_MENU_CLASS + "-items-container";
    DX_MENU_ITEM_EXPANDED_CLASS = ITEM_CLASS2 + "-expanded";
    DX_MENU_SEPARATOR_CLASS = DX_MENU_CLASS + "-separator";
    DX_MENU_ITEM_LAST_GROUP_ITEM = DX_MENU_CLASS + "-last-group-item";
    DX_ITEM_HAS_TEXT = ITEM_CLASS2 + "-has-text";
    DX_ITEM_HAS_ICON = ITEM_CLASS2 + "-has-icon";
    DX_ITEM_HAS_SUBMENU = ITEM_CLASS2 + "-has-submenu";
    DX_MENU_ITEM_POPOUT_CLASS = ITEM_CLASS2 + "-popout";
    DX_MENU_ITEM_POPOUT_CONTAINER_CLASS = DX_MENU_ITEM_POPOUT_CLASS + "-container";
    DX_MENU_ITEM_CAPTION_CLASS = ITEM_CLASS2 + "-text";
    SINGLE_SELECTION_MODE = "single";
    DEFAULT_DELAY = {
      show: 50,
      hide: 300
    };
    MenuBase = class extends ui_hierarchical_collection_widget_default {
      _getDefaultOptions() {
        return extend2(super._getDefaultOptions(), {
          items: [],
          cssClass: "",
          activeStateEnabled: true,
          showSubmenuMode: {
            name: "onHover",
            delay: {
              show: 50,
              hide: 300
            }
          },
          animation: {
            show: {
              type: "fade",
              from: 0,
              to: 1,
              duration: 100
            },
            hide: {
              type: "fade",
              from: 1,
              to: 0,
              duration: 100
            }
          },
          selectByClick: false,
          focusOnSelectedItem: false,
          keyExpr: null,
          _itemAttributes: {
            role: "menuitem"
          },
          useInkRipple: false
        });
      }
      _itemDataKey() {
        return "dxMenuItemDataKey";
      }
      _itemClass() {
        return ITEM_CLASS2;
      }
      _setAriaSelected() {
      }
      _selectedItemClass() {
        return DX_MENU_SELECTED_ITEM_CLASS;
      }
      _widgetClass() {
        return DX_MENU_BASE_CLASS;
      }
      _focusTarget() {
        return this._itemContainer();
      }
      _clean() {
        this.option("focusedElement", null);
        super._clean();
      }
      _supportedKeys() {
        return extend2(super._supportedKeys(), {
          space: () => {
            var $item = renderer_default(this.option("focusedElement"));
            if (!$item.length || !this._isSelectionEnabled()) {
              return;
            }
            this.selectItem($item[0]);
          },
          pageUp: noop2,
          pageDown: noop2
        });
      }
      _isSelectionEnabled() {
        return this.option("selectionMode") === SINGLE_SELECTION_MODE;
      }
      _init() {
        this._activeStateUnit = ".".concat(ITEM_CLASS2);
        super._init();
        this._renderSelectedItem();
        this._initActions();
      }
      _getTextContainer(itemData) {
        var itemText = itemData.text;
        var $itemContainer = renderer_default("<span>").addClass(DX_MENU_ITEM_CAPTION_CLASS);
        var itemContent = isPlainObject(itemData) ? itemText : String(itemData);
        return itemText && $itemContainer.text(itemContent);
      }
      _getPopoutContainer(itemData) {
        var items = itemData.items;
        var $popOutContainer;
        if (items && items.length) {
          var $popOutImage = renderer_default("<div>").addClass(DX_MENU_ITEM_POPOUT_CLASS);
          $popOutContainer = renderer_default("<span>").addClass(DX_MENU_ITEM_POPOUT_CONTAINER_CLASS).append($popOutImage);
        }
        return $popOutContainer;
      }
      _getDataAdapterOptions() {
        return {
          rootValue: 0,
          multipleSelection: false,
          recursiveSelection: false,
          recursiveExpansion: false,
          searchValue: ""
        };
      }
      _selectByItem(selectedItem) {
        if (!selectedItem) {
          return;
        }
        var nodeToSelect = this._dataAdapter.getNodeByItem(selectedItem);
        this._dataAdapter.toggleSelection(nodeToSelect.internalFields.key, true);
      }
      _renderSelectedItem() {
        var selectedKeys = this._dataAdapter.getSelectedNodesKeys();
        var selectedKey = selectedKeys.length && selectedKeys[0];
        var selectedItem = this.option("selectedItem");
        if (!selectedKey) {
          this._selectByItem(selectedItem);
          return;
        }
        var node = this._dataAdapter.getNodeByKey(selectedKey);
        if (false === node.selectable) {
          return;
        }
        if (!selectedItem) {
          this.option("selectedItem", node.internalFields.item);
          return;
        }
        if (selectedItem !== node.internalFields.item) {
          this._dataAdapter.toggleSelection(selectedKey, false);
          this._selectByItem(selectedItem);
        }
      }
      _initActions() {
      }
      _initMarkup() {
        super._initMarkup();
        this._addCustomCssClass(this.$element());
        this.option("useInkRipple") && this._renderInkRipple();
      }
      _renderInkRipple() {
        this._inkRipple = render();
      }
      _toggleActiveState($element, value2, e) {
        super._toggleActiveState.apply(this, arguments);
        if (!this._inkRipple) {
          return;
        }
        var config2 = {
          element: $element,
          event: e
        };
        if (value2) {
          this._inkRipple.showWave(config2);
        } else {
          this._inkRipple.hideWave(config2);
        }
      }
      _getShowSubmenuMode() {
        var optionValue = this.option("showSubmenuMode");
        optionValue = isObject2(optionValue) ? optionValue.name : optionValue;
        return this._isDesktopDevice() ? optionValue : "onClick";
      }
      _initSelectedItems() {
      }
      _isDesktopDevice() {
        return "desktop" === devices_default.real().deviceType;
      }
      _initEditStrategy() {
        var Strategy = ui_menu_base_edit_strategy_default;
        this._editStrategy = new Strategy(this);
      }
      _addCustomCssClass($element) {
        $element.addClass(this.option("cssClass"));
      }
      _itemWrapperSelector() {
        return ".".concat(DX_MENU_ITEM_WRAPPER_CLASS);
      }
      _hoverStartHandler(e) {
        var $itemElement = this._getItemElementByEventArgs(e);
        if (!$itemElement || this._isItemDisabled($itemElement)) {
          return;
        }
        e.stopPropagation();
        if ("onHover" === this._getShowSubmenuMode()) {
          clearTimeout(this._showSubmenusTimeout);
          this._showSubmenusTimeout = setTimeout(this._showSubmenu.bind(this, $itemElement), this._getSubmenuDelay("show"));
        }
      }
      _getAvailableItems($itemElements) {
        return super._getAvailableItems($itemElements).filter(function() {
          return "hidden" !== renderer_default(this).css("visibility");
        });
      }
      _isItemDisabled($item) {
        return this._disabledGetter($item.data(this._itemDataKey()));
      }
      _showSubmenu($itemElement) {
        this._addExpandedClass($itemElement);
      }
      _addExpandedClass(itemElement) {
        renderer_default(itemElement).addClass(DX_MENU_ITEM_EXPANDED_CLASS);
      }
      _getSubmenuDelay(action) {
        var {
          delay
        } = this.option("showSubmenuMode");
        if (!isDefined(delay)) {
          return DEFAULT_DELAY[action];
        }
        return isObject2(delay) ? delay[action] : delay;
      }
      _getItemElementByEventArgs(eventArgs) {
        var $target = renderer_default(eventArgs.target);
        if ($target.hasClass(this._itemClass()) || $target.get(0) === eventArgs.currentTarget) {
          return $target;
        }
        while (!$target.hasClass(this._itemClass())) {
          $target = $target.parent();
          if ($target.hasClass("dx-submenu")) {
            return null;
          }
        }
        return $target;
      }
      _hoverEndHandler() {
        clearTimeout(this._showSubmenusTimeout);
      }
      _hasSubmenu(node) {
        return node && node.internalFields.childrenKeys.length;
      }
      _renderContentImpl() {
        this._renderItems(this._dataAdapter.getRootNodes());
      }
      _renderItems(nodes, submenuContainer) {
        if (nodes.length) {
          this.hasIcons = false;
          var $nodeContainer = this._renderContainer(this.$element(), submenuContainer);
          var firstVisibleIndex = -1;
          var nextGroupFirstIndex = -1;
          each(nodes, (index2, node) => {
            var isVisibleNode = false !== node.visible;
            if (isVisibleNode && firstVisibleIndex < 0) {
              firstVisibleIndex = index2;
            }
            var isBeginGroup = firstVisibleIndex < index2 && (node.beginGroup || index2 === nextGroupFirstIndex);
            if (isBeginGroup) {
              nextGroupFirstIndex = isVisibleNode ? index2 : index2 + 1;
            }
            if (index2 === nextGroupFirstIndex && firstVisibleIndex < index2) {
              this._renderSeparator($nodeContainer);
            }
            this._renderItem(index2, node, $nodeContainer);
          });
          if (!this.hasIcons) {
            $nodeContainer.addClass(DX_MENU_NO_ICONS_CLASS);
          }
        }
      }
      _renderContainer($wrapper) {
        var $container = renderer_default("<ul>");
        this.setAria("role", "none", $container);
        return $container.appendTo($wrapper).addClass(DX_MENU_ITEMS_CONTAINER_CLASS);
      }
      _createDOMElement($nodeContainer) {
        var $node = renderer_default("<li>");
        this.setAria("role", "none", $node);
        return $node.appendTo($nodeContainer).addClass(DX_MENU_ITEM_WRAPPER_CLASS);
      }
      _renderItem(index2, node, $nodeContainer, $nodeElement) {
        var items = this.option("items");
        var $node = $nodeElement || this._createDOMElement($nodeContainer);
        if (items[index2 + 1] && items[index2 + 1].beginGroup) {
          $node.addClass(DX_MENU_ITEM_LAST_GROUP_ITEM);
        }
        var $itemFrame = super._renderItem(index2, node.internalFields.item, $node);
        if (node.internalFields.item === this.option("selectedItem")) {
          $itemFrame.addClass(DX_MENU_SELECTED_ITEM_CLASS);
        }
        $itemFrame.attr("tabIndex", -1);
        if (this._hasSubmenu(node)) {
          this.setAria("haspopup", "true", $itemFrame);
        }
      }
      _renderItemFrame(index2, itemData, $itemContainer) {
        var $itemFrame = $itemContainer.children(".".concat(ITEM_CLASS2));
        return $itemFrame.length ? $itemFrame : super._renderItemFrame.apply(this, arguments);
      }
      _refreshItem($item, item) {
        var node = this._dataAdapter.getNodeByItem(item);
        var index2 = $item.data(this._itemIndexKey());
        var $nodeContainer = $item.closest("ul");
        var $nodeElement = $item.closest("li");
        this._renderItem(index2, node, $nodeContainer, $nodeElement);
      }
      _addContentClasses(itemData, $itemFrame) {
        var hasText = itemData.text ? !!itemData.text.length : false;
        var hasIcon = !!itemData.icon;
        var hasSubmenu = itemData.items ? !!itemData.items.length : false;
        $itemFrame.toggleClass(DX_ITEM_HAS_TEXT, hasText);
        $itemFrame.toggleClass(DX_ITEM_HAS_ICON, hasIcon);
        if (!this.hasIcons) {
          this.hasIcons = hasIcon;
        }
        $itemFrame.toggleClass(DX_ITEM_HAS_SUBMENU, hasSubmenu);
      }
      _getItemContent($itemFrame) {
        var $itemContent = super._getItemContent($itemFrame);
        if (!$itemContent.length) {
          $itemContent = $itemFrame.children(".".concat(DX_ITEM_CONTENT_CLASS));
        }
        return $itemContent;
      }
      _postprocessRenderItem(args) {
        var $itemElement = renderer_default(args.itemElement);
        var selectedIndex = this._dataAdapter.getSelectedNodesKeys();
        if (!selectedIndex.length || !this._selectedGetter(args.itemData) || !this._isItemSelectable(args.itemData)) {
          this._setAriaSelected($itemElement, "false");
          return;
        }
        var node = this._dataAdapter.getNodeByItem(args.itemData);
        if (node.internalFields.key === selectedIndex[0]) {
          $itemElement.addClass(this._selectedItemClass());
          this._setAriaSelected($itemElement, "true");
        } else {
          this._setAriaSelected($itemElement, "false");
        }
      }
      _isItemSelectable(item) {
        return false !== item.selectable;
      }
      _renderSeparator($itemsContainer) {
        renderer_default("<li>").appendTo($itemsContainer).addClass(DX_MENU_SEPARATOR_CLASS);
      }
      _itemClickHandler(e) {
        if (e._skipHandling) {
          return;
        }
        var itemClickActionHandler = this._createAction(this._updateSubmenuVisibilityOnClick.bind(this));
        this._itemDXEventHandler(e, "onItemClick", {}, {
          afterExecute: itemClickActionHandler.bind(this)
        });
        e._skipHandling = true;
      }
      _updateSubmenuVisibilityOnClick(actionArgs) {
        this._updateSelectedItemOnClick(actionArgs);
        if ("onClick" === this._getShowSubmenuMode()) {
          this._addExpandedClass(actionArgs.args[0].itemElement);
        }
      }
      _updateSelectedItemOnClick(actionArgs) {
        var args = actionArgs.args ? actionArgs.args[0] : actionArgs;
        if (!this._isItemSelectionAllowed(args.itemData)) {
          return;
        }
        var selectedItemKey = this._dataAdapter.getSelectedNodesKeys();
        var selectedNode = selectedItemKey.length && this._dataAdapter.getNodeByKey(selectedItemKey[0]);
        if (selectedNode) {
          this._toggleItemSelection(selectedNode, false);
        }
        if (!selectedNode || selectedNode.internalFields.item !== args.itemData) {
          this.selectItem(args.itemData);
        } else {
          this._fireSelectionChangeEvent(null, this.option("selectedItem"));
          this._setOptionWithoutOptionChange("selectedItem", null);
        }
      }
      _isItemSelectionAllowed(item) {
        var isSelectionByClickEnabled = this._isSelectionEnabled() && this.option("selectByClick");
        return !this._isContainerEmpty() && isSelectionByClickEnabled && this._isItemSelectable(item) && !this._itemsGetter(item);
      }
      _isContainerEmpty() {
        return this._itemContainer().is(":empty");
      }
      _syncSelectionOptions() {
        return asyncNoop();
      }
      _optionChanged(args) {
        switch (args.name) {
          case "showSubmenuMode":
            break;
          case "selectedItem":
            var node = this._dataAdapter.getNodeByItem(args.value);
            var selectedKey = this._dataAdapter.getSelectedNodesKeys()[0];
            if (node && node.internalFields.key !== selectedKey) {
              if (false === node.selectable) {
                break;
              }
              if (selectedKey) {
                this._toggleItemSelection(this._dataAdapter.getNodeByKey(selectedKey), false);
              }
              this._toggleItemSelection(node, true);
              this._updateSelectedItems();
            }
            break;
          case "cssClass":
          case "position":
          case "selectByClick":
          case "animation":
          case "useInkRipple":
            this._invalidate();
            break;
          default:
            super._optionChanged(args);
        }
      }
      _toggleItemSelection(node, value2) {
        var itemElement = this._getElementByItem(node.internalFields.item);
        itemElement && renderer_default(itemElement).toggleClass(DX_MENU_SELECTED_ITEM_CLASS);
        this._dataAdapter.toggleSelection(node.internalFields.key, value2);
      }
      _getElementByItem(itemData) {
        var result2;
        each(this._itemElements(), (_2, itemElement) => {
          if (renderer_default(itemElement).data(this._itemDataKey()) !== itemData) {
            return true;
          }
          result2 = itemElement;
          return false;
        });
        return result2;
      }
      _updateSelectedItems(oldSelection, newSelection) {
        if (oldSelection || newSelection) {
          this._fireSelectionChangeEvent(newSelection, oldSelection);
        }
      }
      _fireSelectionChangeEvent(addedSelection, removedSelection) {
        this._createActionByOption("onSelectionChanged", {
          excludeValidators: ["disabled", "readOnly"]
        })({
          addedItems: [addedSelection],
          removedItems: [removedSelection]
        });
      }
      selectItem(itemElement) {
        var itemData = itemElement.nodeType ? this._getItemData(itemElement) : itemElement;
        var selectedKey = this._dataAdapter.getSelectedNodesKeys()[0];
        var selectedItem = this.option("selectedItem");
        var node = this._dataAdapter.getNodeByItem(itemData);
        if (node.internalFields.key !== selectedKey) {
          if (selectedKey) {
            this._toggleItemSelection(this._dataAdapter.getNodeByKey(selectedKey), false);
          }
          this._toggleItemSelection(node, true);
          this._updateSelectedItems(selectedItem, itemData);
          this._setOptionWithoutOptionChange("selectedItem", itemData);
        }
      }
      unselectItem(itemElement) {
        var itemData = itemElement.nodeType ? this._getItemData(itemElement) : itemElement;
        var node = this._dataAdapter.getNodeByItem(itemData);
        var selectedItem = this.option("selectedItem");
        if (node.internalFields.selected) {
          this._toggleItemSelection(node, false);
          this._updateSelectedItems(selectedItem, null);
          this._setOptionWithoutOptionChange("selectedItem", null);
        }
      }
    };
    MenuBase.ItemClass = item_default;
    ui_menu_base_default = MenuBase;
  }
});

// node_modules/devextreme/esm/ui/context_menu/ui.context_menu.js
var DX_MENU_CLASS2, DX_MENU_ITEM_CLASS, DX_MENU_ITEM_EXPANDED_CLASS2, DX_MENU_PHONE_CLASS, DX_MENU_ITEMS_CONTAINER_CLASS2, DX_MENU_ITEM_WRAPPER_CLASS2, DX_SUBMENU_CLASS, DX_CONTEXT_MENU_CLASS, DX_HAS_CONTEXT_MENU_CLASS, DX_STATE_DISABLED_CLASS, DX_STATE_FOCUSED_CLASS, DX_STATE_HOVER_CLASS, FOCUS_UP2, FOCUS_DOWN2, FOCUS_LEFT2, FOCUS_RIGHT2, FOCUS_FIRST2, FOCUS_LAST2, ACTIONS2, LOCAL_SUBMENU_DIRECTIONS, DEFAULT_SHOW_EVENT, ContextMenu2, ui_context_menu_default;
var init_ui_context_menu = __esm({
  "node_modules/devextreme/esm/ui/context_menu/ui.context_menu.js"() {
    init_renderer();
    init_dom_adapter();
    init_events_engine();
    init_guid();
    init_component_registrator();
    init_common();
    init_type();
    init_dom();
    init_element();
    init_iterator();
    init_array();
    init_extend();
    init_window();
    init_fx();
    init_position2();
    init_devices();
    init_utils2();
    init_ui_overlay();
    init_ui_menu_base();
    init_deferred();
    init_contextmenu();
    init_hold();
    DX_MENU_CLASS2 = "dx-menu";
    DX_MENU_ITEM_CLASS = DX_MENU_CLASS2 + "-item";
    DX_MENU_ITEM_EXPANDED_CLASS2 = DX_MENU_ITEM_CLASS + "-expanded";
    DX_MENU_PHONE_CLASS = "dx-menu-phone-overlay";
    DX_MENU_ITEMS_CONTAINER_CLASS2 = DX_MENU_CLASS2 + "-items-container";
    DX_MENU_ITEM_WRAPPER_CLASS2 = DX_MENU_ITEM_CLASS + "-wrapper";
    DX_SUBMENU_CLASS = "dx-submenu";
    DX_CONTEXT_MENU_CLASS = "dx-context-menu";
    DX_HAS_CONTEXT_MENU_CLASS = "dx-has-context-menu";
    DX_STATE_DISABLED_CLASS = "dx-state-disabled";
    DX_STATE_FOCUSED_CLASS = "dx-state-focused";
    DX_STATE_HOVER_CLASS = "dx-state-hover";
    FOCUS_UP2 = "up";
    FOCUS_DOWN2 = "down";
    FOCUS_LEFT2 = "left";
    FOCUS_RIGHT2 = "right";
    FOCUS_FIRST2 = "first";
    FOCUS_LAST2 = "last";
    ACTIONS2 = ["onShowing", "onShown", "onSubmenuCreated", "onHiding", "onHidden", "onPositioning", "onLeftFirstItem", "onLeftLastItem", "onCloseRootSubmenu", "onExpandLastSubmenu"];
    LOCAL_SUBMENU_DIRECTIONS = [FOCUS_UP2, FOCUS_DOWN2, FOCUS_FIRST2, FOCUS_LAST2];
    DEFAULT_SHOW_EVENT = "dxcontextmenu";
    ContextMenu2 = class extends ui_menu_base_default {
      getShowEvent(showEventOption) {
        var result2 = null;
        if (isObject2(showEventOption)) {
          if (null !== showEventOption.name) {
            result2 = showEventOption.name || DEFAULT_SHOW_EVENT;
          }
        } else {
          result2 = showEventOption;
        }
        return result2;
      }
      getShowDelay(showEventOption) {
        return isObject2(showEventOption) && showEventOption.delay;
      }
      _getDefaultOptions() {
        return extend2(super._getDefaultOptions(), {
          showEvent: DEFAULT_SHOW_EVENT,
          closeOnOutsideClick: true,
          position: {
            at: "top left",
            my: "top left"
          },
          onShowing: null,
          onShown: null,
          onSubmenuCreated: null,
          onHiding: null,
          onHidden: null,
          onPositioning: null,
          submenuDirection: "auto",
          visible: false,
          target: void 0,
          onLeftFirstItem: null,
          onLeftLastItem: null,
          onCloseRootSubmenu: null,
          onExpandLastSubmenu: null
        });
      }
      _defaultOptionsRules() {
        return super._defaultOptionsRules().concat([{
          device: () => !hasWindow(),
          options: {
            animation: null
          }
        }]);
      }
      _initActions() {
        this._actions = {};
        each(ACTIONS2, (index2, action) => {
          this._actions[action] = this._createActionByOption(action) || noop2;
        });
      }
      _setOptionsByReference() {
        super._setOptionsByReference();
        extend2(this._optionsByReference, {
          animation: true,
          selectedItem: true
        });
      }
      _focusInHandler() {
      }
      _itemContainer() {
        return this._overlay ? this._overlay.$content() : renderer_default();
      }
      _eventBindingTarget() {
        return this._itemContainer();
      }
      itemsContainer() {
        return this._overlay ? this._overlay.$content() : void 0;
      }
      _supportedKeys() {
        return extend2(super._supportedKeys(), {
          space: () => {
            var $item = renderer_default(this.option("focusedElement"));
            this.hide();
            if (!$item.length || !this._isSelectionEnabled()) {
              return;
            }
            this.selectItem($item[0]);
          },
          escape: this.hide
        });
      }
      _getActiveItem() {
        var $availableItems = this._getAvailableItems();
        var $focusedItem = $availableItems.filter(".".concat(DX_STATE_FOCUSED_CLASS));
        var $hoveredItem = $availableItems.filter(".".concat(DX_STATE_HOVER_CLASS));
        var $hoveredItemContainer = $hoveredItem.closest(".".concat(DX_MENU_ITEMS_CONTAINER_CLASS2));
        if ($hoveredItemContainer.find(".".concat(DX_MENU_ITEM_CLASS)).index($focusedItem) >= 0) {
          return $focusedItem;
        }
        if ($hoveredItem.length) {
          return $hoveredItem;
        }
        return super._getActiveItem();
      }
      _moveFocus(location) {
        var $items = this._getItemsByLocation(location);
        var $oldTarget = this._getActiveItem(true);
        var $hoveredItem = this.itemsContainer().find(".".concat(DX_STATE_HOVER_CLASS));
        var $focusedItem = renderer_default(this.option("focusedElement"));
        var $activeItemHighlighted = !!($focusedItem.length || $hoveredItem.length);
        var $newTarget;
        switch (location) {
          case FOCUS_UP2:
            $newTarget = $activeItemHighlighted ? this._prevItem($items) : $oldTarget;
            this._setFocusedElement($newTarget);
            if ($oldTarget.is($items.first())) {
              this._actions.onLeftFirstItem($oldTarget);
            }
            break;
          case FOCUS_DOWN2:
            $newTarget = $activeItemHighlighted ? this._nextItem($items) : $oldTarget;
            this._setFocusedElement($newTarget);
            if ($oldTarget.is($items.last())) {
              this._actions.onLeftLastItem($oldTarget);
            }
            break;
          case FOCUS_RIGHT2:
            $newTarget = this.option("rtlEnabled") ? this._hideSubmenuHandler() : this._expandSubmenuHandler($items, location);
            this._setFocusedElement($newTarget);
            break;
          case FOCUS_LEFT2:
            $newTarget = this.option("rtlEnabled") ? this._expandSubmenuHandler($items, location) : this._hideSubmenuHandler();
            this._setFocusedElement($newTarget);
            break;
          case FOCUS_FIRST2:
            $newTarget = $items.first();
            this._setFocusedElement($newTarget);
            break;
          case FOCUS_LAST2:
            $newTarget = $items.last();
            this._setFocusedElement($newTarget);
            break;
          default:
            return super._moveFocus(location);
        }
      }
      _setFocusedElement($element) {
        if ($element && 0 !== $element.length) {
          this.option("focusedElement", getPublicElement($element));
        }
      }
      _getItemsByLocation(location) {
        var $activeItem = this._getActiveItem(true);
        var $items;
        if (inArray(location, LOCAL_SUBMENU_DIRECTIONS) >= 0) {
          $items = $activeItem.closest(".".concat(DX_MENU_ITEMS_CONTAINER_CLASS2)).children().children();
        }
        $items = this._getAvailableItems($items);
        return $items;
      }
      _getAriaTarget() {
        return this.$element();
      }
      _refreshActiveDescendant() {
        if (isDefined(this._overlay)) {
          var $target = this._overlay.$content();
          super._refreshActiveDescendant($target);
        }
      }
      _hideSubmenuHandler() {
        var $curItem = this._getActiveItem(true);
        var $parentItem = $curItem.parents(".".concat(DX_MENU_ITEM_EXPANDED_CLASS2)).first();
        if ($parentItem.length) {
          this._hideSubmenusOnSameLevel($parentItem);
          this._hideSubmenu($curItem.closest(".".concat(DX_SUBMENU_CLASS)));
          return $parentItem;
        }
        this._actions.onCloseRootSubmenu($curItem);
        return $curItem;
      }
      _expandSubmenuHandler($items, location) {
        var $curItem = this._getActiveItem(true);
        var itemData = this._getItemData($curItem);
        var node = this._dataAdapter.getNodeByItem(itemData);
        var isItemHasSubmenu = this._hasSubmenu(node);
        var $submenu = $curItem.children(".".concat(DX_SUBMENU_CLASS));
        if (isItemHasSubmenu && !$curItem.hasClass(DX_STATE_DISABLED_CLASS)) {
          if (!$submenu.length || "hidden" === $submenu.css("visibility")) {
            this._showSubmenu($curItem);
          }
          return this._nextItem(this._getItemsByLocation(location));
        }
        this._actions.onExpandLastSubmenu($curItem);
        return;
      }
      _clean() {
        if (this._overlay) {
          this._overlay.$element().remove();
          this._overlay = null;
        }
        this._detachShowContextMenuEvents(this._getTarget());
        super._clean();
      }
      _initMarkup() {
        this.$element().addClass(DX_HAS_CONTEXT_MENU_CLASS);
        super._initMarkup();
      }
      _render() {
        super._render();
        this._renderVisibility(this.option("visible"));
        this._addWidgetClass();
      }
      _renderContentImpl() {
        this._detachShowContextMenuEvents(this._getTarget());
        this._attachShowContextMenuEvents();
      }
      _attachKeyboardEvents() {
        !this._keyboardListenerId && this._focusTarget().length && super._attachKeyboardEvents();
      }
      _renderContextMenuOverlay() {
        if (this._overlay) {
          return;
        }
        var overlayOptions = this._getOverlayOptions();
        this._overlay = this._createComponent(renderer_default("<div>").appendTo(this._$element), ui_overlay_default, overlayOptions);
        var $overlayContent = this._overlay.$content();
        $overlayContent.addClass(DX_CONTEXT_MENU_CLASS);
        this._addCustomCssClass($overlayContent);
        this._addPlatformDependentClass($overlayContent);
        this._attachContextMenuEvent();
      }
      preventShowingDefaultContextMenuAboveOverlay() {
        var $itemContainer = this._itemContainer();
        var eventName = addNamespace2(name, this.NAME);
        events_engine_default.off($itemContainer, eventName, ".".concat(DX_SUBMENU_CLASS));
        events_engine_default.on($itemContainer, eventName, ".".concat(DX_SUBMENU_CLASS), ((e) => {
          e.stopPropagation();
          e.preventDefault();
          events_engine_default.off($itemContainer, eventName, ".".concat(DX_SUBMENU_CLASS));
        }).bind(this));
      }
      _itemContextMenuHandler(e) {
        super._itemContextMenuHandler(e);
        e.stopPropagation();
      }
      _addPlatformDependentClass($element) {
        if (devices_default.current().phone) {
          $element.addClass(DX_MENU_PHONE_CLASS);
        }
      }
      _detachShowContextMenuEvents(target) {
        var showEvent = this.getShowEvent(this.option("showEvent"));
        if (!showEvent) {
          return;
        }
        var eventName = addNamespace2(showEvent, this.NAME);
        if (this._showContextMenuEventHandler) {
          events_engine_default.off(dom_adapter_default.getDocument(), eventName, target, this._showContextMenuEventHandler);
        } else {
          events_engine_default.off(renderer_default(target), eventName);
        }
      }
      _attachShowContextMenuEvents() {
        var target = this._getTarget();
        var showEvent = this.getShowEvent(this.option("showEvent"));
        if (!showEvent) {
          return;
        }
        var eventName = addNamespace2(showEvent, this.NAME);
        var contextMenuAction = this._createAction((e) => {
          var delay = this.getShowDelay(this.option("showEvent"));
          if (delay) {
            setTimeout(() => this._show(e.event), delay);
          } else {
            this._show(e.event);
          }
        }, {
          validatingTargetName: "target"
        });
        var handler = (e) => contextMenuAction({
          event: e,
          target: renderer_default(e.currentTarget)
        });
        contextMenuAction = this._createAction(contextMenuAction);
        if (isRenderer(target) || target.nodeType || isWindow(target)) {
          this._showContextMenuEventHandler = void 0;
          events_engine_default.on(target, eventName, handler);
        } else {
          this._showContextMenuEventHandler = handler;
          events_engine_default.on(dom_adapter_default.getDocument(), eventName, target, this._showContextMenuEventHandler);
        }
      }
      _hoverEndHandler(e) {
        super._hoverEndHandler(e);
        e.stopPropagation();
      }
      _renderDimensions() {
      }
      _renderContainer($wrapper, submenuContainer) {
        var $holder = submenuContainer || this._itemContainer();
        $wrapper = renderer_default("<div>");
        $wrapper.appendTo($holder).addClass(DX_SUBMENU_CLASS).css("visibility", submenuContainer ? "hidden" : "visible");
        var $itemsContainer = super._renderContainer($wrapper);
        if (submenuContainer) {
          return $itemsContainer;
        }
        if (this.option("width")) {
          return $itemsContainer.css("minWidth", this.option("width"));
        }
        if (this.option("height")) {
          return $itemsContainer.css("minHeight", this.option("height"));
        }
        return $itemsContainer;
      }
      _renderSubmenuItems(node, $itemFrame) {
        this._renderItems(this._getChildNodes(node), $itemFrame);
        this._actions.onSubmenuCreated({
          itemElement: getPublicElement($itemFrame),
          itemData: node.internalFields.item,
          submenuElement: getPublicElement($itemFrame.children(".".concat(DX_SUBMENU_CLASS)))
        });
      }
      _getOverlayOptions() {
        var position3 = this.option("position");
        var overlayOptions = {
          focusStateEnabled: this.option("focusStateEnabled"),
          animation: this.option("animation"),
          innerOverlay: true,
          closeOnOutsideClick: this._closeOnOutsideClickHandler.bind(this),
          propagateOutsideClick: true,
          closeOnTargetScroll: true,
          deferRendering: false,
          position: {
            at: position3.at,
            my: position3.my,
            of: this._getTarget(),
            collision: "flipfit"
          },
          shading: false,
          showTitle: false,
          height: "auto",
          width: "auto",
          onShown: this._overlayShownActionHandler.bind(this),
          onHiding: this._overlayHidingActionHandler.bind(this),
          onHidden: this._overlayHiddenActionHandler.bind(this)
        };
        return overlayOptions;
      }
      _overlayShownActionHandler(arg) {
        this._actions.onShown(arg);
      }
      _overlayHidingActionHandler(arg) {
        this._actions.onHiding(arg);
        if (!arg.cancel) {
          this._hideAllShownSubmenus();
          this._setOptionWithoutOptionChange("visible", false);
        }
      }
      _overlayHiddenActionHandler(arg) {
        this._actions.onHidden(arg);
      }
      _closeOnOutsideClickHandler(e) {
        var closeOnOutsideClick = this.option("closeOnOutsideClick");
        if (isFunction(closeOnOutsideClick)) {
          return closeOnOutsideClick(e);
        }
        if (!closeOnOutsideClick) {
          return false;
        }
        if (dom_adapter_default.isDocument(e.target)) {
          return true;
        }
        var $activeItemContainer = this._getActiveItemsContainer(e.target);
        var $itemContainers = this._getItemsContainers();
        var $clickedItem = this._searchActiveItem(e.target);
        var $rootItem = this.$element().parents(".".concat(DX_MENU_ITEM_CLASS));
        var isRootItemClicked = $clickedItem[0] === $rootItem[0] && $clickedItem.length && $rootItem.length;
        var isInnerOverlayClicked = this._isIncludeOverlay($activeItemContainer, $itemContainers) && $clickedItem.length;
        if (isInnerOverlayClicked || isRootItemClicked) {
          if ("onClick" === this._getShowSubmenuMode()) {
            this._hideAllShownChildSubmenus($clickedItem);
          }
          return false;
        }
        return true;
      }
      _getActiveItemsContainer(target) {
        return renderer_default(target).closest(".".concat(DX_MENU_ITEMS_CONTAINER_CLASS2));
      }
      _getItemsContainers() {
        return this._overlay.$content().find(".".concat(DX_MENU_ITEMS_CONTAINER_CLASS2));
      }
      _searchActiveItem(target) {
        return renderer_default(target).closest(".".concat(DX_MENU_ITEM_CLASS)).eq(0);
      }
      _isIncludeOverlay($activeOverlay, $allOverlays) {
        var isSame = false;
        each($allOverlays, (index2, $overlay) => {
          if ($activeOverlay.is($overlay) && !isSame) {
            isSame = true;
          }
        });
        return isSame;
      }
      _hideAllShownChildSubmenus($clickedItem) {
        var $submenuElements = $clickedItem.find(".".concat(DX_SUBMENU_CLASS));
        var shownSubmenus = extend2([], this._shownSubmenus);
        if ($submenuElements.length > 0) {
          each(shownSubmenus, (index2, $submenu) => {
            var $context = this._searchActiveItem($submenu.context).parent();
            if ($context.parent().is($clickedItem.parent().parent()) && !$context.is($clickedItem.parent())) {
              this._hideSubmenu($submenu);
            }
          });
        }
      }
      _showSubmenu($item) {
        var node = this._dataAdapter.getNodeByItem(this._getItemData($item));
        this._hideSubmenusOnSameLevel($item);
        if (!this._hasSubmenu(node)) {
          return;
        }
        var $submenu = $item.children(".".concat(DX_SUBMENU_CLASS));
        var isSubmenuRendered = $submenu.length;
        super._showSubmenu($item);
        if (!isSubmenuRendered) {
          this._renderSubmenuItems(node, $item);
        }
        if (!this._isSubmenuVisible($submenu)) {
          this._drawSubmenu($item);
        }
      }
      _hideSubmenusOnSameLevel($item) {
        var $expandedItems = $item.parent(".".concat(DX_MENU_ITEM_WRAPPER_CLASS2)).siblings().find(".".concat(DX_MENU_ITEM_EXPANDED_CLASS2));
        if ($expandedItems.length) {
          $expandedItems.removeClass(DX_MENU_ITEM_EXPANDED_CLASS2);
          this._hideSubmenu($expandedItems.find(".".concat(DX_SUBMENU_CLASS)));
        }
      }
      _hideSubmenuGroup($submenu) {
        if (this._isSubmenuVisible($submenu)) {
          this._hideSubmenuCore($submenu);
        }
      }
      _isSubmenuVisible($submenu) {
        return "visible" === $submenu.css("visibility");
      }
      _drawSubmenu($itemElement) {
        var animation3 = this.option("animation") ? this.option("animation").show : {};
        var $submenu = $itemElement.children(".".concat(DX_SUBMENU_CLASS));
        var submenuPosition = this._getSubmenuPosition($itemElement);
        if (this._overlay && this._overlay.option("visible")) {
          if (!isDefined(this._shownSubmenus)) {
            this._shownSubmenus = [];
          }
          if (inArray($submenu, this._shownSubmenus)) {
            this._shownSubmenus.push($submenu);
          }
          if (animation3) {
            fx_default.stop($submenu);
          }
          position_default.setup($submenu, submenuPosition);
          if (animation3) {
            if (isPlainObject(animation3.to)) {
              animation3.to.position = submenuPosition;
            }
            this._animate($submenu, animation3);
          }
          $submenu.css("visibility", "visible");
        }
      }
      _animate($container, options2) {
        fx_default.animate($container, options2);
      }
      _getSubmenuPosition($rootItem) {
        var submenuDirection = this.option("submenuDirection").toLowerCase();
        var $rootItemWrapper = $rootItem.parent(".".concat(DX_MENU_ITEM_WRAPPER_CLASS2));
        var position3 = {
          collision: "flip",
          of: $rootItemWrapper,
          offset: {
            h: 0,
            v: -1
          }
        };
        switch (submenuDirection) {
          case "left":
            position3.at = "left top";
            position3.my = "right top";
            break;
          case "right":
            position3.at = "right top";
            position3.my = "left top";
            break;
          default:
            if (this.option("rtlEnabled")) {
              position3.at = "left top";
              position3.my = "right top";
            } else {
              position3.at = "right top";
              position3.my = "left top";
            }
        }
        return position3;
      }
      _updateSubmenuVisibilityOnClick(actionArgs) {
        if (!actionArgs.args.length) {
          return;
        }
        var itemData = actionArgs.args[0].itemData;
        var node = this._dataAdapter.getNodeByItem(itemData);
        if (!node) {
          return;
        }
        var $itemElement = renderer_default(actionArgs.args[0].itemElement);
        var $submenu = $itemElement.find(".".concat(DX_SUBMENU_CLASS));
        var shouldRenderSubmenu = this._hasSubmenu(node) && !$submenu.length;
        if (shouldRenderSubmenu) {
          this._renderSubmenuItems(node, $itemElement);
          $submenu = $itemElement.find(".".concat(DX_SUBMENU_CLASS));
        }
        if ($itemElement.context === $submenu.context && "visible" === $submenu.css("visibility")) {
          return;
        }
        var notCloseMenuOnItemClick = itemData && false === itemData.closeMenuOnClick;
        if (!itemData || itemData.disabled || notCloseMenuOnItemClick) {
          return;
        }
        this._updateSelectedItemOnClick(actionArgs);
        if (0 === $submenu.length) {
          var $prevSubmenu = renderer_default($itemElement.parents(".".concat(DX_SUBMENU_CLASS))[0]);
          this._hideSubmenu($prevSubmenu);
          if (!actionArgs.canceled && this._overlay && this._overlay.option("visible")) {
            this.option("visible", false);
          }
        } else {
          if (this._shownSubmenus && this._shownSubmenus.length > 0) {
            if (this._shownSubmenus[0].is($submenu)) {
              this._hideSubmenu($submenu);
            }
          }
          this._showSubmenu($itemElement);
        }
      }
      _hideSubmenu($curSubmenu) {
        var shownSubmenus = extend2([], this._shownSubmenus);
        each(shownSubmenus, (index2, $submenu) => {
          if ($curSubmenu.is($submenu) || contains2($curSubmenu[0], $submenu[0])) {
            $submenu.parent().removeClass(DX_MENU_ITEM_EXPANDED_CLASS2);
            this._hideSubmenuCore($submenu);
          }
        });
      }
      _hideSubmenuCore($submenu) {
        var index2 = inArray($submenu, this._shownSubmenus);
        var animation3 = this.option("animation") ? this.option("animation").hide : null;
        if (index2 >= 0) {
          this._shownSubmenus.splice(index2, 1);
        }
        this._stopAnimate($submenu);
        animation3 && this._animate($submenu, animation3);
        $submenu.css("visibility", "hidden");
      }
      _stopAnimate($container) {
        fx_default.stop($container, true);
      }
      _hideAllShownSubmenus() {
        var shownSubmenus = extend2([], this._shownSubmenus);
        var $expandedItems = this._overlay.$content().find(".".concat(DX_MENU_ITEM_EXPANDED_CLASS2));
        $expandedItems.removeClass(DX_MENU_ITEM_EXPANDED_CLASS2);
        each(shownSubmenus, (_2, $submenu) => {
          this._hideSubmenu($submenu);
        });
      }
      _visibilityChanged(visible2) {
        if (visible2) {
          this._renderContentImpl();
        }
      }
      _optionChanged(args) {
        if (inArray(args.name, ACTIONS2) > -1) {
          this._initActions();
          return;
        }
        switch (args.name) {
          case "visible":
            this._renderVisibility(args.value);
            break;
          case "showEvent":
          case "position":
          case "submenuDirection":
            this._invalidate();
            break;
          case "target":
            args.previousValue && this._detachShowContextMenuEvents(args.previousValue);
            this._invalidate();
            break;
          case "closeOnOutsideClick":
            break;
          default:
            super._optionChanged(args);
        }
      }
      _renderVisibility(showing) {
        return showing ? this._show() : this._hide();
      }
      _toggleVisibility() {
      }
      _show(event) {
        var args = {
          jQEvent: event
        };
        var promise2 = new Deferred().reject().promise();
        this._actions.onShowing(args);
        if (args.cancel) {
          return promise2;
        }
        var position3 = this._positionContextMenu(event);
        if (position3) {
          var _event$originalEvent;
          if (!this._overlay) {
            this._renderContextMenuOverlay();
            this._overlay.$content().addClass(this._widgetClass());
            this._renderFocusState();
            this._attachHoverEvents();
            this._attachClickEvent();
            this._renderItems(this._dataAdapter.getRootNodes());
          }
          this._setOptionWithoutOptionChange("visible", true);
          this._overlay.option("position", position3);
          promise2 = this._overlay.show();
          event && event.stopPropagation();
          this._setAriaAttributes();
          if ((null === event || void 0 === event ? void 0 : null === (_event$originalEvent = event.originalEvent) || void 0 === _event$originalEvent ? void 0 : _event$originalEvent.type) === hold_default.name) {
            this.preventShowingDefaultContextMenuAboveOverlay();
          }
        }
        return promise2;
      }
      _setAriaAttributes() {
        this._overlayContentId = "dx-".concat(new guid_default());
        this.setAria("owns", this._overlayContentId);
        this.setAria({
          id: this._overlayContentId,
          role: "menu"
        }, this._overlay.$content());
      }
      _cleanAriaAttributes() {
        this._overlay && this.setAria("id", null, this._overlay.$content());
        this.setAria("owns", void 0);
      }
      _getTarget() {
        return this.option("target") || this.option("position").of || renderer_default(dom_adapter_default.getDocument());
      }
      _getContextMenuPosition() {
        return extend2({}, this.option("position"), {
          of: this._getTarget()
        });
      }
      _positionContextMenu(jQEvent) {
        var position3 = this._getContextMenuPosition();
        var isInitialPosition = this._isInitialOptionValue("position");
        var positioningAction = this._createActionByOption("onPositioning", actionArgs);
        if (jQEvent && jQEvent.preventDefault && isInitialPosition) {
          position3.of = jQEvent;
        }
        var actionArgs = {
          position: position3,
          event: jQEvent
        };
        positioningAction(actionArgs);
        if (actionArgs.cancel) {
          position3 = null;
        } else if (actionArgs.event) {
          actionArgs.event.cancel = true;
          jQEvent.preventDefault();
        }
        return position3;
      }
      _refresh() {
        if (!hasWindow()) {
          super._refresh();
        } else if (this._overlay) {
          var lastPosition = this._overlay.option("position");
          super._refresh();
          this._overlay && this._overlay.option("position", lastPosition);
        } else {
          super._refresh();
        }
      }
      _hide() {
        var promise2;
        if (this._overlay) {
          promise2 = this._overlay.hide();
          this._setOptionWithoutOptionChange("visible", false);
        }
        this._cleanAriaAttributes();
        this.option("focusedElement", null);
        return promise2 || new Deferred().reject().promise();
      }
      toggle(showing) {
        var visible2 = this.option("visible");
        showing = void 0 === showing ? !visible2 : showing;
        return this._renderVisibility(showing);
      }
      show() {
        return this.toggle(true);
      }
      hide() {
        return this.toggle(false);
      }
    };
    component_registrator_default("dxContextMenu", ContextMenu2);
    ui_context_menu_default = ContextMenu2;
  }
});

// node_modules/devextreme/esm/ui/context_menu.js
var context_menu_default;
var init_context_menu = __esm({
  "node_modules/devextreme/esm/ui/context_menu.js"() {
    init_ui_context_menu();
    context_menu_default = ui_context_menu_default;
  }
});

// node_modules/devextreme/esm/ui/list/ui.list.edit.strategy.grouped.js
var LIST_ITEM_CLASS, LIST_GROUP_CLASS, SELECTION_SHIFT, SELECTION_MASK, combineIndex, splitIndex, GroupedEditStrategy, ui_list_edit_strategy_grouped_default;
var init_ui_list_edit_strategy_grouped = __esm({
  "node_modules/devextreme/esm/ui/list/ui.list.edit.strategy.grouped.js"() {
    init_renderer();
    init_type();
    init_iterator();
    init_store_helper();
    init_query();
    init_ui_collection_widget_edit_strategy_plain();
    LIST_ITEM_CLASS = "dx-list-item";
    LIST_GROUP_CLASS = "dx-list-group";
    SELECTION_SHIFT = 20;
    SELECTION_MASK = (1 << SELECTION_SHIFT) - 1;
    combineIndex = function(indices) {
      return (indices.group << SELECTION_SHIFT) + indices.item;
    };
    splitIndex = function(combinedIndex) {
      return {
        group: combinedIndex >> SELECTION_SHIFT,
        item: combinedIndex & SELECTION_MASK
      };
    };
    GroupedEditStrategy = ui_collection_widget_edit_strategy_plain_default.inherit({
      _groupElements: function() {
        return this._collectionWidget._itemContainer().find("." + LIST_GROUP_CLASS);
      },
      _groupItemElements: function($group) {
        return $group.find("." + LIST_ITEM_CLASS);
      },
      getIndexByItemData: function(itemData) {
        var groups = this._collectionWidget.option("items");
        var index2 = false;
        if (!itemData) {
          return false;
        }
        if (itemData.items && itemData.items.length) {
          itemData = itemData.items[0];
        }
        each(groups, function(groupIndex, group) {
          if (!group.items) {
            return false;
          }
          each(group.items, function(itemIndex, item) {
            if (item !== itemData) {
              return true;
            }
            index2 = {
              group: groupIndex,
              item: itemIndex
            };
            return false;
          });
          if (index2) {
            return false;
          }
        });
        return index2;
      },
      getItemDataByIndex: function(index2) {
        var items = this._collectionWidget.option("items");
        if (isNumeric(index2)) {
          return this.itemsGetter()[index2];
        }
        return index2 && items[index2.group] && items[index2.group].items[index2.item] || null;
      },
      itemsGetter: function() {
        var resultItems = [];
        var items = this._collectionWidget.option("items");
        for (var i = 0; i < items.length; i++) {
          if (items[i] && items[i].items) {
            resultItems = resultItems.concat(items[i].items);
          } else {
            resultItems.push(items[i]);
          }
        }
        return resultItems;
      },
      deleteItemAtIndex: function(index2) {
        var indices = splitIndex(index2);
        var itemGroup = this._collectionWidget.option("items")[indices.group].items;
        itemGroup.splice(indices.item, 1);
      },
      getKeysByItems: function(items) {
        var plainItems = [];
        var i;
        for (i = 0; i < items.length; i++) {
          if (items[i] && items[i].items) {
            plainItems = plainItems.concat(items[i].items);
          } else {
            plainItems.push(items[i]);
          }
        }
        var result2 = [];
        for (i = 0; i < plainItems.length; i++) {
          result2.push(this._collectionWidget.keyOf(plainItems[i]));
        }
        return result2;
      },
      getIndexByKey: function(key, items) {
        var groups = items || this._collectionWidget.option("items");
        var index2 = -1;
        var that = this;
        each(groups, function(groupIndex, group) {
          if (!group.items) {
            return;
          }
          each(group.items, function(itemIndex, item) {
            var itemKey = that._collectionWidget.keyOf(item);
            if (that._equalKeys(itemKey, key)) {
              index2 = {
                group: groupIndex,
                item: itemIndex
              };
              return false;
            }
          });
          if (-1 !== index2) {
            return false;
          }
        });
        return index2;
      },
      _getGroups: function(items) {
        var dataSource = this._collectionWidget.getDataSource();
        var group = dataSource && dataSource.group();
        if (group) {
          return store_helper_default.queryByOptions(query_default(items), {
            group
          }).toArray();
        }
        return this._collectionWidget.option("items");
      },
      getItemsByKeys: function(keys, items) {
        var result2 = [];
        var groups = this._getGroups(items);
        var groupItemByKeyMap = {};
        var getItemMeta = (key) => {
          var index2 = this.getIndexByKey(key, groups);
          var group = index2 && groups[index2.group];
          if (!group) {
            return;
          }
          return {
            groupKey: group.key,
            item: group.items[index2.item]
          };
        };
        each(keys, function(_2, key) {
          var itemMeta = getItemMeta(key);
          if (!itemMeta) {
            return;
          }
          var groupKey = itemMeta.groupKey;
          var item = itemMeta.item;
          var selectedGroup = groupItemByKeyMap[groupKey];
          if (!selectedGroup) {
            selectedGroup = {
              key: groupKey,
              items: []
            };
            groupItemByKeyMap[groupKey] = selectedGroup;
            result2.push(selectedGroup);
          }
          selectedGroup.items.push(item);
        });
        return result2;
      },
      moveItemAtIndexToIndex: function(movingIndex, destinationIndex) {
        var items = this._collectionWidget.option("items");
        var movingIndices = splitIndex(movingIndex);
        var destinationIndices = splitIndex(destinationIndex);
        var movingItemGroup = items[movingIndices.group].items;
        var destinationItemGroup = items[destinationIndices.group].items;
        var movedItemData = movingItemGroup[movingIndices.item];
        movingItemGroup.splice(movingIndices.item, 1);
        destinationItemGroup.splice(destinationIndices.item, 0, movedItemData);
      },
      _isItemIndex: function(index2) {
        return index2 && isNumeric(index2.group) && isNumeric(index2.item);
      },
      _getNormalizedItemIndex: function(itemElement) {
        var $item = renderer_default(itemElement);
        var $group = $item.closest("." + LIST_GROUP_CLASS);
        if (!$group.length) {
          return -1;
        }
        return combineIndex({
          group: this._groupElements().index($group),
          item: this._groupItemElements($group).index($item)
        });
      },
      _normalizeItemIndex: function(index2) {
        return combineIndex(index2);
      },
      _denormalizeItemIndex: function(index2) {
        return splitIndex(index2);
      },
      _getItemByNormalizedIndex: function(index2) {
        var indices = splitIndex(index2);
        var $group = this._groupElements().eq(indices.group);
        return this._groupItemElements($group).eq(indices.item);
      },
      _itemsFromSameParent: function(firstIndex, secondIndex) {
        return splitIndex(firstIndex).group === splitIndex(secondIndex).group;
      }
    });
    ui_list_edit_strategy_grouped_default = GroupedEditStrategy;
  }
});

// node_modules/devextreme/esm/ui/list/ui.list.edit.decorator_registry.js
function register(option, type2, decoratorClass) {
  var decoratorsRegistry = registry;
  var decoratorConfig = {};
  decoratorConfig[option] = decoratorsRegistry[option] ? decoratorsRegistry[option] : {};
  decoratorConfig[option][type2] = decoratorClass;
  extend2(decoratorsRegistry, decoratorConfig);
}
var registry;
var init_ui_list_edit_decorator_registry = __esm({
  "node_modules/devextreme/esm/ui/list/ui.list.edit.decorator_registry.js"() {
    init_extend();
    registry = {};
  }
});

// node_modules/devextreme/esm/events/swipe.js
var SWIPE_START_EVENT, SWIPE_EVENT, SWIPE_END_EVENT, HorizontalStrategy, VerticalStrategy, STRATEGIES, SwipeEmitter;
var init_swipe = __esm({
  "node_modules/devextreme/esm/events/swipe.js"() {
    init_utils2();
    init_emitter_gesture();
    init_emitter_registrator();
    SWIPE_START_EVENT = "dxswipestart";
    SWIPE_EVENT = "dxswipe";
    SWIPE_END_EVENT = "dxswipeend";
    HorizontalStrategy = {
      defaultItemSizeFunc: function() {
        return this.getElement().width();
      },
      getBounds: function() {
        return [this._maxLeftOffset, this._maxRightOffset];
      },
      calcOffsetRatio: function(e) {
        var endEventData = eventData(e);
        return (endEventData.x - (this._savedEventData && this._savedEventData.x || 0)) / this._itemSizeFunc().call(this, e);
      },
      isFastSwipe: function(e) {
        var endEventData = eventData(e);
        return this.FAST_SWIPE_SPEED_LIMIT * Math.abs(endEventData.x - this._tickData.x) >= endEventData.time - this._tickData.time;
      }
    };
    VerticalStrategy = {
      defaultItemSizeFunc: function() {
        return this.getElement().height();
      },
      getBounds: function() {
        return [this._maxTopOffset, this._maxBottomOffset];
      },
      calcOffsetRatio: function(e) {
        var endEventData = eventData(e);
        return (endEventData.y - (this._savedEventData && this._savedEventData.y || 0)) / this._itemSizeFunc().call(this, e);
      },
      isFastSwipe: function(e) {
        var endEventData = eventData(e);
        return this.FAST_SWIPE_SPEED_LIMIT * Math.abs(endEventData.y - this._tickData.y) >= endEventData.time - this._tickData.time;
      }
    };
    STRATEGIES = {
      horizontal: HorizontalStrategy,
      vertical: VerticalStrategy
    };
    SwipeEmitter = emitter_gesture_default.inherit({
      TICK_INTERVAL: 300,
      FAST_SWIPE_SPEED_LIMIT: 10,
      ctor: function(element) {
        this.callBase(element);
        this.direction = "horizontal";
        this.elastic = true;
      },
      _getStrategy: function() {
        return STRATEGIES[this.direction];
      },
      _defaultItemSizeFunc: function() {
        return this._getStrategy().defaultItemSizeFunc.call(this);
      },
      _itemSizeFunc: function() {
        return this.itemSizeFunc || this._defaultItemSizeFunc;
      },
      _init: function(e) {
        this._tickData = eventData(e);
      },
      _start: function(e) {
        this._savedEventData = eventData(e);
        e = this._fireEvent(SWIPE_START_EVENT, e);
        if (!e.cancel) {
          this._maxLeftOffset = e.maxLeftOffset;
          this._maxRightOffset = e.maxRightOffset;
          this._maxTopOffset = e.maxTopOffset;
          this._maxBottomOffset = e.maxBottomOffset;
        }
      },
      _move: function(e) {
        var strategy3 = this._getStrategy();
        var moveEventData = eventData(e);
        var offset2 = strategy3.calcOffsetRatio.call(this, e);
        offset2 = this._fitOffset(offset2, this.elastic);
        if (moveEventData.time - this._tickData.time > this.TICK_INTERVAL) {
          this._tickData = moveEventData;
        }
        this._fireEvent(SWIPE_EVENT, e, {
          offset: offset2
        });
        e.preventDefault();
      },
      _end: function(e) {
        var strategy3 = this._getStrategy();
        var offsetRatio = strategy3.calcOffsetRatio.call(this, e);
        var isFast = strategy3.isFastSwipe.call(this, e);
        var startOffset = offsetRatio;
        var targetOffset = this._calcTargetOffset(offsetRatio, isFast);
        startOffset = this._fitOffset(startOffset, this.elastic);
        targetOffset = this._fitOffset(targetOffset, false);
        this._fireEvent(SWIPE_END_EVENT, e, {
          offset: startOffset,
          targetOffset
        });
      },
      _fitOffset: function(offset2, elastic) {
        var strategy3 = this._getStrategy();
        var bounds = strategy3.getBounds.call(this);
        if (offset2 < -bounds[0]) {
          return elastic ? (-2 * bounds[0] + offset2) / 3 : -bounds[0];
        }
        if (offset2 > bounds[1]) {
          return elastic ? (2 * bounds[1] + offset2) / 3 : bounds[1];
        }
        return offset2;
      },
      _calcTargetOffset: function(offsetRatio, isFast) {
        var result2;
        if (isFast) {
          result2 = Math.ceil(Math.abs(offsetRatio));
          if (offsetRatio < 0) {
            result2 = -result2;
          }
        } else {
          result2 = Math.round(offsetRatio);
        }
        return result2;
      }
    });
    emitter_registrator_default({
      emitter: SwipeEmitter,
      events: [SWIPE_START_EVENT, SWIPE_EVENT, SWIPE_END_EVENT]
    });
  }
});

// node_modules/devextreme/esm/ui/list/ui.list.edit.decorator.js
var LIST_EDIT_DECORATOR, SWIPE_START_EVENT_NAME, SWIPE_UPDATE_EVENT_NAME, SWIPE_END_EVENT_NAME, EditDecorator, ui_list_edit_decorator_default;
var init_ui_list_edit_decorator = __esm({
  "node_modules/devextreme/esm/ui/list/ui.list.edit.decorator.js"() {
    init_renderer();
    init_events_engine();
    init_common();
    init_class();
    init_swipe();
    init_utils2();
    LIST_EDIT_DECORATOR = "dxListEditDecorator";
    SWIPE_START_EVENT_NAME = addNamespace2(SWIPE_START_EVENT, LIST_EDIT_DECORATOR);
    SWIPE_UPDATE_EVENT_NAME = addNamespace2(SWIPE_EVENT, LIST_EDIT_DECORATOR);
    SWIPE_END_EVENT_NAME = addNamespace2(SWIPE_END_EVENT, LIST_EDIT_DECORATOR);
    EditDecorator = class_default.inherit({
      ctor: function(list) {
        this._list = list;
        this._init();
      },
      _init: noop2,
      _shouldHandleSwipe: false,
      _attachSwipeEvent: function(config2) {
        var swipeConfig = {
          itemSizeFunc: (function() {
            if (this._clearSwipeCache) {
              this._itemWidthCache = this._list.$element().width();
              this._clearSwipeCache = false;
            }
            return this._itemWidthCache;
          }).bind(this)
        };
        events_engine_default.on(config2.$itemElement, SWIPE_START_EVENT_NAME, swipeConfig, this._itemSwipeStartHandler.bind(this));
        events_engine_default.on(config2.$itemElement, SWIPE_UPDATE_EVENT_NAME, this._itemSwipeUpdateHandler.bind(this));
        events_engine_default.on(config2.$itemElement, SWIPE_END_EVENT_NAME, this._itemSwipeEndHandler.bind(this));
      },
      _itemSwipeStartHandler: function(e) {
        var $itemElement = renderer_default(e.currentTarget);
        if ($itemElement.is(".dx-state-disabled, .dx-state-disabled *")) {
          e.cancel = true;
          return;
        }
        clearTimeout(this._list._inkRippleTimer);
        this._swipeStartHandler($itemElement, e);
      },
      _itemSwipeUpdateHandler: function(e) {
        var $itemElement = renderer_default(e.currentTarget);
        this._swipeUpdateHandler($itemElement, e);
      },
      _itemSwipeEndHandler: function(e) {
        var $itemElement = renderer_default(e.currentTarget);
        this._swipeEndHandler($itemElement, e);
        this._clearSwipeCache = true;
      },
      beforeBag: noop2,
      afterBag: noop2,
      _commonOptions: function() {
        return {
          activeStateEnabled: this._list.option("activeStateEnabled"),
          hoverStateEnabled: this._list.option("hoverStateEnabled"),
          focusStateEnabled: this._list.option("focusStateEnabled")
        };
      },
      modifyElement: function(config2) {
        if (this._shouldHandleSwipe) {
          this._attachSwipeEvent(config2);
          this._clearSwipeCache = true;
        }
      },
      afterRender: noop2,
      handleClick: noop2,
      handleKeyboardEvents: noop2,
      handleEnterPressing: noop2,
      handleContextMenu: noop2,
      _swipeStartHandler: noop2,
      _swipeUpdateHandler: noop2,
      _swipeEndHandler: noop2,
      visibilityChange: noop2,
      getExcludedSelectors: noop2,
      dispose: noop2
    });
    ui_list_edit_decorator_default = EditDecorator;
  }
});

// node_modules/devextreme/esm/ui/list/ui.list.edit.decorator.static.js
var STATIC_DELETE_BUTTON_CONTAINER_CLASS, STATIC_DELETE_BUTTON_CLASS;
var init_ui_list_edit_decorator_static = __esm({
  "node_modules/devextreme/esm/ui/list/ui.list.edit.decorator.static.js"() {
    init_renderer();
    init_button();
    init_ui_list_edit_decorator_registry();
    init_ui_list_edit_decorator();
    STATIC_DELETE_BUTTON_CONTAINER_CLASS = "dx-list-static-delete-button-container";
    STATIC_DELETE_BUTTON_CLASS = "dx-list-static-delete-button";
    register("delete", "static", ui_list_edit_decorator_default.inherit({
      afterBag: function(config2) {
        var $itemElement = config2.$itemElement;
        var $container = config2.$container;
        var $button = renderer_default("<div>").addClass(STATIC_DELETE_BUTTON_CLASS);
        this._list._createComponent($button, button_default, {
          icon: "remove",
          onClick: (function(args) {
            args.event.stopPropagation();
            this._deleteItem($itemElement);
          }).bind(this),
          integrationOptions: {}
        });
        $container.addClass(STATIC_DELETE_BUTTON_CONTAINER_CLASS).append($button);
      },
      _deleteItem: function($itemElement) {
        if ($itemElement.is(".dx-state-disabled, .dx-state-disabled *")) {
          return;
        }
        this._list.deleteItem($itemElement);
      }
    }));
  }
});

// node_modules/devextreme/esm/ui/list/ui.list.edit.decorator.switchable.js
var abstract5, LIST_EDIT_DECORATOR2, POINTER_DOWN_EVENT_NAME, ACTIVE_EVENT_NAME2, LIST_ITEM_CONTENT_CLASS, SWITCHABLE_DELETE_READY_CLASS, SWITCHABLE_MENU_SHIELD_POSITIONING_CLASS, SWITCHABLE_DELETE_TOP_SHIELD_CLASS, SWITCHABLE_DELETE_BOTTOM_SHIELD_CLASS, SWITCHABLE_MENU_ITEM_SHIELD_POSITIONING_CLASS, SWITCHABLE_DELETE_ITEM_CONTENT_SHIELD_CLASS, SWITCHABLE_DELETE_BUTTON_CONTAINER_CLASS, SwitchableEditDecorator, ui_list_edit_decorator_switchable_default;
var init_ui_list_edit_decorator_switchable = __esm({
  "node_modules/devextreme/esm/ui/list/ui.list.edit.decorator.switchable.js"() {
    init_renderer();
    init_events_engine();
    init_common();
    init_ui_list_edit_decorator();
    init_utils2();
    init_pointer();
    init_emitter_feedback();
    abstract5 = ui_list_edit_decorator_default.abstract;
    LIST_EDIT_DECORATOR2 = "dxListEditDecorator";
    POINTER_DOWN_EVENT_NAME = addNamespace2(pointer_default.down, LIST_EDIT_DECORATOR2);
    ACTIVE_EVENT_NAME2 = addNamespace2(ACTIVE_EVENT_NAME, LIST_EDIT_DECORATOR2);
    LIST_ITEM_CONTENT_CLASS = "dx-list-item-content";
    SWITCHABLE_DELETE_READY_CLASS = "dx-list-switchable-delete-ready";
    SWITCHABLE_MENU_SHIELD_POSITIONING_CLASS = "dx-list-switchable-menu-shield-positioning";
    SWITCHABLE_DELETE_TOP_SHIELD_CLASS = "dx-list-switchable-delete-top-shield";
    SWITCHABLE_DELETE_BOTTOM_SHIELD_CLASS = "dx-list-switchable-delete-bottom-shield";
    SWITCHABLE_MENU_ITEM_SHIELD_POSITIONING_CLASS = "dx-list-switchable-menu-item-shield-positioning";
    SWITCHABLE_DELETE_ITEM_CONTENT_SHIELD_CLASS = "dx-list-switchable-delete-item-content-shield";
    SWITCHABLE_DELETE_BUTTON_CONTAINER_CLASS = "dx-list-switchable-delete-button-container";
    SwitchableEditDecorator = ui_list_edit_decorator_default.inherit({
      _init: function() {
        this._$topShield = renderer_default("<div>").addClass(SWITCHABLE_DELETE_TOP_SHIELD_CLASS);
        this._$bottomShield = renderer_default("<div>").addClass(SWITCHABLE_DELETE_BOTTOM_SHIELD_CLASS);
        this._$itemContentShield = renderer_default("<div>").addClass(SWITCHABLE_DELETE_ITEM_CONTENT_SHIELD_CLASS);
        events_engine_default.on(this._$topShield, POINTER_DOWN_EVENT_NAME, this._cancelDeleteReadyItem.bind(this));
        events_engine_default.on(this._$bottomShield, POINTER_DOWN_EVENT_NAME, this._cancelDeleteReadyItem.bind(this));
        this._list.$element().append(this._$topShield.toggle(false)).append(this._$bottomShield.toggle(false));
      },
      handleClick: function() {
        return this._cancelDeleteReadyItem();
      },
      _cancelDeleteReadyItem: function() {
        if (!this._$readyToDeleteItem) {
          return false;
        }
        this._cancelDelete(this._$readyToDeleteItem);
        return true;
      },
      _cancelDelete: function($itemElement) {
        this._toggleDeleteReady($itemElement, false);
      },
      _toggleDeleteReady: function($itemElement, readyToDelete) {
        if (void 0 === readyToDelete) {
          readyToDelete = !this._isReadyToDelete($itemElement);
        }
        this._toggleShields($itemElement, readyToDelete);
        this._toggleScrolling(readyToDelete);
        this._cacheReadyToDeleteItem($itemElement, readyToDelete);
        this._animateToggleDelete($itemElement, readyToDelete);
      },
      _isReadyToDelete: function($itemElement) {
        return $itemElement.hasClass(SWITCHABLE_DELETE_READY_CLASS);
      },
      _toggleShields: function($itemElement, enabled) {
        this._list.$element().toggleClass(SWITCHABLE_MENU_SHIELD_POSITIONING_CLASS, enabled);
        this._$topShield.toggle(enabled);
        this._$bottomShield.toggle(enabled);
        if (enabled) {
          this._updateShieldsHeight($itemElement);
        }
        this._toggleContentShield($itemElement, enabled);
      },
      _updateShieldsHeight: function($itemElement) {
        var $list = this._list.$element();
        var listTopOffset = $list.offset().top;
        var listHeight = $list.outerHeight();
        var itemTopOffset = $itemElement.offset().top;
        var itemHeight = $itemElement.outerHeight();
        var dirtyTopShieldHeight = itemTopOffset - listTopOffset;
        var dirtyBottomShieldHeight = listHeight - itemHeight - dirtyTopShieldHeight;
        this._$topShield.height(Math.max(dirtyTopShieldHeight, 0));
        this._$bottomShield.height(Math.max(dirtyBottomShieldHeight, 0));
      },
      _toggleContentShield: function($itemElement, enabled) {
        if (enabled) {
          $itemElement.find("." + LIST_ITEM_CONTENT_CLASS).first().append(this._$itemContentShield);
        } else {
          this._$itemContentShield.detach();
        }
      },
      _toggleScrolling: function(readyToDelete) {
        var scrollView = this._list.$element().dxScrollView("instance");
        if (readyToDelete) {
          scrollView.on("start", this._cancelScrolling);
        } else {
          scrollView.off("start", this._cancelScrolling);
        }
      },
      _cancelScrolling: function(args) {
        args.event.cancel = true;
      },
      _cacheReadyToDeleteItem: function($itemElement, cache) {
        if (cache) {
          this._$readyToDeleteItem = $itemElement;
        } else {
          delete this._$readyToDeleteItem;
        }
      },
      _animateToggleDelete: function($itemElement, readyToDelete) {
        if (readyToDelete) {
          this._enablePositioning($itemElement);
          this._prepareDeleteReady($itemElement);
          this._animatePrepareDeleteReady($itemElement);
          events_engine_default.off($itemElement, pointer_default.up);
        } else {
          this._forgetDeleteReady($itemElement);
          this._animateForgetDeleteReady($itemElement).done(this._disablePositioning.bind(this, $itemElement));
        }
      },
      _enablePositioning: function($itemElement) {
        $itemElement.addClass(SWITCHABLE_MENU_ITEM_SHIELD_POSITIONING_CLASS);
        events_engine_default.on($itemElement, ACTIVE_EVENT_NAME2, noop2);
        events_engine_default.one($itemElement, pointer_default.up, this._disablePositioning.bind(this, $itemElement));
      },
      _disablePositioning: function($itemElement) {
        $itemElement.removeClass(SWITCHABLE_MENU_ITEM_SHIELD_POSITIONING_CLASS);
        events_engine_default.off($itemElement, ACTIVE_EVENT_NAME2);
      },
      _prepareDeleteReady: function($itemElement) {
        $itemElement.addClass(SWITCHABLE_DELETE_READY_CLASS);
      },
      _forgetDeleteReady: function($itemElement) {
        $itemElement.removeClass(SWITCHABLE_DELETE_READY_CLASS);
      },
      _animatePrepareDeleteReady: abstract5,
      _animateForgetDeleteReady: abstract5,
      _getDeleteButtonContainer: function($itemElement) {
        $itemElement = $itemElement || this._$readyToDeleteItem;
        return $itemElement.children("." + SWITCHABLE_DELETE_BUTTON_CONTAINER_CLASS);
      },
      _deleteItem: function($itemElement) {
        $itemElement = $itemElement || this._$readyToDeleteItem;
        this._getDeleteButtonContainer($itemElement).detach();
        if ($itemElement.is(".dx-state-disabled, .dx-state-disabled *")) {
          return;
        }
        this._list.deleteItem($itemElement).always(this._cancelDelete.bind(this, $itemElement));
      },
      _isRtlEnabled: function() {
        return this._list.option("rtlEnabled");
      },
      dispose: function() {
        if (this._$topShield) {
          this._$topShield.remove();
        }
        if (this._$bottomShield) {
          this._$bottomShield.remove();
        }
        this.callBase.apply(this, arguments);
      }
    });
    ui_list_edit_decorator_switchable_default = SwitchableEditDecorator;
  }
});

// node_modules/devextreme/esm/ui/list/ui.list.edit.decorator.switchable.button.js
var SWITCHABLE_DELETE_BUTTON_CONTAINER_CLASS2, SWITCHABLE_DELETE_BUTTON_WRAPPER_CLASS, SWITCHABLE_DELETE_BUTTON_INNER_WRAPPER_CLASS, SWITCHABLE_DELETE_BUTTON_CLASS, SWITCHABLE_DELETE_BUTTON_ANIMATION_DURATION, SwitchableButtonEditDecorator, TOGGLE_DELETE_SWITCH_CONTAINER_CLASS, TOGGLE_DELETE_SWITCH_CLASS;
var init_ui_list_edit_decorator_switchable_button = __esm({
  "node_modules/devextreme/esm/ui/list/ui.list.edit.decorator.switchable.button.js"() {
    init_renderer();
    init_fx();
    init_button();
    init_message();
    init_ui_list_edit_decorator_registry();
    init_ui_list_edit_decorator_switchable();
    SWITCHABLE_DELETE_BUTTON_CONTAINER_CLASS2 = "dx-list-switchable-delete-button-container";
    SWITCHABLE_DELETE_BUTTON_WRAPPER_CLASS = "dx-list-switchable-delete-button-wrapper";
    SWITCHABLE_DELETE_BUTTON_INNER_WRAPPER_CLASS = "dx-list-switchable-delete-button-inner-wrapper";
    SWITCHABLE_DELETE_BUTTON_CLASS = "dx-list-switchable-delete-button";
    SWITCHABLE_DELETE_BUTTON_ANIMATION_DURATION = 200;
    SwitchableButtonEditDecorator = ui_list_edit_decorator_switchable_default.inherit({
      _init: function() {
        this.callBase.apply(this, arguments);
        var $buttonContainer = renderer_default("<div>").addClass(SWITCHABLE_DELETE_BUTTON_CONTAINER_CLASS2);
        var $buttonWrapper = renderer_default("<div>").addClass(SWITCHABLE_DELETE_BUTTON_WRAPPER_CLASS);
        var $buttonInnerWrapper = renderer_default("<div>").addClass(SWITCHABLE_DELETE_BUTTON_INNER_WRAPPER_CLASS);
        var $button = renderer_default("<div>").addClass(SWITCHABLE_DELETE_BUTTON_CLASS);
        this._list._createComponent($button, button_default, {
          text: message_default.format("dxListEditDecorator-delete"),
          type: "danger",
          onClick: (function(e) {
            this._deleteItem();
            e.event.stopPropagation();
          }).bind(this),
          integrationOptions: {}
        });
        $buttonContainer.append($buttonWrapper);
        $buttonWrapper.append($buttonInnerWrapper);
        $buttonInnerWrapper.append($button);
        this._$buttonContainer = $buttonContainer;
      },
      _enablePositioning: function($itemElement) {
        this.callBase.apply(this, arguments);
        fx_default.stop(this._$buttonContainer, true);
        this._$buttonContainer.appendTo($itemElement);
      },
      _disablePositioning: function() {
        this.callBase.apply(this, arguments);
        this._$buttonContainer.detach();
      },
      _animatePrepareDeleteReady: function() {
        var rtl = this._isRtlEnabled();
        var listWidth = this._list.$element().width();
        var buttonWidth = this._buttonWidth();
        var fromValue = rtl ? listWidth : -buttonWidth;
        var toValue = rtl ? listWidth - buttonWidth : 0;
        return fx_default.animate(this._$buttonContainer, {
          type: "custom",
          duration: SWITCHABLE_DELETE_BUTTON_ANIMATION_DURATION,
          from: {
            right: fromValue
          },
          to: {
            right: toValue
          }
        });
      },
      _animateForgetDeleteReady: function() {
        var rtl = this._isRtlEnabled();
        var listWidth = this._list.$element().width();
        var buttonWidth = this._buttonWidth();
        var fromValue = rtl ? listWidth - buttonWidth : 0;
        var toValue = rtl ? listWidth : -buttonWidth;
        return fx_default.animate(this._$buttonContainer, {
          type: "custom",
          duration: SWITCHABLE_DELETE_BUTTON_ANIMATION_DURATION,
          from: {
            right: fromValue
          },
          to: {
            right: toValue
          }
        });
      },
      _buttonWidth: function() {
        if (!this._buttonContainerWidth) {
          this._buttonContainerWidth = this._$buttonContainer.outerWidth();
        }
        return this._buttonContainerWidth;
      },
      dispose: function() {
        if (this._$buttonContainer) {
          this._$buttonContainer.remove();
        }
        this.callBase.apply(this, arguments);
      }
    });
    TOGGLE_DELETE_SWITCH_CONTAINER_CLASS = "dx-list-toggle-delete-switch-container";
    TOGGLE_DELETE_SWITCH_CLASS = "dx-list-toggle-delete-switch";
    register("delete", "toggle", SwitchableButtonEditDecorator.inherit({
      beforeBag: function(config2) {
        var $itemElement = config2.$itemElement;
        var $container = config2.$container;
        var $toggle = renderer_default("<div>").addClass(TOGGLE_DELETE_SWITCH_CLASS);
        this._list._createComponent($toggle, button_default, {
          icon: "toggle-delete",
          onClick: (function(e) {
            fx_default.stop(this._$buttonContainer, false);
            this._toggleDeleteReady($itemElement);
            e.event.stopPropagation();
          }).bind(this),
          integrationOptions: {}
        });
        $container.addClass(TOGGLE_DELETE_SWITCH_CONTAINER_CLASS);
        $container.append($toggle);
      }
    }));
    register("delete", "slideButton", SwitchableButtonEditDecorator.inherit({
      _shouldHandleSwipe: true,
      _swipeEndHandler: function($itemElement, args) {
        if (0 !== args.targetOffset) {
          fx_default.stop(this._$buttonContainer, false);
          this._toggleDeleteReady($itemElement);
        }
        return true;
      }
    }));
  }
});

// node_modules/devextreme/esm/ui/list/ui.list.edit.decorator_menu_helper.js
var EditDecoratorMenuHelperMixin, ui_list_edit_decorator_menu_helper_default;
var init_ui_list_edit_decorator_menu_helper = __esm({
  "node_modules/devextreme/esm/ui/list/ui.list.edit.decorator_menu_helper.js"() {
    EditDecoratorMenuHelperMixin = {
      _menuEnabled: function() {
        return !!this._menuItems().length;
      },
      _menuItems: function() {
        return this._list.option("menuItems");
      },
      _deleteEnabled: function() {
        return this._list.option("allowItemDeleting");
      },
      _fireMenuAction: function($itemElement, action) {
        this._list._itemEventHandlerByHandler($itemElement, action, {}, {
          excludeValidators: ["disabled", "readOnly"]
        });
      }
    };
    ui_list_edit_decorator_menu_helper_default = EditDecoratorMenuHelperMixin;
  }
});

// node_modules/devextreme/esm/ui/collection/ui.collection_widget.async.js
var AsyncCollectionWidget, ui_collection_widget_async_default;
var init_ui_collection_widget_async = __esm({
  "node_modules/devextreme/esm/ui/collection/ui.collection_widget.async.js"() {
    init_ui_collection_widget_edit();
    init_deferred();
    init_common();
    AsyncCollectionWidget = ui_collection_widget_edit_default.inherit({
      _initMarkup() {
        this._deferredItems = [];
        this.callBase();
      },
      _renderItemContent(args) {
        var renderContentDeferred = new Deferred();
        var itemDeferred = new Deferred();
        this._deferredItems[args.index] = itemDeferred;
        var $itemContent = this.callBase.call(this, args);
        itemDeferred.done(() => {
          renderContentDeferred.resolve($itemContent);
        });
        return renderContentDeferred.promise();
      },
      _createItemByTemplate(itemTemplate, renderArgs) {
        return itemTemplate.render({
          model: renderArgs.itemData,
          container: renderArgs.container,
          index: renderArgs.index,
          onRendered: () => {
            this._deferredItems[renderArgs.index].resolve();
          }
        });
      },
      _postProcessRenderItems: noop2,
      _renderItemsAsync() {
        var d = new Deferred();
        when.apply(this, this._deferredItems).done(() => {
          this._postProcessRenderItems();
          d.resolve();
        });
        return d.promise();
      },
      _clean() {
        this.callBase();
        this._deferredItems = [];
      }
    });
    ui_collection_widget_async_default = AsyncCollectionWidget;
  }
});

// node_modules/devextreme/esm/ui/toolbar/constants.js
var TOOLBAR_CLASS;
var init_constants = __esm({
  "node_modules/devextreme/esm/ui/toolbar/constants.js"() {
    TOOLBAR_CLASS = "dx-toolbar";
  }
});

// node_modules/devextreme/esm/ui/toolbar/ui.toolbar.base.js
var TOOLBAR_BEFORE_CLASS, TOOLBAR_CENTER_CLASS, TOOLBAR_AFTER_CLASS, TOOLBAR_MINI_CLASS, TOOLBAR_ITEM_CLASS, TOOLBAR_LABEL_CLASS, TOOLBAR_BUTTON_CLASS, TOOLBAR_ITEMS_CONTAINER_CLASS, TOOLBAR_GROUP_CLASS, TOOLBAR_COMPACT_CLASS, TOOLBAR_LABEL_SELECTOR, TOOLBAR_MULTILINE_CLASS, TEXT_BUTTON_MODE, DEFAULT_BUTTON_TYPE, TOOLBAR_ITEM_DATA_KEY, ToolbarBase, ui_toolbar_base_default;
var init_ui_toolbar_base = __esm({
  "node_modules/devextreme/esm/ui/toolbar/ui.toolbar.base.js"() {
    init_renderer();
    init_themes();
    init_common();
    init_type();
    init_component_registrator();
    init_array();
    init_extend();
    init_iterator();
    init_position();
    init_ui_collection_widget_async();
    init_promise();
    init_bindable_template();
    init_errors();
    init_fx();
    init_constants();
    TOOLBAR_BEFORE_CLASS = "dx-toolbar-before";
    TOOLBAR_CENTER_CLASS = "dx-toolbar-center";
    TOOLBAR_AFTER_CLASS = "dx-toolbar-after";
    TOOLBAR_MINI_CLASS = "dx-toolbar-mini";
    TOOLBAR_ITEM_CLASS = "dx-toolbar-item";
    TOOLBAR_LABEL_CLASS = "dx-toolbar-label";
    TOOLBAR_BUTTON_CLASS = "dx-toolbar-button";
    TOOLBAR_ITEMS_CONTAINER_CLASS = "dx-toolbar-items-container";
    TOOLBAR_GROUP_CLASS = "dx-toolbar-group";
    TOOLBAR_COMPACT_CLASS = "dx-toolbar-compact";
    TOOLBAR_LABEL_SELECTOR = "." + TOOLBAR_LABEL_CLASS;
    TOOLBAR_MULTILINE_CLASS = "dx-toolbar-multiline";
    TEXT_BUTTON_MODE = "text";
    DEFAULT_BUTTON_TYPE = "default";
    TOOLBAR_ITEM_DATA_KEY = "dxToolbarItemDataKey";
    ToolbarBase = ui_collection_widget_async_default.inherit({
      compactMode: false,
      ctor: function(element, options2) {
        this._userOptions = options2 || {};
        this.callBase(element, options2);
        if ("height" in this._userOptions) {
          errors_default.log("W0001", this.NAME, "height", "20.1", "Functionality associated with this option is not intended for the Toolbar widget.");
        }
      },
      _getSynchronizableOptionsForCreateComponent: function() {
        return this.callBase().filter((item) => "disabled" !== item);
      },
      _initTemplates: function() {
        this.callBase();
        var template = new BindableTemplate((function($container, data2, rawModel) {
          if (isPlainObject(data2)) {
            if (data2.text) {
              $container.text(data2.text).wrapInner("<div>");
            }
            if (data2.html) {
              $container.html(data2.html);
            }
            if ("dxButton" === data2.widget) {
              if (this.option("useFlatButtons")) {
                data2.options = data2.options || {};
                data2.options.stylingMode = data2.options.stylingMode || TEXT_BUTTON_MODE;
              }
              if (this.option("useDefaultButtons")) {
                data2.options = data2.options || {};
                data2.options.type = data2.options.type || DEFAULT_BUTTON_TYPE;
              }
            }
          } else {
            $container.text(String(data2));
          }
          this._getTemplate("dx-polymorph-widget").render({
            container: $container,
            model: rawModel,
            parent: this
          });
        }).bind(this), ["text", "html", "widget", "options"], this.option("integrationOptions.watchMethod"));
        this._templateManager.addDefaultTemplates({
          item: template,
          menuItem: template
        });
      },
      _getDefaultOptions: function() {
        return extend2(this.callBase(), {
          renderAs: "topToolbar",
          grouped: false,
          useFlatButtons: false,
          useDefaultButtons: false,
          multiline: false
        });
      },
      _defaultOptionsRules: function() {
        return this.callBase().concat([{
          device: function() {
            return isMaterial();
          },
          options: {
            useFlatButtons: true
          }
        }]);
      },
      _itemContainer: function() {
        return this._$toolbarItemsContainer.find(["." + TOOLBAR_BEFORE_CLASS, "." + TOOLBAR_CENTER_CLASS, "." + TOOLBAR_AFTER_CLASS].join(","));
      },
      _itemClass: function() {
        return TOOLBAR_ITEM_CLASS;
      },
      _itemDataKey: function() {
        return TOOLBAR_ITEM_DATA_KEY;
      },
      _buttonClass: function() {
        return TOOLBAR_BUTTON_CLASS;
      },
      _dimensionChanged: function() {
        this._arrangeItems();
        this._applyCompactMode();
      },
      _initMarkup: function() {
        this._renderToolbar();
        this._renderSections();
        this.callBase();
        this.setAria("role", "toolbar");
      },
      _waitParentAnimationFinished: function() {
        var $element = this.$element();
        return new promise_default((resolve) => {
          var runCheck = () => {
            clearTimeout(this._waitParentAnimationTimeout);
            this._waitParentAnimationTimeout = setTimeout(() => (() => {
              var readyToResolve = true;
              $element.parents().each((_2, parent) => {
                if (fx_default.isAnimating(renderer_default(parent))) {
                  readyToResolve = false;
                  return false;
                }
              });
              if (readyToResolve) {
                resolve();
              }
              return readyToResolve;
            })() || runCheck(), 15);
          };
          runCheck();
        });
      },
      _render: function() {
        this.callBase();
        this._renderItemsAsync();
        if (isMaterial()) {
          promise_default.all([this._waitParentAnimationFinished(), this._checkWebFontForLabelsLoaded()]).then(this._dimensionChanged.bind(this));
        }
      },
      _postProcessRenderItems: function() {
        this._arrangeItems();
      },
      _renderToolbar: function() {
        this.$element().addClass(TOOLBAR_CLASS).toggleClass(TOOLBAR_MULTILINE_CLASS, this.option("multiline"));
        this._$toolbarItemsContainer = renderer_default("<div>").addClass(TOOLBAR_ITEMS_CONTAINER_CLASS).appendTo(this.$element());
      },
      _renderSections: function() {
        var $container = this._$toolbarItemsContainer;
        var that = this;
        each(["before", "center", "after"], function() {
          var sectionClass = "dx-toolbar-" + this;
          var $section = $container.find("." + sectionClass);
          if (!$section.length) {
            that["_$" + this + "Section"] = $section = renderer_default("<div>").addClass(sectionClass).appendTo($container);
          }
        });
      },
      _checkWebFontForLabelsLoaded: function() {
        var $labels = this.$element().find(TOOLBAR_LABEL_SELECTOR);
        var promises = [];
        $labels.each((_2, label) => {
          var text = renderer_default(label).text();
          var fontWeight = renderer_default(label).css("fontWeight");
          promises.push(waitWebFont(text, fontWeight));
        });
        return promise_default.all(promises);
      },
      _arrangeItems: function(elementWidth) {
        elementWidth = elementWidth || this.$element().width();
        this._$centerSection.css({
          margin: "0 auto",
          float: "none"
        });
        var beforeRect = getBoundingRect(this._$beforeSection.get(0));
        var afterRect = getBoundingRect(this._$afterSection.get(0));
        this._alignCenterSection(beforeRect, afterRect, elementWidth);
        var $label = this._$toolbarItemsContainer.find(TOOLBAR_LABEL_SELECTOR).eq(0);
        var $section = $label.parent();
        if (!$label.length) {
          return;
        }
        var labelOffset = beforeRect.width ? beforeRect.width : $label.position().left;
        var widthBeforeSection = $section.hasClass(TOOLBAR_BEFORE_CLASS) ? 0 : labelOffset;
        var widthAfterSection = $section.hasClass(TOOLBAR_AFTER_CLASS) ? 0 : afterRect.width;
        var elemsAtSectionWidth = 0;
        $section.children().not(TOOLBAR_LABEL_SELECTOR).each(function() {
          elemsAtSectionWidth += renderer_default(this).outerWidth();
        });
        var freeSpace = elementWidth - elemsAtSectionWidth;
        var sectionMaxWidth = Math.max(freeSpace - widthBeforeSection - widthAfterSection, 0);
        if ($section.hasClass(TOOLBAR_BEFORE_CLASS)) {
          this._alignSection(this._$beforeSection, sectionMaxWidth);
        } else {
          var labelPaddings = $label.outerWidth() - $label.width();
          $label.css("maxWidth", sectionMaxWidth - labelPaddings);
        }
      },
      _alignCenterSection: function(beforeRect, afterRect, elementWidth) {
        this._alignSection(this._$centerSection, elementWidth - beforeRect.width - afterRect.width);
        var isRTL = this.option("rtlEnabled");
        var leftRect = isRTL ? afterRect : beforeRect;
        var rightRect = isRTL ? beforeRect : afterRect;
        var centerRect = getBoundingRect(this._$centerSection.get(0));
        if (leftRect.right > centerRect.left || centerRect.right > rightRect.left) {
          this._$centerSection.css({
            marginLeft: leftRect.width,
            marginRight: rightRect.width,
            float: leftRect.width > rightRect.width ? "none" : "right"
          });
        }
      },
      _alignSection: function($section, maxWidth) {
        var $labels = $section.find(TOOLBAR_LABEL_SELECTOR);
        var labels = $labels.toArray();
        maxWidth -= this._getCurrentLabelsPaddings(labels);
        var currentWidth = this._getCurrentLabelsWidth(labels);
        var difference = Math.abs(currentWidth - maxWidth);
        if (maxWidth < currentWidth) {
          labels = labels.reverse();
          this._alignSectionLabels(labels, difference, false);
        } else {
          this._alignSectionLabels(labels, difference, true);
        }
      },
      _alignSectionLabels: function(labels, difference, expanding) {
        var getRealLabelWidth = function(label) {
          return getBoundingRect(label).width;
        };
        for (var i = 0; i < labels.length; i++) {
          var $label = renderer_default(labels[i]);
          var currentLabelWidth = Math.ceil(getRealLabelWidth(labels[i]));
          var labelMaxWidth = void 0;
          if (expanding) {
            $label.css("maxWidth", "inherit");
          }
          var possibleLabelWidth = Math.ceil(expanding ? getRealLabelWidth(labels[i]) : currentLabelWidth);
          if (possibleLabelWidth < difference) {
            labelMaxWidth = expanding ? possibleLabelWidth : 0;
            difference -= possibleLabelWidth;
          } else {
            labelMaxWidth = expanding ? currentLabelWidth + difference : currentLabelWidth - difference;
            $label.css("maxWidth", labelMaxWidth);
            break;
          }
          $label.css("maxWidth", labelMaxWidth);
        }
      },
      _applyCompactMode: function() {
        var $element = this.$element();
        $element.removeClass(TOOLBAR_COMPACT_CLASS);
        if (this.option("compactMode") && this._getSummaryItemsWidth(this.itemElements(), true) > $element.width()) {
          $element.addClass(TOOLBAR_COMPACT_CLASS);
        }
      },
      _getCurrentLabelsWidth: function(labels) {
        var width = 0;
        labels.forEach(function(label, index2) {
          width += renderer_default(label).outerWidth();
        });
        return width;
      },
      _getCurrentLabelsPaddings: function(labels) {
        var padding = 0;
        labels.forEach(function(label, index2) {
          padding += renderer_default(label).outerWidth() - renderer_default(label).width();
        });
        return padding;
      },
      _renderItem: function(index2, item, itemContainer, $after) {
        var location = item.location || "center";
        var container = itemContainer || this["_$" + location + "Section"];
        var itemHasText = !!(item.text || item.html);
        var itemElement = this.callBase(index2, item, container, $after);
        itemElement.toggleClass(this._buttonClass(), !itemHasText).toggleClass(TOOLBAR_LABEL_CLASS, itemHasText).addClass(item.cssClass);
        return itemElement;
      },
      _renderGroupedItems: function() {
        var that = this;
        each(this.option("items"), function(groupIndex, group) {
          var groupItems = group.items;
          var $container = renderer_default("<div>").addClass(TOOLBAR_GROUP_CLASS);
          var location = group.location || "center";
          if (!groupItems || !groupItems.length) {
            return;
          }
          each(groupItems, function(itemIndex, item) {
            that._renderItem(itemIndex, item, $container, null);
          });
          that._$toolbarItemsContainer.find(".dx-toolbar-" + location).append($container);
        });
      },
      _renderItems: function(items) {
        var grouped = this.option("grouped") && items.length && items[0].items;
        grouped ? this._renderGroupedItems() : this.callBase(items);
      },
      _getToolbarItems: function() {
        return this.option("items") || [];
      },
      _renderContentImpl: function() {
        var items = this._getToolbarItems();
        this.$element().toggleClass(TOOLBAR_MINI_CLASS, 0 === items.length);
        if (this._renderedItemsCount) {
          this._renderItems(items.slice(this._renderedItemsCount));
        } else {
          this._renderItems(items);
        }
        this._applyCompactMode();
      },
      _renderEmptyMessage: noop2,
      _clean: function() {
        this._$toolbarItemsContainer.children().empty();
        this.$element().empty();
      },
      _visibilityChanged: function(visible2) {
        if (visible2) {
          this._arrangeItems();
        }
      },
      _isVisible: function() {
        return this.$element().width() > 0 && this.$element().height() > 0;
      },
      _getIndexByItem: function(item) {
        return inArray(item, this._getToolbarItems());
      },
      _itemOptionChanged: function(item, property, value2) {
        this.callBase.apply(this, [item, property, value2]);
        this._arrangeItems();
      },
      _optionChanged: function(args) {
        var name2 = args.name;
        switch (name2) {
          case "width":
            this.callBase.apply(this, arguments);
            this._dimensionChanged();
            break;
          case "multiline":
            this.$element().toggleClass(TOOLBAR_MULTILINE_CLASS, args.value);
            break;
          case "renderAs":
          case "useFlatButtons":
          case "useDefaultButtons":
            this._invalidate();
            break;
          case "compactMode":
            this._applyCompactMode();
            break;
          case "grouped":
            break;
          default:
            this.callBase.apply(this, arguments);
        }
      },
      _dispose: function() {
        this.callBase();
        clearTimeout(this._waitParentAnimationTimeout);
      }
    });
    component_registrator_default("dxToolbarBase", ToolbarBase);
    ui_toolbar_base_default = ToolbarBase;
  }
});

// node_modules/devextreme/esm/ui/popup.js
var window16, POPUP_CLASS, POPUP_WRAPPER_CLASS, POPUP_FULL_SCREEN_CLASS, POPUP_FULL_SCREEN_WIDTH_CLASS, POPUP_NORMAL_CLASS, POPUP_CONTENT_CLASS, DISABLED_STATE_CLASS3, POPUP_DRAGGABLE_CLASS, POPUP_TITLE_CLASS, POPUP_TITLE_CLOSEBUTTON_CLASS, POPUP_BOTTOM_CLASS, POPUP_HAS_CLOSE_BUTTON_CLASS, TEMPLATE_WRAPPER_CLASS3, POPUP_CONTENT_FLEX_HEIGHT_CLASS, POPUP_CONTENT_INHERIT_HEIGHT_CLASS, ALLOWED_TOOLBAR_ITEM_ALIASES, BUTTON_DEFAULT_TYPE, BUTTON_NORMAL_TYPE, BUTTON_TEXT_MODE, BUTTON_CONTAINED_MODE, IS_IE11, IS_OLD_SAFARI, HEIGHT_STRATEGIES, getButtonPlace, Popup, popup_default;
var init_popup = __esm({
  "node_modules/devextreme/esm/ui/popup.js"() {
    init_translator();
    init_component_registrator();
    init_devices();
    init_element();
    init_renderer();
    init_empty_template();
    init_array();
    init_browser();
    init_common();
    init_extend();
    init_inflector();
    init_iterator();
    init_size();
    init_position();
    init_type();
    init_version2();
    init_window();
    init_visibility_change();
    init_message();
    init_button();
    init_ui_overlay();
    init_themes();
    init_ui_toolbar_base();
    window16 = getWindow();
    POPUP_CLASS = "dx-popup";
    POPUP_WRAPPER_CLASS = "dx-popup-wrapper";
    POPUP_FULL_SCREEN_CLASS = "dx-popup-fullscreen";
    POPUP_FULL_SCREEN_WIDTH_CLASS = "dx-popup-fullscreen-width";
    POPUP_NORMAL_CLASS = "dx-popup-normal";
    POPUP_CONTENT_CLASS = "dx-popup-content";
    DISABLED_STATE_CLASS3 = "dx-state-disabled";
    POPUP_DRAGGABLE_CLASS = "dx-popup-draggable";
    POPUP_TITLE_CLASS = "dx-popup-title";
    POPUP_TITLE_CLOSEBUTTON_CLASS = "dx-closebutton";
    POPUP_BOTTOM_CLASS = "dx-popup-bottom";
    POPUP_HAS_CLOSE_BUTTON_CLASS = "dx-has-close-button";
    TEMPLATE_WRAPPER_CLASS3 = "dx-template-wrapper";
    POPUP_CONTENT_FLEX_HEIGHT_CLASS = "dx-popup-flex-height";
    POPUP_CONTENT_INHERIT_HEIGHT_CLASS = "dx-popup-inherit-height";
    ALLOWED_TOOLBAR_ITEM_ALIASES = ["cancel", "clear", "done"];
    BUTTON_DEFAULT_TYPE = "default";
    BUTTON_NORMAL_TYPE = "normal";
    BUTTON_TEXT_MODE = "text";
    BUTTON_CONTAINED_MODE = "contained";
    IS_IE11 = browser_default.msie && 11 === parseInt(browser_default.version);
    IS_OLD_SAFARI = browser_default.safari && compare(browser_default.version, [11]) < 0;
    HEIGHT_STRATEGIES = {
      static: "",
      inherit: POPUP_CONTENT_INHERIT_HEIGHT_CLASS,
      flex: POPUP_CONTENT_FLEX_HEIGHT_CLASS
    };
    getButtonPlace = (name2) => {
      var device = devices_default.current();
      var platform = device.platform;
      var toolbar = "bottom";
      var location = "before";
      if ("ios" === platform) {
        switch (name2) {
          case "cancel":
            toolbar = "top";
            break;
          case "clear":
            toolbar = "top";
            location = "after";
            break;
          case "done":
            location = "after";
        }
      } else if ("android" === platform && device.version && parseInt(device.version[0]) > 4) {
        switch (name2) {
          case "cancel":
          case "done":
            location = "after";
        }
      }
      return {
        toolbar,
        location
      };
    };
    Popup = ui_overlay_default.inherit({
      _getDefaultOptions: function() {
        return extend2(this.callBase(), {
          fullScreen: false,
          title: "",
          showTitle: true,
          titleTemplate: "title",
          onTitleRendered: null,
          dragEnabled: false,
          toolbarItems: [],
          showCloseButton: false,
          bottomTemplate: "bottom",
          useDefaultToolbarButtons: false,
          useFlatToolbarButtons: false,
          autoResizeEnabled: true
        });
      },
      _defaultOptionsRules: function() {
        var themeName = current();
        return this.callBase().concat([{
          device: {
            platform: "ios"
          },
          options: {
            animation: this._iosAnimation
          }
        }, {
          device: {
            platform: "android"
          },
          options: {
            animation: this._androidAnimation
          }
        }, {
          device: {
            platform: "generic"
          },
          options: {
            showCloseButton: true
          }
        }, {
          device: function(_device) {
            return "desktop" === devices_default.real().deviceType && "generic" === _device.platform;
          },
          options: {
            dragEnabled: true
          }
        }, {
          device: function() {
            return "desktop" === devices_default.real().deviceType && !devices_default.isSimulator();
          },
          options: {
            focusStateEnabled: true
          }
        }, {
          device: function() {
            return isMaterial(themeName);
          },
          options: {
            useDefaultToolbarButtons: true,
            useFlatToolbarButtons: true
          }
        }]);
      },
      _iosAnimation: {
        show: {
          type: "slide",
          duration: 400,
          from: {
            position: {
              my: "top",
              at: "bottom"
            }
          },
          to: {
            position: {
              my: "center",
              at: "center"
            }
          }
        },
        hide: {
          type: "slide",
          duration: 400,
          from: {
            opacity: 1,
            position: {
              my: "center",
              at: "center"
            }
          },
          to: {
            opacity: 1,
            position: {
              my: "top",
              at: "bottom"
            }
          }
        }
      },
      _androidAnimation: function() {
        return this.option("fullScreen") ? {
          show: {
            type: "slide",
            duration: 300,
            from: {
              top: "30%",
              opacity: 0
            },
            to: {
              top: 0,
              opacity: 1
            }
          },
          hide: {
            type: "slide",
            duration: 300,
            from: {
              top: 0,
              opacity: 1
            },
            to: {
              top: "30%",
              opacity: 0
            }
          }
        } : {
          show: {
            type: "fade",
            duration: 400,
            from: 0,
            to: 1
          },
          hide: {
            type: "fade",
            duration: 400,
            from: 1,
            to: 0
          }
        };
      },
      _init: function() {
        this.callBase();
        this.$element().addClass(POPUP_CLASS);
        this.$wrapper().addClass(POPUP_WRAPPER_CLASS);
        this._$popupContent = this._$content.wrapInner(renderer_default("<div>").addClass(POPUP_CONTENT_CLASS)).children().eq(0);
      },
      _render: function() {
        var isFullscreen = this.option("fullScreen");
        this._toggleFullScreenClass(isFullscreen);
        this.callBase();
      },
      _toggleFullScreenClass: function(value2) {
        this.$overlayContent().toggleClass(POPUP_FULL_SCREEN_CLASS, value2).toggleClass(POPUP_NORMAL_CLASS, !value2);
      },
      _initTemplates: function() {
        this.callBase();
        this._templateManager.addDefaultTemplates({
          title: new EmptyTemplate(),
          bottom: new EmptyTemplate()
        });
      },
      _renderContentImpl: function() {
        this._renderTitle();
        this.callBase();
        this._renderBottom();
      },
      _renderTitle: function() {
        var items = this._getToolbarItems("top");
        var titleText = this.option("title");
        var showTitle = this.option("showTitle");
        if (showTitle && !!titleText) {
          items.unshift({
            location: devices_default.current().ios ? "center" : "before",
            text: titleText
          });
        }
        if (showTitle || items.length > 0) {
          this._$title && this._$title.remove();
          var $title = renderer_default("<div>").addClass(POPUP_TITLE_CLASS).insertBefore(this.$content());
          this._$title = this._renderTemplateByType("titleTemplate", items, $title).addClass(POPUP_TITLE_CLASS);
          this._renderDrag();
          this._executeTitleRenderAction(this._$title);
          this._$title.toggleClass(POPUP_HAS_CLOSE_BUTTON_CLASS, this._hasCloseButton());
        } else if (this._$title) {
          this._$title.detach();
        }
      },
      _renderTemplateByType: function(optionName, data2, $container, additionalToolbarOptions) {
        var {
          rtlEnabled,
          useDefaultToolbarButtons,
          useFlatToolbarButtons,
          disabled
        } = this.option();
        var template = this._getTemplateByOption(optionName);
        var toolbarTemplate = template instanceof EmptyTemplate;
        if (toolbarTemplate) {
          var integrationOptions = extend2({}, this.option("integrationOptions"), {
            skipTemplates: ["content", "title"]
          });
          var toolbarOptions = extend2(additionalToolbarOptions, {
            items: data2,
            rtlEnabled,
            useDefaultButtons: useDefaultToolbarButtons,
            useFlatButtons: useFlatToolbarButtons,
            disabled,
            integrationOptions
          });
          this._getTemplate("dx-polymorph-widget").render({
            container: $container,
            model: {
              widget: "dxToolbarBase",
              options: toolbarOptions
            }
          });
          var $toolbar = $container.children("div");
          $container.replaceWith($toolbar);
          return $toolbar;
        } else {
          var $result = renderer_default(template.render({
            container: getPublicElement($container)
          }));
          if ($result.hasClass(TEMPLATE_WRAPPER_CLASS3)) {
            $container.replaceWith($result);
            $container = $result;
          }
          return $container;
        }
      },
      _executeTitleRenderAction: function($titleElement) {
        this._getTitleRenderAction()({
          titleElement: getPublicElement($titleElement)
        });
      },
      _getTitleRenderAction: function() {
        return this._titleRenderAction || this._createTitleRenderAction();
      },
      _createTitleRenderAction: function() {
        return this._titleRenderAction = this._createActionByOption("onTitleRendered", {
          element: this.element(),
          excludeValidators: ["disabled", "readOnly"]
        });
      },
      _getCloseButton: function() {
        return {
          toolbar: "top",
          location: "after",
          template: this._getCloseButtonRenderer()
        };
      },
      _getCloseButtonRenderer: function() {
        return (_2, __, container) => {
          var $button = renderer_default("<div>").addClass(POPUP_TITLE_CLOSEBUTTON_CLASS);
          this._createComponent($button, button_default, {
            icon: "close",
            onClick: this._createToolbarItemAction(void 0),
            stylingMode: "text",
            integrationOptions: {}
          });
          renderer_default(container).append($button);
        };
      },
      _getToolbarItems: function(toolbar) {
        var toolbarItems = this.option("toolbarItems");
        var toolbarsItems = [];
        this._toolbarItemClasses = [];
        var currentPlatform = devices_default.current().platform;
        var index2 = 0;
        each(toolbarItems, (_2, data2) => {
          var isShortcut = isDefined(data2.shortcut);
          var item = isShortcut ? getButtonPlace(data2.shortcut) : data2;
          if (isShortcut && "ios" === currentPlatform && index2 < 2) {
            item.toolbar = "top";
            index2++;
          }
          item.toolbar = data2.toolbar || item.toolbar || "top";
          if (item && item.toolbar === toolbar) {
            if (isShortcut) {
              extend2(item, {
                location: data2.location
              }, this._getToolbarItemByAlias(data2));
            }
            var isLTROrder = "generic" === currentPlatform;
            if ("done" === data2.shortcut && isLTROrder || "cancel" === data2.shortcut && !isLTROrder) {
              toolbarsItems.unshift(item);
            } else {
              toolbarsItems.push(item);
            }
          }
        });
        if ("top" === toolbar && this._hasCloseButton()) {
          toolbarsItems.push(this._getCloseButton());
        }
        return toolbarsItems;
      },
      _hasCloseButton() {
        return this.option("showCloseButton") && this.option("showTitle");
      },
      _getLocalizationKey: (itemType) => "done" === itemType.toLowerCase() ? "OK" : camelize2(itemType, true),
      _getToolbarItemByAlias: function(data2) {
        var that = this;
        var itemType = data2.shortcut;
        if (inArray(itemType, ALLOWED_TOOLBAR_ITEM_ALIASES) < 0) {
          return false;
        }
        var itemConfig = extend2({
          text: message_default.format(this._getLocalizationKey(itemType)),
          onClick: this._createToolbarItemAction(data2.onClick),
          integrationOptions: {},
          type: that.option("useDefaultToolbarButtons") ? BUTTON_DEFAULT_TYPE : BUTTON_NORMAL_TYPE,
          stylingMode: that.option("useFlatToolbarButtons") ? BUTTON_TEXT_MODE : BUTTON_CONTAINED_MODE
        }, data2.options || {});
        var itemClass = POPUP_CLASS + "-" + itemType;
        this._toolbarItemClasses.push(itemClass);
        return {
          template: function(_2, __, container) {
            var $toolbarItem = renderer_default("<div>").addClass(itemClass).appendTo(container);
            that._createComponent($toolbarItem, button_default, itemConfig);
          }
        };
      },
      _createToolbarItemAction: function(clickAction) {
        return this._createAction(clickAction, {
          afterExecute: function(e) {
            e.component.hide();
          }
        });
      },
      _renderBottom: function() {
        var items = this._getToolbarItems("bottom");
        if (items.length) {
          this._$bottom && this._$bottom.remove();
          var $bottom = renderer_default("<div>").addClass(POPUP_BOTTOM_CLASS).insertAfter(this.$content());
          this._$bottom = this._renderTemplateByType("bottomTemplate", items, $bottom, {
            compactMode: true
          }).addClass(POPUP_BOTTOM_CLASS);
          this._toggleClasses();
        } else {
          this._$bottom && this._$bottom.detach();
        }
      },
      _toggleDisabledState: function(value2) {
        this.callBase(...arguments);
        this.$content().toggleClass(DISABLED_STATE_CLASS3, Boolean(value2));
      },
      _toggleClasses: function() {
        var aliases = ALLOWED_TOOLBAR_ITEM_ALIASES;
        each(aliases, (_2, alias) => {
          var className = POPUP_CLASS + "-" + alias;
          if (inArray(className, this._toolbarItemClasses) >= 0) {
            this.$wrapper().addClass(className + "-visible");
            this._$bottom.addClass(className);
          } else {
            this.$wrapper().removeClass(className + "-visible");
            this._$bottom.removeClass(className);
          }
        });
      },
      _getContainer: function() {
        if (this.option("fullScreen")) {
          return renderer_default(window16);
        }
        return this.callBase();
      },
      _getDragTarget: function() {
        return this.topToolbar();
      },
      _renderGeometryImpl: function(isDimensionChanged) {
        if (!isDimensionChanged) {
          this._resetContentHeight();
        }
        this.callBase(...arguments);
        this._setContentHeight();
      },
      _resetContentHeight: function() {
        this.$content().css({
          height: "auto",
          maxHeight: "none"
        });
      },
      _renderDrag: function() {
        this.callBase();
        this.$overlayContent().toggleClass(POPUP_DRAGGABLE_CLASS, this.option("dragEnabled"));
      },
      _renderResize: function() {
        this.callBase();
        this._resizable.option("onResize", (e) => {
          this._setContentHeight();
          this._actions.onResize(e);
        });
      },
      _setContentHeight: function() {
        (this.option("forceApplyBindings") || noop2)();
        var overlayContent = this.$overlayContent().get(0);
        var currentHeightStrategyClass = this._chooseHeightStrategy(overlayContent);
        this.$content().css(this._getHeightCssStyles(currentHeightStrategyClass, overlayContent));
        this._setHeightClasses(this.$overlayContent(), currentHeightStrategyClass);
      },
      _heightStrategyChangeOffset: function(currentHeightStrategyClass, popupVerticalPaddings) {
        return currentHeightStrategyClass === HEIGHT_STRATEGIES.flex ? -popupVerticalPaddings : 0;
      },
      _chooseHeightStrategy: function(overlayContent) {
        var isAutoWidth = "auto" === overlayContent.style.width || "" === overlayContent.style.width;
        var currentHeightStrategyClass = HEIGHT_STRATEGIES.static;
        if (this._isAutoHeight() && this.option("autoResizeEnabled")) {
          if (isAutoWidth || IS_OLD_SAFARI) {
            if (!IS_IE11) {
              currentHeightStrategyClass = HEIGHT_STRATEGIES.inherit;
            }
          } else {
            currentHeightStrategyClass = HEIGHT_STRATEGIES.flex;
          }
        }
        return currentHeightStrategyClass;
      },
      _getHeightCssStyles: function(currentHeightStrategyClass, overlayContent) {
        var cssStyles = {};
        var contentMaxHeight = this._getOptionValue("maxHeight", overlayContent);
        var contentMinHeight = this._getOptionValue("minHeight", overlayContent);
        var popupHeightParts = this._splitPopupHeight();
        var toolbarsAndVerticalOffsetsHeight = popupHeightParts.header + popupHeightParts.footer + popupHeightParts.contentVerticalOffsets + popupHeightParts.popupVerticalOffsets + this._heightStrategyChangeOffset(currentHeightStrategyClass, popupHeightParts.popupVerticalPaddings);
        if (currentHeightStrategyClass === HEIGHT_STRATEGIES.static) {
          if (!this._isAutoHeight() || contentMaxHeight || contentMinHeight) {
            var overlayHeight = this.option("fullScreen") ? Math.min(getBoundingRect(overlayContent).height, getWindow().innerHeight) : getBoundingRect(overlayContent).height;
            var contentHeight = overlayHeight - toolbarsAndVerticalOffsetsHeight;
            cssStyles = {
              height: Math.max(0, contentHeight),
              minHeight: "auto",
              maxHeight: "auto"
            };
          }
        } else {
          var container = renderer_default(this._getContainer()).get(0);
          var maxHeightValue = addOffsetToMaxHeight(contentMaxHeight, -toolbarsAndVerticalOffsetsHeight, container);
          var minHeightValue = addOffsetToMinHeight(contentMinHeight, -toolbarsAndVerticalOffsetsHeight, container);
          cssStyles = {
            height: "auto",
            minHeight: minHeightValue,
            maxHeight: maxHeightValue
          };
        }
        return cssStyles;
      },
      _setHeightClasses: function($container, currentClass) {
        var excessClasses = "";
        for (var name2 in HEIGHT_STRATEGIES) {
          if (HEIGHT_STRATEGIES[name2] !== currentClass) {
            excessClasses += " " + HEIGHT_STRATEGIES[name2];
          }
        }
        $container.removeClass(excessClasses).addClass(currentClass);
      },
      _isAutoHeight: function() {
        return "auto" === this.$overlayContent().get(0).style.height;
      },
      _splitPopupHeight: function() {
        var topToolbar = this.topToolbar();
        var bottomToolbar = this.bottomToolbar();
        return {
          header: getVisibleHeight(topToolbar && topToolbar.get(0)),
          footer: getVisibleHeight(bottomToolbar && bottomToolbar.get(0)),
          contentVerticalOffsets: getVerticalOffsets(this.$overlayContent().get(0), true),
          popupVerticalOffsets: getVerticalOffsets(this.$content().get(0), true),
          popupVerticalPaddings: getVerticalOffsets(this.$content().get(0), false)
        };
      },
      _shouldFixBodyPosition: function() {
        return this.callBase() || this.option("fullScreen");
      },
      _toggleSafariFullScreen: function(value2) {
        var toggleFullScreenBeforeShown = this._shouldFixBodyPosition() && value2 && !this._isShown;
        if (toggleFullScreenBeforeShown) {
          this._bodyScrollTop = value2 ? window16.pageYOffset : void 0;
        } else {
          this._toggleSafariScrolling(!value2);
        }
      },
      _renderDimensions: function() {
        if (this.option("fullScreen")) {
          this.$overlayContent().css({
            width: "100%",
            height: "100%",
            minWidth: "",
            maxWidth: "",
            minHeight: "",
            maxHeight: ""
          });
        } else {
          this.callBase(...arguments);
        }
        if (hasWindow()) {
          this._renderFullscreenWidthClass();
        }
      },
      _renderFullscreenWidthClass: function() {
        this.$overlayContent().toggleClass(POPUP_FULL_SCREEN_WIDTH_CLASS, this.$overlayContent().outerWidth() === renderer_default(window16).width());
      },
      refreshPosition: function() {
        this._renderPosition();
      },
      _renderPosition: function() {
        if (this.option("fullScreen")) {
          move(this.$overlayContent(), {
            top: 0,
            left: 0
          });
        } else {
          (this.option("forceApplyBindings") || noop2)();
          return this.callBase(...arguments);
        }
      },
      _optionChanged: function(args) {
        switch (args.name) {
          case "disabled":
            this.callBase(args);
            this._renderTitle();
            this._renderBottom();
            break;
          case "showTitle":
          case "title":
          case "titleTemplate":
            this._renderTitle();
            this._renderGeometry();
            triggerResizeEvent(this.$overlayContent());
            break;
          case "bottomTemplate":
            this._renderBottom();
            this._renderGeometry();
            triggerResizeEvent(this.$overlayContent());
            break;
          case "onTitleRendered":
            this._createTitleRenderAction(args.value);
            break;
          case "toolbarItems":
          case "useDefaultToolbarButtons":
          case "useFlatToolbarButtons":
            var shouldRenderGeometry = !args.fullName.match(/^toolbarItems((\[\d+\])(\.(options|visible).*)?)?$/);
            this._renderTitle();
            this._renderBottom();
            if (shouldRenderGeometry) {
              this._renderGeometry();
              triggerResizeEvent(this.$overlayContent());
            }
            break;
          case "dragEnabled":
            this._renderDrag();
            break;
          case "autoResizeEnabled":
            this._renderGeometry();
            triggerResizeEvent(this.$overlayContent());
            break;
          case "fullScreen":
            this._toggleFullScreenClass(args.value);
            this._toggleSafariFullScreen(args.value);
            this._renderGeometry();
            triggerResizeEvent(this.$overlayContent());
            break;
          case "showCloseButton":
            this._renderTitle();
            break;
          default:
            this.callBase(args);
        }
      },
      bottomToolbar: function() {
        return this._$bottom;
      },
      topToolbar: function() {
        return this._$title;
      },
      $content: function() {
        return this._$popupContent;
      },
      content: function() {
        return getPublicElement(this.$content());
      },
      $overlayContent: function() {
        return this._$content;
      }
    });
    component_registrator_default("dxPopup", Popup);
    popup_default = Popup;
  }
});

// node_modules/devextreme/esm/ui/popover_contants.js
var POPOVER_BOUNDARY_OFFSET;
var init_popover_contants = __esm({
  "node_modules/devextreme/esm/ui/popover_contants.js"() {
    POPOVER_BOUNDARY_OFFSET = 10;
  }
});

// node_modules/devextreme/esm/ui/popover.js
var window17, POPOVER_CLASS, POPOVER_WRAPPER_CLASS, POPOVER_ARROW_CLASS, POPOVER_WITHOUT_TITLE_CLASS, POSITION_FLIP_MAP, WEIGHT_OF_SIDES, POSITION_ALIASES2, SIDE_BORDER_WIDTH_STYLES2, getEventNameByOption, getEventName2, getEventDelay, attachEvent, detachEvent, Popover, popover_default;
var init_popover = __esm({
  "node_modules/devextreme/esm/ui/popover.js"() {
    init_renderer();
    init_window();
    init_element();
    init_dom_adapter();
    init_events_engine();
    init_component_registrator();
    init_common();
    init_extend();
    init_translator();
    init_position2();
    init_type();
    init_math();
    init_utils2();
    init_popup();
    init_position();
    init_popover_contants();
    window17 = getWindow();
    POPOVER_CLASS = "dx-popover";
    POPOVER_WRAPPER_CLASS = "dx-popover-wrapper";
    POPOVER_ARROW_CLASS = "dx-popover-arrow";
    POPOVER_WITHOUT_TITLE_CLASS = "dx-popover-without-title";
    POSITION_FLIP_MAP = {
      left: "right",
      top: "bottom",
      right: "left",
      bottom: "top",
      center: "center"
    };
    WEIGHT_OF_SIDES = {
      left: -1,
      top: -1,
      center: 0,
      right: 1,
      bottom: 1
    };
    POSITION_ALIASES2 = {
      top: {
        my: "bottom center",
        at: "top center",
        collision: "fit flip"
      },
      bottom: {
        my: "top center",
        at: "bottom center",
        collision: "fit flip"
      },
      right: {
        my: "left center",
        at: "right center",
        collision: "flip fit"
      },
      left: {
        my: "right center",
        at: "left center",
        collision: "flip fit"
      }
    };
    SIDE_BORDER_WIDTH_STYLES2 = {
      left: "borderLeftWidth",
      top: "borderTopWidth",
      right: "borderRightWidth",
      bottom: "borderBottomWidth"
    };
    getEventNameByOption = function(optionValue) {
      return isObject2(optionValue) ? optionValue.name : optionValue;
    };
    getEventName2 = function(that, optionName) {
      var optionValue = that.option(optionName);
      return getEventNameByOption(optionValue);
    };
    getEventDelay = function(that, optionName) {
      var optionValue = that.option(optionName);
      return isObject2(optionValue) && optionValue.delay;
    };
    attachEvent = function(that, name2) {
      var target = that.option("target");
      var isSelector = isString2(target);
      var event = getEventName2(that, name2 + "Event");
      if (!event || that.option("disabled")) {
        return;
      }
      var eventName = addNamespace2(event, that.NAME);
      var action = that._createAction((function() {
        var delay = getEventDelay(that, name2 + "Event");
        this._clearEventsTimeouts();
        if (delay) {
          this._timeouts[name2] = setTimeout(function() {
            that[name2]();
          }, delay);
        } else {
          that[name2]();
        }
      }).bind(that), {
        validatingTargetName: "target"
      });
      var handler = function(e) {
        action({
          event: e,
          target: renderer_default(e.currentTarget)
        });
      };
      var EVENT_HANDLER_NAME = "_" + name2 + "EventHandler";
      if (isSelector) {
        that[EVENT_HANDLER_NAME] = handler;
        events_engine_default.on(dom_adapter_default.getDocument(), eventName, target, handler);
      } else {
        var targetElement = getPublicElement(renderer_default(target));
        that[EVENT_HANDLER_NAME] = void 0;
        events_engine_default.on(targetElement, eventName, handler);
      }
    };
    detachEvent = function(that, target, name2, event) {
      var eventName = event || getEventName2(that, name2 + "Event");
      if (!eventName) {
        return;
      }
      eventName = addNamespace2(eventName, that.NAME);
      var EVENT_HANDLER_NAME = "_" + name2 + "EventHandler";
      if (that[EVENT_HANDLER_NAME]) {
        events_engine_default.off(dom_adapter_default.getDocument(), eventName, target, that[EVENT_HANDLER_NAME]);
      } else {
        events_engine_default.off(getPublicElement(renderer_default(target)), eventName);
      }
    };
    Popover = popup_default.inherit({
      _getDefaultOptions: function() {
        return extend2(this.callBase(), {
          target: window17,
          shading: false,
          position: "bottom",
          closeOnOutsideClick: true,
          animation: {
            show: {
              type: "fade",
              from: 0,
              to: 1
            },
            hide: {
              type: "fade",
              to: 0
            }
          },
          showTitle: false,
          width: "auto",
          height: "auto",
          dragEnabled: false,
          resizeEnabled: false,
          fullScreen: false,
          closeOnTargetScroll: true,
          arrowPosition: "",
          arrowOffset: 0,
          boundaryOffset: {
            h: POPOVER_BOUNDARY_OFFSET,
            v: POPOVER_BOUNDARY_OFFSET
          },
          _fixedPosition: true
        });
      },
      _defaultOptionsRules: function() {
        return [{
          device: {
            platform: "ios"
          },
          options: {
            arrowPosition: {
              boundaryOffset: {
                h: 20,
                v: -10
              },
              collision: "fit"
            }
          }
        }, {
          device: function() {
            return !hasWindow();
          },
          options: {
            animation: null
          }
        }];
      },
      _init: function() {
        this.callBase();
        this._renderArrow();
        this._timeouts = {};
        this.$element().addClass(POPOVER_CLASS);
        this.$wrapper().addClass(POPOVER_WRAPPER_CLASS);
      },
      _render: function() {
        this.callBase.apply(this, arguments);
        this._detachEvents(this.option("target"));
        this._attachEvents();
      },
      _detachEvents: function(target) {
        detachEvent(this, target, "show");
        detachEvent(this, target, "hide");
      },
      _attachEvents: function() {
        attachEvent(this, "show");
        attachEvent(this, "hide");
      },
      _renderArrow: function() {
        this._$arrow = renderer_default("<div>").addClass(POPOVER_ARROW_CLASS).prependTo(this.$overlayContent());
      },
      _documentDownHandler: function(e) {
        if (this._isOutsideClick(e)) {
          return this.callBase(e);
        }
        return true;
      },
      _isOutsideClick: function(e) {
        return !renderer_default(e.target).closest(this.option("target")).length;
      },
      _animate: function(animation3) {
        if (animation3 && animation3.to && "object" === typeof animation3.to) {
          extend2(animation3.to, {
            position: this._getContainerPosition()
          });
        }
        this.callBase.apply(this, arguments);
      },
      _stopAnimation: function() {
        this.callBase.apply(this, arguments);
      },
      _renderTitle: function() {
        this.$wrapper().toggleClass(POPOVER_WITHOUT_TITLE_CLASS, !this.option("showTitle"));
        this.callBase();
      },
      _renderPosition: function() {
        this.callBase();
        this._renderOverlayPosition();
      },
      _renderOverlayBoundaryOffset: noop2,
      _renderOverlayPosition: function() {
        this._resetOverlayPosition();
        this._updateContentSize();
        var contentPosition = this._getContainerPosition();
        var resultLocation = position_default.setup(this.$overlayContent(), contentPosition);
        var positionSide = this._getSideByLocation(resultLocation);
        this._togglePositionClass("dx-position-" + positionSide);
        this._toggleFlippedClass(resultLocation.h.flip, resultLocation.v.flip);
        var isArrowVisible = this._isHorizontalSide() || this._isVerticalSide();
        if (isArrowVisible) {
          this._renderArrowPosition(positionSide);
        }
      },
      _resetOverlayPosition: function() {
        this._setContentHeight(true);
        this._togglePositionClass("dx-position-" + this._positionSide);
        move(this.$overlayContent(), {
          left: 0,
          top: 0
        });
        this._$arrow.css({
          top: "auto",
          right: "auto",
          bottom: "auto",
          left: "auto"
        });
      },
      _updateContentSize: function() {
        if (!this.$content()) {
          return;
        }
        var containerLocation = position_default.calculate(this.$overlayContent(), this._getContainerPosition());
        if (containerLocation.h.oversize > 0 && this._isHorizontalSide() && !containerLocation.h.fit) {
          var newContainerWidth = this.$overlayContent().width() - containerLocation.h.oversize;
          this.$overlayContent().width(newContainerWidth);
        }
        if (containerLocation.v.oversize > 0 && this._isVerticalSide() && !containerLocation.v.fit) {
          var newOverlayContentHeight = this.$overlayContent().height() - containerLocation.v.oversize;
          var newPopupContentHeight = this.$content().height() - containerLocation.v.oversize;
          this.$overlayContent().height(newOverlayContentHeight);
          this.$content().height(newPopupContentHeight);
        }
      },
      _getContainerPosition: function() {
        var offset2 = pairToObject(this._position.offset || "");
        var hOffset = offset2.h;
        var vOffset = offset2.v;
        var isVerticalSide = this._isVerticalSide();
        var isHorizontalSide = this._isHorizontalSide();
        if (isVerticalSide || isHorizontalSide) {
          var isPopoverInside = this._isPopoverInside();
          var sign2 = (isPopoverInside ? -1 : 1) * WEIGHT_OF_SIDES[this._positionSide];
          var arrowSize = isVerticalSide ? this._$arrow.height() : this._$arrow.width();
          var arrowSizeCorrection = this._getContentBorderWidth(this._positionSide);
          var arrowOffset = sign2 * (arrowSize - arrowSizeCorrection);
          isVerticalSide ? vOffset += arrowOffset : hOffset += arrowOffset;
        }
        return extend2({}, this._position, {
          offset: hOffset + " " + vOffset
        });
      },
      _getContentBorderWidth: function(side) {
        var borderWidth = this.$overlayContent().css(SIDE_BORDER_WIDTH_STYLES2[side]);
        return parseInt(borderWidth) || 0;
      },
      _getSideByLocation: function(location) {
        var isFlippedByVertical = location.v.flip;
        var isFlippedByHorizontal = location.h.flip;
        return this._isVerticalSide() && isFlippedByVertical || this._isHorizontalSide() && isFlippedByHorizontal || this._isPopoverInside() ? POSITION_FLIP_MAP[this._positionSide] : this._positionSide;
      },
      _togglePositionClass: function(positionClass) {
        this.$wrapper().removeClass("dx-position-left dx-position-right dx-position-top dx-position-bottom").addClass(positionClass);
      },
      _toggleFlippedClass: function(isFlippedHorizontal, isFlippedVertical) {
        this.$wrapper().toggleClass("dx-popover-flipped-horizontal", isFlippedHorizontal).toggleClass("dx-popover-flipped-vertical", isFlippedVertical);
      },
      _renderArrowPosition: function(side) {
        var _$target$get;
        var arrowRect = getBoundingRect(this._$arrow.get(0));
        var arrowFlip = -(this._isVerticalSide(side) ? arrowRect.height : arrowRect.width);
        this._$arrow.css(POSITION_FLIP_MAP[side], arrowFlip);
        var axis = this._isVerticalSide(side) ? "left" : "top";
        var sizeProperty = this._isVerticalSide(side) ? "width" : "height";
        var $target = renderer_default(this._position.of);
        var targetOffset = position_default.offset($target) || {
          top: 0,
          left: 0
        };
        var contentOffset = position_default.offset(this.$overlayContent());
        var arrowSize = arrowRect[sizeProperty];
        var contentLocation = contentOffset[axis];
        var contentSize = getBoundingRect(this.$overlayContent().get(0))[sizeProperty];
        var targetLocation = targetOffset[axis];
        var targetSize = null !== (_$target$get = $target.get(0)) && void 0 !== _$target$get && _$target$get.preventDefault ? 0 : getBoundingRect($target.get(0))[sizeProperty];
        var min = Math.max(contentLocation, targetLocation);
        var max = Math.min(contentLocation + contentSize, targetLocation + targetSize);
        var arrowLocation;
        if ("start" === this.option("arrowPosition")) {
          arrowLocation = min - contentLocation;
        } else if ("end" === this.option("arrowPosition")) {
          arrowLocation = max - contentLocation - arrowSize;
        } else {
          arrowLocation = (min + max) / 2 - contentLocation - arrowSize / 2;
        }
        var borderWidth = this._getContentBorderWidth(side);
        var finalArrowLocation = fitIntoRange(arrowLocation - borderWidth + this.option("arrowOffset"), borderWidth, contentSize - arrowSize - 2 * borderWidth);
        this._$arrow.css(axis, finalArrowLocation);
      },
      _isPopoverInside: function() {
        var position3 = this._transformStringPosition(this.option("position"), POSITION_ALIASES2);
        var my = position_default.setup.normalizeAlign(position3.my);
        var at = position_default.setup.normalizeAlign(position3.at);
        return my.h === at.h && my.v === at.v;
      },
      _setContentHeight: function(fullUpdate) {
        if (fullUpdate) {
          this.callBase();
        }
      },
      _renderWrapperPosition: function() {
        if (this.option("shading")) {
          this.$wrapper().css({
            top: 0,
            left: 0
          });
        }
      },
      _renderWrapperDimensions: function() {
        if (this.option("shading")) {
          this.$wrapper().css({
            width: "100%",
            height: "100%"
          });
        }
      },
      _normalizePosition: function() {
        var position3 = extend2({}, this._transformStringPosition(this.option("position"), POSITION_ALIASES2));
        if (!position3.of) {
          position3.of = this.option("target");
        }
        if (!position3.collision) {
          position3.collision = "flip";
        }
        if (!position3.boundaryOffset) {
          position3.boundaryOffset = this.option("boundaryOffset");
        }
        this._positionSide = this._getDisplaySide(position3);
        this._position = position3;
      },
      _getDisplaySide: function(position3) {
        var my = position_default.setup.normalizeAlign(position3.my);
        var at = position_default.setup.normalizeAlign(position3.at);
        var weightSign = WEIGHT_OF_SIDES[my.h] === WEIGHT_OF_SIDES[at.h] && WEIGHT_OF_SIDES[my.v] === WEIGHT_OF_SIDES[at.v] ? -1 : 1;
        var horizontalWeight = Math.abs(WEIGHT_OF_SIDES[my.h] - weightSign * WEIGHT_OF_SIDES[at.h]);
        var verticalWeight = Math.abs(WEIGHT_OF_SIDES[my.v] - weightSign * WEIGHT_OF_SIDES[at.v]);
        return horizontalWeight > verticalWeight ? at.h : at.v;
      },
      _isVerticalSide: function(side) {
        side = side || this._positionSide;
        return "top" === side || "bottom" === side;
      },
      _isHorizontalSide: function(side) {
        side = side || this._positionSide;
        return "left" === side || "right" === side;
      },
      _clearEventTimeout: function(name2) {
        clearTimeout(this._timeouts[name2]);
      },
      _clearEventsTimeouts: function() {
        this._clearEventTimeout("show");
        this._clearEventTimeout("hide");
      },
      _clean: function() {
        this._detachEvents(this.option("target"));
        this.callBase.apply(this, arguments);
      },
      _optionChanged: function(args) {
        switch (args.name) {
          case "boundaryOffset":
          case "arrowPosition":
          case "arrowOffset":
            this._renderGeometry();
            break;
          case "fullScreen":
            if (args.value) {
              this.option("fullScreen", false);
            }
            break;
          case "target":
            args.previousValue && this._detachEvents(args.previousValue);
            this.callBase(args);
            break;
          case "showEvent":
          case "hideEvent":
            var name2 = args.name.substring(0, 4);
            var event = getEventNameByOption(args.previousValue);
            this.hide();
            detachEvent(this, this.option("target"), name2, event);
            attachEvent(this, name2);
            break;
          case "visible":
            this._clearEventTimeout(args.value ? "show" : "hide");
            this.callBase(args);
            break;
          default:
            this.callBase(args);
        }
      },
      show: function(target) {
        if (target) {
          this.option("target", target);
        }
        return this.callBase();
      }
    });
    component_registrator_default("dxPopover", Popover);
    popover_default = Popover;
  }
});

// node_modules/devextreme/esm/ui/action_sheet.js
var window18, ACTION_SHEET_CLASS, ACTION_SHEET_CONTAINER_CLASS, ACTION_SHEET_POPUP_WRAPPER_CLASS, ACTION_SHEET_POPOVER_WRAPPER_CLASS, ACTION_SHEET_CANCEL_BUTTON_CLASS, ACTION_SHEET_ITEM_CLASS, ACTION_SHEET_ITEM_DATA_KEY, ACTION_SHEET_WITHOUT_TITLE_CLASS, ActionSheet, action_sheet_default;
var init_action_sheet = __esm({
  "node_modules/devextreme/esm/ui/action_sheet.js"() {
    init_renderer();
    init_window();
    init_common();
    init_message();
    init_component_registrator();
    init_extend();
    init_button();
    init_ui_collection_widget_edit();
    init_popup();
    init_popover();
    init_bindable_template();
    init_deferred();
    window18 = getWindow();
    ACTION_SHEET_CLASS = "dx-actionsheet";
    ACTION_SHEET_CONTAINER_CLASS = "dx-actionsheet-container";
    ACTION_SHEET_POPUP_WRAPPER_CLASS = "dx-actionsheet-popup-wrapper";
    ACTION_SHEET_POPOVER_WRAPPER_CLASS = "dx-actionsheet-popover-wrapper";
    ACTION_SHEET_CANCEL_BUTTON_CLASS = "dx-actionsheet-cancel";
    ACTION_SHEET_ITEM_CLASS = "dx-actionsheet-item";
    ACTION_SHEET_ITEM_DATA_KEY = "dxActionSheetItemData";
    ACTION_SHEET_WITHOUT_TITLE_CLASS = "dx-actionsheet-without-title";
    ActionSheet = ui_collection_widget_edit_default.inherit({
      _getDefaultOptions: function() {
        return extend2(this.callBase(), {
          usePopover: false,
          target: null,
          title: "",
          showTitle: true,
          showCancelButton: true,
          cancelText: message_default.format("Cancel"),
          onCancelClick: null,
          visible: false,
          noDataText: "",
          focusStateEnabled: false,
          selectionByClick: false
        });
      },
      _defaultOptionsRules: function() {
        return this.callBase().concat([{
          device: {
            platform: "ios",
            tablet: true
          },
          options: {
            usePopover: true
          }
        }]);
      },
      _initTemplates: function() {
        this.callBase();
        this._templateManager.addDefaultTemplates({
          item: new BindableTemplate(function($container, data2) {
            var button = new button_default(renderer_default("<div>"), extend2({
              onClick: data2 && data2.click
            }, data2));
            $container.append(button.$element());
          }, ["disabled", "icon", "text", "type", "onClick", "click"], this.option("integrationOptions.watchMethod"))
        });
      },
      _itemContainer: function() {
        return this._$itemContainer;
      },
      _itemClass: function() {
        return ACTION_SHEET_ITEM_CLASS;
      },
      _itemDataKey: function() {
        return ACTION_SHEET_ITEM_DATA_KEY;
      },
      _toggleVisibility: noop2,
      _renderDimensions: noop2,
      _initMarkup: function() {
        this.callBase();
        this.$element().addClass(ACTION_SHEET_CLASS);
        this._createItemContainer();
      },
      _render: function() {
        this._renderPopup();
      },
      _createItemContainer: function() {
        this._$itemContainer = renderer_default("<div>").addClass(ACTION_SHEET_CONTAINER_CLASS);
        this._renderDisabled();
      },
      _renderDisabled: function() {
        this._$itemContainer.toggleClass("dx-state-disabled", this.option("disabled"));
      },
      _renderPopup: function() {
        this._$popup = renderer_default("<div>").appendTo(this.$element());
        this._isPopoverMode() ? this._createPopover() : this._createPopup();
        this._renderPopupTitle();
        this._mapPopupOption("visible");
      },
      _mapPopupOption: function(optionName) {
        this._popup && this._popup.option(optionName, this.option(optionName));
      },
      _isPopoverMode: function() {
        return this.option("usePopover") && this.option("target");
      },
      _renderPopupTitle: function() {
        this._mapPopupOption("showTitle");
        this._popup && this._popup.$wrapper().toggleClass(ACTION_SHEET_WITHOUT_TITLE_CLASS, !this.option("showTitle"));
      },
      _clean: function() {
        if (this._$popup) {
          this._$popup.remove();
        }
        this.callBase();
      },
      _overlayConfig: function() {
        return {
          onInitialized: (function(args) {
            this._popup = args.component;
          }).bind(this),
          disabled: false,
          showTitle: true,
          title: this.option("title"),
          deferRendering: !window18.angular,
          onContentReady: this._popupContentReadyAction.bind(this),
          onHidden: this.hide.bind(this)
        };
      },
      _createPopover: function() {
        this._createComponent(this._$popup, popover_default, extend2(this._overlayConfig(), {
          width: this.option("width") || 200,
          height: this.option("height") || "auto",
          target: this.option("target")
        }));
        this._popup.$wrapper().addClass(ACTION_SHEET_POPOVER_WRAPPER_CLASS);
      },
      _createPopup: function() {
        this._createComponent(this._$popup, popup_default, extend2(this._overlayConfig(), {
          dragEnabled: false,
          width: this.option("width") || "100%",
          height: this.option("height") || "auto",
          showCloseButton: false,
          position: {
            my: "bottom",
            at: "bottom",
            of: window18
          },
          animation: {
            show: {
              type: "slide",
              duration: 400,
              from: {
                position: {
                  my: "top",
                  at: "bottom",
                  of: window18
                }
              },
              to: {
                position: {
                  my: "bottom",
                  at: "bottom",
                  of: window18
                }
              }
            },
            hide: {
              type: "slide",
              duration: 400,
              from: {
                position: {
                  my: "bottom",
                  at: "bottom",
                  of: window18
                }
              },
              to: {
                position: {
                  my: "top",
                  at: "bottom",
                  of: window18
                }
              }
            }
          }
        }));
        this._popup.$wrapper().addClass(ACTION_SHEET_POPUP_WRAPPER_CLASS);
      },
      _popupContentReadyAction: function() {
        this._popup.$content().append(this._$itemContainer);
        this._attachClickEvent();
        this._attachHoldEvent();
        this._prepareContent();
        this._renderContent();
        this._renderCancelButton();
      },
      _renderCancelButton: function() {
        if (this._isPopoverMode()) {
          return;
        }
        if (this._$cancelButton) {
          this._$cancelButton.remove();
        }
        if (this.option("showCancelButton")) {
          var cancelClickAction = this._createActionByOption("onCancelClick") || noop2;
          var that = this;
          this._$cancelButton = renderer_default("<div>").addClass(ACTION_SHEET_CANCEL_BUTTON_CLASS).appendTo(this._popup && this._popup.$content());
          this._createComponent(this._$cancelButton, button_default, {
            disabled: false,
            text: this.option("cancelText"),
            onClick: function(e) {
              var hidingArgs = {
                event: e,
                cancel: false
              };
              cancelClickAction(hidingArgs);
              if (!hidingArgs.cancel) {
                that.hide();
              }
            },
            integrationOptions: {}
          });
        }
      },
      _attachItemClickEvent: noop2,
      _itemClickHandler: function(e) {
        this.callBase(e);
        if (!renderer_default(e.target).is(".dx-state-disabled, .dx-state-disabled *")) {
          this.hide();
        }
      },
      _itemHoldHandler: function(e) {
        this.callBase(e);
        if (!renderer_default(e.target).is(".dx-state-disabled, .dx-state-disabled *")) {
          this.hide();
        }
      },
      _optionChanged: function(args) {
        switch (args.name) {
          case "width":
          case "height":
          case "visible":
          case "title":
            this._mapPopupOption(args.name);
            break;
          case "disabled":
            this._renderDisabled();
            break;
          case "showTitle":
            this._renderPopupTitle();
            break;
          case "showCancelButton":
          case "onCancelClick":
          case "cancelText":
            this._renderCancelButton();
            break;
          case "target":
          case "usePopover":
          case "items":
            this._invalidate();
            break;
          default:
            this.callBase(args);
        }
      },
      toggle: function(showing) {
        var that = this;
        var d = new Deferred();
        that._popup.toggle(showing).done(function() {
          that.option("visible", showing);
          d.resolveWith(that);
        });
        return d.promise();
      },
      show: function() {
        return this.toggle(true);
      },
      hide: function() {
        return this.toggle(false);
      }
    });
    component_registrator_default("dxActionSheet", ActionSheet);
    action_sheet_default = ActionSheet;
  }
});

// node_modules/devextreme/esm/ui/list/ui.list.edit.decorator.switchable.slide.js
var LIST_EDIT_DECORATOR3, CLICK_EVENT_NAME2, ACTIVE_EVENT_NAME3, SLIDE_MENU_CLASS, SLIDE_MENU_WRAPPER_CLASS, SLIDE_MENU_CONTENT_CLASS, SLIDE_MENU_BUTTONS_CONTAINER_CLASS, SLIDE_MENU_BUTTONS_CLASS, SLIDE_MENU_BUTTON_CLASS, SLIDE_MENU_BUTTON_MENU_CLASS, SLIDE_MENU_BUTTON_DELETE_CLASS, SLIDE_MENU_ANIMATION_DURATION, SLIDE_MENU_ANIMATION_EASING;
var init_ui_list_edit_decorator_switchable_slide = __esm({
  "node_modules/devextreme/esm/ui/list/ui.list.edit.decorator.switchable.slide.js"() {
    init_renderer();
    init_events_engine();
    init_common();
    init_click();
    init_message();
    init_translator();
    init_utils2();
    init_emitter_feedback();
    init_ui_list_edit_decorator_menu_helper();
    init_ui_list_edit_decorator_registry();
    init_ui_list_edit_decorator_switchable();
    init_fx();
    init_themes();
    init_action_sheet();
    LIST_EDIT_DECORATOR3 = "dxListEditDecorator";
    CLICK_EVENT_NAME2 = addNamespace2(CLICK_EVENT_NAME, LIST_EDIT_DECORATOR3);
    ACTIVE_EVENT_NAME3 = addNamespace2(ACTIVE_EVENT_NAME, LIST_EDIT_DECORATOR3);
    SLIDE_MENU_CLASS = "dx-list-slide-menu";
    SLIDE_MENU_WRAPPER_CLASS = "dx-list-slide-menu-wrapper";
    SLIDE_MENU_CONTENT_CLASS = "dx-list-slide-menu-content";
    SLIDE_MENU_BUTTONS_CONTAINER_CLASS = "dx-list-slide-menu-buttons-container";
    SLIDE_MENU_BUTTONS_CLASS = "dx-list-slide-menu-buttons";
    SLIDE_MENU_BUTTON_CLASS = "dx-list-slide-menu-button";
    SLIDE_MENU_BUTTON_MENU_CLASS = "dx-list-slide-menu-button-menu";
    SLIDE_MENU_BUTTON_DELETE_CLASS = "dx-list-slide-menu-button-delete";
    SLIDE_MENU_ANIMATION_DURATION = 400;
    SLIDE_MENU_ANIMATION_EASING = "cubic-bezier(0.075, 0.82, 0.165, 1)";
    register("menu", "slide", ui_list_edit_decorator_switchable_default.inherit({
      _shouldHandleSwipe: true,
      _init: function() {
        this.callBase.apply(this, arguments);
        this._$buttonsContainer = renderer_default("<div>").addClass(SLIDE_MENU_BUTTONS_CONTAINER_CLASS);
        events_engine_default.on(this._$buttonsContainer, ACTIVE_EVENT_NAME3, noop2);
        this._$buttons = renderer_default("<div>").addClass(SLIDE_MENU_BUTTONS_CLASS).appendTo(this._$buttonsContainer);
        this._renderMenu();
        this._renderDeleteButton();
      },
      _renderMenu: function() {
        if (!this._menuEnabled()) {
          return;
        }
        var menuItems = this._menuItems();
        if (1 === menuItems.length) {
          var menuItem = menuItems[0];
          this._renderMenuButton(menuItem.text, (function(e) {
            e.stopPropagation();
            this._fireAction(menuItem);
          }).bind(this));
        } else {
          var $menu = renderer_default("<div>").addClass(SLIDE_MENU_CLASS);
          this._menu = this._list._createComponent($menu, action_sheet_default, {
            showTitle: false,
            items: menuItems,
            onItemClick: (function(args) {
              this._fireAction(args.itemData);
            }).bind(this),
            integrationOptions: {}
          });
          $menu.appendTo(this._list.$element());
          var $menuButton = this._renderMenuButton(message_default.format("dxListEditDecorator-more"), (function(e) {
            e.stopPropagation();
            this._menu.show();
          }).bind(this));
          this._menu.option("target", $menuButton);
        }
      },
      _renderMenuButton: function(text, action) {
        var $menuButton = renderer_default("<div>").addClass(SLIDE_MENU_BUTTON_CLASS).addClass(SLIDE_MENU_BUTTON_MENU_CLASS).text(text);
        this._$buttons.append($menuButton);
        events_engine_default.on($menuButton, CLICK_EVENT_NAME2, action);
        return $menuButton;
      },
      _renderDeleteButton: function() {
        if (!this._deleteEnabled()) {
          return;
        }
        var $deleteButton = renderer_default("<div>").addClass(SLIDE_MENU_BUTTON_CLASS).addClass(SLIDE_MENU_BUTTON_DELETE_CLASS).text(isMaterial() ? "" : message_default.format("dxListEditDecorator-delete"));
        events_engine_default.on($deleteButton, CLICK_EVENT_NAME2, (function(e) {
          e.stopPropagation();
          this._deleteItem();
        }).bind(this));
        this._$buttons.append($deleteButton);
      },
      _fireAction: function(menuItem) {
        this._fireMenuAction(renderer_default(this._cachedNode), menuItem.action);
        this._cancelDeleteReadyItem();
      },
      modifyElement: function(config2) {
        this.callBase.apply(this, arguments);
        var $itemElement = config2.$itemElement;
        $itemElement.addClass(SLIDE_MENU_WRAPPER_CLASS);
        var $slideMenuContent = renderer_default("<div>").addClass(SLIDE_MENU_CONTENT_CLASS);
        $itemElement.wrapInner($slideMenuContent);
      },
      _getDeleteButtonContainer: function() {
        return this._$buttonsContainer;
      },
      handleClick: function(_2, e) {
        if (renderer_default(e.target).closest("." + SLIDE_MENU_CONTENT_CLASS).length) {
          return this.callBase.apply(this, arguments);
        }
        return false;
      },
      _swipeStartHandler: function($itemElement) {
        this._enablePositioning($itemElement);
        this._cacheItemData($itemElement);
        this._setPositions(this._getPositions(0));
      },
      _swipeUpdateHandler: function($itemElement, args) {
        var rtl = this._isRtlEnabled();
        var signCorrection = rtl ? -1 : 1;
        var isItemReadyToDelete = this._isReadyToDelete($itemElement);
        var moveJustStarted = this._getCurrentPositions().content === this._getStartPositions().content;
        if (moveJustStarted && !isItemReadyToDelete && args.offset * signCorrection > 0) {
          args.cancel = true;
          return;
        }
        var offset2 = this._cachedItemWidth * args.offset;
        var startOffset = isItemReadyToDelete ? -this._cachedButtonWidth * signCorrection : 0;
        var correctedOffset = (offset2 + startOffset) * signCorrection;
        var percent = correctedOffset < 0 ? Math.abs((offset2 + startOffset) / this._cachedButtonWidth) : 0;
        this._setPositions(this._getPositions(percent));
        return true;
      },
      _getStartPositions: function() {
        var rtl = this._isRtlEnabled();
        var signCorrection = rtl ? -1 : 1;
        return {
          content: 0,
          buttonsContainer: rtl ? -this._cachedButtonWidth : this._cachedItemWidth,
          buttons: -this._cachedButtonWidth * signCorrection
        };
      },
      _getPositions: function(percent) {
        var rtl = this._isRtlEnabled();
        var signCorrection = rtl ? -1 : 1;
        var startPositions = this._getStartPositions();
        return {
          content: startPositions.content - percent * this._cachedButtonWidth * signCorrection,
          buttonsContainer: startPositions.buttonsContainer - Math.min(percent, 1) * this._cachedButtonWidth * signCorrection,
          buttons: startPositions.buttons + Math.min(percent, 1) * this._cachedButtonWidth * signCorrection
        };
      },
      _getCurrentPositions: function() {
        return {
          content: locate(this._$cachedContent).left,
          buttonsContainer: locate(this._$buttonsContainer).left,
          buttons: locate(this._$buttons).left
        };
      },
      _setPositions: function(positions) {
        move(this._$cachedContent, {
          left: positions.content
        });
        move(this._$buttonsContainer, {
          left: positions.buttonsContainer
        });
        move(this._$buttons, {
          left: positions.buttons
        });
      },
      _cacheItemData: function($itemElement) {
        if ($itemElement[0] === this._cachedNode) {
          return;
        }
        this._$cachedContent = $itemElement.find("." + SLIDE_MENU_CONTENT_CLASS);
        this._cachedItemWidth = $itemElement.outerWidth();
        this._cachedButtonWidth = this._cachedButtonWidth || this._$buttons.outerWidth();
        this._$buttonsContainer.width(this._cachedButtonWidth);
        if (this._$cachedContent.length) {
          this._cachedNode = $itemElement[0];
        }
      },
      _minButtonContainerLeftOffset: function() {
        return this._cachedItemWidth - this._cachedButtonWidth;
      },
      _swipeEndHandler: function($itemElement, args) {
        this._cacheItemData($itemElement);
        var signCorrection = this._isRtlEnabled() ? 1 : -1;
        var offset2 = this._cachedItemWidth * args.offset;
        var endedAtReadyToDelete = !this._isReadyToDelete($itemElement) && offset2 * signCorrection > 0.2 * this._cachedButtonWidth;
        var readyToDelete = args.targetOffset === signCorrection && endedAtReadyToDelete;
        this._toggleDeleteReady($itemElement, readyToDelete);
        return true;
      },
      _enablePositioning: function($itemElement) {
        fx_default.stop(this._$cachedContent, true);
        this.callBase.apply(this, arguments);
        this._$buttonsContainer.appendTo($itemElement);
      },
      _disablePositioning: function() {
        this.callBase.apply(this, arguments);
        this._$buttonsContainer.detach();
      },
      _animatePrepareDeleteReady: function() {
        return this._animateToPositions(this._getPositions(1));
      },
      _animateForgetDeleteReady: function($itemElement) {
        this._cacheItemData($itemElement);
        return this._animateToPositions(this._getPositions(0));
      },
      _animateToPositions: function(positions) {
        var that = this;
        var currentPosition = this._getCurrentPositions();
        var durationTimePart = Math.min(Math.abs(currentPosition.content - positions.content) / this._cachedButtonWidth, 1);
        return fx_default.animate(this._$cachedContent, {
          from: currentPosition,
          to: positions,
          easing: SLIDE_MENU_ANIMATION_EASING,
          duration: SLIDE_MENU_ANIMATION_DURATION * durationTimePart,
          strategy: "frame",
          draw: function(positions2) {
            that._setPositions(positions2);
          }
        });
      },
      dispose: function() {
        if (this._menu) {
          this._menu.$element().remove();
        }
        if (this._$buttonsContainer) {
          this._$buttonsContainer.remove();
        }
        this.callBase.apply(this, arguments);
      }
    }).include(ui_list_edit_decorator_menu_helper_default));
  }
});

// node_modules/devextreme/esm/ui/list/ui.list.edit.decorator.swipe.js
var init_ui_list_edit_decorator_swipe = __esm({
  "node_modules/devextreme/esm/ui/list/ui.list.edit.decorator.swipe.js"() {
    init_translator();
    init_fx();
    init_ui_list_edit_decorator_registry();
    init_ui_list_edit_decorator();
    init_deferred();
    register("delete", "swipe", ui_list_edit_decorator_default.inherit({
      _shouldHandleSwipe: true,
      _renderItemPosition: function($itemElement, offset2, animate3) {
        var deferred = new Deferred();
        var itemOffset = offset2 * this._itemElementWidth;
        if (animate3) {
          fx_default.animate($itemElement, {
            to: {
              left: itemOffset
            },
            type: "slide",
            complete: function() {
              deferred.resolve($itemElement, offset2);
            }
          });
        } else {
          move($itemElement, {
            left: itemOffset
          });
          deferred.resolve();
        }
        return deferred.promise();
      },
      _swipeStartHandler: function($itemElement) {
        this._itemElementWidth = $itemElement.width();
        return true;
      },
      _swipeUpdateHandler: function($itemElement, args) {
        this._renderItemPosition($itemElement, args.offset);
        return true;
      },
      _swipeEndHandler: function($itemElement, args) {
        var offset2 = args.targetOffset;
        this._renderItemPosition($itemElement, offset2, true).done((function($itemElement2, offset3) {
          if (Math.abs(offset3)) {
            this._list.deleteItem($itemElement2).fail((function() {
              this._renderItemPosition($itemElement2, 0, true);
            }).bind(this));
          }
        }).bind(this));
        return true;
      }
    }));
  }
});

// node_modules/devextreme/esm/ui/list/item.js
var LIST_ITEM_BADGE_CONTAINER_CLASS, LIST_ITEM_BADGE_CLASS, BADGE_CLASS, LIST_ITEM_CHEVRON_CONTAINER_CLASS, LIST_ITEM_CHEVRON_CLASS, ListItem, item_default2;
var init_item2 = __esm({
  "node_modules/devextreme/esm/ui/list/item.js"() {
    init_renderer();
    init_item();
    LIST_ITEM_BADGE_CONTAINER_CLASS = "dx-list-item-badge-container";
    LIST_ITEM_BADGE_CLASS = "dx-list-item-badge";
    BADGE_CLASS = "dx-badge";
    LIST_ITEM_CHEVRON_CONTAINER_CLASS = "dx-list-item-chevron-container";
    LIST_ITEM_CHEVRON_CLASS = "dx-list-item-chevron";
    ListItem = item_default.inherit({
      _renderWatchers: function() {
        this.callBase();
        this._startWatcher("badge", this._renderBadge.bind(this));
        this._startWatcher("showChevron", this._renderShowChevron.bind(this));
      },
      _renderBadge: function(badge) {
        this._$element.children("." + LIST_ITEM_BADGE_CONTAINER_CLASS).remove();
        if (!badge) {
          return;
        }
        var $badge = renderer_default("<div>").addClass(LIST_ITEM_BADGE_CONTAINER_CLASS).append(renderer_default("<div>").addClass(LIST_ITEM_BADGE_CLASS).addClass(BADGE_CLASS).text(badge));
        var $chevron = this._$element.children("." + LIST_ITEM_CHEVRON_CONTAINER_CLASS).first();
        $chevron.length > 0 ? $badge.insertBefore($chevron) : $badge.appendTo(this._$element);
      },
      _renderShowChevron: function(showChevron) {
        this._$element.children("." + LIST_ITEM_CHEVRON_CONTAINER_CLASS).remove();
        if (!showChevron) {
          return;
        }
        var $chevronContainer = renderer_default("<div>").addClass(LIST_ITEM_CHEVRON_CONTAINER_CLASS);
        var $chevron = renderer_default("<div>").addClass(LIST_ITEM_CHEVRON_CLASS);
        $chevronContainer.append($chevron).appendTo(this._$element);
      }
    });
    item_default2 = ListItem;
  }
});

// node_modules/devextreme/esm/ui/scroll_view/ui.scrollbar.js
var SCROLLBAR, SCROLLABLE_SCROLLBAR_CLASS, SCROLLABLE_SCROLLBAR_ACTIVE_CLASS, SCROLLABLE_SCROLL_CLASS, SCROLLABLE_SCROLL_CONTENT_CLASS, HOVER_ENABLED_STATE, HORIZONTAL, THUMB_MIN_SIZE, SCROLLBAR_VISIBLE, activeScrollbar, Scrollbar, ui_scrollbar_default;
var init_ui_scrollbar = __esm({
  "node_modules/devextreme/esm/ui/scroll_view/ui.scrollbar.js"() {
    init_renderer();
    init_dom_adapter();
    init_events_engine();
    init_ready_callbacks();
    init_translator();
    init_ui_widget();
    init_utils2();
    init_common();
    init_type();
    init_extend();
    init_pointer();
    SCROLLBAR = "dxScrollbar";
    SCROLLABLE_SCROLLBAR_CLASS = "dx-scrollable-scrollbar";
    SCROLLABLE_SCROLLBAR_ACTIVE_CLASS = "".concat(SCROLLABLE_SCROLLBAR_CLASS, "-active");
    SCROLLABLE_SCROLL_CLASS = "dx-scrollable-scroll";
    SCROLLABLE_SCROLL_CONTENT_CLASS = "dx-scrollable-scroll-content";
    HOVER_ENABLED_STATE = "dx-scrollbar-hoverable";
    HORIZONTAL = "horizontal";
    THUMB_MIN_SIZE = 15;
    SCROLLBAR_VISIBLE = {
      onScroll: "onScroll",
      onHover: "onHover",
      always: "always",
      never: "never"
    };
    activeScrollbar = null;
    Scrollbar = ui_widget_default.inherit({
      _getDefaultOptions: function() {
        return extend2(this.callBase(), {
          direction: null,
          visible: false,
          activeStateEnabled: false,
          visibilityMode: SCROLLBAR_VISIBLE.onScroll,
          containerSize: 0,
          contentSize: 0,
          expandable: true,
          scaleRatio: 1
        });
      },
      _init: function() {
        this.callBase();
        this._isHovered = false;
      },
      _initMarkup: function() {
        this._renderThumb();
        this.callBase();
      },
      _render: function() {
        this.callBase();
        this._renderDirection();
        this._update();
        this._attachPointerDownHandler();
        this.option("hoverStateEnabled", this._isHoverMode());
        this.$element().toggleClass(HOVER_ENABLED_STATE, this.option("hoverStateEnabled"));
      },
      _renderThumb: function() {
        this._$thumb = renderer_default("<div>").addClass(SCROLLABLE_SCROLL_CLASS);
        renderer_default("<div>").addClass(SCROLLABLE_SCROLL_CONTENT_CLASS).appendTo(this._$thumb);
        this.$element().addClass(SCROLLABLE_SCROLLBAR_CLASS).append(this._$thumb);
      },
      isThumb: function($element) {
        return !!this.$element().find($element).length;
      },
      _isHoverMode: function() {
        var visibilityMode = this.option("visibilityMode");
        return (visibilityMode === SCROLLBAR_VISIBLE.onHover || visibilityMode === SCROLLBAR_VISIBLE.always) && this.option("expandable");
      },
      _renderDirection: function() {
        var direction = this.option("direction");
        this.$element().addClass("dx-scrollbar-" + direction);
        this._dimension = direction === HORIZONTAL ? "width" : "height";
        this._prop = direction === HORIZONTAL ? "left" : "top";
      },
      _attachPointerDownHandler: function() {
        events_engine_default.on(this._$thumb, addNamespace2(pointer_default.down, SCROLLBAR), this.feedbackOn.bind(this));
      },
      feedbackOn: function() {
        this.$element().addClass(SCROLLABLE_SCROLLBAR_ACTIVE_CLASS);
        activeScrollbar = this;
      },
      feedbackOff: function() {
        this.$element().removeClass(SCROLLABLE_SCROLLBAR_ACTIVE_CLASS);
        activeScrollbar = null;
      },
      cursorEnter: function() {
        this._isHovered = true;
        if (this._needScrollbar()) {
          this.option("visible", true);
        }
      },
      cursorLeave: function() {
        this._isHovered = false;
        this.option("visible", false);
      },
      _renderDimensions: function() {
        this._$thumb.css({
          width: this.option("width"),
          height: this.option("height")
        });
      },
      _toggleVisibility: function(visible2) {
        if (this.option("visibilityMode") === SCROLLBAR_VISIBLE.onScroll) {
          this._$thumb.css("opacity");
        }
        visible2 = this._adjustVisibility(visible2);
        this.option().visible = visible2;
        this._$thumb.toggleClass("dx-state-invisible", !visible2);
      },
      _adjustVisibility: function(visible2) {
        if (this._baseContainerToContentRatio && !this._needScrollbar()) {
          return false;
        }
        switch (this.option("visibilityMode")) {
          case SCROLLBAR_VISIBLE.onScroll:
            break;
          case SCROLLBAR_VISIBLE.onHover:
            visible2 = visible2 || !!this._isHovered;
            break;
          case SCROLLBAR_VISIBLE.never:
            visible2 = false;
            break;
          case SCROLLBAR_VISIBLE.always:
            visible2 = true;
        }
        return visible2;
      },
      moveTo: function(location) {
        if (this._isHidden()) {
          return;
        }
        if (isPlainObject(location)) {
          location = location[this._prop] || 0;
        }
        var scrollBarLocation = {};
        scrollBarLocation[this._prop] = this._calculateScrollBarPosition(location);
        move(this._$thumb, scrollBarLocation);
      },
      _calculateScrollBarPosition: function(location) {
        return -location * this._thumbRatio;
      },
      _update: function() {
        var containerSize = Math.round(this.option("containerSize"));
        var contentSize = Math.round(this.option("contentSize"));
        var baseContainerSize = Math.round(this.option("baseContainerSize"));
        var baseContentSize = Math.round(this.option("baseContentSize"));
        if (isNaN(baseContainerSize)) {
          baseContainerSize = containerSize;
          baseContentSize = contentSize;
        }
        this._baseContainerToContentRatio = baseContentSize ? baseContainerSize / baseContentSize : baseContainerSize;
        this._realContainerToContentRatio = contentSize ? containerSize / contentSize : containerSize;
        var thumbSize = Math.round(Math.max(Math.round(containerSize * this._realContainerToContentRatio), THUMB_MIN_SIZE));
        this._thumbRatio = (containerSize - thumbSize) / (this.option("scaleRatio") * (contentSize - containerSize));
        this.option(this._dimension, thumbSize / this.option("scaleRatio"));
        this.$element().css("display", this._needScrollbar() ? "" : "none");
      },
      _isHidden: function() {
        return this.option("visibilityMode") === SCROLLBAR_VISIBLE.never;
      },
      _needScrollbar: function() {
        return !this._isHidden() && this._baseContainerToContentRatio < 1;
      },
      containerToContentRatio: function() {
        return this._realContainerToContentRatio;
      },
      _normalizeSize: function(size) {
        return isPlainObject(size) ? size[this._dimension] || 0 : size;
      },
      _clean: function() {
        this.callBase();
        if (this === activeScrollbar) {
          activeScrollbar = null;
        }
        events_engine_default.off(this._$thumb, "." + SCROLLBAR);
      },
      _optionChanged: function(args) {
        if (this._isHidden()) {
          return;
        }
        switch (args.name) {
          case "containerSize":
          case "contentSize":
            this.option()[args.name] = this._normalizeSize(args.value);
            this._update();
            break;
          case "baseContentSize":
          case "baseContainerSize":
            this._update();
            break;
          case "visibilityMode":
          case "direction":
            this._invalidate();
            break;
          case "scaleRatio":
            this._update();
            break;
          default:
            this.callBase.apply(this, arguments);
        }
      },
      update: deferRenderer(function() {
        this._adjustVisibility() && this.option("visible", true);
      })
    });
    ready_callbacks_default.add(function() {
      events_engine_default.subscribeGlobal(dom_adapter_default.getDocument(), addNamespace2(pointer_default.up, SCROLLBAR), function() {
        if (activeScrollbar) {
          activeScrollbar.feedbackOff();
        }
      });
    });
    ui_scrollbar_default = Scrollbar;
  }
});

// node_modules/devextreme/esm/ui/scroll_view/ui.scrollable.native.js
var SCROLLABLE_NATIVE, SCROLLABLE_NATIVE_CLASS, SCROLLABLE_SCROLLBAR_SIMULATED, SCROLLABLE_SCROLLBARS_HIDDEN, VERTICAL, HORIZONTAL2, HIDE_SCROLLBAR_TIMEOUT, isIE, NativeStrategy, ui_scrollable_native_default;
var init_ui_scrollable_native = __esm({
  "node_modules/devextreme/esm/ui/scroll_view/ui.scrollable.native.js"() {
    init_renderer();
    init_events_engine();
    init_utils2();
    init_common();
    init_iterator();
    init_devices();
    init_class();
    init_ui_scrollbar();
    init_browser();
    SCROLLABLE_NATIVE = "dxNativeScrollable";
    SCROLLABLE_NATIVE_CLASS = "dx-scrollable-native";
    SCROLLABLE_SCROLLBAR_SIMULATED = "dx-scrollable-scrollbar-simulated";
    SCROLLABLE_SCROLLBARS_HIDDEN = "dx-scrollable-scrollbars-hidden";
    VERTICAL = "vertical";
    HORIZONTAL2 = "horizontal";
    HIDE_SCROLLBAR_TIMEOUT = 500;
    isIE = browser_default.msie && browser_default.version < 12;
    NativeStrategy = class_default.inherit({
      ctor: function(scrollable) {
        this._init(scrollable);
      },
      _init: function(scrollable) {
        this._component = scrollable;
        this._$element = scrollable.$element();
        this._$container = renderer_default(scrollable.container());
        this._$content = scrollable.$content();
        this._direction = scrollable.option("direction");
        this._useSimulatedScrollbar = scrollable.option("useSimulatedScrollbar");
        this.option = scrollable.option.bind(scrollable);
        this._createActionByOption = scrollable._createActionByOption.bind(scrollable);
        this._isLocked = scrollable._isLocked.bind(scrollable);
        this._isDirection = scrollable._isDirection.bind(scrollable);
        this._allowedDirection = scrollable._allowedDirection.bind(scrollable);
        this._getMaxOffset = scrollable._getMaxOffset.bind(scrollable);
        this._isRtlNativeStrategy = scrollable._isRtlNativeStrategy.bind(scrollable);
      },
      render: function() {
        var device = devices_default.real();
        var deviceType = device.platform;
        this._$element.addClass(SCROLLABLE_NATIVE_CLASS).addClass(SCROLLABLE_NATIVE_CLASS + "-" + deviceType).toggleClass(SCROLLABLE_SCROLLBARS_HIDDEN, !this._isScrollbarVisible());
        if (this._isScrollbarVisible() && this._useSimulatedScrollbar) {
          this._renderScrollbars();
        }
      },
      updateRtlPosition: function(isFirstRender) {
        if (isFirstRender && this.option("rtlEnabled")) {
          if (this._isScrollbarVisible() && this._useSimulatedScrollbar) {
            this._moveScrollbars();
          }
        }
      },
      _renderScrollbars: function() {
        this._scrollbars = {};
        this._hideScrollbarTimeout = 0;
        this._$element.addClass(SCROLLABLE_SCROLLBAR_SIMULATED);
        this._renderScrollbar(VERTICAL);
        this._renderScrollbar(HORIZONTAL2);
      },
      _renderScrollbar: function(direction) {
        if (!this._isDirection(direction)) {
          return;
        }
        this._scrollbars[direction] = new ui_scrollbar_default(renderer_default("<div>").appendTo(this._$element), {
          direction,
          expandable: this._component.option("scrollByThumb")
        });
      },
      handleInit: noop2,
      handleStart: noop2,
      handleMove: function(e) {
        if (this._isLocked()) {
          e.cancel = true;
          return;
        }
        if (this._allowedDirection()) {
          e.originalEvent.isScrollingEvent = true;
        }
      },
      handleEnd: noop2,
      handleCancel: noop2,
      handleStop: noop2,
      _eachScrollbar: function(callback) {
        callback = callback.bind(this);
        each(this._scrollbars || {}, function(direction, scrollbar) {
          callback(scrollbar, direction);
        });
      },
      createActions: function() {
        this._scrollAction = this._createActionByOption("onScroll");
        this._updateAction = this._createActionByOption("onUpdated");
      },
      _createActionArgs: function() {
        var {
          left,
          top
        } = this.location();
        return {
          event: this._eventForUserAction,
          scrollOffset: this._getScrollOffset(),
          reachedLeft: this._isRtlNativeStrategy() ? this._isReachedRight(-left) : this._isReachedLeft(left),
          reachedRight: this._isRtlNativeStrategy() ? this._isReachedLeft(-Math.abs(left)) : this._isReachedRight(left),
          reachedTop: this._isDirection(VERTICAL) ? Math.round(top) >= 0 : void 0,
          reachedBottom: this._isDirection(VERTICAL) ? Math.round(Math.abs(top) - this._getMaxOffset().top) >= 0 : void 0
        };
      },
      _getScrollOffset: function() {
        var {
          top,
          left
        } = this.location();
        return {
          top: -top,
          left: this._normalizeOffsetLeft(-left)
        };
      },
      _normalizeOffsetLeft(scrollLeft) {
        if (this._isRtlNativeStrategy()) {
          return this._getMaxOffset().left + this._getScrollSign() * scrollLeft;
        }
        return scrollLeft;
      },
      _isReachedLeft: function(left) {
        return this._isDirection(HORIZONTAL2) ? Math.round(left) >= 0 : void 0;
      },
      _isReachedRight: function(left) {
        return this._isDirection(HORIZONTAL2) ? Math.round(Math.abs(left) - this._getMaxOffset().left) >= 0 : void 0;
      },
      _isScrollbarVisible: function() {
        var {
          showScrollbar
        } = this.option();
        return "never" !== showScrollbar && false !== showScrollbar;
      },
      handleScroll: function(e) {
        this._eventForUserAction = e;
        this._moveScrollbars();
        this._scrollAction(this._createActionArgs());
      },
      _moveScrollbars: function() {
        var {
          top,
          left
        } = this._getScrollOffset();
        this._eachScrollbar(function(scrollbar) {
          scrollbar.moveTo({
            top: -top,
            left: -left
          });
          scrollbar.option("visible", true);
        });
        this._hideScrollbars();
      },
      _hideScrollbars: function() {
        clearTimeout(this._hideScrollbarTimeout);
        this._hideScrollbarTimeout = setTimeout((function() {
          this._eachScrollbar(function(scrollbar) {
            scrollbar.option("visible", false);
          });
        }).bind(this), HIDE_SCROLLBAR_TIMEOUT);
      },
      location: function() {
        return {
          left: -this._$container.scrollLeft(),
          top: -this._$container.scrollTop()
        };
      },
      disabledChanged: noop2,
      update: function() {
        this._update();
        this._updateAction(this._createActionArgs());
      },
      _update: function() {
        this._updateDimensions();
        this._updateScrollbars();
      },
      _updateDimensions: function() {
        this._containerSize = {
          height: this._$container.height(),
          width: this._$container.width()
        };
        this._componentContentSize = {
          height: this._component.$content().height(),
          width: this._component.$content().width()
        };
        this._contentSize = {
          height: this._$content.height(),
          width: this._$content.width()
        };
      },
      _updateScrollbars: function() {
        this._eachScrollbar(function(scrollbar, direction) {
          var dimension = direction === VERTICAL ? "height" : "width";
          scrollbar.option({
            containerSize: this._containerSize[dimension],
            contentSize: this._componentContentSize[dimension]
          });
          scrollbar.update();
        });
      },
      _allowedDirections: function() {
        return {
          vertical: this._isDirection(VERTICAL) && this._contentSize.height > this._containerSize.height,
          horizontal: this._isDirection(HORIZONTAL2) && this._contentSize.width > this._containerSize.width
        };
      },
      dispose: function() {
        var className = this._$element.get(0).className;
        var scrollableNativeRegexp = new RegExp(SCROLLABLE_NATIVE_CLASS + "\\S*", "g");
        if (scrollableNativeRegexp.test(className)) {
          this._$element.removeClass(className.match(scrollableNativeRegexp).join(" "));
        }
        events_engine_default.off(this._$element, "." + SCROLLABLE_NATIVE);
        events_engine_default.off(this._$container, "." + SCROLLABLE_NATIVE);
        this._removeScrollbars();
        clearTimeout(this._hideScrollbarTimeout);
      },
      _removeScrollbars: function() {
        this._eachScrollbar(function(scrollbar) {
          scrollbar.$element().remove();
        });
      },
      scrollBy: function(distance) {
        var location = this.location();
        this._$container.scrollTop(Math.round(-location.top - distance.top));
        this._$container.scrollLeft(Math.round(-location.left - this._getScrollSign() * distance.left));
      },
      _getScrollSign() {
        return isIE && this._isRtlNativeStrategy() ? -1 : 1;
      },
      validate: function(e) {
        if (this.option("disabled")) {
          return false;
        }
        if (isDxMouseWheelEvent(e) && this._isScrolledInMaxDirection(e)) {
          return false;
        }
        return !!this._allowedDirection();
      },
      _isScrolledInMaxDirection(e) {
        var container = this._$container.get(0);
        var result2;
        if (e.delta > 0) {
          result2 = e.shiftKey ? !container.scrollLeft : !container.scrollTop;
        } else if (e.shiftKey) {
          result2 = container.scrollLeft >= this._getMaxOffset().left;
        } else {
          result2 = container.scrollTop >= this._getMaxOffset().top;
        }
        return result2;
      },
      getDirection: function() {
        return this._allowedDirection();
      }
    });
    ui_scrollable_native_default = NativeStrategy;
  }
});

// node_modules/devextreme/esm/ui/scroll_view/ui.scroll_view.native.pull_down.js
var SCROLLVIEW_PULLDOWN_REFRESHING_CLASS, SCROLLVIEW_PULLDOWN_READY_CLASS, SCROLLVIEW_PULLDOWN_IMAGE_CLASS, SCROLLVIEW_PULLDOWN_INDICATOR_CLASS, SCROLLVIEW_PULLDOWN_TEXT_CLASS, SCROLLVIEW_PULLDOWN_VISIBLE_TEXT_CLASS, STATE_RELEASED, STATE_READY, STATE_REFRESHING, STATE_LOADING, PULLDOWN_RELEASE_TIME, PullDownNativeScrollViewStrategy, ui_scroll_view_native_pull_down_default;
var init_ui_scroll_view_native_pull_down = __esm({
  "node_modules/devextreme/esm/ui/scroll_view/ui.scroll_view.native.pull_down.js"() {
    init_renderer();
    init_callbacks();
    init_translator();
    init_ui_scrollable_native();
    init_load_indicator();
    init_iterator();
    init_deferred();
    SCROLLVIEW_PULLDOWN_REFRESHING_CLASS = "dx-scrollview-pull-down-loading";
    SCROLLVIEW_PULLDOWN_READY_CLASS = "dx-scrollview-pull-down-ready";
    SCROLLVIEW_PULLDOWN_IMAGE_CLASS = "dx-scrollview-pull-down-image";
    SCROLLVIEW_PULLDOWN_INDICATOR_CLASS = "dx-scrollview-pull-down-indicator";
    SCROLLVIEW_PULLDOWN_TEXT_CLASS = "dx-scrollview-pull-down-text";
    SCROLLVIEW_PULLDOWN_VISIBLE_TEXT_CLASS = "dx-scrollview-pull-down-text-visible";
    STATE_RELEASED = 0;
    STATE_READY = 1;
    STATE_REFRESHING = 2;
    STATE_LOADING = 3;
    PULLDOWN_RELEASE_TIME = 400;
    PullDownNativeScrollViewStrategy = ui_scrollable_native_default.inherit({
      _init: function(scrollView) {
        this.callBase(scrollView);
        this._$topPocket = scrollView._$topPocket;
        this._$pullDown = scrollView._$pullDown;
        this._$refreshingText = scrollView._$refreshingText;
        this._$scrollViewContent = renderer_default(scrollView.content());
        this._$container = renderer_default(scrollView.container());
        this._initCallbacks();
      },
      _initCallbacks: function() {
        this.pullDownCallbacks = callbacks_default();
        this.releaseCallbacks = callbacks_default();
        this.reachBottomCallbacks = callbacks_default();
      },
      render: function() {
        this.callBase();
        this._renderPullDown();
        this._releaseState();
      },
      _renderPullDown: function() {
        var $image = renderer_default("<div>").addClass(SCROLLVIEW_PULLDOWN_IMAGE_CLASS);
        var $loadContainer = renderer_default("<div>").addClass(SCROLLVIEW_PULLDOWN_INDICATOR_CLASS);
        var $loadIndicator = new load_indicator_default(renderer_default("<div>")).$element();
        var $text = this._$pullDownText = renderer_default("<div>").addClass(SCROLLVIEW_PULLDOWN_TEXT_CLASS);
        this._$pullingDownText = renderer_default("<div>").text(this.option("pullingDownText")).appendTo($text);
        this._$pulledDownText = renderer_default("<div>").text(this.option("pulledDownText")).appendTo($text);
        this._$refreshingText = renderer_default("<div>").text(this.option("refreshingText")).appendTo($text);
        this._$pullDown.empty().append($image).append($loadContainer.append($loadIndicator)).append($text);
      },
      _releaseState: function() {
        this._state = STATE_RELEASED;
        this._refreshPullDownText();
      },
      _refreshPullDownText: function() {
        var that = this;
        var pullDownTextItems = [{
          element: this._$pullingDownText,
          visibleState: STATE_RELEASED
        }, {
          element: this._$pulledDownText,
          visibleState: STATE_READY
        }, {
          element: this._$refreshingText,
          visibleState: STATE_REFRESHING
        }];
        each(pullDownTextItems, function(_2, item) {
          var action = that._state === item.visibleState ? "addClass" : "removeClass";
          item.element[action](SCROLLVIEW_PULLDOWN_VISIBLE_TEXT_CLASS);
        });
      },
      update: function() {
        this.callBase();
        this._setTopPocketOffset();
      },
      _updateDimensions: function() {
        this.callBase();
        this._topPocketSize = this._$topPocket.get(0).clientHeight;
        var contentEl = this._$scrollViewContent.get(0);
        var containerEl = this._$container.get(0);
        this._bottomBoundary = Math.max(contentEl.clientHeight - containerEl.clientHeight, 0);
      },
      _allowedDirections: function() {
        var allowedDirections = this.callBase();
        allowedDirections.vertical = allowedDirections.vertical || this._pullDownEnabled;
        return allowedDirections;
      },
      _setTopPocketOffset: function() {
        this._$topPocket.css({
          top: -this._topPocketSize
        });
      },
      handleEnd: function() {
        this.callBase();
        this._complete();
      },
      handleStop: function() {
        this.callBase();
        this._complete();
      },
      _complete: function() {
        if (this._state === STATE_READY) {
          this._setPullDownOffset(this._topPocketSize);
          clearTimeout(this._pullDownRefreshTimeout);
          this._pullDownRefreshTimeout = setTimeout((function() {
            this._pullDownRefreshing();
          }).bind(this), 400);
        }
      },
      _setPullDownOffset: function(offset2) {
        move(this._$topPocket, {
          top: offset2
        });
        move(this._$scrollViewContent, {
          top: offset2
        });
      },
      handleScroll: function(e) {
        this.callBase(e);
        if (this._state === STATE_REFRESHING) {
          return;
        }
        var currentLocation = this.location().top;
        var scrollDelta = (this._location || 0) - currentLocation;
        this._location = currentLocation;
        if (this._isPullDown()) {
          this._pullDownReady();
        } else if (scrollDelta > 0 && this._isReachBottom()) {
          this._reachBottom();
        } else {
          this._stateReleased();
        }
      },
      _isPullDown: function() {
        return this._pullDownEnabled && this._location >= this._topPocketSize;
      },
      _isReachBottom: function() {
        return this._reachBottomEnabled && Math.round(this._bottomBoundary + Math.floor(this._location)) <= 1;
      },
      _reachBottom: function() {
        if (this._state === STATE_LOADING) {
          return;
        }
        this._state = STATE_LOADING;
        this.reachBottomCallbacks.fire();
      },
      _pullDownReady: function() {
        if (this._state === STATE_READY) {
          return;
        }
        this._state = STATE_READY;
        this._$pullDown.addClass(SCROLLVIEW_PULLDOWN_READY_CLASS);
        this._refreshPullDownText();
      },
      _stateReleased: function() {
        if (this._state === STATE_RELEASED) {
          return;
        }
        this._$pullDown.removeClass(SCROLLVIEW_PULLDOWN_REFRESHING_CLASS).removeClass(SCROLLVIEW_PULLDOWN_READY_CLASS);
        this._releaseState();
      },
      _pullDownRefreshing: function() {
        if (this._state === STATE_REFRESHING) {
          return;
        }
        this._state = STATE_REFRESHING;
        this._$pullDown.addClass(SCROLLVIEW_PULLDOWN_REFRESHING_CLASS).removeClass(SCROLLVIEW_PULLDOWN_READY_CLASS);
        this._refreshPullDownText();
        this.pullDownCallbacks.fire();
      },
      pullDownEnable: function(enabled) {
        if (enabled) {
          this._updateDimensions();
          this._setTopPocketOffset();
        }
        this._pullDownEnabled = enabled;
      },
      reachBottomEnable: function(enabled) {
        this._reachBottomEnabled = enabled;
      },
      pendingRelease: function() {
        this._state = STATE_READY;
      },
      release: function() {
        var deferred = new Deferred();
        this._updateDimensions();
        clearTimeout(this._releaseTimeout);
        if (this._state === STATE_LOADING) {
          this._state = STATE_RELEASED;
        }
        this._releaseTimeout = setTimeout((function() {
          this._setPullDownOffset(0);
          this._stateReleased();
          this.releaseCallbacks.fire();
          this._updateAction();
          deferred.resolve();
        }).bind(this), PULLDOWN_RELEASE_TIME);
        return deferred.promise();
      },
      dispose: function() {
        clearTimeout(this._pullDownRefreshTimeout);
        clearTimeout(this._releaseTimeout);
        this.callBase();
      }
    });
    ui_scroll_view_native_pull_down_default = PullDownNativeScrollViewStrategy;
  }
});

// node_modules/devextreme/esm/ui/scroll_view/ui.scroll_view.native.swipe_down.js
var SCROLLVIEW_PULLDOWN_DOWN_LOADING_CLASS, SCROLLVIEW_PULLDOWN_INDICATOR_CLASS2, SCROLLVIEW_PULLDOWN_REFRESHING_CLASS2, PULLDOWN_ICON_CLASS, STATE_RELEASED2, STATE_READY2, STATE_REFRESHING2, STATE_TOUCHED, STATE_PULLED, SwipeDownNativeScrollViewStrategy, ui_scroll_view_native_swipe_down_default;
var init_ui_scroll_view_native_swipe_down = __esm({
  "node_modules/devextreme/esm/ui/scroll_view/ui.scroll_view.native.swipe_down.js"() {
    init_renderer();
    init_callbacks();
    init_translator();
    init_utils2();
    init_ui_scrollable_native();
    init_load_indicator();
    init_deferred();
    SCROLLVIEW_PULLDOWN_DOWN_LOADING_CLASS = "dx-scrollview-pull-down-loading";
    SCROLLVIEW_PULLDOWN_INDICATOR_CLASS2 = "dx-scrollview-pull-down-indicator";
    SCROLLVIEW_PULLDOWN_REFRESHING_CLASS2 = "dx-scrollview-pull-down-refreshing";
    PULLDOWN_ICON_CLASS = "dx-icon-pulldown";
    STATE_RELEASED2 = 0;
    STATE_READY2 = 1;
    STATE_REFRESHING2 = 2;
    STATE_TOUCHED = 4;
    STATE_PULLED = 5;
    SwipeDownNativeScrollViewStrategy = ui_scrollable_native_default.inherit({
      _init: function(scrollView) {
        this.callBase(scrollView);
        this._$topPocket = scrollView._$topPocket;
        this._$pullDown = scrollView._$pullDown;
        this._$scrollViewContent = renderer_default(scrollView.content());
        this._$container = renderer_default(scrollView.container());
        this._initCallbacks();
        this._location = 0;
      },
      _initCallbacks: function() {
        this.pullDownCallbacks = callbacks_default();
        this.releaseCallbacks = callbacks_default();
        this.reachBottomCallbacks = callbacks_default();
      },
      render: function() {
        this.callBase();
        this._renderPullDown();
        this._releaseState();
      },
      _renderPullDown: function() {
        var $loadContainer = renderer_default("<div>").addClass(SCROLLVIEW_PULLDOWN_INDICATOR_CLASS2);
        var $loadIndicator = new load_indicator_default(renderer_default("<div>")).$element();
        this._$icon = renderer_default("<div>").addClass(PULLDOWN_ICON_CLASS);
        this._$pullDown.empty().append(this._$icon).append($loadContainer.append($loadIndicator));
      },
      _releaseState: function() {
        this._state = STATE_RELEASED2;
        this._releasePullDown();
        this._updateDimensions();
      },
      _releasePullDown: function() {
        this._$pullDown.css({
          opacity: 0
        });
      },
      _updateDimensions: function() {
        this.callBase();
        this._topPocketSize = this._$topPocket.get(0).clientHeight;
        var contentEl = this._$scrollViewContent.get(0);
        var containerEl = this._$container.get(0);
        this._bottomBoundary = Math.max(contentEl.clientHeight - containerEl.clientHeight, 0);
      },
      _allowedDirections: function() {
        var allowedDirections = this.callBase();
        allowedDirections.vertical = allowedDirections.vertical || this._pullDownEnabled;
        return allowedDirections;
      },
      handleInit: function(e) {
        this.callBase(e);
        if (this._state === STATE_RELEASED2 && 0 === this._location) {
          this._startClientY = eventData(e.originalEvent).y;
          this._state = STATE_TOUCHED;
        }
      },
      handleMove: function(e) {
        this.callBase(e);
        this._deltaY = eventData(e.originalEvent).y - this._startClientY;
        if (this._state === STATE_TOUCHED) {
          if (this._pullDownEnabled && this._deltaY > 0) {
            this._state = STATE_PULLED;
          } else {
            this._complete();
          }
        }
        if (this._state === STATE_PULLED) {
          e.preventDefault();
          this._movePullDown();
        }
      },
      _movePullDown: function() {
        var pullDownHeight = this._getPullDownHeight();
        var top = Math.min(3 * pullDownHeight, this._deltaY + this._getPullDownStartPosition());
        var angle = 180 * top / pullDownHeight / 3;
        this._$pullDown.css({
          opacity: 1
        }).toggleClass(SCROLLVIEW_PULLDOWN_REFRESHING_CLASS2, top < pullDownHeight);
        move(this._$pullDown, {
          top
        });
        this._$icon.css({
          transform: "rotate(" + angle + "deg)"
        });
      },
      _isPullDown: function() {
        return this._pullDownEnabled && this._state === STATE_PULLED && this._deltaY >= this._getPullDownHeight() - this._getPullDownStartPosition();
      },
      _getPullDownHeight: function() {
        return Math.round(0.05 * this._$element.outerHeight());
      },
      _getPullDownStartPosition: function() {
        return -Math.round(1.5 * this._$pullDown.outerHeight());
      },
      handleEnd: function() {
        if (this._isPullDown()) {
          this._pullDownRefreshing();
        }
        this._complete();
      },
      handleStop: function() {
        this._complete();
      },
      _complete: function() {
        if (this._state === STATE_TOUCHED || this._state === STATE_PULLED) {
          this._releaseState();
        }
      },
      handleScroll: function(e) {
        this.callBase(e);
        if (this._state === STATE_REFRESHING2) {
          return;
        }
        var currentLocation = this.location().top;
        var scrollDelta = this._location - currentLocation;
        this._location = currentLocation;
        if (scrollDelta > 0 && this._isReachBottom()) {
          this._reachBottom();
        } else {
          this._stateReleased();
        }
      },
      _isReachBottom: function() {
        return this._reachBottomEnabled && Math.round(this._bottomBoundary + Math.floor(this._location)) <= 1;
      },
      _reachBottom: function() {
        this.reachBottomCallbacks.fire();
      },
      _stateReleased: function() {
        if (this._state === STATE_RELEASED2) {
          return;
        }
        this._$pullDown.removeClass(SCROLLVIEW_PULLDOWN_DOWN_LOADING_CLASS);
        this._releaseState();
      },
      _pullDownRefreshing: function() {
        this._state = STATE_REFRESHING2;
        this._pullDownRefreshHandler();
      },
      _pullDownRefreshHandler: function() {
        this._refreshPullDown();
        this.pullDownCallbacks.fire();
      },
      _refreshPullDown: function() {
        this._$pullDown.addClass(SCROLLVIEW_PULLDOWN_DOWN_LOADING_CLASS);
        move(this._$pullDown, {
          top: this._getPullDownHeight()
        });
      },
      pullDownEnable: function(enabled) {
        this._$topPocket.toggle(enabled);
        this._pullDownEnabled = enabled;
      },
      reachBottomEnable: function(enabled) {
        this._reachBottomEnabled = enabled;
      },
      pendingRelease: function() {
        this._state = STATE_READY2;
      },
      release: function() {
        var deferred = new Deferred();
        this._updateDimensions();
        clearTimeout(this._releaseTimeout);
        this._releaseTimeout = setTimeout((function() {
          this._stateReleased();
          this.releaseCallbacks.fire();
          this._updateAction();
          deferred.resolve();
        }).bind(this), 800);
        return deferred.promise();
      },
      dispose: function() {
        clearTimeout(this._pullDownRefreshTimeout);
        clearTimeout(this._releaseTimeout);
        this.callBase();
      }
    });
    ui_scroll_view_native_swipe_down_default = SwipeDownNativeScrollViewStrategy;
  }
});

// node_modules/devextreme/esm/ui/scroll_view/animator.js
var abstract6, Animator, animator_default;
var init_animator = __esm({
  "node_modules/devextreme/esm/ui/scroll_view/animator.js"() {
    init_common();
    init_class();
    init_frame();
    abstract6 = class_default.abstract;
    Animator = class_default.inherit({
      ctor: function() {
        this._finished = true;
        this._stopped = false;
        this._proxiedStepCore = this._stepCore.bind(this);
      },
      start: function() {
        this._stopped = false;
        this._finished = false;
        this._stepCore();
      },
      stop: function() {
        this._stopped = true;
        cancelAnimationFrame(this._stepAnimationFrame);
      },
      _stepCore: function() {
        if (this._isStopped()) {
          this._stop();
          return;
        }
        if (this._isFinished()) {
          this._finished = true;
          this._complete();
          return;
        }
        this._step();
        this._stepAnimationFrame = requestAnimationFrame(this._proxiedStepCore);
      },
      _step: abstract6,
      _isFinished: noop2,
      _stop: noop2,
      _complete: noop2,
      _isStopped: function() {
        return this._stopped;
      },
      inProgress: function() {
        return !(this._stopped || this._finished);
      }
    });
    animator_default = Animator;
  }
});

// node_modules/devextreme/esm/ui/scroll_view/ui.scrollable.simulated.js
var SCROLLABLE_SIMULATED, SCROLLABLE_STRATEGY, SCROLLABLE_SIMULATED_CURSOR, SCROLLABLE_SIMULATED_KEYBOARD, SCROLLABLE_SIMULATED_CLASS2, SCROLLABLE_SCROLLBARS_ALWAYSVISIBLE, SCROLLABLE_SCROLLBAR_CLASS2, VERTICAL2, HORIZONTAL3, ACCELERATION, OUT_BOUNDS_ACCELERATION, MIN_VELOCITY_LIMIT, FRAME_DURATION, SCROLL_LINE_HEIGHT, VALIDATE_WHEEL_TIMEOUT, BOUNCE_MIN_VELOCITY_LIMIT, BOUNCE_DURATION, BOUNCE_FRAMES, BOUNCE_ACCELERATION_SUM, KEY_CODES, InertiaAnimator, BounceAnimator, Scroller, hoveredScrollable, activeScrollable, SimulatedStrategy;
var init_ui_scrollable_simulated = __esm({
  "node_modules/devextreme/esm/ui/scroll_view/ui.scrollable.simulated.js"() {
    init_renderer();
    init_dom_adapter();
    init_events_engine();
    init_inflector();
    init_extend();
    init_window();
    init_iterator();
    init_type();
    init_position();
    init_translator();
    init_class();
    init_animator();
    init_utils2();
    init_common();
    init_ui_scrollbar();
    init_deferred();
    SCROLLABLE_SIMULATED = "dxSimulatedScrollable";
    SCROLLABLE_STRATEGY = "dxScrollableStrategy";
    SCROLLABLE_SIMULATED_CURSOR = SCROLLABLE_SIMULATED + "Cursor";
    SCROLLABLE_SIMULATED_KEYBOARD = SCROLLABLE_SIMULATED + "Keyboard";
    SCROLLABLE_SIMULATED_CLASS2 = "dx-scrollable-simulated";
    SCROLLABLE_SCROLLBARS_ALWAYSVISIBLE = "dx-scrollable-scrollbars-alwaysvisible";
    SCROLLABLE_SCROLLBAR_CLASS2 = "dx-scrollable-scrollbar";
    VERTICAL2 = "vertical";
    HORIZONTAL3 = "horizontal";
    ACCELERATION = 0.92;
    OUT_BOUNDS_ACCELERATION = 0.5;
    MIN_VELOCITY_LIMIT = 1;
    FRAME_DURATION = Math.round(1e3 / 60);
    SCROLL_LINE_HEIGHT = 40;
    VALIDATE_WHEEL_TIMEOUT = 500;
    BOUNCE_MIN_VELOCITY_LIMIT = MIN_VELOCITY_LIMIT / 5;
    BOUNCE_DURATION = 400;
    BOUNCE_FRAMES = BOUNCE_DURATION / FRAME_DURATION;
    BOUNCE_ACCELERATION_SUM = (1 - Math.pow(ACCELERATION, BOUNCE_FRAMES)) / (1 - ACCELERATION);
    KEY_CODES = {
      PAGE_UP: "pageUp",
      PAGE_DOWN: "pageDown",
      END: "end",
      HOME: "home",
      LEFT: "leftArrow",
      UP: "upArrow",
      RIGHT: "rightArrow",
      DOWN: "downArrow",
      TAB: "tab"
    };
    InertiaAnimator = animator_default.inherit({
      ctor: function(scroller) {
        this.callBase();
        this.scroller = scroller;
      },
      VELOCITY_LIMIT: MIN_VELOCITY_LIMIT,
      _isFinished: function() {
        return Math.abs(this.scroller._velocity) <= this.VELOCITY_LIMIT;
      },
      _step: function() {
        this.scroller._scrollStep(this.scroller._velocity);
        this.scroller._velocity *= this._acceleration();
      },
      _acceleration: function() {
        return this.scroller._inBounds() ? ACCELERATION : OUT_BOUNDS_ACCELERATION;
      },
      _complete: function() {
        this.scroller._scrollComplete();
      }
    });
    BounceAnimator = InertiaAnimator.inherit({
      VELOCITY_LIMIT: BOUNCE_MIN_VELOCITY_LIMIT,
      _isFinished: function() {
        return this.scroller._crossBoundOnNextStep() || this.callBase();
      },
      _acceleration: function() {
        return ACCELERATION;
      },
      _complete: function() {
        this.scroller._move(this.scroller._bounceLocation);
        this.callBase();
      }
    });
    Scroller = class_default.inherit({
      ctor: function(options2) {
        this._initOptions(options2);
        this._initAnimators();
        this._initScrollbar();
      },
      _initOptions: function(options2) {
        this._location = 0;
        this._topReached = false;
        this._bottomReached = false;
        this._axis = options2.direction === HORIZONTAL3 ? "x" : "y";
        this._prop = options2.direction === HORIZONTAL3 ? "left" : "top";
        this._dimension = options2.direction === HORIZONTAL3 ? "width" : "height";
        this._scrollProp = options2.direction === HORIZONTAL3 ? "scrollLeft" : "scrollTop";
        each(options2, (optionName, optionValue) => {
          this["_" + optionName] = optionValue;
        });
      },
      _initAnimators: function() {
        this._inertiaAnimator = new InertiaAnimator(this);
        this._bounceAnimator = new BounceAnimator(this);
      },
      _initScrollbar: function() {
        this._scrollbar = new ui_scrollbar_default(renderer_default("<div>").appendTo(this._$container), {
          direction: this._direction,
          visible: this._scrollByThumb,
          visibilityMode: this._visibilityModeNormalize(this._scrollbarVisible),
          expandable: this._scrollByThumb
        });
        this._$scrollbar = this._scrollbar.$element();
      },
      _visibilityModeNormalize: function(mode) {
        return true === mode ? "onScroll" : false === mode ? "never" : mode;
      },
      _scrollStep: function(delta) {
        var prevLocation = this._location;
        this._location += delta;
        this._suppressBounce();
        this._move();
        if (Math.abs(prevLocation - this._location) < 1) {
          return;
        }
        events_engine_default.triggerHandler(this._$container, {
          type: "scroll"
        });
      },
      _suppressBounce: function() {
        if (this._bounceEnabled || this._inBounds(this._location)) {
          return;
        }
        this._velocity = 0;
        this._location = this._boundLocation();
      },
      _boundLocation: function(location) {
        location = void 0 !== location ? location : this._location;
        return Math.max(Math.min(location, this._maxOffset), this._minOffset);
      },
      _move: function(location) {
        this._location = void 0 !== location ? location * this._getScaleRatio() : this._location;
        this._moveContent();
        this._moveScrollbar();
      },
      _moveContent: function() {
        var location = this._location;
        this._$container[this._scrollProp](-location / this._getScaleRatio());
        this._moveContentByTranslator(location);
      },
      _getScaleRatio: function() {
        if (hasWindow() && !this._scaleRatio) {
          var element = this._$element.get(0);
          var realDimension = this._getRealDimension(element, this._dimension);
          var baseDimension = this._getBaseDimension(element, this._dimension);
          this._scaleRatio = Math.round(realDimension / baseDimension * 100) / 100;
        }
        return this._scaleRatio || 1;
      },
      _getRealDimension: function(element, dimension) {
        return Math.round(getBoundingRect(element)[dimension]);
      },
      _getBaseDimension: function(element, dimension) {
        var dimensionName = "offset" + titleize(dimension);
        return element[dimensionName];
      },
      _moveContentByTranslator: function(location) {
        var translateOffset;
        var minOffset = -this._maxScrollPropValue;
        if (location > 0) {
          translateOffset = location;
        } else if (location <= minOffset) {
          translateOffset = location - minOffset;
        } else {
          translateOffset = location % 1;
        }
        if (this._translateOffset === translateOffset) {
          return;
        }
        var targetLocation = {};
        targetLocation[this._prop] = translateOffset;
        this._translateOffset = translateOffset;
        if (0 === translateOffset) {
          resetPosition(this._$content);
          return;
        }
        move(this._$content, targetLocation);
      },
      _moveScrollbar: function() {
        this._scrollbar.moveTo(this._location);
      },
      _scrollComplete: function() {
        if (this._inBounds()) {
          this._hideScrollbar();
          if (this._completeDeferred) {
            this._completeDeferred.resolve();
          }
        }
        this._scrollToBounds();
      },
      _scrollToBounds: function() {
        if (this._inBounds()) {
          return;
        }
        this._bounceAction();
        this._setupBounce();
        this._bounceAnimator.start();
      },
      _setupBounce: function() {
        var boundLocation = this._bounceLocation = this._boundLocation();
        var bounceDistance = boundLocation - this._location;
        this._velocity = bounceDistance / BOUNCE_ACCELERATION_SUM;
      },
      _inBounds: function(location) {
        location = void 0 !== location ? location : this._location;
        return this._boundLocation(location) === location;
      },
      _crossBoundOnNextStep: function() {
        var location = this._location;
        var nextLocation = location + this._velocity;
        return location < this._minOffset && nextLocation >= this._minOffset || location > this._maxOffset && nextLocation <= this._maxOffset;
      },
      _initHandler: function(e) {
        this._stopScrolling();
        this._prepareThumbScrolling(e);
      },
      _stopScrolling: deferRenderer(function() {
        this._hideScrollbar();
        this._inertiaAnimator.stop();
        this._bounceAnimator.stop();
      }),
      _prepareThumbScrolling: function(e) {
        if (isDxMouseWheelEvent(e.originalEvent)) {
          return;
        }
        var $target = renderer_default(e.originalEvent.target);
        var scrollbarClicked = this._isScrollbar($target);
        if (scrollbarClicked) {
          this._moveToMouseLocation(e);
        }
        this._thumbScrolling = scrollbarClicked || this._isThumb($target);
        this._crossThumbScrolling = !this._thumbScrolling && this._isAnyThumbScrolling($target);
        if (this._thumbScrolling) {
          this._scrollbar.feedbackOn();
        }
      },
      _isThumbScrollingHandler: function($target) {
        return this._isThumb($target);
      },
      _moveToMouseLocation: function(e) {
        var mouseLocation = e["page" + this._axis.toUpperCase()] - this._$element.offset()[this._prop];
        var location = this._location + mouseLocation / this._containerToContentRatio() - this._$container.height() / 2;
        this._scrollStep(-Math.round(location));
      },
      _startHandler: function() {
        this._showScrollbar();
      },
      _moveHandler: function(delta) {
        if (this._crossThumbScrolling) {
          return;
        }
        if (this._thumbScrolling) {
          delta[this._axis] = -Math.round(delta[this._axis] / this._containerToContentRatio());
        }
        this._scrollBy(delta);
      },
      _scrollBy: function(delta) {
        delta = delta[this._axis];
        if (!this._inBounds()) {
          delta *= OUT_BOUNDS_ACCELERATION;
        }
        this._scrollStep(delta);
      },
      _scrollByHandler: function(delta) {
        this._scrollBy(delta);
        this._scrollComplete();
      },
      _containerToContentRatio: function() {
        return this._scrollbar.containerToContentRatio();
      },
      _endHandler: function(velocity) {
        this._completeDeferred = new Deferred();
        this._velocity = velocity[this._axis];
        this._inertiaHandler();
        this._resetThumbScrolling();
        return this._completeDeferred.promise();
      },
      _inertiaHandler: function() {
        this._suppressInertia();
        this._inertiaAnimator.start();
      },
      _suppressInertia: function() {
        if (!this._inertiaEnabled || this._thumbScrolling) {
          this._velocity = 0;
        }
      },
      _resetThumbScrolling: function() {
        this._thumbScrolling = false;
        this._crossThumbScrolling = false;
      },
      _stopHandler: function() {
        if (this._thumbScrolling) {
          this._scrollComplete();
        }
        this._resetThumbScrolling();
        this._scrollToBounds();
      },
      _disposeHandler: function() {
        this._stopScrolling();
        this._$scrollbar.remove();
      },
      _updateHandler: function() {
        this._update();
        this._moveToBounds();
      },
      _update: function() {
        this._stopScrolling();
        return deferUpdate(() => {
          this._resetScaleRatio();
          this._updateLocation();
          this._updateBounds();
          this._updateScrollbar();
          deferRender(() => {
            this._moveScrollbar();
            this._scrollbar.update();
          });
        });
      },
      _resetScaleRatio: function() {
        this._scaleRatio = null;
      },
      _updateLocation: function() {
        this._location = (locate(this._$content)[this._prop] - this._$container[this._scrollProp]()) * this._getScaleRatio();
      },
      _updateBounds: function() {
        this._maxOffset = this._getMaxOffset();
        this._minOffset = this._getMinOffset();
      },
      _getMaxOffset: function() {
        return 0;
      },
      _getMinOffset: function() {
        this._maxScrollPropValue = Math.max(this._contentSize() - this._containerSize(), 0);
        return -this._maxScrollPropValue;
      },
      _updateScrollbar: deferUpdater(function() {
        var containerSize = this._containerSize();
        var contentSize = this._contentSize();
        var baseContainerSize = this._getBaseDimension(this._$container.get(0), this._dimension);
        var baseContentSize = this._getBaseDimension(this._$content.get(0), this._dimension);
        deferRender(() => {
          this._scrollbar.option({
            containerSize,
            contentSize,
            baseContainerSize,
            baseContentSize,
            scaleRatio: this._getScaleRatio()
          });
        });
      }),
      _moveToBounds: deferRenderer(deferUpdater(deferRenderer(function() {
        var location = this._boundLocation();
        var locationChanged = location !== this._location;
        this._location = location;
        this._move();
        if (locationChanged) {
          this._scrollAction();
        }
      }))),
      _createActionsHandler: function(actions) {
        this._scrollAction = actions.scroll;
        this._bounceAction = actions.bounce;
      },
      _showScrollbar: function() {
        this._scrollbar.option("visible", true);
      },
      _hideScrollbar: function() {
        this._scrollbar.option("visible", false);
      },
      _containerSize: function() {
        return this._getRealDimension(this._$container.get(0), this._dimension);
      },
      _contentSize: function() {
        var isOverflowHidden = "hidden" === this._$content.css("overflow" + this._axis.toUpperCase());
        var contentSize = this._getRealDimension(this._$content.get(0), this._dimension);
        if (!isOverflowHidden) {
          var containerScrollSize = this._$content[0]["scroll" + titleize(this._dimension)] * this._getScaleRatio();
          contentSize = Math.max(containerScrollSize, contentSize);
        }
        return contentSize;
      },
      _validateEvent: function(e) {
        var $target = renderer_default(e.originalEvent.target);
        return this._isThumb($target) || this._isScrollbar($target);
      },
      _isThumb: function($element) {
        return this._scrollByThumb && this._scrollbar.isThumb($element);
      },
      _isScrollbar: function($element) {
        return this._scrollByThumb && $element && $element.is(this._$scrollbar);
      },
      _reachedMin: function() {
        return Math.round(this._location - this._minOffset) <= 0;
      },
      _reachedMax: function() {
        return Math.round(this._location - this._maxOffset) >= 0;
      },
      _cursorEnterHandler: function() {
        this._resetScaleRatio();
        this._updateScrollbar();
        this._scrollbar.cursorEnter();
      },
      _cursorLeaveHandler: function() {
        this._scrollbar.cursorLeave();
      },
      dispose: noop2
    });
    SimulatedStrategy = class_default.inherit({
      ctor: function(scrollable) {
        this._init(scrollable);
      },
      _init: function(scrollable) {
        this._component = scrollable;
        this._$element = scrollable.$element();
        this._$container = renderer_default(scrollable.container());
        this._$wrapper = scrollable._$wrapper;
        this._$content = scrollable.$content();
        this.option = scrollable.option.bind(scrollable);
        this._createActionByOption = scrollable._createActionByOption.bind(scrollable);
        this._isLocked = scrollable._isLocked.bind(scrollable);
        this._isDirection = scrollable._isDirection.bind(scrollable);
        this._allowedDirection = scrollable._allowedDirection.bind(scrollable);
        this._getMaxOffset = scrollable._getMaxOffset.bind(scrollable);
      },
      render: function() {
        this._$element.addClass(SCROLLABLE_SIMULATED_CLASS2);
        this._createScrollers();
        if (this.option("useKeyboard")) {
          this._$container.prop("tabIndex", 0);
        }
        this._attachKeyboardHandler();
        this._attachCursorHandlers();
      },
      _createScrollers: function() {
        this._scrollers = {};
        if (this._isDirection(HORIZONTAL3)) {
          this._createScroller(HORIZONTAL3);
        }
        if (this._isDirection(VERTICAL2)) {
          this._createScroller(VERTICAL2);
        }
        this._$element.toggleClass(SCROLLABLE_SCROLLBARS_ALWAYSVISIBLE, "always" === this.option("showScrollbar"));
      },
      _createScroller: function(direction) {
        this._scrollers[direction] = new Scroller(this._scrollerOptions(direction));
      },
      _scrollerOptions: function(direction) {
        return {
          direction,
          $content: this._$content,
          $container: this._$container,
          $wrapper: this._$wrapper,
          $element: this._$element,
          scrollByThumb: this.option("scrollByThumb"),
          scrollbarVisible: this.option("showScrollbar"),
          bounceEnabled: this.option("bounceEnabled"),
          inertiaEnabled: this.option("inertiaEnabled"),
          isAnyThumbScrolling: this._isAnyThumbScrolling.bind(this)
        };
      },
      _applyScaleRatio: function(targetLocation) {
        for (var direction in this._scrollers) {
          var prop = this._getPropByDirection(direction);
          if (isDefined(targetLocation[prop])) {
            var scroller = this._scrollers[direction];
            targetLocation[prop] *= scroller._getScaleRatio();
          }
        }
        return targetLocation;
      },
      _isAnyThumbScrolling: function($target) {
        var result2 = false;
        this._eventHandler("isThumbScrolling", $target).done(function(isThumbScrollingVertical, isThumbScrollingHorizontal) {
          result2 = isThumbScrollingVertical || isThumbScrollingHorizontal;
        });
        return result2;
      },
      handleInit: function(e) {
        this._suppressDirections(e);
        this._eventForUserAction = e;
        this._eventHandler("init", e);
      },
      _suppressDirections: function(e) {
        if (isDxMouseWheelEvent(e.originalEvent)) {
          this._prepareDirections(true);
          return;
        }
        this._prepareDirections();
        this._eachScroller(function(scroller, direction) {
          var $target = renderer_default(e.originalEvent.target);
          var isValid = scroller._validateEvent(e) || this.option("scrollByContent") && this._isContent($target);
          this._validDirections[direction] = isValid;
        });
      },
      _isContent: function($element) {
        return !!$element.closest(this._$element).length;
      },
      _prepareDirections: function(value2) {
        value2 = value2 || false;
        this._validDirections = {};
        this._validDirections[HORIZONTAL3] = value2;
        this._validDirections[VERTICAL2] = value2;
      },
      _eachScroller: function(callback) {
        callback = callback.bind(this);
        each(this._scrollers, function(direction, scroller) {
          callback(scroller, direction);
        });
      },
      handleStart: function(e) {
        this._eventForUserAction = e;
        this._eventHandler("start").done(this._startAction);
      },
      _saveActive: function() {
        activeScrollable = this;
      },
      _resetActive: function() {
        if (activeScrollable === this) {
          activeScrollable = null;
        }
      },
      handleMove: function(e) {
        if (this._isLocked()) {
          e.cancel = true;
          this._resetActive();
          return;
        }
        this._saveActive();
        e.preventDefault && e.preventDefault();
        this._adjustDistance(e, e.delta);
        this._eventForUserAction = e;
        this._eventHandler("move", e.delta);
      },
      _adjustDistance: function(e, distance) {
        distance.x *= this._validDirections[HORIZONTAL3];
        distance.y *= this._validDirections[VERTICAL2];
        var devicePixelRatio = this._tryGetDevicePixelRatio();
        if (devicePixelRatio && isDxMouseWheelEvent(e.originalEvent)) {
          distance.x = Math.round(distance.x / devicePixelRatio * 100) / 100;
          distance.y = Math.round(distance.y / devicePixelRatio * 100) / 100;
        }
      },
      _tryGetDevicePixelRatio: function() {
        if (hasWindow()) {
          return getWindow().devicePixelRatio;
        }
      },
      handleEnd: function(e) {
        this._resetActive();
        this._refreshCursorState(e.originalEvent && e.originalEvent.target);
        this._adjustDistance(e, e.velocity);
        this._eventForUserAction = e;
        return this._eventHandler("end", e.velocity).done(this._endAction);
      },
      handleCancel: function(e) {
        this._resetActive();
        this._eventForUserAction = e;
        return this._eventHandler("end", {
          x: 0,
          y: 0
        });
      },
      handleStop: function() {
        this._resetActive();
        this._eventHandler("stop");
      },
      handleScroll: function() {
        this._updateRtlConfig();
        this._scrollAction();
      },
      _attachKeyboardHandler: function() {
        events_engine_default.off(this._$element, ".".concat(SCROLLABLE_SIMULATED_KEYBOARD));
        if (!this.option("disabled") && this.option("useKeyboard")) {
          events_engine_default.on(this._$element, addNamespace2("keydown", SCROLLABLE_SIMULATED_KEYBOARD), this._keyDownHandler.bind(this));
        }
      },
      _keyDownHandler: function(e) {
        clearTimeout(this._updateHandlerTimeout);
        this._updateHandlerTimeout = setTimeout(() => {
          if (normalizeKeyName(e) === KEY_CODES.TAB) {
            this._eachScroller((scroller) => {
              scroller._updateHandler();
            });
          }
        });
        if (!this._$container.is(dom_adapter_default.getActiveElement())) {
          return;
        }
        var handled = true;
        switch (normalizeKeyName(e)) {
          case KEY_CODES.DOWN:
            this._scrollByLine({
              y: 1
            });
            break;
          case KEY_CODES.UP:
            this._scrollByLine({
              y: -1
            });
            break;
          case KEY_CODES.RIGHT:
            this._scrollByLine({
              x: 1
            });
            break;
          case KEY_CODES.LEFT:
            this._scrollByLine({
              x: -1
            });
            break;
          case KEY_CODES.PAGE_DOWN:
            this._scrollByPage(1);
            break;
          case KEY_CODES.PAGE_UP:
            this._scrollByPage(-1);
            break;
          case KEY_CODES.HOME:
            this._scrollToHome();
            break;
          case KEY_CODES.END:
            this._scrollToEnd();
            break;
          default:
            handled = false;
        }
        if (handled) {
          e.stopPropagation();
          e.preventDefault();
        }
      },
      _scrollByLine: function(lines) {
        var devicePixelRatio = this._tryGetDevicePixelRatio();
        var scrollOffset = SCROLL_LINE_HEIGHT;
        if (devicePixelRatio) {
          scrollOffset = Math.abs(scrollOffset / devicePixelRatio * 100) / 100;
        }
        this.scrollBy({
          top: (lines.y || 0) * -scrollOffset,
          left: (lines.x || 0) * -scrollOffset
        });
      },
      _scrollByPage: function(page) {
        var prop = this._wheelProp();
        var dimension = this._dimensionByProp(prop);
        var distance = {};
        distance[prop] = page * -this._$container[dimension]();
        this.scrollBy(distance);
      },
      _dimensionByProp: function(prop) {
        return "left" === prop ? "width" : "height";
      },
      _getPropByDirection: function(direction) {
        return direction === HORIZONTAL3 ? "left" : "top";
      },
      _scrollToHome: function() {
        var prop = this._wheelProp();
        var distance = {};
        distance[prop] = 0;
        this._component.scrollTo(distance);
      },
      _scrollToEnd: function() {
        var prop = this._wheelProp();
        var dimension = this._dimensionByProp(prop);
        var distance = {};
        distance[prop] = this._$content[dimension]() - this._$container[dimension]();
        this._component.scrollTo(distance);
      },
      createActions: function() {
        this._startAction = this._createActionHandler("onStart");
        this._endAction = this._createActionHandler("onEnd");
        this._updateAction = this._createActionHandler("onUpdated");
        this._createScrollerActions();
      },
      _createScrollerActions: function() {
        this._scrollAction = this._createActionHandler("onScroll");
        this._bounceAction = this._createActionHandler("onBounce");
        this._eventHandler("createActions", {
          scroll: this._scrollAction,
          bounce: this._bounceAction
        });
      },
      _createActionHandler: function(optionName) {
        var actionHandler = this._createActionByOption(optionName);
        return () => {
          actionHandler(extend2(this._createActionArgs(), arguments));
        };
      },
      _createActionArgs: function() {
        var {
          horizontal: scrollerX,
          vertical: scrollerY
        } = this._scrollers;
        var offset2 = this._getScrollOffset();
        this._scrollOffset = {
          top: scrollerY && offset2.top,
          left: scrollerX && offset2.left
        };
        return {
          event: this._eventForUserAction,
          scrollOffset: this._scrollOffset,
          reachedLeft: scrollerX && scrollerX._reachedMax(),
          reachedRight: scrollerX && scrollerX._reachedMin(),
          reachedTop: scrollerY && scrollerY._reachedMax(),
          reachedBottom: scrollerY && scrollerY._reachedMin()
        };
      },
      _getScrollOffset() {
        return {
          top: -this.location().top,
          left: -this.location().left
        };
      },
      _eventHandler: function(eventName) {
        var args = [].slice.call(arguments).slice(1);
        var deferreds = map(this._scrollers, (scroller) => scroller["_" + eventName + "Handler"].apply(scroller, args));
        return when.apply(renderer_default, deferreds).promise();
      },
      location: function() {
        var location = locate(this._$content);
        location.top -= this._$container.scrollTop();
        location.left -= this._$container.scrollLeft();
        return location;
      },
      disabledChanged: function() {
        this._attachCursorHandlers();
      },
      _attachCursorHandlers: function() {
        events_engine_default.off(this._$element, ".".concat(SCROLLABLE_SIMULATED_CURSOR));
        if (!this.option("disabled") && this._isHoverMode()) {
          events_engine_default.on(this._$element, addNamespace2("mouseenter", SCROLLABLE_SIMULATED_CURSOR), this._cursorEnterHandler.bind(this));
          events_engine_default.on(this._$element, addNamespace2("mouseleave", SCROLLABLE_SIMULATED_CURSOR), this._cursorLeaveHandler.bind(this));
        }
      },
      _isHoverMode: function() {
        return "onHover" === this.option("showScrollbar");
      },
      _cursorEnterHandler: function(e) {
        e = e || {};
        e.originalEvent = e.originalEvent || {};
        if (activeScrollable || e.originalEvent._hoverHandled) {
          return;
        }
        if (hoveredScrollable) {
          hoveredScrollable._cursorLeaveHandler();
        }
        hoveredScrollable = this;
        this._eventHandler("cursorEnter");
        e.originalEvent._hoverHandled = true;
      },
      _cursorLeaveHandler: function(e) {
        if (hoveredScrollable !== this || activeScrollable === hoveredScrollable) {
          return;
        }
        this._eventHandler("cursorLeave");
        hoveredScrollable = null;
        this._refreshCursorState(e && e.relatedTarget);
      },
      _refreshCursorState: function(target) {
        if (!this._isHoverMode() && (!target || activeScrollable)) {
          return;
        }
        var $target = renderer_default(target);
        var $scrollable = $target.closest(".".concat(SCROLLABLE_SIMULATED_CLASS2, ":not(.dx-state-disabled)"));
        var targetScrollable = $scrollable.length && $scrollable.data(SCROLLABLE_STRATEGY);
        if (hoveredScrollable && hoveredScrollable !== targetScrollable) {
          hoveredScrollable._cursorLeaveHandler();
        }
        if (targetScrollable) {
          targetScrollable._cursorEnterHandler();
        }
      },
      update: function() {
        var result2 = this._eventHandler("update").done(this._updateAction);
        return when(result2, deferUpdate(() => {
          var allowedDirections = this._allowedDirections();
          deferRender(() => {
            var touchDirection = allowedDirections.vertical ? "pan-x" : "";
            touchDirection = allowedDirections.horizontal ? "pan-y" : touchDirection;
            touchDirection = allowedDirections.vertical && allowedDirections.horizontal ? "none" : touchDirection;
            this._$container.css("touchAction", touchDirection);
          });
          return when().promise();
        }));
      },
      _allowedDirections: function() {
        var bounceEnabled = this.option("bounceEnabled");
        var verticalScroller = this._scrollers[VERTICAL2];
        var horizontalScroller = this._scrollers[HORIZONTAL3];
        return {
          vertical: verticalScroller && (verticalScroller._minOffset < 0 || bounceEnabled),
          horizontal: horizontalScroller && (horizontalScroller._minOffset < 0 || bounceEnabled)
        };
      },
      _updateBounds: function() {
        this._scrollers[HORIZONTAL3] && this._scrollers[HORIZONTAL3]._updateBounds();
      },
      _isHorizontalAndRtlEnabled: function() {
        return this.option("rtlEnabled") && this.option("direction") !== VERTICAL2;
      },
      updateRtlPosition: function(needInitializeRtlConfig) {
        if (needInitializeRtlConfig) {
          this._rtlConfig = {
            scrollRight: 0,
            clientWidth: this._$container.get(0).clientWidth,
            windowPixelRatio: this._getWindowDevicePixelRatio()
          };
        }
        this._updateBounds();
        if (this._isHorizontalAndRtlEnabled()) {
          deferUpdate(() => {
            var scrollLeft = this._getMaxOffset().left - this._rtlConfig.scrollRight;
            if (scrollLeft <= 0) {
              scrollLeft = 0;
              this._rtlConfig.scrollRight = this._getMaxOffset().left;
            }
            deferRender(() => {
              if (this._getScrollOffset().left !== scrollLeft) {
                this._rtlConfig.skipUpdating = true;
                this._component.scrollTo({
                  left: scrollLeft
                });
                this._rtlConfig.skipUpdating = false;
              }
            });
          });
        }
      },
      _updateRtlConfig: function() {
        if (this._isHorizontalAndRtlEnabled() && !this._rtlConfig.skipUpdating) {
          var {
            clientWidth,
            scrollLeft
          } = this._$container.get(0);
          var windowPixelRatio = this._getWindowDevicePixelRatio();
          if (this._rtlConfig.windowPixelRatio === windowPixelRatio && this._rtlConfig.clientWidth === clientWidth) {
            this._rtlConfig.scrollRight = this._getMaxOffset().left - scrollLeft;
          }
          this._rtlConfig.clientWidth = clientWidth;
          this._rtlConfig.windowPixelRatio = windowPixelRatio;
        }
      },
      _getWindowDevicePixelRatio: function() {
        return hasWindow() ? getWindow().devicePixelRatio : 1;
      },
      scrollBy: function(distance) {
        var verticalScroller = this._scrollers[VERTICAL2];
        var horizontalScroller = this._scrollers[HORIZONTAL3];
        if (verticalScroller) {
          distance.top = verticalScroller._boundLocation(distance.top + verticalScroller._location) - verticalScroller._location;
        }
        if (horizontalScroller) {
          distance.left = horizontalScroller._boundLocation(distance.left + horizontalScroller._location) - horizontalScroller._location;
        }
        this._prepareDirections(true);
        this._startAction();
        this._eventHandler("scrollBy", {
          x: distance.left,
          y: distance.top
        });
        this._endAction();
        this._updateRtlConfig();
      },
      validate: function(e) {
        if (isDxMouseWheelEvent(e) && isCommandKeyPressed(e)) {
          return false;
        }
        if (this.option("disabled")) {
          return false;
        }
        if (this.option("bounceEnabled")) {
          return true;
        }
        return isDxMouseWheelEvent(e) ? this._validateWheel(e) : this._validateMove(e);
      },
      _validateWheel: function(e) {
        var scroller = this._scrollers[this._wheelDirection(e)];
        var reachedMin = scroller._reachedMin();
        var reachedMax = scroller._reachedMax();
        var contentGreaterThanContainer = !reachedMin || !reachedMax;
        var locatedNotAtBound = !reachedMin && !reachedMax;
        var scrollFromMin = reachedMin && e.delta > 0;
        var scrollFromMax = reachedMax && e.delta < 0;
        var validated = contentGreaterThanContainer && (locatedNotAtBound || scrollFromMin || scrollFromMax);
        validated = validated || void 0 !== this._validateWheelTimer;
        if (validated) {
          clearTimeout(this._validateWheelTimer);
          this._validateWheelTimer = setTimeout(() => {
            this._validateWheelTimer = void 0;
          }, VALIDATE_WHEEL_TIMEOUT);
        }
        return validated;
      },
      _validateMove: function(e) {
        if (!this.option("scrollByContent") && !renderer_default(e.target).closest(".".concat(SCROLLABLE_SCROLLBAR_CLASS2)).length) {
          return false;
        }
        return this._allowedDirection();
      },
      getDirection: function(e) {
        return isDxMouseWheelEvent(e) ? this._wheelDirection(e) : this._allowedDirection();
      },
      _wheelProp: function() {
        return this._wheelDirection() === HORIZONTAL3 ? "left" : "top";
      },
      _wheelDirection: function(e) {
        switch (this.option("direction")) {
          case HORIZONTAL3:
            return HORIZONTAL3;
          case VERTICAL2:
            return VERTICAL2;
          default:
            return e && e.shiftKey ? HORIZONTAL3 : VERTICAL2;
        }
      },
      dispose: function() {
        this._resetActive();
        if (hoveredScrollable === this) {
          hoveredScrollable = null;
        }
        this._eventHandler("dispose");
        this._detachEventHandlers();
        this._$element.removeClass(SCROLLABLE_SIMULATED_CLASS2);
        this._eventForUserAction = null;
        clearTimeout(this._validateWheelTimer);
        clearTimeout(this._updateHandlerTimeout);
      },
      _detachEventHandlers: function() {
        events_engine_default.off(this._$element, ".".concat(SCROLLABLE_SIMULATED_CURSOR));
        events_engine_default.off(this._$container, ".".concat(SCROLLABLE_SIMULATED_KEYBOARD));
      }
    });
  }
});

// node_modules/devextreme/esm/ui/scroll_view/ui.scroll_view.simulated.js
var math, SCROLLVIEW_PULLDOWN_REFRESHING_CLASS3, SCROLLVIEW_PULLDOWN_READY_CLASS2, SCROLLVIEW_PULLDOWN_IMAGE_CLASS2, SCROLLVIEW_PULLDOWN_INDICATOR_CLASS3, SCROLLVIEW_PULLDOWN_TEXT_CLASS2, SCROLLVIEW_PULLDOWN_VISIBLE_TEXT_CLASS2, STATE_RELEASED3, STATE_READY3, STATE_REFRESHING3, STATE_LOADING2, ScrollViewScroller, SimulatedScrollViewStrategy, ui_scroll_view_simulated_default;
var init_ui_scroll_view_simulated = __esm({
  "node_modules/devextreme/esm/ui/scroll_view/ui.scroll_view.simulated.js"() {
    init_renderer();
    init_callbacks();
    init_iterator();
    init_common();
    init_extend();
    init_ui_scrollable_simulated();
    init_load_indicator();
    math = Math;
    SCROLLVIEW_PULLDOWN_REFRESHING_CLASS3 = "dx-scrollview-pull-down-loading";
    SCROLLVIEW_PULLDOWN_READY_CLASS2 = "dx-scrollview-pull-down-ready";
    SCROLLVIEW_PULLDOWN_IMAGE_CLASS2 = "dx-scrollview-pull-down-image";
    SCROLLVIEW_PULLDOWN_INDICATOR_CLASS3 = "dx-scrollview-pull-down-indicator";
    SCROLLVIEW_PULLDOWN_TEXT_CLASS2 = "dx-scrollview-pull-down-text";
    SCROLLVIEW_PULLDOWN_VISIBLE_TEXT_CLASS2 = "dx-scrollview-pull-down-text-visible";
    STATE_RELEASED3 = 0;
    STATE_READY3 = 1;
    STATE_REFRESHING3 = 2;
    STATE_LOADING2 = 3;
    ScrollViewScroller = Scroller.inherit({
      ctor: function() {
        this._topPocketSize = 0;
        this._bottomPocketSize = 0;
        this.callBase.apply(this, arguments);
        this._initCallbacks();
        this._releaseState();
      },
      _releaseState: function() {
        this._state = STATE_RELEASED3;
        this._refreshPullDownText();
      },
      _refreshPullDownText: function() {
        var that = this;
        var pullDownTextItems = [{
          element: this._$pullingDownText,
          visibleState: STATE_RELEASED3
        }, {
          element: this._$pulledDownText,
          visibleState: STATE_READY3
        }, {
          element: this._$refreshingText,
          visibleState: STATE_REFRESHING3
        }];
        each(pullDownTextItems, function(_2, item) {
          var action = that._state === item.visibleState ? "addClass" : "removeClass";
          item.element[action](SCROLLVIEW_PULLDOWN_VISIBLE_TEXT_CLASS2);
        });
      },
      _initCallbacks: function() {
        this.pullDownCallbacks = callbacks_default();
        this.releaseCallbacks = callbacks_default();
        this.reachBottomCallbacks = callbacks_default();
      },
      _updateBounds: function() {
        var considerPockets = "horizontal" !== this._direction;
        if (considerPockets) {
          this._topPocketSize = this._$topPocket.get(0).clientHeight;
          this._bottomPocketSize = this._$bottomPocket.get(0).clientHeight;
          var containerEl = this._$container.get(0);
          var contentEl = this._$content.get(0);
          var scrollTopMax = Math.max(contentEl.clientHeight - containerEl.clientHeight, 0);
          this._bottomBoundary = scrollTopMax - this._topPocketSize - this._bottomPocketSize;
        }
        this.callBase();
      },
      _updateScrollbar: function() {
        this._scrollbar.option({
          containerSize: this._containerSize(),
          contentSize: this._contentSize() - this._topPocketSize - this._bottomPocketSize,
          scaleRatio: this._getScaleRatio()
        });
      },
      _moveContent: function() {
        this.callBase();
        if (this._isPullDown()) {
          this._pullDownReady();
        } else if (this._isReachBottom()) {
          this._reachBottomReady();
        } else if (this._state !== STATE_RELEASED3) {
          this._stateReleased();
        }
      },
      _moveScrollbar: function() {
        this._scrollbar.moveTo(this._topPocketSize + this._location);
      },
      _isPullDown: function() {
        return this._pullDownEnabled && this._location >= 0;
      },
      _isReachBottom: function() {
        var containerEl = this._$container.get(0);
        return this._reachBottomEnabled && Math.round(this._bottomBoundary - Math.ceil(containerEl.scrollTop)) <= 1;
      },
      _scrollComplete: function() {
        if (this._inBounds() && this._state === STATE_READY3) {
          this._pullDownRefreshing();
        } else if (this._inBounds() && this._state === STATE_LOADING2) {
          this._reachBottomLoading();
        } else {
          this.callBase();
        }
      },
      _reachBottomReady: function() {
        if (this._state === STATE_LOADING2) {
          return;
        }
        this._state = STATE_LOADING2;
        this._minOffset = this._getMinOffset();
      },
      _getMaxOffset: function() {
        return -this._topPocketSize;
      },
      _getMinOffset: function() {
        return math.min(this.callBase(), -this._topPocketSize);
      },
      _reachBottomLoading: function() {
        this.reachBottomCallbacks.fire();
      },
      _pullDownReady: function() {
        if (this._state === STATE_READY3) {
          return;
        }
        this._state = STATE_READY3;
        this._maxOffset = 0;
        this._$pullDown.addClass(SCROLLVIEW_PULLDOWN_READY_CLASS2);
        this._refreshPullDownText();
      },
      _stateReleased: function() {
        if (this._state === STATE_RELEASED3) {
          return;
        }
        this._releaseState();
        this._updateBounds();
        this._$pullDown.removeClass(SCROLLVIEW_PULLDOWN_REFRESHING_CLASS3).removeClass(SCROLLVIEW_PULLDOWN_READY_CLASS2);
        this.releaseCallbacks.fire();
      },
      _pullDownRefreshing: function() {
        if (this._state === STATE_REFRESHING3) {
          return;
        }
        this._state = STATE_REFRESHING3;
        this._$pullDown.addClass(SCROLLVIEW_PULLDOWN_REFRESHING_CLASS3).removeClass(SCROLLVIEW_PULLDOWN_READY_CLASS2);
        this._refreshPullDownText();
        this.pullDownCallbacks.fire();
      },
      _releaseHandler: function() {
        if (this._state === STATE_RELEASED3) {
          this._moveToBounds();
        }
        this._update();
        if (this._releaseTask) {
          this._releaseTask.abort();
        }
        this._releaseTask = executeAsync(this._release.bind(this));
        return this._releaseTask.promise;
      },
      _release: function() {
        this._stateReleased();
        this._scrollComplete();
      },
      _reachBottomEnablingHandler: function(enabled) {
        if (this._reachBottomEnabled === enabled) {
          return;
        }
        this._reachBottomEnabled = enabled;
        this._updateBounds();
      },
      _pullDownEnablingHandler: function(enabled) {
        if (this._pullDownEnabled === enabled) {
          return;
        }
        this._pullDownEnabled = enabled;
        this._considerTopPocketChange();
        this._updateHandler();
      },
      _considerTopPocketChange: function() {
        this._location -= this._$topPocket.height() || -this._topPocketSize;
        this._maxOffset = 0;
        this._move();
      },
      _pendingReleaseHandler: function() {
        this._state = STATE_READY3;
      },
      dispose: function() {
        if (this._releaseTask) {
          this._releaseTask.abort();
        }
        this.callBase();
      }
    });
    SimulatedScrollViewStrategy = SimulatedStrategy.inherit({
      _init: function(scrollView) {
        this.callBase(scrollView);
        this._$pullDown = scrollView._$pullDown;
        this._$topPocket = scrollView._$topPocket;
        this._$bottomPocket = scrollView._$bottomPocket;
        this._initCallbacks();
      },
      _initCallbacks: function() {
        this.pullDownCallbacks = callbacks_default();
        this.releaseCallbacks = callbacks_default();
        this.reachBottomCallbacks = callbacks_default();
      },
      render: function() {
        this._renderPullDown();
        this.callBase();
      },
      _renderPullDown: function() {
        var $image = renderer_default("<div>").addClass(SCROLLVIEW_PULLDOWN_IMAGE_CLASS2);
        var $loadContainer = renderer_default("<div>").addClass(SCROLLVIEW_PULLDOWN_INDICATOR_CLASS3);
        var $loadIndicator = new load_indicator_default(renderer_default("<div>")).$element();
        var $text = this._$pullDownText = renderer_default("<div>").addClass(SCROLLVIEW_PULLDOWN_TEXT_CLASS2);
        this._$pullingDownText = renderer_default("<div>").text(this.option("pullingDownText")).appendTo($text);
        this._$pulledDownText = renderer_default("<div>").text(this.option("pulledDownText")).appendTo($text);
        this._$refreshingText = renderer_default("<div>").text(this.option("refreshingText")).appendTo($text);
        this._$pullDown.empty().append($image).append($loadContainer.append($loadIndicator)).append($text);
      },
      pullDownEnable: function(enabled) {
        this._eventHandler("pullDownEnabling", enabled);
      },
      reachBottomEnable: function(enabled) {
        this._eventHandler("reachBottomEnabling", enabled);
      },
      _createScroller: function(direction) {
        var that = this;
        var scroller = that._scrollers[direction] = new ScrollViewScroller(that._scrollerOptions(direction));
        scroller.pullDownCallbacks.add(function() {
          that.pullDownCallbacks.fire();
        });
        scroller.releaseCallbacks.add(function() {
          that.releaseCallbacks.fire();
        });
        scroller.reachBottomCallbacks.add(function() {
          that.reachBottomCallbacks.fire();
        });
      },
      _scrollerOptions: function(direction) {
        return extend2(this.callBase(direction), {
          $topPocket: this._$topPocket,
          $bottomPocket: this._$bottomPocket,
          $pullDown: this._$pullDown,
          $pullDownText: this._$pullDownText,
          $pullingDownText: this._$pullingDownText,
          $pulledDownText: this._$pulledDownText,
          $refreshingText: this._$refreshingText
        });
      },
      pendingRelease: function() {
        this._eventHandler("pendingRelease");
      },
      release: function() {
        return this._eventHandler("release").done(this._updateAction);
      },
      location: function() {
        var location = this.callBase();
        location.top += this._$topPocket.height();
        return location;
      },
      dispose: function() {
        each(this._scrollers, function() {
          this.dispose();
        });
        this.callBase();
      }
    });
    ui_scroll_view_simulated_default = SimulatedScrollViewStrategy;
  }
});

// node_modules/devextreme/esm/ui/scroll_view/ui.events.emitter.gesture.scroll.js
var abstract7, realDevice3, SCROLL_INIT_EVENT, SCROLL_START_EVENT, SCROLL_MOVE_EVENT, SCROLL_END_EVENT, SCROLL_STOP_EVENT, SCROLL_CANCEL_EVENT, Locker, TimeoutLocker, WheelLocker, PointerLocker, ScrollEmitter, ui_events_emitter_gesture_scroll_default;
var init_ui_events_emitter_gesture_scroll = __esm({
  "node_modules/devextreme/esm/ui/scroll_view/ui.events.emitter.gesture.scroll.js"() {
    init_events_engine();
    init_class();
    init_utils2();
    init_emitter_gesture();
    init_emitter_registrator();
    init_frame();
    init_devices();
    init_version2();
    abstract7 = class_default.abstract;
    realDevice3 = devices_default.real();
    SCROLL_INIT_EVENT = "dxscrollinit";
    SCROLL_START_EVENT = "dxscrollstart";
    SCROLL_MOVE_EVENT = "dxscroll";
    SCROLL_END_EVENT = "dxscrollend";
    SCROLL_STOP_EVENT = "dxscrollstop";
    SCROLL_CANCEL_EVENT = "dxscrollcancel";
    Locker = class_default.inherit(function() {
      var NAMESPACED_SCROLL_EVENT = addNamespace2("scroll", "dxScrollEmitter");
      return {
        ctor: function(element) {
          this._element = element;
          this._locked = false;
          var that = this;
          this._proxiedScroll = function(e) {
            that._scroll(e);
          };
          events_engine_default.on(this._element, NAMESPACED_SCROLL_EVENT, this._proxiedScroll);
        },
        _scroll: abstract7,
        check: function(e, callback) {
          if (this._locked) {
            callback();
          }
        },
        dispose: function() {
          events_engine_default.off(this._element, NAMESPACED_SCROLL_EVENT, this._proxiedScroll);
        }
      };
    }());
    TimeoutLocker = Locker.inherit({
      ctor: function(element, timeout) {
        this.callBase(element);
        this._timeout = timeout;
      },
      _scroll: function() {
        this._prepare();
        this._forget();
      },
      _prepare: function() {
        if (this._timer) {
          this._clearTimer();
        }
        this._locked = true;
      },
      _clearTimer: function() {
        clearTimeout(this._timer);
        this._locked = false;
        this._timer = null;
      },
      _forget: function() {
        var that = this;
        this._timer = setTimeout(function() {
          that._clearTimer();
        }, this._timeout);
      },
      dispose: function() {
        this.callBase();
        this._clearTimer();
      }
    });
    WheelLocker = TimeoutLocker.inherit({
      ctor: function(element) {
        this.callBase(element, 400);
        this._lastWheelDirection = null;
      },
      check: function(e, callback) {
        this._checkDirectionChanged(e);
        this.callBase(e, callback);
      },
      _checkDirectionChanged: function(e) {
        if (!isDxMouseWheelEvent(e)) {
          this._lastWheelDirection = null;
          return;
        }
        var direction = e.shiftKey || false;
        var directionChange = null !== this._lastWheelDirection && direction !== this._lastWheelDirection;
        this._lastWheelDirection = direction;
        this._locked = this._locked && !directionChange;
      }
    });
    PointerLocker = TimeoutLocker.inherit({
      ctor: function(element) {
        this.callBase(element, 400);
      }
    });
    !function() {
      var ios8_greater = realDevice3.ios && compare(realDevice3.version, [8]) >= 0;
      var android5_greater = realDevice3.android && compare(realDevice3.version, [5]) >= 0;
      if (!(ios8_greater || android5_greater)) {
        return;
      }
      PointerLocker = Locker.inherit({
        _scroll: function() {
          this._locked = true;
          var that = this;
          cancelAnimationFrame(this._scrollFrame);
          this._scrollFrame = requestAnimationFrame(function() {
            that._locked = false;
          });
        },
        check: function(e, callback) {
          cancelAnimationFrame(this._scrollFrame);
          cancelAnimationFrame(this._checkFrame);
          var that = this;
          var callBase = this.callBase;
          this._checkFrame = requestAnimationFrame(function() {
            callBase.call(that, e, callback);
            that._locked = false;
          });
        },
        dispose: function() {
          this.callBase();
          cancelAnimationFrame(this._scrollFrame);
          cancelAnimationFrame(this._checkFrame);
        }
      });
    }();
    ScrollEmitter = emitter_gesture_default.inherit(function() {
      var FRAME_DURATION2 = Math.round(1e3 / 60);
      return {
        ctor: function(element) {
          this.callBase.apply(this, arguments);
          this.direction = "both";
          this._pointerLocker = new PointerLocker(element);
          this._wheelLocker = new WheelLocker(element);
        },
        validate: function() {
          return true;
        },
        configure: function(data2) {
          if (data2.scrollTarget) {
            this._pointerLocker.dispose();
            this._wheelLocker.dispose();
            this._pointerLocker = new PointerLocker(data2.scrollTarget);
            this._wheelLocker = new WheelLocker(data2.scrollTarget);
          }
          this.callBase(data2);
        },
        _init: function(e) {
          this._wheelLocker.check(e, (function() {
            if (isDxMouseWheelEvent(e)) {
              this._accept(e);
            }
          }).bind(this));
          this._pointerLocker.check(e, (function() {
            var skipCheck = this.isNative && isMouseEvent(e);
            if (!isDxMouseWheelEvent(e) && !skipCheck) {
              this._accept(e);
            }
          }).bind(this));
          this._fireEvent(SCROLL_INIT_EVENT, e);
          this._prevEventData = eventData(e);
        },
        move: function(e) {
          this.callBase.apply(this, arguments);
          e.isScrollingEvent = this.isNative || e.isScrollingEvent;
        },
        _start: function(e) {
          this._savedEventData = eventData(e);
          this._fireEvent(SCROLL_START_EVENT, e);
          this._prevEventData = eventData(e);
        },
        _move: function(e) {
          var currentEventData = eventData(e);
          this._fireEvent(SCROLL_MOVE_EVENT, e, {
            delta: eventDelta(this._prevEventData, currentEventData)
          });
          var delta = eventDelta(this._savedEventData, currentEventData);
          if (delta.time > 200) {
            this._savedEventData = this._prevEventData;
          }
          this._prevEventData = eventData(e);
        },
        _end: function(e) {
          var endEventDelta = eventDelta(this._prevEventData, eventData(e));
          var velocity = {
            x: 0,
            y: 0
          };
          if (!isDxMouseWheelEvent(e) && endEventDelta.time < 100) {
            var delta = eventDelta(this._savedEventData, this._prevEventData);
            var velocityMultiplier = FRAME_DURATION2 / delta.time;
            velocity = {
              x: delta.x * velocityMultiplier,
              y: delta.y * velocityMultiplier
            };
          }
          this._fireEvent(SCROLL_END_EVENT, e, {
            velocity
          });
        },
        _stop: function(e) {
          this._fireEvent(SCROLL_STOP_EVENT, e);
        },
        cancel: function(e) {
          this.callBase.apply(this, arguments);
          this._fireEvent(SCROLL_CANCEL_EVENT, e);
        },
        dispose: function() {
          this.callBase.apply(this, arguments);
          this._pointerLocker.dispose();
          this._wheelLocker.dispose();
        },
        _clearSelection: function() {
          if (this.isNative) {
            return;
          }
          return this.callBase.apply(this, arguments);
        },
        _toggleGestureCover: function() {
          if (this.isNative) {
            return;
          }
          return this.callBase.apply(this, arguments);
        }
      };
    }());
    emitter_registrator_default({
      emitter: ScrollEmitter,
      events: [SCROLL_INIT_EVENT, SCROLL_START_EVENT, SCROLL_MOVE_EVENT, SCROLL_END_EVENT, SCROLL_STOP_EVENT, SCROLL_CANCEL_EVENT]
    });
    ui_events_emitter_gesture_scroll_default = {
      init: SCROLL_INIT_EVENT,
      start: SCROLL_START_EVENT,
      move: SCROLL_MOVE_EVENT,
      end: SCROLL_END_EVENT,
      stop: SCROLL_STOP_EVENT,
      cancel: SCROLL_CANCEL_EVENT
    };
  }
});

// node_modules/devextreme/esm/ui/scroll_view/ui.scrollable.device.js
var deviceDependentOptions;
var init_ui_scrollable_device = __esm({
  "node_modules/devextreme/esm/ui/scroll_view/ui.scrollable.device.js"() {
    init_devices();
    init_support();
    deviceDependentOptions = function() {
      return [{
        device: function() {
          return !nativeScrolling;
        },
        options: {
          useNative: false
        }
      }, {
        device: function(_device) {
          return !devices_default.isSimulator() && "desktop" === devices_default.real().deviceType && "generic" === _device.platform;
        },
        options: {
          bounceEnabled: false,
          scrollByThumb: true,
          scrollByContent: touch,
          showScrollbar: "onHover"
        }
      }];
    };
  }
});

// node_modules/devextreme/esm/renovation/ui/scroll_view/utils/get_relative_offset.js
function getRelativeOffset(targetElementClass, sourceElement) {
  var offset2 = {
    left: 0,
    top: 0
  };
  var element = sourceElement;
  while (null !== (_element = element) && void 0 !== _element && _element.offsetParent && !element.classList.contains(targetElementClass)) {
    var _element;
    var parentElement = element.offsetParent;
    var elementRect = element.getBoundingClientRect();
    var parentElementRect = parentElement.getBoundingClientRect();
    offset2.left += elementRect.left - parentElementRect.left;
    offset2.top += elementRect.top - parentElementRect.top;
    element = element.offsetParent;
  }
  return offset2;
}
var init_get_relative_offset = __esm({
  "node_modules/devextreme/esm/renovation/ui/scroll_view/utils/get_relative_offset.js"() {
  }
});

// node_modules/devextreme/esm/renovation/ui/scroll_view/common/consts.js
var DIRECTION_VERTICAL, DIRECTION_HORIZONTAL, SCROLLABLE_CONTENT_CLASS;
var init_consts = __esm({
  "node_modules/devextreme/esm/renovation/ui/scroll_view/common/consts.js"() {
    DIRECTION_VERTICAL = "vertical";
    DIRECTION_HORIZONTAL = "horizontal";
    SCROLLABLE_CONTENT_CLASS = "dx-scrollable-content";
  }
});

// node_modules/devextreme/esm/renovation/ui/scroll_view/utils/get_element_location_internal.js
function getElementLocationInternal(targetElement, direction, containerElement, scrollOffset, offset2) {
  var additionalOffset = _extends({
    top: 0,
    left: 0,
    right: 0,
    bottom: 0
  }, offset2);
  var isVertical = direction === DIRECTION_VERTICAL;
  var prop = isVertical ? "top" : "left";
  var inverseProp = isVertical ? "bottom" : "right";
  var dimension = isVertical ? "height" : "width";
  var containerOffsetSize = containerElement["offset".concat(titleize(dimension))];
  var containerClientSize = containerElement["client".concat(titleize(dimension))];
  var containerSize = containerElement.getBoundingClientRect()[dimension];
  var elementSize = targetElement.getBoundingClientRect()[dimension];
  var scale = 1;
  if (Math.abs(containerSize - containerOffsetSize) > 1) {
    scale = containerSize / containerOffsetSize;
  }
  var relativeElementOffset = getRelativeOffset(SCROLLABLE_CONTENT_CLASS, targetElement)[prop] / scale;
  var containerScrollOffset = scrollOffset[prop];
  var relativeStartOffset = containerScrollOffset - relativeElementOffset + additionalOffset[prop];
  var relativeEndOffset = containerScrollOffset - relativeElementOffset - elementSize / scale + containerClientSize - additionalOffset[inverseProp];
  if (relativeStartOffset <= 0 && relativeEndOffset >= 0) {
    return containerScrollOffset;
  }
  return containerScrollOffset - (Math.abs(relativeStartOffset) > Math.abs(relativeEndOffset) ? relativeEndOffset : relativeStartOffset);
}
var init_get_element_location_internal = __esm({
  "node_modules/devextreme/esm/renovation/ui/scroll_view/utils/get_element_location_internal.js"() {
    init_extends();
    init_inflector();
    init_get_relative_offset();
    init_consts();
  }
});

// node_modules/devextreme/esm/ui/scroll_view/ui.scrollable.js
var SCROLLABLE, SCROLLABLE_STRATEGY2, SCROLLABLE_CLASS, SCROLLABLE_DISABLED_CLASS, SCROLLABLE_CONTAINER_CLASS, SCROLLABLE_WRAPPER_CLASS, SCROLLABLE_CONTENT_CLASS2, VERTICAL3, HORIZONTAL4, BOTH, isIE2, Scrollable, ui_scrollable_default;
var init_ui_scrollable = __esm({
  "node_modules/devextreme/esm/ui/scroll_view/ui.scrollable.js"() {
    init_renderer();
    init_events_engine();
    init_support();
    init_browser();
    init_common();
    init_type();
    init_extend();
    init_element();
    init_window();
    init_dom_adapter();
    init_devices();
    init_component_registrator();
    init_dom_component();
    init_selectors();
    init_utils2();
    init_ui_events_emitter_gesture_scroll();
    init_ui_scrollable_simulated();
    init_ui_scrollable_native();
    init_ui_scrollable_device();
    init_deferred();
    init_get_element_location_internal();
    SCROLLABLE = "dxScrollable";
    SCROLLABLE_STRATEGY2 = "dxScrollableStrategy";
    SCROLLABLE_CLASS = "dx-scrollable";
    SCROLLABLE_DISABLED_CLASS = "dx-scrollable-disabled";
    SCROLLABLE_CONTAINER_CLASS = "dx-scrollable-container";
    SCROLLABLE_WRAPPER_CLASS = "dx-scrollable-wrapper";
    SCROLLABLE_CONTENT_CLASS2 = "dx-scrollable-content";
    VERTICAL3 = "vertical";
    HORIZONTAL4 = "horizontal";
    BOTH = "both";
    isIE2 = browser_default.msie && browser_default.version < 12;
    Scrollable = dom_component_default.inherit({
      _getDefaultOptions: function() {
        return extend2(this.callBase(), {
          disabled: false,
          onScroll: null,
          direction: VERTICAL3,
          showScrollbar: "onScroll",
          useNative: true,
          bounceEnabled: true,
          scrollByContent: true,
          scrollByThumb: false,
          onUpdated: null,
          onStart: null,
          onEnd: null,
          onBounce: null,
          useSimulatedScrollbar: false,
          useKeyboard: true,
          inertiaEnabled: true,
          updateManually: false
        });
      },
      _defaultOptionsRules: function() {
        return this.callBase().concat(deviceDependentOptions(), [{
          device: function() {
            return nativeScrolling && "android" === devices_default.real().platform && !browser_default.mozilla;
          },
          options: {
            useSimulatedScrollbar: true
          }
        }]);
      },
      _initOptions: function(options2) {
        this.callBase(options2);
        if (!("useSimulatedScrollbar" in options2)) {
          this._setUseSimulatedScrollbar();
        }
      },
      _setUseSimulatedScrollbar: function() {
        if (!this.initialOption("useSimulatedScrollbar")) {
          this.option("useSimulatedScrollbar", !this.option("useNative"));
        }
      },
      _init: function() {
        this.callBase();
        this._initScrollableMarkup();
        this._locked = false;
      },
      _visibilityChanged: function(visible2) {
        if (visible2) {
          this.update();
          this._updateRtlPosition();
          this._savedScrollOffset && this.scrollTo(this._savedScrollOffset);
          delete this._savedScrollOffset;
        } else {
          this._savedScrollOffset = this.scrollOffset();
        }
      },
      _initScrollableMarkup: function() {
        var $element = this.$element().addClass(SCROLLABLE_CLASS);
        var $container = this._$container = renderer_default("<div>").addClass(SCROLLABLE_CONTAINER_CLASS);
        var $wrapper = this._$wrapper = renderer_default("<div>").addClass(SCROLLABLE_WRAPPER_CLASS);
        var $content = this._$content = renderer_default("<div>").addClass(SCROLLABLE_CONTENT_CLASS2);
        if (isIE2 && dom_adapter_default.hasDocumentProperty("onbeforeactivate")) {
          events_engine_default.on($element, addNamespace2("beforeactivate", SCROLLABLE), function(e) {
            if (!renderer_default(e.target).is(focusable)) {
              e.preventDefault();
            }
          });
        }
        $content.append($element.contents()).appendTo($container);
        $container.appendTo($wrapper);
        $wrapper.appendTo($element);
      },
      _dimensionChanged: function() {
        this.update();
        this._updateRtlPosition();
      },
      _initMarkup: function() {
        this.callBase();
        this._renderDirection();
      },
      _render: function() {
        this._renderStrategy();
        this._attachEventHandlers();
        this._renderDisabledState();
        this._createActions();
        this.update();
        this.callBase();
        this._updateRtlPosition(true);
      },
      _updateRtlPosition: function(needInitializeRtlConfig) {
        this._strategy.updateRtlPosition(needInitializeRtlConfig);
      },
      _getMaxOffset: function() {
        var {
          scrollWidth,
          clientWidth,
          scrollHeight,
          clientHeight
        } = renderer_default(this.container()).get(0);
        return {
          left: scrollWidth - clientWidth,
          top: scrollHeight - clientHeight
        };
      },
      _attachEventHandlers: function() {
        var strategy3 = this._strategy;
        var initEventData = {
          getDirection: strategy3.getDirection.bind(strategy3),
          validate: this._validate.bind(this),
          isNative: this.option("useNative"),
          scrollTarget: this._$container
        };
        events_engine_default.off(this._$wrapper, "." + SCROLLABLE);
        events_engine_default.on(this._$wrapper, addNamespace2(ui_events_emitter_gesture_scroll_default.init, SCROLLABLE), initEventData, this._initHandler.bind(this));
        events_engine_default.on(this._$wrapper, addNamespace2(ui_events_emitter_gesture_scroll_default.start, SCROLLABLE), strategy3.handleStart.bind(strategy3));
        events_engine_default.on(this._$wrapper, addNamespace2(ui_events_emitter_gesture_scroll_default.move, SCROLLABLE), strategy3.handleMove.bind(strategy3));
        events_engine_default.on(this._$wrapper, addNamespace2(ui_events_emitter_gesture_scroll_default.end, SCROLLABLE), strategy3.handleEnd.bind(strategy3));
        events_engine_default.on(this._$wrapper, addNamespace2(ui_events_emitter_gesture_scroll_default.cancel, SCROLLABLE), strategy3.handleCancel.bind(strategy3));
        events_engine_default.on(this._$wrapper, addNamespace2(ui_events_emitter_gesture_scroll_default.stop, SCROLLABLE), strategy3.handleStop.bind(strategy3));
        events_engine_default.off(this._$container, "." + SCROLLABLE);
        events_engine_default.on(this._$container, addNamespace2("scroll", SCROLLABLE), strategy3.handleScroll.bind(strategy3));
      },
      _validate: function(e) {
        if (this._isLocked()) {
          return false;
        }
        this._updateIfNeed();
        return this._strategy.validate(e);
      },
      _initHandler: function() {
        var strategy3 = this._strategy;
        strategy3.handleInit.apply(strategy3, arguments);
      },
      _renderDisabledState: function() {
        this.$element().toggleClass(SCROLLABLE_DISABLED_CLASS, this.option("disabled"));
        if (this.option("disabled")) {
          this._lock();
        } else {
          this._unlock();
        }
      },
      _renderDirection: function() {
        this.$element().removeClass("dx-scrollable-" + HORIZONTAL4).removeClass("dx-scrollable-" + VERTICAL3).removeClass("dx-scrollable-" + BOTH).addClass("dx-scrollable-" + this.option("direction"));
      },
      _renderStrategy: function() {
        this._createStrategy();
        this._strategy.render();
        this.$element().data(SCROLLABLE_STRATEGY2, this._strategy);
      },
      _createStrategy: function() {
        this._strategy = this.option("useNative") ? new ui_scrollable_native_default(this) : new SimulatedStrategy(this);
      },
      _createActions: function() {
        this._strategy && this._strategy.createActions();
      },
      _clean: function() {
        this._strategy && this._strategy.dispose();
      },
      _optionChanged: function(args) {
        switch (args.name) {
          case "onStart":
          case "onEnd":
          case "onUpdated":
          case "onScroll":
          case "onBounce":
            this._createActions();
            break;
          case "direction":
            this._resetInactiveDirection();
            this._invalidate();
            break;
          case "useNative":
            this._setUseSimulatedScrollbar();
            this._invalidate();
            break;
          case "inertiaEnabled":
          case "scrollByThumb":
          case "bounceEnabled":
          case "useKeyboard":
          case "showScrollbar":
          case "useSimulatedScrollbar":
            this._invalidate();
            break;
          case "disabled":
            this._renderDisabledState();
            this._strategy && this._strategy.disabledChanged();
            break;
          case "updateManually":
          case "scrollByContent":
            break;
          case "width":
            this.callBase(args);
            this._updateRtlPosition();
            break;
          default:
            this.callBase(args);
        }
      },
      _resetInactiveDirection: function() {
        var inactiveProp = this._getInactiveProp();
        if (!inactiveProp || !hasWindow()) {
          return;
        }
        var scrollOffset = this.scrollOffset();
        scrollOffset[inactiveProp] = 0;
        this.scrollTo(scrollOffset);
      },
      _getInactiveProp: function() {
        var direction = this.option("direction");
        if (direction === VERTICAL3) {
          return "left";
        }
        if (direction === HORIZONTAL4) {
          return "top";
        }
      },
      _location: function() {
        return this._strategy.location();
      },
      _normalizeLocation: function(location) {
        if (isPlainObject(location)) {
          var left = ensureDefined(location.left, location.x);
          var top = ensureDefined(location.top, location.y);
          return {
            left: isDefined(left) ? -left : void 0,
            top: isDefined(top) ? -top : void 0
          };
        } else {
          var direction = this.option("direction");
          return {
            left: direction !== VERTICAL3 ? -location : void 0,
            top: direction !== HORIZONTAL4 ? -location : void 0
          };
        }
      },
      _isLocked: function() {
        return this._locked;
      },
      _lock: function() {
        this._locked = true;
      },
      _unlock: function() {
        if (!this.option("disabled")) {
          this._locked = false;
        }
      },
      _isDirection: function(direction) {
        var current2 = this.option("direction");
        if (direction === VERTICAL3) {
          return current2 !== HORIZONTAL4;
        }
        if (direction === HORIZONTAL4) {
          return current2 !== VERTICAL3;
        }
        return current2 === direction;
      },
      _updateAllowedDirection: function() {
        var allowedDirections = this._strategy._allowedDirections();
        if (this._isDirection(BOTH) && allowedDirections.vertical && allowedDirections.horizontal) {
          this._allowedDirectionValue = BOTH;
        } else if (this._isDirection(HORIZONTAL4) && allowedDirections.horizontal) {
          this._allowedDirectionValue = HORIZONTAL4;
        } else if (this._isDirection(VERTICAL3) && allowedDirections.vertical) {
          this._allowedDirectionValue = VERTICAL3;
        } else {
          this._allowedDirectionValue = null;
        }
      },
      _allowedDirection: function() {
        return this._allowedDirectionValue;
      },
      $content: function() {
        return this._$content;
      },
      content: function() {
        return getPublicElement(this._$content);
      },
      container: function() {
        return getPublicElement(this._$container);
      },
      scrollOffset: function() {
        return this._strategy._getScrollOffset();
      },
      _isRtlNativeStrategy: function() {
        var {
          useNative,
          rtlEnabled
        } = this.option();
        return useNative && rtlEnabled;
      },
      scrollTop: function() {
        return this.scrollOffset().top;
      },
      scrollLeft: function() {
        return this.scrollOffset().left;
      },
      clientHeight: function() {
        return this._$container.height();
      },
      scrollHeight: function() {
        return this.$content().outerHeight();
      },
      clientWidth: function() {
        return this._$container.width();
      },
      scrollWidth: function() {
        return this.$content().outerWidth();
      },
      update: function() {
        if (!this._strategy) {
          return;
        }
        return when(this._strategy.update()).done((function() {
          this._updateAllowedDirection();
        }).bind(this));
      },
      scrollBy: function(distance) {
        distance = this._normalizeLocation(distance);
        if (!distance.top && !distance.left) {
          return;
        }
        this._updateIfNeed();
        this._strategy.scrollBy(distance);
      },
      scrollTo: function(targetLocation) {
        targetLocation = this._normalizeLocation(targetLocation);
        this._updateIfNeed();
        var location = this._location();
        if (!this.option("useNative")) {
          targetLocation = this._strategy._applyScaleRatio(targetLocation);
          location = this._strategy._applyScaleRatio(location);
        }
        if (this._isRtlNativeStrategy()) {
          var scrollSign = isIE2 ? -1 : 1;
          location.left = scrollSign * location.left - this._getMaxOffset().left;
        }
        var distance = this._normalizeLocation({
          left: location.left - ensureDefined(targetLocation.left, location.left),
          top: location.top - ensureDefined(targetLocation.top, location.top)
        });
        if (!distance.top && !distance.left) {
          return;
        }
        this._strategy.scrollBy(distance);
      },
      scrollToElement: function(element, offset2) {
        var $element = renderer_default(element);
        var elementInsideContent = this.$content().find(element).length;
        var elementIsInsideContent = $element.parents("." + SCROLLABLE_CLASS).length - $element.parents("." + SCROLLABLE_CONTENT_CLASS2).length === 0;
        if (!elementInsideContent || !elementIsInsideContent) {
          return;
        }
        var scrollPosition = {
          top: 0,
          left: 0
        };
        var direction = this.option("direction");
        if (direction !== VERTICAL3) {
          scrollPosition.left = this.getScrollElementPosition($element, HORIZONTAL4, offset2);
        }
        if (direction !== HORIZONTAL4) {
          scrollPosition.top = this.getScrollElementPosition($element, VERTICAL3, offset2);
        }
        this.scrollTo(scrollPosition);
      },
      getScrollElementPosition: function($element, direction, offset2) {
        var scrollOffset = this.scrollOffset();
        return getElementLocationInternal($element.get(0), direction, renderer_default(this.container()).get(0), scrollOffset, offset2);
      },
      _updateIfNeed: function() {
        if (!this.option("updateManually")) {
          this.update();
        }
      },
      _useTemplates: function() {
        return false;
      }
    });
    component_registrator_default(SCROLLABLE, Scrollable);
    ui_scrollable_default = Scrollable;
  }
});

// node_modules/devextreme/esm/ui/scroll_view/ui.scroll_view.js
var SCROLLVIEW_CLASS, SCROLLVIEW_CONTENT_CLASS, SCROLLVIEW_TOP_POCKET_CLASS, SCROLLVIEW_BOTTOM_POCKET_CLASS, SCROLLVIEW_PULLDOWN_CLASS, SCROLLVIEW_REACHBOTTOM_CLASS, SCROLLVIEW_REACHBOTTOM_INDICATOR_CLASS, SCROLLVIEW_REACHBOTTOM_TEXT_CLASS, SCROLLVIEW_LOADPANEL, refreshStrategies, isServerSide, scrollViewServerConfig, ScrollView, ui_scroll_view_default;
var init_ui_scroll_view = __esm({
  "node_modules/devextreme/esm/ui/scroll_view/ui.scroll_view.js"() {
    init_renderer();
    init_devices();
    init_window();
    init_message();
    init_component_registrator();
    init_element();
    init_extend();
    init_common();
    init_ui_scroll_view_native_pull_down();
    init_ui_scroll_view_native_swipe_down();
    init_ui_scroll_view_simulated();
    init_ui_scrollable();
    init_load_indicator();
    init_themes();
    init_load_panel();
    SCROLLVIEW_CLASS = "dx-scrollview";
    SCROLLVIEW_CONTENT_CLASS = SCROLLVIEW_CLASS + "-content";
    SCROLLVIEW_TOP_POCKET_CLASS = SCROLLVIEW_CLASS + "-top-pocket";
    SCROLLVIEW_BOTTOM_POCKET_CLASS = SCROLLVIEW_CLASS + "-bottom-pocket";
    SCROLLVIEW_PULLDOWN_CLASS = SCROLLVIEW_CLASS + "-pull-down";
    SCROLLVIEW_REACHBOTTOM_CLASS = SCROLLVIEW_CLASS + "-scrollbottom";
    SCROLLVIEW_REACHBOTTOM_INDICATOR_CLASS = SCROLLVIEW_REACHBOTTOM_CLASS + "-indicator";
    SCROLLVIEW_REACHBOTTOM_TEXT_CLASS = SCROLLVIEW_REACHBOTTOM_CLASS + "-text";
    SCROLLVIEW_LOADPANEL = SCROLLVIEW_CLASS + "-loadpanel";
    refreshStrategies = {
      pullDown: ui_scroll_view_native_pull_down_default,
      swipeDown: ui_scroll_view_native_swipe_down_default,
      simulated: ui_scroll_view_simulated_default
    };
    isServerSide = !hasWindow();
    scrollViewServerConfig = {
      finishLoading: noop2,
      release: noop2,
      refresh: noop2,
      _optionChanged: function(args) {
        if ("onUpdated" !== args.name) {
          return this.callBase.apply(this, arguments);
        }
      }
    };
    ScrollView = ui_scrollable_default.inherit(isServerSide ? scrollViewServerConfig : {
      _getDefaultOptions: function() {
        return extend2(this.callBase(), {
          pullingDownText: message_default.format("dxScrollView-pullingDownText"),
          pulledDownText: message_default.format("dxScrollView-pulledDownText"),
          refreshingText: message_default.format("dxScrollView-refreshingText"),
          reachBottomText: message_default.format("dxScrollView-reachBottomText"),
          onPullDown: null,
          onReachBottom: null,
          refreshStrategy: "pullDown"
        });
      },
      _defaultOptionsRules: function() {
        return this.callBase().concat([{
          device: function() {
            var realDevice4 = devices_default.real();
            return "android" === realDevice4.platform;
          },
          options: {
            refreshStrategy: "swipeDown"
          }
        }, {
          device: function() {
            return isMaterial();
          },
          options: {
            pullingDownText: "",
            pulledDownText: "",
            refreshingText: "",
            reachBottomText: ""
          }
        }]);
      },
      _init: function() {
        this.callBase();
        this._loadingIndicatorEnabled = true;
      },
      _initScrollableMarkup: function() {
        this.callBase();
        this.$element().addClass(SCROLLVIEW_CLASS);
        this._initContent();
        this._initTopPocket();
        this._initBottomPocket();
        this._initLoadPanel();
      },
      _initContent: function() {
        var $content = renderer_default("<div>").addClass(SCROLLVIEW_CONTENT_CLASS);
        this._$content.wrapInner($content);
      },
      _initTopPocket: function() {
        var $topPocket = this._$topPocket = renderer_default("<div>").addClass(SCROLLVIEW_TOP_POCKET_CLASS);
        var $pullDown = this._$pullDown = renderer_default("<div>").addClass(SCROLLVIEW_PULLDOWN_CLASS);
        $topPocket.append($pullDown);
        this._$content.prepend($topPocket);
      },
      _initBottomPocket: function() {
        var $bottomPocket = this._$bottomPocket = renderer_default("<div>").addClass(SCROLLVIEW_BOTTOM_POCKET_CLASS);
        var $reachBottom = this._$reachBottom = renderer_default("<div>").addClass(SCROLLVIEW_REACHBOTTOM_CLASS);
        var $loadContainer = renderer_default("<div>").addClass(SCROLLVIEW_REACHBOTTOM_INDICATOR_CLASS);
        var $loadIndicator = new load_indicator_default(renderer_default("<div>")).$element();
        var $text = this._$reachBottomText = renderer_default("<div>").addClass(SCROLLVIEW_REACHBOTTOM_TEXT_CLASS);
        this._updateReachBottomText();
        $reachBottom.append($loadContainer.append($loadIndicator)).append($text);
        $bottomPocket.append($reachBottom);
        this._$content.append($bottomPocket);
      },
      _initLoadPanel: function() {
        var $loadPanelElement = renderer_default("<div>").addClass(SCROLLVIEW_LOADPANEL).appendTo(this.$element());
        var loadPanelOptions = {
          shading: false,
          delay: 400,
          message: this.option("refreshingText"),
          position: {
            of: this.$element()
          }
        };
        this._loadPanel = this._createComponent($loadPanelElement, load_panel_default, loadPanelOptions);
      },
      _updateReachBottomText: function() {
        this._$reachBottomText.text(this.option("reachBottomText"));
      },
      _createStrategy: function() {
        var strategyName = this.option("useNative") ? this.option("refreshStrategy") : "simulated";
        var strategyClass = refreshStrategies[strategyName];
        this._strategy = new strategyClass(this);
        this._strategy.pullDownCallbacks.add(this._pullDownHandler.bind(this));
        this._strategy.releaseCallbacks.add(this._releaseHandler.bind(this));
        this._strategy.reachBottomCallbacks.add(this._reachBottomHandler.bind(this));
      },
      _createActions: function() {
        this.callBase();
        this._pullDownAction = this._createActionByOption("onPullDown");
        this._reachBottomAction = this._createActionByOption("onReachBottom");
        this._tryRefreshPocketState();
      },
      _tryRefreshPocketState: function() {
        this._pullDownEnable(this.hasActionSubscription("onPullDown"));
        this._reachBottomEnable(this.hasActionSubscription("onReachBottom"));
      },
      on: function(eventName) {
        var result2 = this.callBase.apply(this, arguments);
        if ("pullDown" === eventName || "reachBottom" === eventName) {
          this._tryRefreshPocketState();
        }
        return result2;
      },
      _pullDownEnable: function(enabled) {
        if (0 === arguments.length) {
          return this._pullDownEnabled;
        }
        if (this._$pullDown && this._strategy) {
          this._$pullDown.toggle(enabled);
          this._strategy.pullDownEnable(enabled);
          this._pullDownEnabled = enabled;
        }
      },
      _reachBottomEnable: function(enabled) {
        if (0 === arguments.length) {
          return this._reachBottomEnabled;
        }
        if (this._$reachBottom && this._strategy) {
          this._$reachBottom.toggle(enabled);
          this._strategy.reachBottomEnable(enabled);
          this._reachBottomEnabled = enabled;
        }
      },
      _pullDownHandler: function() {
        this._loadingIndicator(false);
        this._pullDownLoading();
      },
      _loadingIndicator: function(value2) {
        if (arguments.length < 1) {
          return this._loadingIndicatorEnabled;
        }
        this._loadingIndicatorEnabled = value2;
      },
      _pullDownLoading: function() {
        this.startLoading();
        this._pullDownAction();
      },
      _reachBottomHandler: function() {
        this._loadingIndicator(false);
        this._reachBottomLoading();
      },
      _reachBottomLoading: function() {
        this.startLoading();
        this._reachBottomAction();
      },
      _releaseHandler: function() {
        this.finishLoading();
        this._loadingIndicator(true);
      },
      _optionChanged: function(args) {
        switch (args.name) {
          case "onPullDown":
          case "onReachBottom":
            this._createActions();
            break;
          case "pullingDownText":
          case "pulledDownText":
          case "refreshingText":
          case "refreshStrategy":
            this._invalidate();
            break;
          case "reachBottomText":
            this._updateReachBottomText();
            break;
          default:
            this.callBase(args);
        }
      },
      content: function() {
        return getPublicElement(this._$content.children().eq(1));
      },
      release: function(preventReachBottom) {
        if (void 0 !== preventReachBottom) {
          this.toggleLoading(!preventReachBottom);
        }
        return this._strategy.release();
      },
      toggleLoading: function(showOrHide) {
        this._reachBottomEnable(showOrHide);
      },
      isFull: function() {
        return renderer_default(this.content()).height() > renderer_default(this.container()).height();
      },
      refresh: function() {
        if (!this.hasActionSubscription("onPullDown")) {
          return;
        }
        this._strategy.pendingRelease();
        this._pullDownLoading();
      },
      startLoading: function() {
        if (this._loadingIndicator() && this.$element().is(":visible")) {
          this._loadPanel.show();
        }
        this._lock();
      },
      finishLoading: function() {
        this._loadPanel.hide();
        this._unlock();
      },
      _dispose: function() {
        this._strategy.dispose();
        this.callBase();
        if (this._loadPanel) {
          this._loadPanel.$element().remove();
        }
      }
    });
    component_registrator_default("dxScrollView", ScrollView);
    ui_scroll_view_default = ScrollView;
  }
});

// node_modules/devextreme/esm/ui/scroll_view.js
var scroll_view_default;
var init_scroll_view = __esm({
  "node_modules/devextreme/esm/ui/scroll_view.js"() {
    init_ui_scroll_view();
    scroll_view_default = ui_scroll_view_default;
  }
});

// node_modules/devextreme/esm/ui/collection/ui.collection_widget.live_update.js
var PRIVATE_KEY_FIELD, ui_collection_widget_live_update_default;
var init_ui_collection_widget_live_update = __esm({
  "node_modules/devextreme/esm/ui/collection/ui.collection_widget.live_update.js"() {
    init_renderer();
    init_ui_collection_widget_edit();
    init_extend();
    init_iterator();
    init_array_utils();
    init_utils3();
    init_deferred();
    init_array_compare();
    init_dom_adapter();
    init_common();
    PRIVATE_KEY_FIELD = "__dx_key__";
    ui_collection_widget_live_update_default = ui_collection_widget_edit_default.inherit({
      _getDefaultOptions: function() {
        return extend2(this.callBase(), {
          repaintChangesOnly: false
        });
      },
      ctor: function() {
        this.callBase.apply(this, arguments);
        this._customizeStoreLoadOptions = (e) => {
          var dataSource = this._dataSource;
          if (dataSource && !dataSource.isLoaded()) {
            this._correctionIndex = 0;
          }
          if (this._correctionIndex && e.storeLoadOptions) {
            e.storeLoadOptions.skip += this._correctionIndex;
          }
        }, this._dataSource && this._dataSource.on("customizeStoreLoadOptions", this._customizeStoreLoadOptions);
      },
      reload: function() {
        this._correctionIndex = 0;
      },
      _init: function() {
        this.callBase();
        this._refreshItemsCache();
        this._correctionIndex = 0;
      },
      _findItemElementByKey: function(key) {
        var result2 = renderer_default();
        var keyExpr = this.key();
        this.itemElements().each((_2, item) => {
          var $item = renderer_default(item);
          var itemData = this._getItemData($item);
          if (keyExpr ? keysEqual(keyExpr, this.keyOf(itemData), key) : this._isItemEquals(itemData, key)) {
            result2 = $item;
            return false;
          }
        });
        return result2;
      },
      _dataSourceChangedHandler: function(newItems, e) {
        if (null !== e && void 0 !== e && e.changes) {
          this._modifyByChanges(e.changes);
        } else {
          this.callBase(newItems, e);
          this._refreshItemsCache();
        }
      },
      _isItemEquals: function(item1, item2) {
        if (item1 && item1[PRIVATE_KEY_FIELD]) {
          item1 = item1.data;
        }
        try {
          return JSON.stringify(item1) === JSON.stringify(item2);
        } catch (e) {
          return item1 === item2;
        }
      },
      _isItemStrictEquals: function(item1, item2) {
        return this._isItemEquals(item1, item2);
      },
      _shouldAddNewGroup: function(changes, items) {
        var result2 = false;
        if (this.option("grouped")) {
          if (!changes.length) {
            result2 = true;
          }
          each(changes, (i, change) => {
            if ("insert" === change.type) {
              result2 = true;
              each(items, (_2, item) => {
                if (void 0 !== change.data.key && change.data.key === item.key) {
                  result2 = false;
                  return false;
                }
              });
            }
          });
        }
        return result2;
      },
      _partialRefresh: function() {
        if (this.option("repaintChangesOnly")) {
          var result2 = findChanges(this._itemsCache, this._editStrategy.itemsGetter(), (data2) => {
            if (data2 && void 0 !== data2[PRIVATE_KEY_FIELD]) {
              return data2[PRIVATE_KEY_FIELD];
            }
            return this.keyOf(data2);
          }, this._isItemStrictEquals.bind(this));
          if (result2 && this._itemsCache.length && !this._shouldAddNewGroup(result2, this._itemsCache)) {
            this._modifyByChanges(result2, true);
            this._renderEmptyMessage();
            return true;
          } else {
            this._refreshItemsCache();
          }
        }
        return false;
      },
      _refreshItemsCache: function() {
        if (this.option("repaintChangesOnly")) {
          var items = this._editStrategy.itemsGetter();
          try {
            this._itemsCache = extend2(true, [], items);
            if (!this.key()) {
              this._itemsCache = this._itemsCache.map((itemCache, index2) => ({
                [PRIVATE_KEY_FIELD]: items[index2],
                data: itemCache
              }));
            }
          } catch (e) {
            this._itemsCache = extend2([], items);
          }
        }
      },
      _dispose: function() {
        this._dataSource && this._dataSource.off("customizeStoreLoadOptions", this._customizeStoreLoadOptions);
        this.callBase();
      },
      _updateByChange: function(keyInfo, items, change, isPartialRefresh) {
        if (isPartialRefresh) {
          this._renderItem(change.index, change.data, null, this._findItemElementByKey(change.key));
        } else {
          var changedItem = items[indexByKey(keyInfo, items, change.key)];
          if (changedItem) {
            update(keyInfo, items, change.key, change.data).done(() => {
              this._renderItem(items.indexOf(changedItem), changedItem, null, this._findItemElementByKey(change.key));
            });
          }
        }
      },
      _insertByChange: function(keyInfo, items, change, isPartialRefresh) {
        when(isPartialRefresh || insert(keyInfo, items, change.data, change.index)).done(() => {
          var _change$index;
          this._beforeItemElementInserted(change);
          var $itemContainer = this._getItemContainer(change.data);
          this._renderItem(null !== (_change$index = change.index) && void 0 !== _change$index ? _change$index : items.length, change.data, $itemContainer);
          this._afterItemElementInserted();
          this._correctionIndex++;
        });
      },
      _getItemContainer: function(changeData) {
        return this._itemContainer();
      },
      _updateSelectionAfterRemoveByChange: function(removeIndex) {
        var selectedIndex = this.option("selectedIndex");
        if (selectedIndex > removeIndex) {
          this.option("selectedIndex", selectedIndex - 1);
        } else if (selectedIndex === removeIndex && 1 === this.option("selectedItems").length) {
          this.option("selectedItems", []);
        } else {
          this._normalizeSelectedItems();
        }
      },
      _beforeItemElementInserted: function(change) {
        var selectedIndex = this.option("selectedIndex");
        if (change.index <= selectedIndex) {
          this.option("selectedIndex", selectedIndex + 1);
        }
      },
      _afterItemElementInserted: noop2,
      _removeByChange: function(keyInfo, items, change, isPartialRefresh) {
        var index2 = isPartialRefresh ? change.index : indexByKey(keyInfo, items, change.key);
        var removedItem = isPartialRefresh ? change.oldItem : items[index2];
        if (removedItem) {
          var $removedItemElement = this._findItemElementByKey(change.key);
          var deletedActionArgs = this._extendActionArgs($removedItemElement);
          this._waitDeletingPrepare($removedItemElement).done(() => {
            if (isPartialRefresh) {
              this._updateIndicesAfterIndex(index2 - 1);
              this._afterItemElementDeleted($removedItemElement, deletedActionArgs);
              this._updateSelectionAfterRemoveByChange(index2);
            } else {
              this._deleteItemElementByIndex(index2);
              this._afterItemElementDeleted($removedItemElement, deletedActionArgs);
            }
          });
          this._correctionIndex--;
        }
      },
      _modifyByChanges: function(changes, isPartialRefresh) {
        var items = this._editStrategy.itemsGetter();
        var keyInfo = {
          key: this.key.bind(this),
          keyOf: this.keyOf.bind(this)
        };
        var dataSource = this._dataSource;
        var paginate = dataSource && dataSource.paginate();
        var group = dataSource && dataSource.group();
        if (paginate || group) {
          changes = changes.filter((item) => "insert" !== item.type || void 0 !== item.index);
        }
        changes.forEach((change) => this["_".concat(change.type, "ByChange")](keyInfo, items, change, isPartialRefresh));
        this._renderedItemsCount = items.length;
        this._refreshItemsCache();
        this._fireContentReadyAction();
      },
      _appendItemToContainer: function($container, $itemFrame, index2) {
        var nextSiblingElement = $container.children(this._itemSelector()).get(index2);
        dom_adapter_default.insertElement($container.get(0), $itemFrame.get(0), nextSiblingElement);
      },
      _optionChanged: function(args) {
        switch (args.name) {
          case "items":
            var isItemsUpdated = this._partialRefresh(args.value);
            if (!isItemsUpdated) {
              this.callBase(args);
            }
            break;
          case "dataSource":
            if (!this.option("repaintChangesOnly") || !args.value) {
              this.option("items", []);
            }
            this.callBase(args);
            break;
          case "repaintChangesOnly":
            break;
          default:
            this.callBase(args);
        }
      }
    });
  }
});

// node_modules/devextreme/esm/ui/shared/grouped_data_converter_mixin.js
var isCorrectStructure, grouped_data_converter_mixin_default;
var init_grouped_data_converter_mixin = __esm({
  "node_modules/devextreme/esm/ui/shared/grouped_data_converter_mixin.js"() {
    init_type();
    isCorrectStructure = (data2) => Array.isArray(data2) && data2.every((item) => {
      var hasTwoFields = 2 === Object.keys(item).length;
      var hasCorrectFields = "key" in item && "items" in item;
      return hasTwoFields && hasCorrectFields && Array.isArray(item.items);
    });
    grouped_data_converter_mixin_default = {
      _getSpecificDataSourceOption: function() {
        var dataSource = this.option("dataSource");
        var hasSimpleItems = false;
        var data2 = {};
        if (this._getGroupedOption() && isCorrectStructure(dataSource)) {
          data2 = dataSource.reduce((accumulator, item) => {
            var items = item.items.map((innerItem) => {
              if (!isObject2(innerItem)) {
                innerItem = {
                  text: innerItem
                };
                hasSimpleItems = true;
              }
              if (!("key" in innerItem)) {
                innerItem.key = item.key;
              }
              return innerItem;
            });
            return accumulator.concat(items);
          }, []);
          dataSource = {
            store: {
              type: "array",
              data: data2
            },
            group: {
              selector: "key",
              keepInitialKeyOrder: true
            }
          };
          if (hasSimpleItems) {
            dataSource.searchExpr = "text";
          }
        }
        return dataSource;
      }
    };
  }
});

// node_modules/devextreme/esm/ui/list/ui.list.base.js
function getScrollView() {
  return _scrollView || scroll_view_default;
}
var LIST_CLASS, LIST_ITEM_CLASS2, LIST_ITEM_SELECTOR, LIST_ITEM_ICON_CONTAINER_CLASS, LIST_ITEM_ICON_CLASS, LIST_GROUP_CLASS2, LIST_GROUP_HEADER_CLASS, LIST_GROUP_BODY_CLASS, LIST_COLLAPSIBLE_GROUPS_CLASS, LIST_GROUP_COLLAPSED_CLASS, LIST_GROUP_HEADER_INDICATOR_CLASS, LIST_HAS_NEXT_CLASS, LIST_NEXT_BUTTON_CLASS, WRAP_ITEM_TEXT_CLASS, SELECT_ALL_ITEM_SELECTOR, LIST_ITEM_DATA_KEY, LIST_FEEDBACK_SHOW_TIMEOUT, groupItemsGetter, _scrollView, ListBase;
var init_ui_list_base = __esm({
  "node_modules/devextreme/esm/ui/list/ui.list.base.js"() {
    init_renderer();
    init_events_engine();
    init_common();
    init_type();
    init_icon();
    init_element();
    init_iterator();
    init_data();
    init_extend();
    init_fx();
    init_click();
    init_swipe();
    init_support();
    init_message();
    init_utils_ink_ripple();
    init_devices();
    init_item2();
    init_button();
    init_utils2();
    init_themes();
    init_window();
    init_scroll_view();
    init_ui_scrollable_device();
    init_ui_collection_widget_live_update();
    init_bindable_template();
    init_deferred();
    init_grouped_data_converter_mixin();
    LIST_CLASS = "dx-list";
    LIST_ITEM_CLASS2 = "dx-list-item";
    LIST_ITEM_SELECTOR = "." + LIST_ITEM_CLASS2;
    LIST_ITEM_ICON_CONTAINER_CLASS = "dx-list-item-icon-container";
    LIST_ITEM_ICON_CLASS = "dx-list-item-icon";
    LIST_GROUP_CLASS2 = "dx-list-group";
    LIST_GROUP_HEADER_CLASS = "dx-list-group-header";
    LIST_GROUP_BODY_CLASS = "dx-list-group-body";
    LIST_COLLAPSIBLE_GROUPS_CLASS = "dx-list-collapsible-groups";
    LIST_GROUP_COLLAPSED_CLASS = "dx-list-group-collapsed";
    LIST_GROUP_HEADER_INDICATOR_CLASS = "dx-list-group-header-indicator";
    LIST_HAS_NEXT_CLASS = "dx-has-next";
    LIST_NEXT_BUTTON_CLASS = "dx-list-next-button";
    WRAP_ITEM_TEXT_CLASS = "dx-wrap-item-text";
    SELECT_ALL_ITEM_SELECTOR = ".dx-list-select-all";
    LIST_ITEM_DATA_KEY = "dxListItemData";
    LIST_FEEDBACK_SHOW_TIMEOUT = 70;
    groupItemsGetter = compileGetter("items");
    ListBase = ui_collection_widget_live_update_default.inherit({
      _activeStateUnit: [LIST_ITEM_SELECTOR, SELECT_ALL_ITEM_SELECTOR].join(","),
      _supportedKeys: function() {
        var that = this;
        var moveFocusPerPage = function(direction) {
          var $item = getEdgeVisibleItem(direction);
          var isFocusedItem = $item.is(that.option("focusedElement"));
          if (isFocusedItem) {
            !function($item2, direction2) {
              var resultPosition = $item2.position().top;
              if ("prev" === direction2) {
                resultPosition = $item2.position().top - that.$element().height() + $item2.outerHeight();
              }
              that.scrollTo(resultPosition);
            }($item, direction);
            $item = getEdgeVisibleItem(direction);
          }
          that.option("focusedElement", getPublicElement($item));
          that.scrollToItem($item);
        };
        function getEdgeVisibleItem(direction) {
          var scrollTop = that.scrollTop();
          var containerHeight = that.$element().height();
          var $item = renderer_default(that.option("focusedElement"));
          var isItemVisible = true;
          if (!$item.length) {
            return renderer_default();
          }
          while (isItemVisible) {
            var $nextItem = $item[direction]();
            if (!$nextItem.length) {
              break;
            }
            var nextItemLocation = $nextItem.position().top + $nextItem.outerHeight() / 2;
            isItemVisible = nextItemLocation < containerHeight + scrollTop && nextItemLocation > scrollTop;
            if (isItemVisible) {
              $item = $nextItem;
            }
          }
          return $item;
        }
        return extend2(this.callBase(), {
          leftArrow: noop2,
          rightArrow: noop2,
          pageUp: function() {
            moveFocusPerPage("prev");
            return false;
          },
          pageDown: function() {
            moveFocusPerPage("next");
            return false;
          }
        });
      },
      _getDefaultOptions: function() {
        return extend2(this.callBase(), {
          hoverStateEnabled: true,
          pullRefreshEnabled: false,
          scrollingEnabled: true,
          showScrollbar: "onScroll",
          useNativeScrolling: true,
          bounceEnabled: true,
          scrollByContent: true,
          scrollByThumb: false,
          pullingDownText: message_default.format("dxList-pullingDownText"),
          pulledDownText: message_default.format("dxList-pulledDownText"),
          refreshingText: message_default.format("dxList-refreshingText"),
          pageLoadingText: message_default.format("dxList-pageLoadingText"),
          onScroll: null,
          onPullRefresh: null,
          onPageLoading: null,
          pageLoadMode: "scrollBottom",
          nextButtonText: message_default.format("dxList-nextButtonText"),
          onItemSwipe: null,
          grouped: false,
          onGroupRendered: null,
          collapsibleGroups: false,
          groupTemplate: "group",
          indicateLoading: true,
          activeStateEnabled: true,
          _itemAttributes: {
            role: "option"
          },
          _listAttributes: {
            role: "listbox"
          },
          useInkRipple: false,
          wrapItemText: false,
          _swipeEnabled: true,
          _revertPageOnEmptyLoad: false,
          showChevronExpr: function(data2) {
            return data2 ? data2.showChevron : void 0;
          },
          badgeExpr: function(data2) {
            return data2 ? data2.badge : void 0;
          }
        });
      },
      _defaultOptionsRules: function() {
        var themeName = current();
        return this.callBase().concat(deviceDependentOptions(), [{
          device: function() {
            return !nativeScrolling;
          },
          options: {
            useNativeScrolling: false
          }
        }, {
          device: function(_device) {
            return !nativeScrolling && !devices_default.isSimulator() && "desktop" === devices_default.real().deviceType && "generic" === _device.platform;
          },
          options: {
            showScrollbar: "onHover",
            pageLoadMode: "nextButton"
          }
        }, {
          device: function() {
            return "desktop" === devices_default.real().deviceType && !devices_default.isSimulator();
          },
          options: {
            focusStateEnabled: true
          }
        }, {
          device: function() {
            return isMaterial(themeName);
          },
          options: {
            pullingDownText: "",
            pulledDownText: "",
            refreshingText: "",
            pageLoadingText: "",
            useInkRipple: true
          }
        }]);
      },
      _visibilityChanged: function(visible2) {
        if (visible2) {
          this._updateLoadingState(true);
        }
      },
      _itemClass: function() {
        return LIST_ITEM_CLASS2;
      },
      _itemDataKey: function() {
        return LIST_ITEM_DATA_KEY;
      },
      _itemContainer: function() {
        return this._$container;
      },
      _saveSelectionChangeEvent: function(e) {
        this._selectionChangeEventInstance = e;
      },
      _getSelectionChangeEvent: function() {
        return this._selectionChangeEventInstance;
      },
      _refreshItemElements: function() {
        if (!this.option("grouped")) {
          this._itemElementsCache = this._itemContainer().children(this._itemSelector());
        } else {
          this._itemElementsCache = this._itemContainer().children("." + LIST_GROUP_CLASS2).children("." + LIST_GROUP_BODY_CLASS).children(this._itemSelector());
        }
      },
      _modifyByChanges: function() {
        this.callBase.apply(this, arguments);
        this._refreshItemElements();
        this._updateLoadingState(true);
      },
      reorderItem: function(itemElement, toItemElement) {
        var promise2 = this.callBase(itemElement, toItemElement);
        return promise2.done(function() {
          this._refreshItemElements();
        });
      },
      deleteItem: function(itemElement) {
        var promise2 = this.callBase(itemElement);
        return promise2.done(function() {
          this._refreshItemElements();
        });
      },
      _itemElements: function() {
        return this._itemElementsCache;
      },
      _itemSelectHandler: function(e) {
        if ("single" === this.option("selectionMode") && this.isItemSelected(e.currentTarget)) {
          return;
        }
        return this.callBase(e);
      },
      _allowDynamicItemsAppend: function() {
        return true;
      },
      _resetDataSourcePageIndex: function() {
        var currentDataSource = this.getDataSource();
        if (currentDataSource && 0 !== currentDataSource.pageIndex()) {
          currentDataSource.pageIndex(0);
          currentDataSource.load();
        }
      },
      _init: function() {
        this.callBase();
        this._resetDataSourcePageIndex();
        this._$container = this.$element();
        this._initScrollView();
        this._feedbackShowTimeout = LIST_FEEDBACK_SHOW_TIMEOUT;
        this._createGroupRenderAction();
      },
      _scrollBottomMode: function() {
        return "scrollBottom" === this.option("pageLoadMode");
      },
      _nextButtonMode: function() {
        return "nextButton" === this.option("pageLoadMode");
      },
      _dataSourceOptions: function() {
        var scrollBottom = this._scrollBottomMode();
        var nextButton = this._nextButtonMode();
        return extend2(this.callBase(), {
          paginate: ensureDefined(scrollBottom || nextButton, true)
        });
      },
      _getGroupedOption: function() {
        return this.option("grouped");
      },
      _getGroupContainerByIndex: function(groupIndex) {
        return this._itemContainer().find(".".concat(LIST_GROUP_CLASS2)).eq(groupIndex).find(".".concat(LIST_GROUP_BODY_CLASS));
      },
      _dataSourceFromUrlLoadMode: function() {
        return "raw";
      },
      _initScrollView: function() {
        var scrollingEnabled = this.option("scrollingEnabled");
        var pullRefreshEnabled = scrollingEnabled && this.option("pullRefreshEnabled");
        var autoPagingEnabled = scrollingEnabled && this._scrollBottomMode() && !!this._dataSource;
        this._scrollView = this._createComponent(this.$element(), getScrollView(), {
          disabled: this.option("disabled") || !scrollingEnabled,
          onScroll: this._scrollHandler.bind(this),
          onPullDown: pullRefreshEnabled ? this._pullDownHandler.bind(this) : null,
          onReachBottom: autoPagingEnabled ? this._scrollBottomHandler.bind(this) : null,
          showScrollbar: this.option("showScrollbar"),
          useNative: this.option("useNativeScrolling"),
          bounceEnabled: this.option("bounceEnabled"),
          scrollByContent: this.option("scrollByContent"),
          scrollByThumb: this.option("scrollByThumb"),
          pullingDownText: this.option("pullingDownText"),
          pulledDownText: this.option("pulledDownText"),
          refreshingText: this.option("refreshingText"),
          reachBottomText: this.option("pageLoadingText"),
          useKeyboard: false
        });
        this._$container = renderer_default(this._scrollView.content());
        if (this.option("wrapItemText")) {
          this._$container.addClass(WRAP_ITEM_TEXT_CLASS);
        }
        this._createScrollViewActions();
      },
      _createScrollViewActions: function() {
        this._scrollAction = this._createActionByOption("onScroll");
        this._pullRefreshAction = this._createActionByOption("onPullRefresh");
        this._pageLoadingAction = this._createActionByOption("onPageLoading");
      },
      _scrollHandler: function(e) {
        this._scrollAction && this._scrollAction(e);
      },
      _initTemplates: function() {
        this._templateManager.addDefaultTemplates({
          group: new BindableTemplate(function($container, data2) {
            if (isPlainObject(data2)) {
              if (data2.key) {
                $container.text(data2.key);
              }
            } else {
              $container.text(String(data2));
            }
          }, ["key"], this.option("integrationOptions.watchMethod"))
        });
        this.callBase();
      },
      _prepareDefaultItemTemplate: function(data2, $container) {
        this.callBase(data2, $container);
        if (data2.icon) {
          var $icon = getImageContainer(data2.icon).addClass(LIST_ITEM_ICON_CLASS);
          var $iconContainer = renderer_default("<div>").addClass(LIST_ITEM_ICON_CONTAINER_CLASS);
          $iconContainer.append($icon);
          $container.prepend($iconContainer);
        }
      },
      _getBindableFields: function() {
        return ["text", "html", "icon"];
      },
      _updateLoadingState: function(tryLoadMore) {
        var isDataLoaded = !tryLoadMore || this._isLastPage();
        var scrollBottomMode = this._scrollBottomMode();
        var stopLoading = isDataLoaded || !scrollBottomMode;
        var hideLoadIndicator = stopLoading && !this._isDataSourceLoading();
        if (stopLoading || this._scrollViewIsFull()) {
          this._scrollView.release(hideLoadIndicator);
          this._toggleNextButton(this._shouldRenderNextButton() && !this._isLastPage());
          this._loadIndicationSuppressed(false);
        } else {
          this._infiniteDataLoading();
        }
      },
      _shouldRenderNextButton: function() {
        return this._nextButtonMode() && this._dataSource && this._dataSource.isLoaded();
      },
      _isDataSourceFirstLoadCompleted: function(newValue) {
        if (isDefined(newValue)) {
          this._isFirstLoadCompleted = newValue;
        }
        return this._isFirstLoadCompleted;
      },
      _dataSourceLoadingChangedHandler: function(isLoading) {
        if (this._loadIndicationSuppressed()) {
          return;
        }
        if (isLoading && this.option("indicateLoading")) {
          this._showLoadingIndicatorTimer = setTimeout((function() {
            var isEmpty3 = !this._itemElements().length;
            var shouldIndicateLoading = !isEmpty3 || this._isDataSourceFirstLoadCompleted();
            if (shouldIndicateLoading) {
              var _this$_scrollView;
              null === (_this$_scrollView = this._scrollView) || void 0 === _this$_scrollView ? void 0 : _this$_scrollView.startLoading();
            }
          }).bind(this));
        } else {
          clearTimeout(this._showLoadingIndicatorTimer);
          this._scrollView && this._scrollView.finishLoading();
        }
        if (!isLoading) {
          this._isDataSourceFirstLoadCompleted(false);
        }
      },
      _dataSourceChangedHandler: function() {
        if (!this._shouldAppendItems() && hasWindow()) {
          this._scrollView && this._scrollView.scrollTo(0);
        }
        this.callBase.apply(this, arguments);
        this._isDataSourceFirstLoadCompleted(true);
      },
      _refreshContent: function() {
        this._prepareContent();
        this._fireContentReadyAction();
      },
      _hideLoadingIfLoadIndicationOff: function() {
        if (!this.option("indicateLoading")) {
          this._dataSourceLoadingChangedHandler(false);
        }
      },
      _loadIndicationSuppressed: function(value2) {
        if (!arguments.length) {
          return this._isLoadIndicationSuppressed;
        }
        this._isLoadIndicationSuppressed = value2;
      },
      _scrollViewIsFull: function() {
        return !this._scrollView || this._scrollView.isFull();
      },
      _pullDownHandler: function(e) {
        this._pullRefreshAction(e);
        if (this._dataSource && !this._isDataSourceLoading()) {
          this._clearSelectedItems();
          this._dataSource.pageIndex(0);
          this._dataSource.reload();
        } else {
          this._updateLoadingState();
        }
      },
      _infiniteDataLoading: function() {
        var isElementVisible2 = this.$element().is(":visible");
        if (isElementVisible2 && !this._scrollViewIsFull() && !this._isDataSourceLoading() && !this._isLastPage()) {
          clearTimeout(this._loadNextPageTimer);
          this._loadNextPageTimer = setTimeout(() => {
            this._loadNextPage().done(this._setPreviousPageIfNewIsEmpty.bind(this));
          });
        }
      },
      _setPreviousPageIfNewIsEmpty: function(result2) {
        if (this.option("_revertPageOnEmptyLoad")) {
          var dataSource = this.getDataSource();
          var pageIndex = null === dataSource || void 0 === dataSource ? void 0 : dataSource.pageIndex();
          if (0 === (null === result2 || void 0 === result2 ? void 0 : result2.length) && pageIndex > 0) {
            this._fireContentReadyAction();
            dataSource.pageIndex(pageIndex - 1);
          }
        }
      },
      _scrollBottomHandler: function(e) {
        this._pageLoadingAction(e);
        if (!this._isDataSourceLoading() && !this._isLastPage()) {
          this._loadNextPage();
        } else {
          this._updateLoadingState();
        }
      },
      _renderItems: function(items) {
        if (this.option("grouped")) {
          each(items, this._renderGroup.bind(this));
          this._attachGroupCollapseEvent();
          this._renderEmptyMessage();
          if (isMaterial()) {
            this.attachGroupHeaderInkRippleEvents();
          }
        } else {
          this.callBase.apply(this, arguments);
        }
        this._refreshItemElements();
        this._updateLoadingState(true);
      },
      _attachGroupCollapseEvent: function() {
        var eventName = addNamespace2(CLICK_EVENT_NAME, this.NAME);
        var selector = "." + LIST_GROUP_HEADER_CLASS;
        var $element = this.$element();
        var collapsibleGroups = this.option("collapsibleGroups");
        $element.toggleClass(LIST_COLLAPSIBLE_GROUPS_CLASS, collapsibleGroups);
        events_engine_default.off($element, eventName, selector);
        if (collapsibleGroups) {
          events_engine_default.on($element, eventName, selector, (function(e) {
            this._createAction((function(e2) {
              var $group = renderer_default(e2.event.currentTarget).parent();
              this._collapseGroupHandler($group);
              if (this.option("focusStateEnabled")) {
                this.option("focusedElement", getPublicElement($group.find("." + LIST_ITEM_CLASS2).eq(0)));
              }
            }).bind(this), {
              validatingTargetName: "element"
            })({
              event: e
            });
          }).bind(this));
        }
      },
      _collapseGroupHandler: function($group, toggle) {
        var deferred = new Deferred();
        if ($group.hasClass(LIST_GROUP_COLLAPSED_CLASS) === toggle) {
          return deferred.resolve();
        }
        var $groupBody = $group.children("." + LIST_GROUP_BODY_CLASS);
        var startHeight = $groupBody.outerHeight();
        var endHeight = 0 === startHeight ? $groupBody.height("auto").outerHeight() : 0;
        $group.toggleClass(LIST_GROUP_COLLAPSED_CLASS, toggle);
        fx_default.animate($groupBody, {
          type: "custom",
          from: {
            height: startHeight
          },
          to: {
            height: endHeight
          },
          duration: 200,
          complete: (function() {
            this.updateDimensions();
            this._updateLoadingState();
            deferred.resolve();
          }).bind(this)
        });
        return deferred.promise();
      },
      _dataSourceLoadErrorHandler: function() {
        this._forgetNextPageLoading();
        if (this._initialized) {
          this._renderEmptyMessage();
          this._updateLoadingState();
        }
      },
      _initMarkup: function() {
        this._itemElementsCache = renderer_default();
        this.$element().addClass(LIST_CLASS);
        this.callBase();
        this.option("useInkRipple") && this._renderInkRipple();
        this.setAria("role", this.option("_listAttributes").role);
      },
      _renderInkRipple: function() {
        this._inkRipple = render();
      },
      _toggleActiveState: function($element, value2, e) {
        this.callBase.apply(this, arguments);
        var that = this;
        if (!this._inkRipple) {
          return;
        }
        var config2 = {
          element: $element,
          event: e
        };
        if (value2) {
          if (isMaterial()) {
            this._inkRippleTimer = setTimeout(function() {
              that._inkRipple.showWave(config2);
            }, LIST_FEEDBACK_SHOW_TIMEOUT / 2);
          } else {
            that._inkRipple.showWave(config2);
          }
        } else {
          clearTimeout(this._inkRippleTimer);
          this._inkRipple.hideWave(config2);
        }
      },
      _postprocessRenderItem: function(args) {
        this._refreshItemElements();
        this.callBase.apply(this, arguments);
        if (this.option("_swipeEnabled")) {
          this._attachSwipeEvent(renderer_default(args.itemElement));
        }
      },
      _attachSwipeEvent: function($itemElement) {
        var endEventName = addNamespace2(SWIPE_END_EVENT, this.NAME);
        events_engine_default.on($itemElement, endEventName, this._itemSwipeEndHandler.bind(this));
      },
      _itemSwipeEndHandler: function(e) {
        this._itemDXEventHandler(e, "onItemSwipe", {
          direction: e.offset < 0 ? "left" : "right"
        });
      },
      _nextButtonHandler: function(e) {
        this._pageLoadingAction(e);
        var source = this._dataSource;
        if (source && !source.isLoading()) {
          this._scrollView.toggleLoading(true);
          this._$nextButton.detach();
          this._loadIndicationSuppressed(true);
          this._loadNextPage();
        }
      },
      _renderGroup: function(index2, group) {
        var $groupElement = renderer_default("<div>").addClass(LIST_GROUP_CLASS2).appendTo(this._itemContainer());
        var $groupHeaderElement = renderer_default("<div>").addClass(LIST_GROUP_HEADER_CLASS).appendTo($groupElement);
        var groupTemplateName = this.option("groupTemplate");
        var groupTemplate = this._getTemplate(group.template || groupTemplateName, group, index2, $groupHeaderElement);
        var renderArgs = {
          index: index2,
          itemData: group,
          container: getPublicElement($groupHeaderElement)
        };
        this._createItemByTemplate(groupTemplate, renderArgs);
        if (isMaterial()) {
          renderer_default("<div>").addClass(LIST_GROUP_HEADER_INDICATOR_CLASS).prependTo($groupHeaderElement);
        }
        this._renderingGroupIndex = index2;
        var $groupBody = renderer_default("<div>").addClass(LIST_GROUP_BODY_CLASS).appendTo($groupElement);
        each(groupItemsGetter(group) || [], (function(itemIndex, item) {
          this._renderItem({
            group: index2,
            item: itemIndex
          }, item, $groupBody);
        }).bind(this));
        this._groupRenderAction({
          groupElement: getPublicElement($groupElement),
          groupIndex: index2,
          groupData: group
        });
      },
      downInkRippleHandler: function(e) {
        this._toggleActiveState(renderer_default(e.currentTarget), true, e);
      },
      upInkRippleHandler: function(e) {
        this._toggleActiveState(renderer_default(e.currentTarget), false);
      },
      attachGroupHeaderInkRippleEvents: function() {
        var selector = "." + LIST_GROUP_HEADER_CLASS;
        var $element = this.$element();
        this._downInkRippleHandler = this._downInkRippleHandler || this.downInkRippleHandler.bind(this);
        this._upInkRippleHandler = this._upInkRippleHandler || this.upInkRippleHandler.bind(this);
        var downArguments = [$element, "dxpointerdown", selector, this._downInkRippleHandler];
        var upArguments = [$element, "dxpointerup dxpointerout", selector, this._upInkRippleHandler];
        events_engine_default.off(...downArguments);
        events_engine_default.on(...downArguments);
        events_engine_default.off(...upArguments);
        events_engine_default.on(...upArguments);
      },
      _createGroupRenderAction: function() {
        this._groupRenderAction = this._createActionByOption("onGroupRendered");
      },
      _clean: function() {
        clearTimeout(this._inkRippleTimer);
        if (this._$nextButton) {
          this._$nextButton.remove();
          this._$nextButton = null;
        }
        delete this._inkRipple;
        this.callBase.apply(this, arguments);
      },
      _dispose: function() {
        this._isDataSourceFirstLoadCompleted(false);
        clearTimeout(this._holdTimer);
        clearTimeout(this._loadNextPageTimer);
        clearTimeout(this._showLoadingIndicatorTimer);
        this.callBase();
      },
      _toggleDisabledState: function(value2) {
        this.callBase(value2);
        this._scrollView.option("disabled", value2 || !this.option("scrollingEnabled"));
      },
      _toggleNextButton: function(value2) {
        var dataSource = this._dataSource;
        var $nextButton = this._getNextButton();
        this.$element().toggleClass(LIST_HAS_NEXT_CLASS, value2);
        if (value2 && dataSource && dataSource.isLoaded()) {
          $nextButton.appendTo(this._itemContainer());
        }
        if (!value2) {
          $nextButton.detach();
        }
      },
      _getNextButton: function() {
        if (!this._$nextButton) {
          this._$nextButton = this._createNextButton();
        }
        return this._$nextButton;
      },
      _createNextButton: function() {
        var $result = renderer_default("<div>").addClass(LIST_NEXT_BUTTON_CLASS);
        var $button = renderer_default("<div>").appendTo($result);
        this._createComponent($button, button_default, {
          text: this.option("nextButtonText"),
          onClick: this._nextButtonHandler.bind(this),
          type: isMaterial() ? "default" : void 0,
          integrationOptions: {}
        });
        return $result;
      },
      _moveFocus: function() {
        this.callBase.apply(this, arguments);
        this.scrollToItem(this.option("focusedElement"));
      },
      _refresh: function() {
        if (!hasWindow()) {
          this.callBase();
        } else {
          var scrollTop = this._scrollView.scrollTop();
          this.callBase();
          scrollTop && this._scrollView.scrollTo(scrollTop);
        }
      },
      _optionChanged: function(args) {
        switch (args.name) {
          case "pageLoadMode":
            this._toggleNextButton(args.value);
            this._initScrollView();
            break;
          case "dataSource":
            this.callBase(args);
            this._initScrollView();
            this._isDataSourceFirstLoadCompleted(false);
            break;
          case "items":
            this.callBase(args);
            this._isDataSourceFirstLoadCompleted(false);
            break;
          case "pullingDownText":
          case "pulledDownText":
          case "refreshingText":
          case "pageLoadingText":
          case "showScrollbar":
          case "bounceEnabled":
          case "scrollByContent":
          case "scrollByThumb":
          case "useNativeScrolling":
          case "scrollingEnabled":
          case "pullRefreshEnabled":
            this._initScrollView();
            this._updateLoadingState();
            break;
          case "nextButtonText":
          case "onItemSwipe":
          case "useInkRipple":
            this._invalidate();
            break;
          case "onScroll":
          case "onPullRefresh":
          case "onPageLoading":
            this._createScrollViewActions();
            break;
          case "grouped":
          case "collapsibleGroups":
          case "groupTemplate":
            this._invalidate();
            break;
          case "wrapItemText":
            this._$container.toggleClass(WRAP_ITEM_TEXT_CLASS, args.value);
            break;
          case "onGroupRendered":
            this._createGroupRenderAction();
            break;
          case "width":
          case "height":
            this.callBase(args);
            this._scrollView.update();
            break;
          case "indicateLoading":
            this._hideLoadingIfLoadIndicationOff();
            break;
          case "visible":
            this.callBase(args);
            this._scrollView.update();
            break;
          case "rtlEnabled":
            this._initScrollView();
            this.callBase(args);
            break;
          case "showChevronExpr":
          case "badgeExpr":
            this._invalidate();
            break;
          case "_swipeEnabled":
          case "_revertPageOnEmptyLoad":
          case "_listAttributes":
            break;
          default:
            this.callBase(args);
        }
      },
      _extendActionArgs: function($itemElement) {
        if (!this.option("grouped")) {
          return this.callBase($itemElement);
        }
        var $group = $itemElement.closest("." + LIST_GROUP_CLASS2);
        var $item = $group.find("." + LIST_ITEM_CLASS2);
        return extend2(this.callBase($itemElement), {
          itemIndex: {
            group: $group.index(),
            item: $item.index($itemElement)
          }
        });
      },
      expandGroup: function(groupIndex) {
        var deferred = new Deferred();
        var $group = this._itemContainer().find("." + LIST_GROUP_CLASS2).eq(groupIndex);
        this._collapseGroupHandler($group, false).done((function() {
          deferred.resolveWith(this);
        }).bind(this));
        return deferred.promise();
      },
      collapseGroup: function(groupIndex) {
        var deferred = new Deferred();
        var $group = this._itemContainer().find("." + LIST_GROUP_CLASS2).eq(groupIndex);
        this._collapseGroupHandler($group, true).done((function() {
          deferred.resolveWith(this);
        }).bind(this));
        return deferred;
      },
      updateDimensions: function() {
        var that = this;
        var deferred = new Deferred();
        if (that._scrollView) {
          that._scrollView.update().done(function() {
            !that._scrollViewIsFull() && that._updateLoadingState(true);
            deferred.resolveWith(that);
          });
        } else {
          deferred.resolveWith(that);
        }
        return deferred.promise();
      },
      reload: function() {
        this.callBase();
        this.scrollTo(0);
        this._pullDownHandler();
      },
      repaint: function() {
        this.scrollTo(0);
        this.callBase();
      },
      scrollTop: function() {
        return this._scrollView.scrollOffset().top;
      },
      clientHeight: function() {
        return this._scrollView.clientHeight();
      },
      scrollHeight: function() {
        return this._scrollView.scrollHeight();
      },
      scrollBy: function(distance) {
        this._scrollView.scrollBy(distance);
      },
      scrollTo: function(location) {
        this._scrollView.scrollTo(location);
      },
      scrollToItem: function(itemElement) {
        var $item = this._editStrategy.getItemElement(itemElement);
        this._scrollView.scrollToElement($item);
      },
      _dimensionChanged: function() {
        this.updateDimensions();
      }
    }).include(grouped_data_converter_mixin_default);
    ListBase.ItemClass = item_default2;
  }
});

// node_modules/devextreme/esm/ui/list/ui.list.edit.decorator.context.js
var CONTEXTMENU_CLASS, CONTEXTMENU_MENUCONTENT_CLASS;
var init_ui_list_edit_decorator_context = __esm({
  "node_modules/devextreme/esm/ui/list/ui.list.edit.decorator.context.js"() {
    init_renderer();
    init_ui_list_edit_decorator_menu_helper();
    init_message();
    init_ui_list_edit_decorator_registry();
    init_ui_list_edit_decorator();
    init_ui_overlay();
    init_ui_list_base();
    CONTEXTMENU_CLASS = "dx-list-context-menu";
    CONTEXTMENU_MENUCONTENT_CLASS = "dx-list-context-menucontent";
    register("menu", "context", ui_list_edit_decorator_default.inherit({
      _init: function() {
        var $menu = renderer_default("<div>").addClass(CONTEXTMENU_CLASS);
        this._list.$element().append($menu);
        this._menu = this._renderOverlay($menu);
      },
      _renderOverlay: function($element) {
        return this._list._createComponent($element, ui_overlay_default, {
          shading: false,
          deferRendering: true,
          closeOnTargetScroll: true,
          closeOnOutsideClick: function(e) {
            return !renderer_default(e.target).closest("." + CONTEXTMENU_CLASS).length;
          },
          animation: {
            show: {
              type: "slide",
              duration: 300,
              from: {
                height: 0,
                opacity: 1
              },
              to: {
                height: (function() {
                  return this._$menuList.outerHeight();
                }).bind(this),
                opacity: 1
              }
            },
            hide: {
              type: "slide",
              duration: 0,
              from: {
                opacity: 1
              },
              to: {
                opacity: 0
              }
            }
          },
          height: (function() {
            return this._$menuList ? this._$menuList.outerHeight() : 0;
          }).bind(this),
          width: (function() {
            return this._list.$element().outerWidth();
          }).bind(this),
          onContentReady: this._renderMenuContent.bind(this)
        });
      },
      _renderMenuContent: function(e) {
        var $overlayContent = e.component.$content();
        var items = this._menuItems().slice();
        if (this._deleteEnabled()) {
          items.push({
            text: message_default.format("dxListEditDecorator-delete"),
            action: this._deleteItem.bind(this)
          });
        }
        this._$menuList = renderer_default("<div>");
        this._list._createComponent(this._$menuList, ListBase, {
          items,
          onItemClick: this._menuItemClickHandler.bind(this),
          height: "auto",
          integrationOptions: {}
        });
        $overlayContent.addClass(CONTEXTMENU_MENUCONTENT_CLASS);
        $overlayContent.append(this._$menuList);
      },
      _menuItemClickHandler: function(args) {
        this._menu.hide();
        this._fireMenuAction(this._$itemWithMenu, args.itemData.action);
      },
      _deleteItem: function() {
        this._list.deleteItem(this._$itemWithMenu);
      },
      handleContextMenu: function($itemElement) {
        this._$itemWithMenu = $itemElement;
        this._menu.option({
          position: {
            my: "top",
            at: "bottom",
            of: $itemElement,
            collision: "flip"
          }
        });
        this._menu.show();
        return true;
      },
      dispose: function() {
        if (this._menu) {
          this._menu.$element().remove();
        }
        this.callBase.apply(this, arguments);
      }
    }).include(ui_list_edit_decorator_menu_helper_default));
  }
});

// node_modules/devextreme/esm/ui/check_box.js
var CHECKBOX_CLASS, CHECKBOX_ICON_CLASS, CHECKBOX_CHECKED_CLASS, CHECKBOX_CONTAINER_CLASS, CHECKBOX_TEXT_CLASS, CHECKBOX_HAS_TEXT_CLASS, CHECKBOX_INDETERMINATE_CLASS, CHECKBOX_FEEDBACK_HIDE_TIMEOUT, CheckBox, check_box_default;
var init_check_box = __esm({
  "node_modules/devextreme/esm/ui/check_box.js"() {
    init_renderer();
    init_events_engine();
    init_devices();
    init_extend();
    init_utils_ink_ripple();
    init_editor();
    init_component_registrator();
    init_utils2();
    init_click();
    CHECKBOX_CLASS = "dx-checkbox";
    CHECKBOX_ICON_CLASS = "dx-checkbox-icon";
    CHECKBOX_CHECKED_CLASS = "dx-checkbox-checked";
    CHECKBOX_CONTAINER_CLASS = "dx-checkbox-container";
    CHECKBOX_TEXT_CLASS = "dx-checkbox-text";
    CHECKBOX_HAS_TEXT_CLASS = "dx-checkbox-has-text";
    CHECKBOX_INDETERMINATE_CLASS = "dx-checkbox-indeterminate";
    CHECKBOX_FEEDBACK_HIDE_TIMEOUT = 100;
    CheckBox = editor_default.inherit({
      _supportedKeys: function() {
        return extend2(this.callBase(), {
          space: function(e) {
            e.preventDefault();
            this._clickAction({
              event: e
            });
          }
        });
      },
      _getDefaultOptions: function() {
        return extend2(this.callBase(), {
          hoverStateEnabled: true,
          activeStateEnabled: true,
          value: false,
          text: "",
          useInkRipple: false
        });
      },
      _defaultOptionsRules: function() {
        return this.callBase().concat([{
          device: function() {
            return "desktop" === devices_default.real().deviceType && !devices_default.isSimulator();
          },
          options: {
            focusStateEnabled: true
          }
        }]);
      },
      _canValueBeChangedByClick: function() {
        return true;
      },
      _useTemplates: function() {
        return false;
      },
      _feedbackHideTimeout: CHECKBOX_FEEDBACK_HIDE_TIMEOUT,
      _initMarkup: function() {
        this._renderSubmitElement();
        this._$container = renderer_default("<div>").addClass(CHECKBOX_CONTAINER_CLASS);
        this.setAria("role", "checkbox");
        this.$element().addClass(CHECKBOX_CLASS);
        this._renderValue();
        this._renderIcon();
        this._renderText();
        this.option("useInkRipple") && this._renderInkRipple();
        this.$element().append(this._$container);
        this.callBase();
      },
      _render: function() {
        this._renderClick();
        this.callBase();
      },
      _renderSubmitElement: function() {
        this._$submitElement = renderer_default("<input>").attr("type", "hidden").appendTo(this.$element());
      },
      _getSubmitElement: function() {
        return this._$submitElement;
      },
      _renderInkRipple: function() {
        this._inkRipple = render({
          waveSizeCoefficient: 2.5,
          useHoldAnimation: false,
          wavesNumber: 2,
          isCentered: true
        });
      },
      _renderInkWave: function(element, dxEvent, doRender, waveIndex) {
        if (!this._inkRipple) {
          return;
        }
        var config2 = {
          element,
          event: dxEvent,
          wave: waveIndex
        };
        if (doRender) {
          this._inkRipple.showWave(config2);
        } else {
          this._inkRipple.hideWave(config2);
        }
      },
      _updateFocusState: function(e, value2) {
        this.callBase.apply(this, arguments);
        this._renderInkWave(this._$icon, e, value2, 0);
      },
      _toggleActiveState: function($element, value2, e) {
        this.callBase.apply(this, arguments);
        this._renderInkWave(this._$icon, e, value2, 1);
      },
      _renderIcon: function() {
        this._$icon = renderer_default("<span>").addClass(CHECKBOX_ICON_CLASS).prependTo(this._$container);
      },
      _renderText: function() {
        var textValue = this.option("text");
        if (!textValue) {
          if (this._$text) {
            this._$text.remove();
            this.$element().removeClass(CHECKBOX_HAS_TEXT_CLASS);
          }
          return;
        }
        if (!this._$text) {
          this._$text = renderer_default("<span>").addClass(CHECKBOX_TEXT_CLASS);
        }
        this._$text.text(textValue);
        this._$container.append(this._$text);
        this.$element().addClass(CHECKBOX_HAS_TEXT_CLASS);
      },
      _renderClick: function() {
        var that = this;
        var eventName = addNamespace2(CLICK_EVENT_NAME, that.NAME);
        that._clickAction = that._createAction(that._clickHandler);
        events_engine_default.off(that.$element(), eventName);
        events_engine_default.on(that.$element(), eventName, function(e) {
          that._clickAction({
            event: e
          });
        });
      },
      _clickHandler: function(args) {
        var that = args.component;
        that._saveValueChangeEvent(args.event);
        that.option("value", !that.option("value"));
      },
      _renderValue: function() {
        var $element = this.$element();
        var checked = this.option("value");
        var indeterminate = void 0 === checked;
        $element.toggleClass(CHECKBOX_CHECKED_CLASS, Boolean(checked));
        $element.toggleClass(CHECKBOX_INDETERMINATE_CLASS, indeterminate);
        this._getSubmitElement().val(checked);
        this.setAria("checked", indeterminate ? "mixed" : checked || "false");
      },
      _optionChanged: function(args) {
        switch (args.name) {
          case "useInkRipple":
            this._invalidate();
            break;
          case "value":
            this._renderValue();
            this.callBase(args);
            break;
          case "text":
            this._renderText();
            this._renderDimensions();
            break;
          default:
            this.callBase(args);
        }
      },
      _clean: function() {
        delete this._inkRipple;
        this.callBase();
      }
    });
    component_registrator_default("dxCheckBox", CheckBox);
    check_box_default = CheckBox;
  }
});

// node_modules/devextreme/esm/ui/radio_group/radio_button.js
var RADIO_BUTTON_CLASS, RADIO_BUTTON_ICON_CLASS, RADIO_BUTTON_ICON_DOT_CLASS, RADIO_BUTTON_CHECKED_CLASS, RADIO_BUTTON_ICON_CHECKED_CLASS, RadioButton, radio_button_default;
var init_radio_button = __esm({
  "node_modules/devextreme/esm/ui/radio_group/radio_button.js"() {
    init_renderer();
    init_events_engine();
    init_devices();
    init_extend();
    init_utils_ink_ripple();
    init_component_registrator();
    init_editor();
    init_utils2();
    init_click();
    RADIO_BUTTON_CLASS = "dx-radiobutton";
    RADIO_BUTTON_ICON_CLASS = "dx-radiobutton-icon";
    RADIO_BUTTON_ICON_DOT_CLASS = "dx-radiobutton-icon-dot";
    RADIO_BUTTON_CHECKED_CLASS = "dx-radiobutton-checked";
    RADIO_BUTTON_ICON_CHECKED_CLASS = "dx-radiobutton-icon-checked";
    RadioButton = editor_default.inherit({
      _supportedKeys: function() {
        return extend2(this.callBase(), {
          space: function(e) {
            e.preventDefault();
            this._clickAction({
              event: e
            });
          }
        });
      },
      _getDefaultOptions: function() {
        return extend2(this.callBase(), {
          hoverStateEnabled: true,
          activeStateEnabled: true,
          value: false,
          useInkRipple: false
        });
      },
      _canValueBeChangedByClick: function() {
        return true;
      },
      _defaultOptionsRules: function() {
        return this.callBase().concat([{
          device: function() {
            return "desktop" === devices_default.real().deviceType && !devices_default.isSimulator();
          },
          options: {
            focusStateEnabled: true
          }
        }]);
      },
      _init: function() {
        this.callBase();
        this.$element().addClass(RADIO_BUTTON_CLASS);
      },
      _initMarkup: function() {
        this.callBase();
        this._renderIcon();
        this.option("useInkRipple") && this._renderInkRipple();
        this._renderCheckedState(this.option("value"));
        this._renderClick();
        this.setAria("role", "radio");
      },
      _renderInkRipple: function() {
        this._inkRipple = render({
          waveSizeCoefficient: 3.3,
          useHoldAnimation: false,
          wavesNumber: 2,
          isCentered: true
        });
      },
      _renderInkWave: function(element, dxEvent, doRender, waveIndex) {
        if (!this._inkRipple) {
          return;
        }
        var config2 = {
          element,
          event: dxEvent,
          wave: waveIndex
        };
        if (doRender) {
          this._inkRipple.showWave(config2);
        } else {
          this._inkRipple.hideWave(config2);
        }
      },
      _updateFocusState: function(e, value2) {
        this.callBase.apply(this, arguments);
        this._renderInkWave(this._$icon, e, value2, 0);
      },
      _toggleActiveState: function($element, value2, e) {
        this.callBase.apply(this, arguments);
        this._renderInkWave(this._$icon, e, value2, 1);
      },
      _renderIcon: function() {
        this._$icon = renderer_default("<div>").addClass(RADIO_BUTTON_ICON_CLASS);
        renderer_default("<div>").addClass(RADIO_BUTTON_ICON_DOT_CLASS).appendTo(this._$icon);
        this.$element().append(this._$icon);
      },
      _renderCheckedState: function(checked) {
        this.$element().toggleClass(RADIO_BUTTON_CHECKED_CLASS, checked).find("." + RADIO_BUTTON_ICON_CLASS).toggleClass(RADIO_BUTTON_ICON_CHECKED_CLASS, checked);
        this.setAria("checked", checked);
      },
      _renderClick: function() {
        var eventName = addNamespace2(CLICK_EVENT_NAME, this.NAME);
        this._clickAction = this._createAction((function(args) {
          this._clickHandler(args.event);
        }).bind(this));
        events_engine_default.off(this.$element(), eventName);
        events_engine_default.on(this.$element(), eventName, (function(e) {
          this._clickAction({
            event: e
          });
        }).bind(this));
      },
      _clickHandler: function(e) {
        this._saveValueChangeEvent(e);
        this.option("value", true);
      },
      _optionChanged: function(args) {
        switch (args.name) {
          case "useInkRipple":
            this._invalidate();
            break;
          case "value":
            this._renderCheckedState(args.value);
            this.callBase(args);
            break;
          default:
            this.callBase(args);
        }
      },
      _clean: function() {
        delete this._inkRipple;
        this.callBase();
      }
    });
    component_registrator_default("dxRadioButton", RadioButton);
    radio_button_default = RadioButton;
  }
});

// node_modules/devextreme/esm/ui/list/ui.list.edit.decorator.selection.js
var SELECT_DECORATOR_ENABLED_CLASS, SELECT_DECORATOR_SELECT_ALL_CLASS, SELECT_DECORATOR_SELECT_ALL_CHECKBOX_CLASS, SELECT_DECORATOR_SELECT_ALL_LABEL_CLASS, SELECT_CHECKBOX_CONTAINER_CLASS, SELECT_CHECKBOX_CLASS, SELECT_RADIO_BUTTON_CONTAINER_CLASS, SELECT_RADIO_BUTTON_CLASS, FOCUSED_STATE_CLASS, CLICK_EVENT_NAME3;
var init_ui_list_edit_decorator_selection = __esm({
  "node_modules/devextreme/esm/ui/list/ui.list.edit.decorator.selection.js"() {
    init_renderer();
    init_events_engine();
    init_click();
    init_extend();
    init_ui_errors();
    init_check_box();
    init_radio_button();
    init_utils2();
    init_ui_list_edit_decorator_registry();
    init_ui_list_edit_decorator();
    SELECT_DECORATOR_ENABLED_CLASS = "dx-list-select-decorator-enabled";
    SELECT_DECORATOR_SELECT_ALL_CLASS = "dx-list-select-all";
    SELECT_DECORATOR_SELECT_ALL_CHECKBOX_CLASS = "dx-list-select-all-checkbox";
    SELECT_DECORATOR_SELECT_ALL_LABEL_CLASS = "dx-list-select-all-label";
    SELECT_CHECKBOX_CONTAINER_CLASS = "dx-list-select-checkbox-container";
    SELECT_CHECKBOX_CLASS = "dx-list-select-checkbox";
    SELECT_RADIO_BUTTON_CONTAINER_CLASS = "dx-list-select-radiobutton-container";
    SELECT_RADIO_BUTTON_CLASS = "dx-list-select-radiobutton";
    FOCUSED_STATE_CLASS = "dx-state-focused";
    CLICK_EVENT_NAME3 = addNamespace2(CLICK_EVENT_NAME, "dxListEditDecorator");
    register("selection", "default", ui_list_edit_decorator_default.inherit({
      _init: function() {
        this.callBase.apply(this, arguments);
        var selectionMode = this._list.option("selectionMode");
        this._singleStrategy = "single" === selectionMode;
        this._containerClass = this._singleStrategy ? SELECT_RADIO_BUTTON_CONTAINER_CLASS : SELECT_CHECKBOX_CONTAINER_CLASS;
        this._controlClass = this._singleStrategy ? SELECT_RADIO_BUTTON_CLASS : SELECT_CHECKBOX_CLASS;
        this._controlWidget = this._singleStrategy ? radio_button_default : check_box_default;
        this._list.$element().addClass(SELECT_DECORATOR_ENABLED_CLASS);
      },
      beforeBag: function(config2) {
        var $itemElement = config2.$itemElement;
        var $container = config2.$container.addClass(this._containerClass);
        var $control = renderer_default("<div>").addClass(this._controlClass).appendTo($container);
        new this._controlWidget($control, extend2(this._commonOptions(), {
          value: this._isSelected($itemElement),
          focusStateEnabled: false,
          hoverStateEnabled: false,
          onValueChanged: (function(e) {
            e.event && this._list._saveSelectionChangeEvent(e.event);
            this._processCheckedState($itemElement, e.value);
            e.event && e.event.stopPropagation();
          }).bind(this)
        }));
      },
      modifyElement: function(config2) {
        this.callBase.apply(this, arguments);
        var $itemElement = config2.$itemElement;
        var control = this._controlWidget.getInstance($itemElement.find("." + this._controlClass));
        events_engine_default.on($itemElement, "stateChanged", (function(e, state) {
          control.option("value", state);
        }).bind(this));
      },
      _updateSelectAllState: function() {
        if (!this._$selectAll) {
          return;
        }
        this._selectAllCheckBox.option("value", this._list.isSelectAll());
      },
      afterRender: function() {
        if ("all" !== this._list.option("selectionMode")) {
          return;
        }
        if (!this._$selectAll) {
          this._renderSelectAll();
        } else {
          this._updateSelectAllState();
        }
      },
      handleKeyboardEvents: function(currentFocusedIndex, moveFocusUp) {
        var moveFocusDown = !moveFocusUp;
        var list = this._list;
        var $selectAll = this._$selectAll;
        var lastItemIndex = list._getLastItemIndex();
        var isFocusOutOfList = moveFocusUp && 0 === currentFocusedIndex || moveFocusDown && currentFocusedIndex === lastItemIndex;
        var hasSelectAllItem = !!$selectAll;
        if (hasSelectAllItem && isFocusOutOfList) {
          list.option("focusedElement", $selectAll);
          list.scrollToItem(list.option("focusedElement"));
          return true;
        }
        return false;
      },
      handleEnterPressing: function(e) {
        if (this._$selectAll && this._$selectAll.hasClass(FOCUSED_STATE_CLASS)) {
          e.target = this._$selectAll.get(0);
          this._list._saveSelectionChangeEvent(e);
          this._selectAllCheckBox.option("value", !this._selectAllCheckBox.option("value"));
          return true;
        }
      },
      _renderSelectAll: function() {
        var $selectAll = this._$selectAll = renderer_default("<div>").addClass(SELECT_DECORATOR_SELECT_ALL_CLASS);
        var list = this._list;
        var downArrowHandler = list._supportedKeys().downArrow.bind(list);
        this._selectAllCheckBox = list._createComponent(renderer_default("<div>").addClass(SELECT_DECORATOR_SELECT_ALL_CHECKBOX_CLASS).appendTo($selectAll), check_box_default, {
          focusStateEnabled: false,
          hoverStateEnabled: false
        });
        this._selectAllCheckBox.registerKeyHandler("downArrow", downArrowHandler);
        renderer_default("<div>").addClass(SELECT_DECORATOR_SELECT_ALL_LABEL_CLASS).text(this._list.option("selectAllText")).appendTo($selectAll);
        this._list.itemsContainer().prepend($selectAll);
        this._updateSelectAllState();
        this._attachSelectAllHandler();
      },
      _attachSelectAllHandler: function() {
        this._selectAllCheckBox.option("onValueChanged", this._selectAllHandler.bind(this));
        events_engine_default.off(this._$selectAll, CLICK_EVENT_NAME3);
        events_engine_default.on(this._$selectAll, CLICK_EVENT_NAME3, this._selectAllClickHandler.bind(this));
      },
      _selectAllHandler: function(e) {
        e.event && e.event.stopPropagation();
        var isSelectedAll = this._selectAllCheckBox.option("value");
        e.event && this._list._saveSelectionChangeEvent(e.event);
        if (true === isSelectedAll) {
          this._selectAllItems();
        } else if (false === isSelectedAll) {
          this._unselectAllItems();
        }
        this._list._createActionByOption("onSelectAllValueChanged")({
          value: isSelectedAll
        });
      },
      _checkSelectAllCapability: function() {
        var list = this._list;
        var dataSource = list.getDataSource();
        if ("allPages" === list.option("selectAllMode") && list.option("grouped") && (!dataSource || !dataSource.group())) {
          ui_errors_default.log("W1010");
          return false;
        }
        return true;
      },
      _selectAllItems: function() {
        if (!this._checkSelectAllCapability()) {
          return;
        }
        this._list._selection.selectAll("page" === this._list.option("selectAllMode"));
      },
      _unselectAllItems: function() {
        if (!this._checkSelectAllCapability()) {
          return;
        }
        this._list._selection.deselectAll("page" === this._list.option("selectAllMode"));
      },
      _selectAllClickHandler: function(e) {
        this._list._saveSelectionChangeEvent(e);
        this._selectAllCheckBox.option("value", !this._selectAllCheckBox.option("value"));
      },
      _isSelected: function($itemElement) {
        return this._list.isItemSelected($itemElement);
      },
      _processCheckedState: function($itemElement, checked) {
        if (checked) {
          this._list.selectItem($itemElement);
        } else {
          this._list.unselectItem($itemElement);
        }
      },
      dispose: function() {
        this._disposeSelectAll();
        this._list.$element().removeClass(SELECT_DECORATOR_ENABLED_CLASS);
        this.callBase.apply(this, arguments);
      },
      _disposeSelectAll: function() {
        if (this._$selectAll) {
          this._$selectAll.remove();
          this._$selectAll = null;
        }
      }
    }));
  }
});

// node_modules/devextreme/esm/ui/draggable.js
var window19, DRAGGABLE, DRAGSTART_EVENT_NAME2, DRAG_EVENT_NAME, DRAGEND_EVENT_NAME, DRAG_ENTER_EVENT_NAME, DRAGEND_LEAVE_EVENT_NAME, POINTERDOWN_EVENT_NAME, CLONE_CLASS, targetDraggable, sourceDraggable, ANONYMOUS_TEMPLATE_NAME5, getMousePosition, GESTURE_COVER_CLASS, OVERLAY_WRAPPER_CLASS2, OVERLAY_CONTENT_CLASS2, ScrollHelper, ScrollAnimator, Draggable, draggable_default;
var init_draggable = __esm({
  "node_modules/devextreme/esm/ui/draggable.js"() {
    init_extends();
    init_renderer();
    init_window();
    init_position();
    init_events_engine();
    init_string();
    init_component_registrator();
    init_translator();
    init_animator();
    init_inflector();
    init_extend();
    init_dom_component();
    init_element();
    init_utils2();
    init_pointer();
    init_drag();
    init_position2();
    init_type();
    init_common();
    init_view_port();
    init_empty_template();
    init_deferred();
    window19 = getWindow();
    DRAGGABLE = "dxDraggable";
    DRAGSTART_EVENT_NAME2 = addNamespace2(DRAG_START_EVENT, DRAGGABLE);
    DRAG_EVENT_NAME = addNamespace2(DRAG_EVENT, DRAGGABLE);
    DRAGEND_EVENT_NAME = addNamespace2(DRAG_END_EVENT, DRAGGABLE);
    DRAG_ENTER_EVENT_NAME = addNamespace2(DRAG_ENTER_EVENT, DRAGGABLE);
    DRAGEND_LEAVE_EVENT_NAME = addNamespace2(DRAG_LEAVE_EVENT, DRAGGABLE);
    POINTERDOWN_EVENT_NAME = addNamespace2(pointer_default.down, DRAGGABLE);
    CLONE_CLASS = "clone";
    ANONYMOUS_TEMPLATE_NAME5 = "content";
    getMousePosition = (event) => ({
      x: event.pageX - renderer_default(window19).scrollLeft(),
      y: event.pageY - renderer_default(window19).scrollTop()
    });
    GESTURE_COVER_CLASS = "dx-gesture-cover";
    OVERLAY_WRAPPER_CLASS2 = "dx-overlay-wrapper";
    OVERLAY_CONTENT_CLASS2 = "dx-overlay-content";
    ScrollHelper = class {
      constructor(orientation, component) {
        this._preventScroll = true;
        this._component = component;
        if ("vertical" === orientation) {
          this._scrollValue = "scrollTop";
          this._overFlowAttr = "overflowY";
          this._sizeAttr = "height";
          this._scrollSizeProp = "scrollHeight";
          this._clientSizeProp = "clientHeight";
          this._limitProps = {
            start: "top",
            end: "bottom"
          };
        } else {
          this._scrollValue = "scrollLeft";
          this._overFlowAttr = "overflowX";
          this._sizeAttr = "width";
          this._scrollSizeProp = "scrollWidth";
          this._clientSizeProp = "clientWidth";
          this._limitProps = {
            start: "left",
            end: "right"
          };
        }
      }
      updateScrollable(elements, mousePosition) {
        var isScrollableFound = false;
        elements.some((element) => {
          var $element = renderer_default(element);
          var isTargetOverOverlayWrapper = $element.hasClass(OVERLAY_WRAPPER_CLASS2) && "none" !== $element.css("pointerEvents");
          var isTargetOverOverlayContent = $element.hasClass(OVERLAY_CONTENT_CLASS2);
          if (isTargetOverOverlayWrapper || isTargetOverOverlayContent) {
            return true;
          }
          isScrollableFound = this._trySetScrollable(element, mousePosition);
          return isScrollableFound;
        });
        if (!isScrollableFound) {
          this._$scrollableAtPointer = null;
          this._scrollSpeed = 0;
        }
      }
      isScrolling() {
        return !!this._scrollSpeed;
      }
      isScrollable($element) {
        return ("auto" === $element.css(this._overFlowAttr) || $element.hasClass("dx-scrollable-container")) && $element.prop(this._scrollSizeProp) > Math.ceil($element[this._sizeAttr]());
      }
      _trySetScrollable(element, mousePosition) {
        var $element = renderer_default(element);
        var distanceToBorders;
        var sensitivity = this._component.option("scrollSensitivity");
        var isScrollable = this.isScrollable($element);
        if (isScrollable) {
          distanceToBorders = this._calculateDistanceToBorders($element, mousePosition);
          if (sensitivity > distanceToBorders[this._limitProps.start]) {
            if (!this._preventScroll) {
              this._scrollSpeed = -this._calculateScrollSpeed(distanceToBorders[this._limitProps.start]);
              this._$scrollableAtPointer = $element;
            }
          } else if (sensitivity > distanceToBorders[this._limitProps.end]) {
            if (!this._preventScroll) {
              this._scrollSpeed = this._calculateScrollSpeed(distanceToBorders[this._limitProps.end]);
              this._$scrollableAtPointer = $element;
            }
          } else {
            isScrollable = false;
            this._preventScroll = false;
          }
        }
        return isScrollable;
      }
      _calculateDistanceToBorders($area, mousePosition) {
        var area = $area.get(0);
        var areaBoundingRect;
        if (area) {
          areaBoundingRect = getBoundingRect(area);
          return {
            left: mousePosition.x - areaBoundingRect.left,
            top: mousePosition.y - areaBoundingRect.top,
            right: areaBoundingRect.right - mousePosition.x,
            bottom: areaBoundingRect.bottom - mousePosition.y
          };
        } else {
          return {};
        }
      }
      _calculateScrollSpeed(distance) {
        var component = this._component;
        var sensitivity = component.option("scrollSensitivity");
        var maxSpeed = component.option("scrollSpeed");
        return Math.ceil(Math.pow((sensitivity - distance) / sensitivity, 2) * maxSpeed);
      }
      scrollByStep() {
        if (this._$scrollableAtPointer && this._scrollSpeed) {
          if (this._$scrollableAtPointer.hasClass("dx-scrollable-container")) {
            var $scrollable = this._$scrollableAtPointer.closest(".dx-scrollable");
            var scrollableInstance = $scrollable.data("dxScrollable") || $scrollable.data("dxScrollView");
            if (scrollableInstance) {
              var nextScrollPosition = scrollableInstance.scrollOffset()[this._limitProps.start] + this._scrollSpeed;
              scrollableInstance.scrollTo({
                [this._limitProps.start]: nextScrollPosition
              });
            }
          } else {
            var _nextScrollPosition = this._$scrollableAtPointer[this._scrollValue]() + this._scrollSpeed;
            this._$scrollableAtPointer[this._scrollValue](_nextScrollPosition);
          }
          var dragMoveArgs = this._component._dragMoveArgs;
          if (dragMoveArgs) {
            this._component._dragMoveHandler(dragMoveArgs);
          }
        }
      }
      reset() {
        this._$scrollableAtPointer = null;
        this._scrollSpeed = 0;
        this._preventScroll = true;
      }
      isOutsideScrollable($scrollable, event) {
        if (!$scrollable) {
          return false;
        }
        var scrollableSize = getBoundingRect($scrollable.get(0));
        var start = scrollableSize[this._limitProps.start];
        var size = scrollableSize[this._sizeAttr];
        var mousePosition = getMousePosition(event);
        var location = "width" === this._sizeAttr ? mousePosition.x : mousePosition.y;
        return location < start || location > start + size;
      }
    };
    ScrollAnimator = animator_default.inherit({
      ctor: function(strategy3) {
        this.callBase();
        this._strategy = strategy3;
      },
      _step: function() {
        var horizontalScrollHelper = this._strategy._horizontalScrollHelper;
        var verticalScrollHelper = this._strategy._verticalScrollHelper;
        horizontalScrollHelper && horizontalScrollHelper.scrollByStep();
        verticalScrollHelper && verticalScrollHelper.scrollByStep();
      }
    });
    Draggable = dom_component_default.inherit({
      reset: noop2,
      dragMove: noop2,
      dragEnter: noop2,
      dragLeave: noop2,
      dragEnd: function(sourceEvent) {
        var sourceDraggable2 = this._getSourceDraggable();
        sourceDraggable2._fireRemoveEvent(sourceEvent);
        return new Deferred().resolve();
      },
      _fireRemoveEvent: noop2,
      _getDefaultOptions: function() {
        return extend2(this.callBase(), {
          onDragStart: null,
          onDragMove: null,
          onDragEnd: null,
          onDragEnter: null,
          onDragLeave: null,
          onDrop: null,
          immediate: true,
          dragDirection: "both",
          boundary: void 0,
          boundOffset: 0,
          allowMoveByClick: false,
          itemData: null,
          container: void 0,
          dragTemplate: void 0,
          contentTemplate: "content",
          handle: "",
          filter: "",
          clone: false,
          autoScroll: true,
          scrollSpeed: 30,
          scrollSensitivity: 60,
          group: void 0,
          data: void 0
        });
      },
      _setOptionsByReference: function() {
        this.callBase.apply(this, arguments);
        extend2(this._optionsByReference, {
          component: true,
          group: true,
          itemData: true,
          data: true
        });
      },
      _init: function() {
        this.callBase();
        this._attachEventHandlers();
        this._scrollAnimator = new ScrollAnimator(this);
        this._horizontalScrollHelper = new ScrollHelper("horizontal", this);
        this._verticalScrollHelper = new ScrollHelper("vertical", this);
      },
      _normalizeCursorOffset: function(offset2) {
        if (isObject2(offset2)) {
          offset2 = {
            h: offset2.x,
            v: offset2.y
          };
        }
        offset2 = splitPair(offset2).map((value2) => parseFloat(value2));
        return {
          left: offset2[0],
          top: 1 === offset2.length ? offset2[0] : offset2[1]
        };
      },
      _getNormalizedCursorOffset: function(offset2, options2) {
        if (isFunction(offset2)) {
          offset2 = offset2.call(this, options2);
        }
        return this._normalizeCursorOffset(offset2);
      },
      _calculateElementOffset: function(options2) {
        var elementOffset;
        var dragElementOffset;
        var event = options2.event;
        var $element = renderer_default(options2.itemElement);
        var $dragElement = renderer_default(options2.dragElement);
        var isCloned = this._dragElementIsCloned();
        var cursorOffset = this.option("cursorOffset");
        var normalizedCursorOffset = {
          left: 0,
          top: 0
        };
        var currentLocate = this._initialLocate = locate($dragElement);
        if (isCloned || options2.initialOffset || cursorOffset) {
          elementOffset = options2.initialOffset || $element.offset();
          if (cursorOffset) {
            normalizedCursorOffset = this._getNormalizedCursorOffset(cursorOffset, options2);
            if (isFinite(normalizedCursorOffset.left)) {
              elementOffset.left = event.pageX;
            }
            if (isFinite(normalizedCursorOffset.top)) {
              elementOffset.top = event.pageY;
            }
          }
          dragElementOffset = $dragElement.offset();
          elementOffset.top -= dragElementOffset.top + (normalizedCursorOffset.top || 0) - currentLocate.top;
          elementOffset.left -= dragElementOffset.left + (normalizedCursorOffset.left || 0) - currentLocate.left;
        }
        return elementOffset;
      },
      _initPosition: function(options2) {
        var $dragElement = renderer_default(options2.dragElement);
        var elementOffset = this._calculateElementOffset(options2);
        if (elementOffset) {
          this._move(elementOffset, $dragElement);
        }
        this._startPosition = locate($dragElement);
      },
      _startAnimator: function() {
        if (!this._scrollAnimator.inProgress()) {
          this._scrollAnimator.start();
        }
      },
      _stopAnimator: function() {
        this._scrollAnimator.stop();
      },
      _addWidgetPrefix: function(className) {
        var componentName = this.NAME;
        return dasherize(componentName) + (className ? "-" + className : "");
      },
      _getItemsSelector: function() {
        return this.option("filter") || "";
      },
      _$content: function() {
        var $element = this.$element();
        var $wrapper = $element.children(".dx-template-wrapper");
        return $wrapper.length ? $wrapper : $element;
      },
      _attachEventHandlers: function() {
        if (this.option("disabled")) {
          return;
        }
        var $element = this._$content();
        var itemsSelector = this._getItemsSelector();
        var allowMoveByClick = this.option("allowMoveByClick");
        var data2 = {
          direction: this.option("dragDirection"),
          immediate: this.option("immediate"),
          checkDropTarget: ($target, event) => {
            var targetGroup = this.option("group");
            var sourceGroup = this._getSourceDraggable().option("group");
            var $scrollable = this._getScrollable($target);
            if (this._verticalScrollHelper.isOutsideScrollable($scrollable, event) || this._horizontalScrollHelper.isOutsideScrollable($scrollable, event)) {
              return false;
            }
            return sourceGroup && sourceGroup === targetGroup;
          }
        };
        if (allowMoveByClick) {
          $element = this._getArea();
          events_engine_default.on($element, POINTERDOWN_EVENT_NAME, data2, this._pointerDownHandler.bind(this));
        }
        if (">" === itemsSelector[0]) {
          itemsSelector = itemsSelector.slice(1);
        }
        events_engine_default.on($element, DRAGSTART_EVENT_NAME2, itemsSelector, data2, this._dragStartHandler.bind(this));
        events_engine_default.on($element, DRAG_EVENT_NAME, data2, this._dragMoveHandler.bind(this));
        events_engine_default.on($element, DRAGEND_EVENT_NAME, data2, this._dragEndHandler.bind(this));
        events_engine_default.on($element, DRAG_ENTER_EVENT_NAME, data2, this._dragEnterHandler.bind(this));
        events_engine_default.on($element, DRAGEND_LEAVE_EVENT_NAME, data2, this._dragLeaveHandler.bind(this));
      },
      _dragElementIsCloned: function() {
        return this._$dragElement && this._$dragElement.hasClass(this._addWidgetPrefix(CLONE_CLASS));
      },
      _getDragTemplateArgs: function($element, $container) {
        return {
          container: getPublicElement($container),
          model: {
            itemData: this.option("itemData"),
            itemElement: getPublicElement($element)
          }
        };
      },
      _createDragElement: function($element) {
        var result2 = $element;
        var clone = this.option("clone");
        var $container = this._getContainer();
        var template = this.option("dragTemplate");
        if (template) {
          template = this._getTemplate(template);
          result2 = renderer_default("<div>").appendTo($container);
          template.render(this._getDragTemplateArgs($element, result2));
        } else if (clone) {
          result2 = renderer_default("<div>").appendTo($container);
          $element.clone().css({
            width: $element.css("width"),
            height: $element.css("height")
          }).appendTo(result2);
        }
        return result2.toggleClass(this._addWidgetPrefix(CLONE_CLASS), result2.get(0) !== $element.get(0)).toggleClass("dx-rtl", this.option("rtlEnabled"));
      },
      _resetDragElement: function() {
        if (this._dragElementIsCloned()) {
          this._$dragElement.remove();
        } else {
          this._toggleDraggingClass(false);
        }
        this._$dragElement = null;
      },
      _resetSourceElement: function() {
        this._toggleDragSourceClass(false);
        this._$sourceElement = null;
      },
      _detachEventHandlers: function() {
        events_engine_default.off(this._$content(), "." + DRAGGABLE);
        events_engine_default.off(this._getArea(), "." + DRAGGABLE);
      },
      _move: function(position3, $element) {
        move($element || this._$dragElement, position3);
      },
      _getDraggableElement: function(e) {
        var $sourceElement = this._getSourceElement();
        if ($sourceElement) {
          return $sourceElement;
        }
        var allowMoveByClick = this.option("allowMoveByClick");
        if (allowMoveByClick) {
          return this.$element();
        }
        var $target = renderer_default(e && e.target);
        var itemsSelector = this._getItemsSelector();
        if (">" === itemsSelector[0]) {
          var $items = this._$content().find(itemsSelector);
          if (!$items.is($target)) {
            $target = $target.closest($items);
          }
        }
        return $target;
      },
      _getSourceElement: function() {
        var draggable = this._getSourceDraggable();
        return draggable._$sourceElement;
      },
      _pointerDownHandler: function(e) {
        if (needSkipEvent(e)) {
          return;
        }
        var position3 = {};
        var $element = this.$element();
        var dragDirection = this.option("dragDirection");
        if ("horizontal" === dragDirection || "both" === dragDirection) {
          position3.left = e.pageX - $element.offset().left + locate($element).left - $element.width() / 2;
        }
        if ("vertical" === dragDirection || "both" === dragDirection) {
          position3.top = e.pageY - $element.offset().top + locate($element).top - $element.height() / 2;
        }
        this._move(position3, $element);
        this._getAction("onDragMove")(this._getEventArgs(e));
      },
      _isValidElement: function(event, $element) {
        var handle = this.option("handle");
        var $target = renderer_default(event.originalEvent && event.originalEvent.target);
        if (handle && !$target.closest(handle).length) {
          return false;
        }
        if (!$element.length) {
          return false;
        }
        return !$element.is(".dx-state-disabled, .dx-state-disabled *");
      },
      _dragStartHandler: function(e) {
        var $element = this._getDraggableElement(e);
        if (!this._isValidElement(e, $element)) {
          e.cancel = true;
          return;
        }
        if (this._$sourceElement) {
          return;
        }
        var dragStartArgs = this._getDragStartArgs(e, $element);
        this._getAction("onDragStart")(dragStartArgs);
        if (dragStartArgs.cancel) {
          e.cancel = true;
          return;
        }
        this.option("itemData", dragStartArgs.itemData);
        this._setSourceDraggable();
        this._$sourceElement = $element;
        var initialOffset = $element.offset();
        var $dragElement = this._$dragElement = this._createDragElement($element);
        this._toggleDraggingClass(true);
        this._toggleDragSourceClass(true);
        this._setGestureCoverCursor($dragElement.children());
        var isFixedPosition = "fixed" === $dragElement.css("position");
        this._initPosition(extend2({}, dragStartArgs, {
          dragElement: $dragElement.get(0),
          initialOffset: isFixedPosition && initialOffset
        }));
        this._getAction("onDraggableElementShown")(_extends({}, dragStartArgs, {
          dragElement: $dragElement
        }));
        var $area = this._getArea();
        var areaOffset = this._getAreaOffset($area);
        var boundOffset = this._getBoundOffset();
        var areaWidth = $area.outerWidth();
        var areaHeight = $area.outerHeight();
        var elementWidth = $dragElement.width();
        var elementHeight = $dragElement.height();
        var startOffset_left = $dragElement.offset().left - areaOffset.left, startOffset_top = $dragElement.offset().top - areaOffset.top;
        if ($area.length) {
          e.maxLeftOffset = startOffset_left - boundOffset.left;
          e.maxRightOffset = areaWidth - startOffset_left - elementWidth - boundOffset.right;
          e.maxTopOffset = startOffset_top - boundOffset.top;
          e.maxBottomOffset = areaHeight - startOffset_top - elementHeight - boundOffset.bottom;
        }
        if (this.option("autoScroll")) {
          this._startAnimator();
        }
      },
      _getAreaOffset: function($area) {
        var offset2 = $area && position_default.offset($area);
        return offset2 ? offset2 : {
          left: 0,
          top: 0
        };
      },
      _toggleDraggingClass: function(value2) {
        this._$dragElement && this._$dragElement.toggleClass(this._addWidgetPrefix("dragging"), value2);
      },
      _toggleDragSourceClass: function(value2, $element) {
        var $sourceElement = $element || this._$sourceElement;
        $sourceElement && $sourceElement.toggleClass(this._addWidgetPrefix("source"), value2);
      },
      _setGestureCoverCursor: function($element) {
        renderer_default(".".concat(GESTURE_COVER_CLASS)).css("cursor", $element.css("cursor"));
      },
      _getBoundOffset: function() {
        var boundOffset = this.option("boundOffset");
        if (isFunction(boundOffset)) {
          boundOffset = boundOffset.call(this);
        }
        return quadToObject(boundOffset);
      },
      _getArea: function() {
        var area = this.option("boundary");
        if (isFunction(area)) {
          area = area.call(this);
        }
        return renderer_default(area);
      },
      _getContainer: function() {
        var container = this.option("container");
        if (void 0 === container) {
          container = value();
        }
        return renderer_default(container);
      },
      _dragMoveHandler: function(e, scrollBy) {
        this._dragMoveArgs = e;
        if (!this._$dragElement) {
          e.cancel = true;
          return;
        }
        var offset2 = e.offset;
        var startPosition = this._startPosition;
        this._move({
          left: startPosition.left + offset2.x,
          top: startPosition.top + offset2.y
        });
        if (!scrollBy) {
          this._updateScrollable(e);
        }
        var eventArgs = this._getEventArgs(e);
        this._getAction("onDragMove")(eventArgs);
        if (true === eventArgs.cancel) {
          return;
        }
        var targetDraggable2 = this._getTargetDraggable();
        targetDraggable2.dragMove(e, scrollBy);
      },
      _updateScrollable: function(e) {
        if (this.option("autoScroll")) {
          var mousePosition = getMousePosition(e);
          var allObjects = getElementsFromPoint(mousePosition.x, mousePosition.y);
          this._verticalScrollHelper.updateScrollable(allObjects, mousePosition);
          this._horizontalScrollHelper.updateScrollable(allObjects, mousePosition);
        }
      },
      _getScrollable: function($element) {
        var $scrollable;
        $element.parents().toArray().some((parent) => {
          var $parent = renderer_default(parent);
          if (this._horizontalScrollHelper.isScrollable($parent) || this._verticalScrollHelper.isScrollable($parent)) {
            $scrollable = $parent;
            return true;
          }
        });
        return $scrollable;
      },
      _defaultActionArgs: function() {
        var args = this.callBase.apply(this, arguments);
        var component = this.option("component");
        if (component) {
          args.component = component;
          args.element = component.element();
        }
        return args;
      },
      _getEventArgs: function(e) {
        var sourceDraggable2 = this._getSourceDraggable();
        var targetDraggable2 = this._getTargetDraggable();
        return {
          event: e,
          itemData: sourceDraggable2.option("itemData"),
          itemElement: getPublicElement(sourceDraggable2._$sourceElement),
          fromComponent: sourceDraggable2.option("component") || sourceDraggable2,
          toComponent: targetDraggable2.option("component") || targetDraggable2,
          fromData: sourceDraggable2.option("data"),
          toData: targetDraggable2.option("data")
        };
      },
      _getDragStartArgs: function(e, $itemElement) {
        var args = this._getEventArgs(e);
        return {
          event: args.event,
          itemData: args.itemData,
          itemElement: $itemElement,
          fromData: args.fromData
        };
      },
      _revertItemToInitialPosition: function() {
        !this._dragElementIsCloned() && this._move(this._initialLocate, this._$sourceElement);
      },
      _dragEndHandler: function(e) {
        var d = new Deferred();
        var dragEndEventArgs = this._getEventArgs(e);
        var dropEventArgs = this._getEventArgs(e);
        var targetDraggable2 = this._getTargetDraggable();
        var needRevertPosition = true;
        try {
          this._getAction("onDragEnd")(dragEndEventArgs);
        } finally {
          when(fromPromise(dragEndEventArgs.cancel)).done((cancel2) => {
            if (!cancel2) {
              if (targetDraggable2 !== this) {
                targetDraggable2._getAction("onDrop")(dropEventArgs);
              }
              if (!dropEventArgs.cancel) {
                needRevertPosition = false;
                when(fromPromise(targetDraggable2.dragEnd(dragEndEventArgs))).always(d.resolve);
                return;
              }
            }
            d.resolve();
          }).fail(d.resolve);
          d.done(() => {
            if (needRevertPosition) {
              this._revertItemToInitialPosition();
            }
            this.reset();
            targetDraggable2.reset();
            this._stopAnimator();
            this._horizontalScrollHelper.reset();
            this._verticalScrollHelper.reset();
            this._resetDragElement();
            this._resetSourceElement();
            this._resetTargetDraggable();
            this._resetSourceDraggable();
          });
        }
      },
      _isTargetOverAnotherDraggable: function(e) {
        var sourceDraggable2 = this._getSourceDraggable();
        if (this === sourceDraggable2) {
          return false;
        }
        var $dragElement = sourceDraggable2._$dragElement;
        var $sourceDraggableElement = sourceDraggable2.$element();
        var $targetDraggableElement = this.$element();
        var mousePosition = getMousePosition(e);
        var elements = getElementsFromPoint(mousePosition.x, mousePosition.y);
        var firstWidgetElement = elements.filter((element) => {
          var $element = renderer_default(element);
          if ($element.hasClass(this._addWidgetPrefix())) {
            return !$element.closest($dragElement).length;
          }
        })[0];
        var $sourceElement = this._getSourceElement();
        var isTargetOverItself = firstWidgetElement === $sourceDraggableElement.get(0);
        var isTargetOverNestedDraggable = renderer_default(firstWidgetElement).closest($sourceElement).length;
        return !firstWidgetElement || firstWidgetElement === $targetDraggableElement.get(0) && !isTargetOverItself && !isTargetOverNestedDraggable;
      },
      _dragEnterHandler: function(e) {
        this._fireDragEnterEvent(e);
        if (this._isTargetOverAnotherDraggable(e)) {
          this._setTargetDraggable();
        }
        var sourceDraggable2 = this._getSourceDraggable();
        sourceDraggable2.dragEnter(e);
      },
      _dragLeaveHandler: function(e) {
        this._fireDragLeaveEvent(e);
        this._resetTargetDraggable();
        if (this !== this._getSourceDraggable()) {
          this.reset();
        }
        var sourceDraggable2 = this._getSourceDraggable();
        sourceDraggable2.dragLeave(e);
      },
      _getAction: function(name2) {
        return this["_" + name2 + "Action"] || this._createActionByOption(name2);
      },
      _getAnonymousTemplateName: function() {
        return ANONYMOUS_TEMPLATE_NAME5;
      },
      _initTemplates: function() {
        if (!this.option("contentTemplate")) {
          return;
        }
        this._templateManager.addDefaultTemplates({
          content: new EmptyTemplate()
        });
        this.callBase.apply(this, arguments);
      },
      _render: function() {
        this.callBase();
        this.$element().addClass(this._addWidgetPrefix());
        var transclude = this._templateManager.anonymousTemplateName === this.option("contentTemplate");
        var template = this._getTemplateByOption("contentTemplate");
        if (template) {
          renderer_default(template.render({
            container: this.element(),
            transclude
          }));
        }
      },
      _optionChanged: function(args) {
        var name2 = args.name;
        switch (name2) {
          case "onDragStart":
          case "onDragMove":
          case "onDragEnd":
          case "onDrop":
          case "onDragEnter":
          case "onDragLeave":
          case "onDraggableElementShown":
            this["_" + name2 + "Action"] = this._createActionByOption(name2);
            break;
          case "dragTemplate":
          case "contentTemplate":
          case "container":
          case "clone":
            break;
          case "allowMoveByClick":
          case "dragDirection":
          case "disabled":
          case "boundary":
          case "filter":
          case "immediate":
            this._resetDragElement();
            this._detachEventHandlers();
            this._attachEventHandlers();
            break;
          case "autoScroll":
            this._verticalScrollHelper.reset();
            this._horizontalScrollHelper.reset();
            break;
          case "scrollSensitivity":
          case "scrollSpeed":
          case "boundOffset":
          case "handle":
          case "group":
          case "data":
          case "itemData":
            break;
          default:
            this.callBase(args);
        }
      },
      _getTargetDraggable: function() {
        return targetDraggable || this;
      },
      _getSourceDraggable: function() {
        return sourceDraggable || this;
      },
      _setTargetDraggable: function() {
        var currentGroup = this.option("group");
        var sourceDraggable2 = this._getSourceDraggable();
        if (currentGroup && currentGroup === sourceDraggable2.option("group")) {
          targetDraggable = this;
        }
      },
      _setSourceDraggable: function() {
        sourceDraggable = this;
      },
      _resetSourceDraggable: function() {
        sourceDraggable = null;
      },
      _resetTargetDraggable: function() {
        targetDraggable = null;
      },
      _dispose: function() {
        this.callBase();
        this._detachEventHandlers();
        this._resetDragElement();
        this._resetTargetDraggable();
        this._resetSourceDraggable();
        this._$sourceElement = null;
        this._stopAnimator();
      },
      _fireDragEnterEvent: function(sourceEvent) {
        var args = this._getEventArgs(sourceEvent);
        this._getAction("onDragEnter")(args);
      },
      _fireDragLeaveEvent: function(sourceEvent) {
        var args = this._getEventArgs(sourceEvent);
        this._getAction("onDragLeave")(args);
      }
    });
    component_registrator_default(DRAGGABLE, Draggable);
    draggable_default = Draggable;
  }
});

// node_modules/devextreme/esm/ui/sortable.js
function getScrollableBoundary($scrollable) {
  var offset2 = $scrollable.offset();
  var style = $scrollable[0].style;
  var paddingLeft = parseFloat(style.paddingLeft) || 0;
  var paddingRight = parseFloat(style.paddingRight) || 0;
  var paddingTop = parseFloat(style.paddingTop) || 0;
  var width = $scrollable[0].clientWidth - (paddingLeft + paddingRight);
  var height = $scrollable.height();
  var left = offset2.left + paddingLeft;
  var top = offset2.top + paddingTop;
  return {
    left,
    right: left + width,
    top,
    bottom: top + height
  };
}
var window20, SORTABLE, PLACEHOLDER_CLASS, CLONE_CLASS2, isElementVisible, animate2, stopAnimation, Sortable, sortable_default;
var init_sortable = __esm({
  "node_modules/devextreme/esm/ui/sortable.js"() {
    init_renderer();
    init_events_engine();
    init_component_registrator();
    init_extend();
    init_draggable();
    init_element();
    init_window();
    init_position();
    init_translator();
    init_fx();
    init_deferred();
    window20 = getWindow();
    SORTABLE = "dxSortable";
    PLACEHOLDER_CLASS = "placeholder";
    CLONE_CLASS2 = "clone";
    isElementVisible = (itemElement) => renderer_default(itemElement).is(":visible");
    animate2 = (element, config2) => {
      var _config$to, _config$to2;
      if (!element) {
        return;
      }
      var left = (null === (_config$to = config2.to) || void 0 === _config$to ? void 0 : _config$to.left) || 0;
      var top = (null === (_config$to2 = config2.to) || void 0 === _config$to2 ? void 0 : _config$to2.top) || 0;
      element.style.transform = "translate(".concat(left, "px,").concat(top, "px)");
      element.style.transition = fx_default.off ? "" : "transform ".concat(config2.duration, "ms ").concat(config2.easing);
    };
    stopAnimation = (element) => {
      if (!element) {
        return;
      }
      element.style.transform = "";
      element.style.transition = "";
    };
    Sortable = draggable_default.inherit({
      _init: function() {
        this.callBase();
        this._sourceScrollHandler = this._handleSourceScroll.bind(this);
        this._sourceScrollableInfo = null;
      },
      _getDefaultOptions: function() {
        return extend2(this.callBase(), {
          clone: true,
          filter: "> *",
          itemOrientation: "vertical",
          dropFeedbackMode: "push",
          allowDropInsideItem: false,
          allowReordering: true,
          moveItemOnDrop: false,
          onDragChange: null,
          onAdd: null,
          onRemove: null,
          onReorder: null,
          onPlaceholderPrepared: null,
          animation: {
            type: "slide",
            duration: 300,
            easing: "ease"
          },
          fromIndex: null,
          toIndex: null,
          dropInsideItem: false,
          itemPoints: null,
          fromIndexOffset: 0,
          offset: 0,
          autoUpdate: false,
          draggableElementSize: 0
        });
      },
      reset: function() {
        this.option({
          dropInsideItem: false,
          toIndex: null,
          fromIndex: null,
          itemPoints: null,
          fromIndexOffset: 0,
          draggableElementSize: 0
        });
        if (this._$placeholderElement) {
          this._$placeholderElement.remove();
        }
        this._$placeholderElement = null;
        if (!this._isIndicateMode() && this._$modifiedItem) {
          this._$modifiedItem.css("marginBottom", this._modifiedItemMargin);
          this._$modifiedItem = null;
        }
      },
      _getPrevVisibleItem: function(items, index2) {
        return items.slice(0, index2).reverse().filter(isElementVisible)[0];
      },
      _dragStartHandler: function(e) {
        this.callBase.apply(this, arguments);
        if (true === e.cancel) {
          return;
        }
        var $sourceElement = this._getSourceElement();
        this._updateItemPoints();
        this._subscribeToSourceScroll(e);
        this.option("fromIndex", this._getElementIndex($sourceElement));
        this.option("fromIndexOffset", this.option("offset"));
      },
      _subscribeToSourceScroll: function(e) {
        var $scrollable = this._getScrollable(renderer_default(e.target));
        if ($scrollable) {
          this._sourceScrollableInfo = {
            element: $scrollable,
            scrollLeft: $scrollable.scrollLeft(),
            scrollTop: $scrollable.scrollTop()
          };
          events_engine_default.off($scrollable, "scroll", this._sourceScrollHandler);
          events_engine_default.on($scrollable, "scroll", this._sourceScrollHandler);
        }
      },
      _unsubscribeFromSourceScroll: function() {
        if (this._sourceScrollableInfo) {
          events_engine_default.off(this._sourceScrollableInfo.element, "scroll", this._sourceScrollHandler);
          this._sourceScrollableInfo = null;
        }
      },
      _handleSourceScroll: function(e) {
        var sourceScrollableInfo = this._sourceScrollableInfo;
        if (sourceScrollableInfo) {
          ["scrollLeft", "scrollTop"].forEach((scrollProp) => {
            if (e.target[scrollProp] !== sourceScrollableInfo[scrollProp]) {
              var scrollBy = e.target[scrollProp] - sourceScrollableInfo[scrollProp];
              this._correctItemPoints(scrollBy);
              this._movePlaceholder();
              sourceScrollableInfo[scrollProp] = e.target[scrollProp];
            }
          });
        }
      },
      _dragEnterHandler: function(e) {
        this.callBase.apply(this, arguments);
        if (this === this._getSourceDraggable()) {
          return;
        }
        this._subscribeToSourceScroll(e);
        this._updateItemPoints();
        this.option("fromIndex", -1);
        if (!this._isIndicateMode()) {
          var itemPoints = this.option("itemPoints");
          var lastItemPoint = itemPoints[itemPoints.length - 1];
          if (lastItemPoint) {
            var $element = this.$element();
            var $sourceElement = this._getSourceElement();
            var isVertical = this._isVerticalOrientation();
            var sourceElementSize = isVertical ? $sourceElement.outerHeight(true) : $sourceElement.outerWidth(true);
            var scrollSize = $element.get(0)[isVertical ? "scrollHeight" : "scrollWidth"];
            var scrollPosition = $element.get(0)[isVertical ? "scrollTop" : "scrollLeft"];
            var positionProp = isVertical ? "top" : "left";
            var lastPointPosition = lastItemPoint[positionProp];
            var elementPosition = $element.offset()[positionProp];
            var freeSize = elementPosition + scrollSize - scrollPosition - lastPointPosition;
            if (freeSize < sourceElementSize) {
              if (isVertical) {
                var items = this._getItems();
                var $lastItem = renderer_default(this._getPrevVisibleItem(items));
                this._$modifiedItem = $lastItem;
                this._modifiedItemMargin = $lastItem.get(0).style.marginBottom;
                $lastItem.css("marginBottom", sourceElementSize - freeSize);
                var $sortable = $lastItem.closest(".dx-sortable");
                var sortable = $sortable.data("dxScrollable") || $sortable.data("dxScrollView");
                sortable && sortable.update();
              }
            }
          }
        }
      },
      _dragLeaveHandler: function() {
        this.callBase.apply(this, arguments);
        if (this !== this._getSourceDraggable()) {
          this._unsubscribeFromSourceScroll();
        }
      },
      dragEnter: function() {
        if (this !== this._getTargetDraggable()) {
          this.option("toIndex", -1);
        }
      },
      dragLeave: function() {
        if (this !== this._getTargetDraggable()) {
          this.option("toIndex", this.option("fromIndex"));
        }
      },
      _allowDrop: function(event) {
        var targetDraggable2 = this._getTargetDraggable();
        var $targetDraggable = targetDraggable2.$element();
        var $scrollable = this._getScrollable($targetDraggable);
        if ($scrollable) {
          var {
            left,
            right,
            top,
            bottom
          } = getScrollableBoundary($scrollable);
          var toIndex = this.option("toIndex");
          var itemPoints = this.option("itemPoints");
          var itemPoint = null === itemPoints || void 0 === itemPoints ? void 0 : itemPoints.filter((item) => item.index === toIndex)[0];
          if (itemPoint && void 0 !== itemPoint.top) {
            var isVertical = this._isVerticalOrientation();
            if (isVertical) {
              return top <= Math.ceil(itemPoint.top) && Math.floor(itemPoint.top) <= bottom;
            } else {
              return left <= Math.ceil(itemPoint.left) && Math.floor(itemPoint.left) <= right;
            }
          }
        }
        return true;
      },
      dragEnd: function(sourceEvent) {
        this._unsubscribeFromSourceScroll();
        var $sourceElement = this._getSourceElement();
        var sourceDraggable2 = this._getSourceDraggable();
        var isSourceDraggable = sourceDraggable2.NAME !== this.NAME;
        var toIndex = this.option("toIndex");
        var event = sourceEvent.event;
        var allowDrop = this._allowDrop(event);
        if (null !== toIndex && toIndex >= 0 && allowDrop) {
          var cancelAdd;
          var cancelRemove;
          if (sourceDraggable2 !== this) {
            cancelAdd = this._fireAddEvent(event);
            if (!cancelAdd) {
              cancelRemove = this._fireRemoveEvent(event);
            }
          }
          if (isSourceDraggable) {
            resetPosition($sourceElement);
          }
          if (this.option("moveItemOnDrop")) {
            !cancelAdd && this._moveItem($sourceElement, toIndex, cancelRemove);
          }
          if (sourceDraggable2 === this) {
            return this._fireReorderEvent(event);
          }
        }
        return new Deferred().resolve();
      },
      dragMove: function(e) {
        var itemPoints = this.option("itemPoints");
        if (!itemPoints) {
          return;
        }
        var isVertical = this._isVerticalOrientation();
        var axisName = isVertical ? "top" : "left";
        var cursorPosition = isVertical ? e.pageY : e.pageX;
        var rtlEnabled = this.option("rtlEnabled");
        var itemPoint;
        for (var i = itemPoints.length - 1; i >= 0; i--) {
          var centerPosition = itemPoints[i + 1] && (itemPoints[i][axisName] + itemPoints[i + 1][axisName]) / 2;
          if ((!isVertical && rtlEnabled ? cursorPosition > centerPosition : centerPosition > cursorPosition) || void 0 === centerPosition) {
            itemPoint = itemPoints[i];
          } else {
            break;
          }
        }
        if (itemPoint) {
          this._updatePlaceholderPosition(e, itemPoint);
          if (this._verticalScrollHelper.isScrolling() && this._isIndicateMode()) {
            this._movePlaceholder();
          }
        }
      },
      _isIndicateMode: function() {
        return "indicate" === this.option("dropFeedbackMode") || this.option("allowDropInsideItem");
      },
      _createPlaceholder: function() {
        var $placeholderContainer;
        if (this._isIndicateMode()) {
          $placeholderContainer = renderer_default("<div>").addClass(this._addWidgetPrefix(PLACEHOLDER_CLASS)).insertBefore(this._getSourceDraggable()._$dragElement);
        }
        this._$placeholderElement = $placeholderContainer;
        return $placeholderContainer;
      },
      _getItems: function() {
        var itemsSelector = this._getItemsSelector();
        return this._$content().find(itemsSelector).not("." + this._addWidgetPrefix(PLACEHOLDER_CLASS)).not("." + this._addWidgetPrefix(CLONE_CLASS2)).toArray();
      },
      _allowReordering: function() {
        var sourceDraggable2 = this._getSourceDraggable();
        var targetDraggable2 = this._getTargetDraggable();
        return sourceDraggable2 !== targetDraggable2 || this.option("allowReordering");
      },
      _isValidPoint: function(visibleIndex, draggableVisibleIndex, dropInsideItem) {
        var allowDropInsideItem = this.option("allowDropInsideItem");
        var allowReordering2 = dropInsideItem || this._allowReordering();
        if (!allowReordering2 && (0 !== visibleIndex || !allowDropInsideItem)) {
          return false;
        }
        if (!this._isIndicateMode()) {
          return true;
        }
        return -1 === draggableVisibleIndex || visibleIndex !== draggableVisibleIndex && (dropInsideItem || visibleIndex !== draggableVisibleIndex + 1);
      },
      _getItemPoints: function() {
        var result2 = [];
        var $item;
        var offset2;
        var itemWidth;
        var rtlEnabled = this.option("rtlEnabled");
        var isVertical = this._isVerticalOrientation();
        var itemElements = this._getItems();
        var visibleItemElements = itemElements.filter(isElementVisible);
        var visibleItemCount = visibleItemElements.length;
        var $draggableItem = this._getDraggableElement();
        var draggableVisibleIndex = visibleItemElements.indexOf($draggableItem.get(0));
        if (visibleItemCount) {
          for (var i = 0; i <= visibleItemCount; i++) {
            var needCorrectLeftPosition = !isVertical && rtlEnabled ^ i === visibleItemCount;
            var needCorrectTopPosition = isVertical && i === visibleItemCount;
            if (i < visibleItemCount) {
              $item = renderer_default(visibleItemElements[i]);
              offset2 = $item.offset();
              itemWidth = $item.outerWidth();
            }
            result2.push({
              dropInsideItem: false,
              left: offset2.left + (needCorrectLeftPosition ? itemWidth : 0),
              top: offset2.top + (needCorrectTopPosition ? result2[i - 1].height : 0),
              index: i === visibleItemCount ? itemElements.length : itemElements.indexOf($item.get(0)),
              $item,
              width: $item.outerWidth(),
              height: $item.outerHeight(),
              isValid: this._isValidPoint(i, draggableVisibleIndex)
            });
          }
          if (this.option("allowDropInsideItem")) {
            var points = result2;
            result2 = [];
            for (var _i = 0; _i < points.length; _i++) {
              result2.push(points[_i]);
              if (points[_i + 1]) {
                result2.push(extend2({}, points[_i], {
                  dropInsideItem: true,
                  top: Math.floor((points[_i].top + points[_i + 1].top) / 2),
                  left: Math.floor((points[_i].left + points[_i + 1].left) / 2),
                  isValid: this._isValidPoint(_i, draggableVisibleIndex, true)
                }));
              }
            }
          }
        } else {
          result2.push({
            dropInsideItem: false,
            index: 0,
            isValid: true
          });
        }
        return result2;
      },
      _updateItemPoints: function(forceUpdate2) {
        if (forceUpdate2 || this.option("autoUpdate") || !this.option("itemPoints")) {
          this.option("itemPoints", this._getItemPoints());
        }
      },
      _correctItemPoints: function(scrollBy) {
        var itemPoints = this.option("itemPoints");
        if (scrollBy && itemPoints && !this.option("autoUpdate")) {
          var isVertical = this._isVerticalOrientation();
          var positionPropName = isVertical ? "top" : "left";
          itemPoints.forEach((itemPoint) => {
            itemPoint[positionPropName] -= scrollBy;
          });
        }
      },
      _getElementIndex: function($itemElement) {
        return this._getItems().indexOf($itemElement.get(0));
      },
      _getDragTemplateArgs: function($element) {
        var args = this.callBase.apply(this, arguments);
        args.model.fromIndex = this._getElementIndex($element);
        return args;
      },
      _togglePlaceholder: function(value2) {
        this._$placeholderElement && this._$placeholderElement.toggle(value2);
      },
      _isVerticalOrientation: function() {
        return "vertical" === this.option("itemOrientation");
      },
      _normalizeToIndex: function(toIndex, dropInsideItem) {
        var isAnotherDraggable = this._getSourceDraggable() !== this._getTargetDraggable();
        var fromIndex = this.option("fromIndex");
        if (null === toIndex) {
          return fromIndex;
        }
        return Math.max(isAnotherDraggable || fromIndex >= toIndex || dropInsideItem ? toIndex : toIndex - 1, 0);
      },
      _updatePlaceholderPosition: function(e, itemPoint) {
        var sourceDraggable2 = this._getSourceDraggable();
        var toIndex = this._normalizeToIndex(itemPoint.index, itemPoint.dropInsideItem);
        var eventArgs = extend2(this._getEventArgs(e), {
          toIndex,
          dropInsideItem: itemPoint.dropInsideItem
        });
        itemPoint.isValid && this._getAction("onDragChange")(eventArgs);
        if (eventArgs.cancel || !itemPoint.isValid) {
          if (!itemPoint.isValid) {
            this.option({
              dropInsideItem: false,
              toIndex: null
            });
          }
          return;
        }
        this.option({
          dropInsideItem: itemPoint.dropInsideItem,
          toIndex: itemPoint.index
        });
        this._getAction("onPlaceholderPrepared")(extend2(this._getEventArgs(e), {
          placeholderElement: getPublicElement(this._$placeholderElement),
          dragElement: getPublicElement(sourceDraggable2._$dragElement)
        }));
        this._updateItemPoints();
      },
      _makeWidthCorrection: function($item, width) {
        this._$scrollable = this._getScrollable($item);
        if (this._$scrollable) {
          var scrollableWidth = this._$scrollable.width();
          var overflowLeft = this._$scrollable.offset().left - $item.offset().left;
          var overflowRight = $item.outerWidth() - overflowLeft - scrollableWidth;
          if (overflowLeft > 0) {
            width -= overflowLeft;
          }
          if (overflowRight > 0) {
            width -= overflowRight;
          }
        }
        return width;
      },
      _updatePlaceholderSizes: function($placeholderElement, itemElement) {
        var dropInsideItem = this.option("dropInsideItem");
        var $item = renderer_default(itemElement);
        var isVertical = this._isVerticalOrientation();
        var width = "";
        var height = "";
        $placeholderElement.toggleClass(this._addWidgetPrefix("placeholder-inside"), dropInsideItem);
        if (isVertical || dropInsideItem) {
          width = $item.outerWidth();
        }
        if (!isVertical || dropInsideItem) {
          height = $item.outerHeight();
        }
        width = this._makeWidthCorrection($item, width);
        $placeholderElement.css({
          width,
          height
        });
      },
      _moveItem: function($itemElement, index2, cancelRemove) {
        var $prevTargetItemElement;
        var $itemElements = this._getItems();
        var $targetItemElement = $itemElements[index2];
        var sourceDraggable2 = this._getSourceDraggable();
        if (cancelRemove) {
          $itemElement = $itemElement.clone();
          sourceDraggable2._toggleDragSourceClass(false, $itemElement);
        }
        if (!$targetItemElement) {
          $prevTargetItemElement = $itemElements[index2 - 1];
        }
        this._moveItemCore($itemElement, $targetItemElement, $prevTargetItemElement);
      },
      _moveItemCore: function($targetItem, item, prevItem) {
        if (!item && !prevItem) {
          $targetItem.appendTo(this.$element());
        } else if (prevItem) {
          $targetItem.insertAfter(renderer_default(prevItem));
        } else {
          $targetItem.insertBefore(renderer_default(item));
        }
      },
      _getDragStartArgs: function(e, $itemElement) {
        return extend2(this.callBase.apply(this, arguments), {
          fromIndex: this._getElementIndex($itemElement)
        });
      },
      _getEventArgs: function(e) {
        var sourceDraggable2 = this._getSourceDraggable();
        var targetDraggable2 = this._getTargetDraggable();
        var dropInsideItem = targetDraggable2.option("dropInsideItem");
        return extend2(this.callBase.apply(this, arguments), {
          fromIndex: sourceDraggable2.option("fromIndex"),
          toIndex: this._normalizeToIndex(targetDraggable2.option("toIndex"), dropInsideItem),
          dropInsideItem
        });
      },
      _optionChanged: function(args) {
        var name2 = args.name;
        switch (name2) {
          case "onDragChange":
          case "onPlaceholderPrepared":
          case "onAdd":
          case "onRemove":
          case "onReorder":
            this["_" + name2 + "Action"] = this._createActionByOption(name2);
            break;
          case "itemOrientation":
          case "allowDropInsideItem":
          case "moveItemOnDrop":
          case "dropFeedbackMode":
          case "itemPoints":
          case "animation":
          case "allowReordering":
          case "fromIndexOffset":
          case "offset":
          case "draggableElementSize":
          case "autoUpdate":
            break;
          case "fromIndex":
            [false, true].forEach((isDragSource) => {
              var fromIndex = isDragSource ? args.value : args.previousValue;
              if (null !== fromIndex) {
                var $fromElement = renderer_default(this._getItems()[fromIndex]);
                this._toggleDragSourceClass(isDragSource, $fromElement);
              }
            });
            break;
          case "dropInsideItem":
            this._optionChangedDropInsideItem(args);
            break;
          case "toIndex":
            this._optionChangedToIndex(args);
            break;
          default:
            this.callBase(args);
        }
      },
      _optionChangedDropInsideItem: function() {
        if (this._isIndicateMode() && this._$placeholderElement) {
          this._movePlaceholder();
        }
      },
      _isPositionVisible: function(position3) {
        var $element = this.$element();
        var scrollContainer;
        if ("hidden" !== $element.css("overflow")) {
          scrollContainer = $element.get(0);
        } else {
          $element.parents().each(function() {
            if ("visible" !== renderer_default(this).css("overflow")) {
              scrollContainer = this;
              return false;
            }
          });
        }
        if (scrollContainer) {
          var clientRect = getBoundingRect(scrollContainer);
          var isVerticalOrientation = this._isVerticalOrientation();
          var start = isVerticalOrientation ? "top" : "left";
          var end = isVerticalOrientation ? "bottom" : "right";
          var pageOffset = isVerticalOrientation ? window20.pageYOffset : window20.pageXOffset;
          if (position3[start] < clientRect[start] + pageOffset || position3[start] > clientRect[end] + pageOffset) {
            return false;
          }
        }
        return true;
      },
      _optionChangedToIndex: function(args) {
        var toIndex = args.value;
        if (this._isIndicateMode()) {
          var showPlaceholder = null !== toIndex && toIndex >= 0;
          this._togglePlaceholder(showPlaceholder);
          if (showPlaceholder) {
            this._movePlaceholder();
          }
        } else {
          this._moveItems(args.previousValue, args.value, args.fullUpdate);
        }
      },
      update: function() {
        if (null === this.option("fromIndex") && null === this.option("toIndex")) {
          return;
        }
        this._updateItemPoints(true);
        this._updateDragSourceClass();
        var toIndex = this.option("toIndex");
        this._optionChangedToIndex({
          value: toIndex,
          fullUpdate: true
        });
      },
      _updateDragSourceClass: function() {
        var fromIndex = this._getActualFromIndex();
        var $fromElement = renderer_default(this._getItems()[fromIndex]);
        if ($fromElement.length) {
          this._$sourceElement = $fromElement;
          this._toggleDragSourceClass(true, $fromElement);
        }
      },
      _makeLeftCorrection: function(left) {
        var $scrollable = this._$scrollable;
        if ($scrollable && this._isVerticalOrientation()) {
          var overflowLeft = $scrollable.offset().left - left;
          if (overflowLeft > 0) {
            left += overflowLeft;
          }
        }
        return left;
      },
      _movePlaceholder: function() {
        var $placeholderElement = this._$placeholderElement || this._createPlaceholder();
        if (!$placeholderElement) {
          return;
        }
        var items = this._getItems();
        var toIndex = this.option("toIndex");
        var isVerticalOrientation = this._isVerticalOrientation();
        var rtlEnabled = this.option("rtlEnabled");
        var dropInsideItem = this.option("dropInsideItem");
        var position3 = null;
        var itemElement = items[toIndex];
        if (itemElement) {
          var $itemElement = renderer_default(itemElement);
          position3 = $itemElement.offset();
          if (!isVerticalOrientation && rtlEnabled && !dropInsideItem) {
            position3.left += $itemElement.outerWidth(true);
          }
        } else {
          var prevVisibleItemElement = itemElement = this._getPrevVisibleItem(items, toIndex);
          if (prevVisibleItemElement) {
            position3 = renderer_default(prevVisibleItemElement).offset();
            if (isVerticalOrientation) {
              position3.top += renderer_default(prevVisibleItemElement).outerHeight(true);
            } else if (!rtlEnabled) {
              position3.left += renderer_default(prevVisibleItemElement).outerWidth(true);
            }
          }
        }
        this._updatePlaceholderSizes($placeholderElement, itemElement);
        if (position3 && !this._isPositionVisible(position3)) {
          position3 = null;
        }
        if (position3) {
          position3.left = this._makeLeftCorrection(position3.left);
          this._move(position3, $placeholderElement);
        }
        $placeholderElement.toggle(!!position3);
      },
      _getPositions: function(items, elementSize, fromIndex, toIndex) {
        var positions = [];
        for (var i = 0; i < items.length; i++) {
          var position3 = 0;
          if (null === toIndex || null === fromIndex) {
            positions.push(position3);
            continue;
          }
          if (-1 === fromIndex) {
            if (i >= toIndex) {
              position3 = elementSize;
            }
          } else if (-1 === toIndex) {
            if (i > fromIndex) {
              position3 = -elementSize;
            }
          } else if (fromIndex < toIndex) {
            if (i > fromIndex && i < toIndex) {
              position3 = -elementSize;
            }
          } else if (fromIndex > toIndex) {
            if (i >= toIndex && i < fromIndex) {
              position3 = elementSize;
            }
          }
          positions.push(position3);
        }
        return positions;
      },
      _getDraggableElementSize: function(isVerticalOrientation) {
        var $draggableItem = this._getDraggableElement();
        var size = this.option("draggableElementSize");
        if (!size) {
          size = isVerticalOrientation ? ($draggableItem.outerHeight() + $draggableItem.outerHeight(true)) / 2 : ($draggableItem.outerWidth() + $draggableItem.outerWidth(true)) / 2;
          if (!this.option("autoUpdate")) {
            this.option("draggableElementSize", size);
          }
        }
        return size;
      },
      _getActualFromIndex: function() {
        var {
          fromIndex,
          fromIndexOffset,
          offset: offset2
        } = this.option();
        return null == fromIndex ? null : fromIndex + fromIndexOffset - offset2;
      },
      _moveItems: function(prevToIndex, toIndex, fullUpdate) {
        var fromIndex = this._getActualFromIndex();
        var isVerticalOrientation = this._isVerticalOrientation();
        var positionPropName = isVerticalOrientation ? "top" : "left";
        var elementSize = this._getDraggableElementSize(isVerticalOrientation);
        var items = this._getItems();
        var prevPositions = this._getPositions(items, elementSize, fromIndex, prevToIndex);
        var positions = this._getPositions(items, elementSize, fromIndex, toIndex);
        var animationConfig = this.option("animation");
        var rtlEnabled = this.option("rtlEnabled");
        for (var i = 0; i < items.length; i++) {
          var itemElement = items[i];
          var prevPosition = prevPositions[i];
          var position3 = positions[i];
          if (null === toIndex || null === fromIndex) {
            stopAnimation(itemElement);
          } else if (prevPosition !== position3 || fullUpdate && position3) {
            animate2(itemElement, extend2({}, animationConfig, {
              to: {
                [positionPropName]: !isVerticalOrientation && rtlEnabled ? -position3 : position3
              }
            }));
          }
        }
      },
      _toggleDragSourceClass: function(value2, $element) {
        var $sourceElement = $element || this._$sourceElement;
        this.callBase.apply(this, arguments);
        if (!this._isIndicateMode()) {
          $sourceElement && $sourceElement.toggleClass(this._addWidgetPrefix("source-hidden"), value2);
        }
      },
      _dispose: function() {
        this.reset();
        this.callBase();
      },
      _fireAddEvent: function(sourceEvent) {
        var args = this._getEventArgs(sourceEvent);
        this._getAction("onAdd")(args);
        return args.cancel;
      },
      _fireRemoveEvent: function(sourceEvent) {
        var sourceDraggable2 = this._getSourceDraggable();
        var args = this._getEventArgs(sourceEvent);
        sourceDraggable2._getAction("onRemove")(args);
        return args.cancel;
      },
      _fireReorderEvent: function(sourceEvent) {
        var args = this._getEventArgs(sourceEvent);
        this._getAction("onReorder")(args);
        return args.promise || new Deferred().resolve();
      }
    });
    component_registrator_default(SORTABLE, Sortable);
    sortable_default = Sortable;
  }
});

// node_modules/devextreme/esm/ui/list/ui.list.edit.decorator.reorder.js
var REORDER_HANDLE_CONTAINER_CLASS, REORDER_HANDLE_CLASS, REORDERING_ITEM_GHOST_CLASS, STATE_HOVER_CLASS;
var init_ui_list_edit_decorator_reorder = __esm({
  "node_modules/devextreme/esm/ui/list/ui.list.edit.decorator.reorder.js"() {
    init_renderer();
    init_events_engine();
    init_extend();
    init_utils2();
    init_ui_list_edit_decorator_registry();
    init_ui_list_edit_decorator();
    init_sortable();
    REORDER_HANDLE_CONTAINER_CLASS = "dx-list-reorder-handle-container";
    REORDER_HANDLE_CLASS = "dx-list-reorder-handle";
    REORDERING_ITEM_GHOST_CLASS = "dx-list-item-ghost-reordering";
    STATE_HOVER_CLASS = "dx-state-hover";
    register("reorder", "default", ui_list_edit_decorator_default.inherit({
      _init: function() {
        var list = this._list;
        this._groupedEnabled = this._list.option("grouped");
        this._lockedDrag = false;
        var filter = this._groupedEnabled ? "> .dx-list-group > .dx-list-group-body > .dx-list-item" : "> .dx-list-item";
        this._sortable = list._createComponent(list._scrollView.content(), sortable_default, extend2({
          component: list,
          contentTemplate: null,
          allowReordering: false,
          filter,
          container: list.$element(),
          dragDirection: list.option("itemDragging.group") ? "both" : "vertical",
          handle: ".".concat(REORDER_HANDLE_CLASS),
          dragTemplate: this._dragTemplate,
          onDragStart: this._dragStartHandler.bind(this),
          onDragChange: this._dragChangeHandler.bind(this),
          onReorder: this._reorderHandler.bind(this)
        }, list.option("itemDragging")));
      },
      afterRender: function() {
        this._sortable.update();
      },
      _dragTemplate: function(e) {
        return renderer_default(e.itemElement).clone().width(renderer_default(e.itemElement).width()).addClass(REORDERING_ITEM_GHOST_CLASS).addClass(STATE_HOVER_CLASS);
      },
      _dragStartHandler: function(e) {
        if (this._lockedDrag) {
          e.cancel = true;
          return;
        }
      },
      _dragChangeHandler: function(e) {
        if (this._groupedEnabled && !this._sameParent(e.fromIndex, e.toIndex)) {
          e.cancel = true;
          return;
        }
      },
      _sameParent: function(fromIndex, toIndex) {
        var $dragging = this._list.getItemElementByFlatIndex(fromIndex);
        var $over = this._list.getItemElementByFlatIndex(toIndex);
        return $over.parent().get(0) === $dragging.parent().get(0);
      },
      _reorderHandler: function(e) {
        var $targetElement = this._list.getItemElementByFlatIndex(e.toIndex);
        this._list.reorderItem(renderer_default(e.itemElement), $targetElement);
      },
      afterBag: function(config2) {
        var $handle = renderer_default("<div>").addClass(REORDER_HANDLE_CLASS);
        events_engine_default.on($handle, "dxpointerdown", (e) => {
          this._lockedDrag = !isMouseEvent(e);
        });
        events_engine_default.on($handle, "dxhold", {
          timeout: 30
        }, (e) => {
          e.cancel = true;
          this._lockedDrag = false;
        });
        config2.$container.addClass(REORDER_HANDLE_CONTAINER_CLASS).append($handle);
      }
    }));
  }
});

// node_modules/devextreme/esm/ui/list/ui.list.edit.provider.js
var editOptionsRegistry, registerOption, LIST_ITEM_BEFORE_BAG_CLASS, LIST_ITEM_AFTER_BAG_CLASS, DECORATOR_BEFORE_BAG_CREATE_METHOD, DECORATOR_AFTER_BAG_CREATE_METHOD, DECORATOR_MODIFY_ELEMENT_METHOD, DECORATOR_AFTER_RENDER_METHOD, DECORATOR_GET_EXCLUDED_SELECTORS_METHOD, EditProvider, ui_list_edit_provider_default;
var init_ui_list_edit_provider = __esm({
  "node_modules/devextreme/esm/ui/list/ui.list.edit.provider.js"() {
    init_renderer();
    init_common();
    init_class();
    init_extend();
    init_iterator();
    init_ui_errors();
    init_ui_list_edit_decorator_registry();
    init_ui_list_edit_decorator_static();
    init_ui_list_edit_decorator_switchable_button();
    init_ui_list_edit_decorator_switchable_slide();
    init_ui_list_edit_decorator_swipe();
    init_ui_list_edit_decorator_context();
    init_ui_list_edit_decorator_selection();
    init_ui_list_edit_decorator_reorder();
    editOptionsRegistry = [];
    registerOption = function(enabledFunc, decoratorTypeFunc, decoratorSubTypeFunc) {
      editOptionsRegistry.push({
        enabled: enabledFunc,
        decoratorType: decoratorTypeFunc,
        decoratorSubType: decoratorSubTypeFunc
      });
    };
    registerOption(function() {
      return this.option("menuItems").length;
    }, function() {
      return "menu";
    }, function() {
      return this.option("menuMode");
    });
    registerOption(function() {
      return !this.option("menuItems").length && this.option("allowItemDeleting");
    }, function() {
      var mode = this.option("itemDeleteMode");
      return "toggle" === mode || "slideButton" === mode || "swipe" === mode || "static" === mode ? "delete" : "menu";
    }, function() {
      var mode = this.option("itemDeleteMode");
      if ("slideItem" === mode) {
        mode = "slide";
      }
      if ("hold" === mode) {
        mode = "context";
      }
      return mode;
    });
    registerOption(function() {
      return "none" !== this.option("selectionMode") && this.option("showSelectionControls");
    }, function() {
      return "selection";
    }, function() {
      return "default";
    });
    registerOption(function() {
      return this.option("itemDragging.allowReordering") || this.option("itemDragging.allowDropInsideItem") || this.option("itemDragging.group");
    }, function() {
      return "reorder";
    }, function() {
      return "default";
    });
    LIST_ITEM_BEFORE_BAG_CLASS = "dx-list-item-before-bag";
    LIST_ITEM_AFTER_BAG_CLASS = "dx-list-item-after-bag";
    DECORATOR_BEFORE_BAG_CREATE_METHOD = "beforeBag";
    DECORATOR_AFTER_BAG_CREATE_METHOD = "afterBag";
    DECORATOR_MODIFY_ELEMENT_METHOD = "modifyElement";
    DECORATOR_AFTER_RENDER_METHOD = "afterRender";
    DECORATOR_GET_EXCLUDED_SELECTORS_METHOD = "getExcludedSelectors";
    EditProvider = class_default.inherit({
      ctor: function(list) {
        this._list = list;
        this._fetchRequiredDecorators();
      },
      dispose: function() {
        if (this._decorators && this._decorators.length) {
          each(this._decorators, function(_2, decorator) {
            decorator.dispose();
          });
        }
      },
      _fetchRequiredDecorators: function() {
        this._decorators = [];
        each(editOptionsRegistry, (function(_2, option) {
          var optionEnabled = option.enabled.call(this._list);
          if (optionEnabled) {
            var decoratorType = option.decoratorType.call(this._list);
            var decoratorSubType = option.decoratorSubType.call(this._list);
            var decorator = this._createDecorator(decoratorType, decoratorSubType);
            this._decorators.push(decorator);
          }
        }).bind(this));
      },
      _createDecorator: function(type2, subType) {
        var decoratorClass = this._findDecorator(type2, subType);
        return new decoratorClass(this._list);
      },
      _findDecorator: function(type2, subType) {
        var foundDecorator = registry[type2][subType];
        if (!foundDecorator) {
          throw ui_errors_default.Error("E1012", type2, subType);
        }
        return foundDecorator;
      },
      modifyItemElement: function(args) {
        var $itemElement = renderer_default(args.itemElement);
        var config2 = {
          $itemElement
        };
        this._prependBeforeBags($itemElement, config2);
        this._appendAfterBags($itemElement, config2);
        this._applyDecorators(DECORATOR_MODIFY_ELEMENT_METHOD, config2);
      },
      afterItemsRendered: function() {
        this._applyDecorators(DECORATOR_AFTER_RENDER_METHOD);
      },
      _prependBeforeBags: function($itemElement, config2) {
        var $beforeBags = this._collectDecoratorsMarkup(DECORATOR_BEFORE_BAG_CREATE_METHOD, config2, LIST_ITEM_BEFORE_BAG_CLASS);
        $itemElement.prepend($beforeBags);
      },
      _appendAfterBags: function($itemElement, config2) {
        var $afterBags = this._collectDecoratorsMarkup(DECORATOR_AFTER_BAG_CREATE_METHOD, config2, LIST_ITEM_AFTER_BAG_CLASS);
        $itemElement.append($afterBags);
      },
      _collectDecoratorsMarkup: function(method, config2, containerClass) {
        var $collector = renderer_default("<div>");
        each(this._decorators, function() {
          var $container = renderer_default("<div>").addClass(containerClass);
          this[method](extend2({
            $container
          }, config2));
          if ($container.children().length) {
            $collector.append($container);
          }
        });
        return $collector.children();
      },
      _applyDecorators: function(method, config2) {
        each(this._decorators, function() {
          this[method](config2);
        });
      },
      _handlerExists: function(name2) {
        if (!this._decorators) {
          return false;
        }
        var decorators = this._decorators;
        var length = decorators.length;
        for (var i = 0; i < length; i++) {
          if (decorators[i][name2] !== noop2) {
            return true;
          }
        }
        return false;
      },
      _eventHandler: function(name2, $itemElement, e) {
        if (!this._decorators) {
          return false;
        }
        var response = false;
        var decorators = this._decorators;
        var length = decorators.length;
        for (var i = 0; i < length; i++) {
          response = decorators[i][name2]($itemElement, e);
          if (response) {
            break;
          }
        }
        return response;
      },
      handleClick: function($itemElement, e) {
        return this._eventHandler("handleClick", $itemElement, e);
      },
      handleKeyboardEvents: function(currentFocusedIndex, moveFocusUp) {
        return this._eventHandler("handleKeyboardEvents", currentFocusedIndex, moveFocusUp);
      },
      handleEnterPressing: function(e) {
        return this._eventHandler("handleEnterPressing", e);
      },
      contextMenuHandlerExists: function() {
        return this._handlerExists("handleContextMenu");
      },
      handleContextMenu: function($itemElement, e) {
        return this._eventHandler("handleContextMenu", $itemElement, e);
      },
      getExcludedItemSelectors: function() {
        var excludedSelectors = [];
        this._applyDecorators(DECORATOR_GET_EXCLUDED_SELECTORS_METHOD, excludedSelectors);
        return excludedSelectors.join(",");
      }
    });
    ui_list_edit_provider_default = EditProvider;
  }
});

// node_modules/devextreme/esm/ui/list/ui.list.edit.js
var LIST_ITEM_SELECTED_CLASS, LIST_ITEM_RESPONSE_WAIT_CLASS, ListEdit, ui_list_edit_default;
var init_ui_list_edit = __esm({
  "node_modules/devextreme/esm/ui/list/ui.list.edit.js"() {
    init_renderer();
    init_utils2();
    init_extend();
    init_ui_list_edit_strategy_grouped();
    init_message();
    init_ui_list_edit_provider();
    init_ui_list_base();
    LIST_ITEM_SELECTED_CLASS = "dx-list-item-selected";
    LIST_ITEM_RESPONSE_WAIT_CLASS = "dx-list-item-response-wait";
    ListEdit = ListBase.inherit({
      _supportedKeys() {
        var that = this;
        var parent = this.callBase();
        var moveFocusedItem = (e, moveUp) => {
          var editStrategy = this._editStrategy;
          var focusedElement = this.option("focusedElement");
          var focusedItemIndex = editStrategy.getNormalizedIndex(focusedElement);
          var isLastIndexFocused = focusedItemIndex === this._getLastItemIndex();
          if (isLastIndexFocused && this._isDataSourceLoading()) {
            return;
          }
          if (e.shiftKey && that.option("itemDragging.allowReordering")) {
            var nextItemIndex = focusedItemIndex + (moveUp ? -1 : 1);
            var $nextItem = editStrategy.getItemElement(nextItemIndex);
            this.reorderItem(focusedElement, $nextItem);
            this.scrollToItem(focusedElement);
            e.preventDefault();
          } else {
            var editProvider = this._editProvider;
            var isInternalMoving = editProvider.handleKeyboardEvents(focusedItemIndex, moveUp);
            if (!isInternalMoving) {
              moveUp ? parent.upArrow(e) : parent.downArrow(e);
            }
          }
        };
        return extend2({}, parent, {
          del: (e) => {
            if (that.option("allowItemDeleting")) {
              e.preventDefault();
              that.deleteItem(that.option("focusedElement"));
            }
          },
          upArrow: (e) => moveFocusedItem(e, true),
          downArrow: (e) => moveFocusedItem(e),
          enter: function(e) {
            if (!this._editProvider.handleEnterPressing(e)) {
              parent.enter.apply(this, arguments);
            }
          },
          space: function(e) {
            if (!this._editProvider.handleEnterPressing(e)) {
              parent.space.apply(this, arguments);
            }
          }
        });
      },
      _updateSelection() {
        this._editProvider.afterItemsRendered();
        this.callBase();
      },
      _getLastItemIndex() {
        return this._itemElements().length - 1;
      },
      _refreshItemElements() {
        this.callBase();
        var excludedSelectors = this._editProvider.getExcludedItemSelectors();
        if (excludedSelectors.length) {
          this._itemElementsCache = this._itemElementsCache.not(excludedSelectors);
        }
      },
      _isItemStrictEquals: function(item1, item2) {
        var privateKey = item1 && item1.__dx_key__;
        if (privateKey && !this.key() && this._selection.isItemSelected(privateKey)) {
          return false;
        }
        return this.callBase(item1, item2);
      },
      _getDefaultOptions() {
        return extend2(this.callBase(), {
          showSelectionControls: false,
          selectionMode: "none",
          selectAllMode: "page",
          onSelectAllValueChanged: null,
          selectAllText: message_default.format("dxList-selectAll"),
          menuItems: [],
          menuMode: "context",
          allowItemDeleting: false,
          itemDeleteMode: "static",
          itemDragging: {}
        });
      },
      _defaultOptionsRules() {
        return this.callBase().concat([{
          device: (_device) => "ios" === _device.platform,
          options: {
            menuMode: "slide",
            itemDeleteMode: "slideItem"
          }
        }, {
          device: {
            platform: "android"
          },
          options: {
            itemDeleteMode: "swipe"
          }
        }]);
      },
      _init() {
        this.callBase();
        this._initEditProvider();
      },
      _initDataSource() {
        this.callBase();
        if (!this._isPageSelectAll()) {
          this._dataSource && this._dataSource.requireTotalCount(true);
        }
      },
      _isPageSelectAll() {
        return "page" === this.option("selectAllMode");
      },
      _initEditProvider() {
        this._editProvider = new ui_list_edit_provider_default(this);
      },
      _disposeEditProvider() {
        if (this._editProvider) {
          this._editProvider.dispose();
        }
      },
      _refreshEditProvider() {
        this._disposeEditProvider();
        this._initEditProvider();
      },
      _initEditStrategy() {
        if (this.option("grouped")) {
          this._editStrategy = new ui_list_edit_strategy_grouped_default(this);
        } else {
          this.callBase();
        }
      },
      _initMarkup() {
        this._refreshEditProvider();
        this.callBase();
      },
      _renderItems() {
        this.callBase(...arguments);
        this._editProvider.afterItemsRendered();
      },
      _selectedItemClass: () => LIST_ITEM_SELECTED_CLASS,
      _itemResponseWaitClass: () => LIST_ITEM_RESPONSE_WAIT_CLASS,
      _itemClickHandler(e) {
        var $itemElement = renderer_default(e.currentTarget);
        if ($itemElement.is(".dx-state-disabled, .dx-state-disabled *")) {
          return;
        }
        var handledByEditProvider = this._editProvider.handleClick($itemElement, e);
        if (handledByEditProvider) {
          return;
        }
        this._saveSelectionChangeEvent(e);
        this.callBase(...arguments);
      },
      _shouldFireContextMenuEvent() {
        return this.callBase(...arguments) || this._editProvider.contextMenuHandlerExists();
      },
      _itemHoldHandler(e) {
        var $itemElement = renderer_default(e.currentTarget);
        if ($itemElement.is(".dx-state-disabled, .dx-state-disabled *")) {
          return;
        }
        var handledByEditProvider = isTouchEvent(e) && this._editProvider.handleContextMenu($itemElement, e);
        if (handledByEditProvider) {
          e.handledByEditProvider = true;
          return;
        }
        this.callBase(...arguments);
      },
      _getItemContainer: function(changeData) {
        if (this.option("grouped")) {
          var _this$_editStrategy$g;
          var groupIndex = null === (_this$_editStrategy$g = this._editStrategy.getIndexByItemData(changeData)) || void 0 === _this$_editStrategy$g ? void 0 : _this$_editStrategy$g.group;
          return this._getGroupContainerByIndex(groupIndex);
        } else {
          return this.callBase(changeData);
        }
      },
      _itemContextMenuHandler(e) {
        var $itemElement = renderer_default(e.currentTarget);
        if ($itemElement.is(".dx-state-disabled, .dx-state-disabled *")) {
          return;
        }
        var handledByEditProvider = !e.handledByEditProvider && this._editProvider.handleContextMenu($itemElement, e);
        if (handledByEditProvider) {
          e.preventDefault();
          return;
        }
        this.callBase(...arguments);
      },
      _postprocessRenderItem(args) {
        this.callBase(...arguments);
        this._editProvider.modifyItemElement(args);
      },
      _clean() {
        this._disposeEditProvider();
        this.callBase();
      },
      focusListItem(index2) {
        var $item = this._editStrategy.getItemElement(index2);
        this.option("focusedElement", $item);
        this.focus();
        this.scrollToItem(this.option("focusedElement"));
      },
      _optionChanged(args) {
        switch (args.name) {
          case "selectAllMode":
            this._initDataSource();
            this._dataSource.pageIndex(0);
            this._dataSource.load();
            break;
          case "grouped":
            this._clearSelectedItems();
            delete this._renderingGroupIndex;
            this._initEditStrategy();
            this.callBase(args);
            break;
          case "showSelectionControls":
          case "menuItems":
          case "menuMode":
          case "allowItemDeleting":
          case "itemDeleteMode":
          case "itemDragging":
          case "selectAllText":
            this._invalidate();
            break;
          case "onSelectAllValueChanged":
            break;
          default:
            this.callBase(args);
        }
      },
      selectAll() {
        return this._selection.selectAll(this._isPageSelectAll());
      },
      unselectAll() {
        return this._selection.deselectAll(this._isPageSelectAll());
      },
      isSelectAll() {
        return this._selection.getSelectAllState(this._isPageSelectAll());
      },
      getFlatIndexByItemElement(itemElement) {
        return this._itemElements().index(itemElement);
      },
      getItemElementByFlatIndex(flatIndex) {
        var $itemElements = this._itemElements();
        if (flatIndex < 0 || flatIndex >= $itemElements.length) {
          return renderer_default();
        }
        return $itemElements.eq(flatIndex);
      },
      getItemByIndex(index2) {
        return this._editStrategy.getItemDataByIndex(index2);
      }
    });
    ui_list_edit_default = ListEdit;
  }
});

// node_modules/devextreme/esm/ui/list/ui.list.edit.search.js
var ListSearch, ui_list_edit_search_default;
var init_ui_list_edit_search = __esm({
  "node_modules/devextreme/esm/ui/list/ui.list.edit.search.js"() {
    init_ui_list_edit();
    init_ui_search_box_mixin();
    ListSearch = ui_list_edit_default.inherit(ui_search_box_mixin_default).inherit({
      _addWidgetPrefix: function(className) {
        return "dx-list-" + className;
      },
      _getCombinedFilter: function() {
        var filter;
        var storeLoadOptions;
        var dataSource = this._dataSource;
        if (dataSource) {
          storeLoadOptions = {
            filter: dataSource.filter()
          };
          dataSource._addSearchFilter(storeLoadOptions);
          filter = storeLoadOptions.filter;
        }
        return filter;
      },
      _initDataSource: function() {
        var value2 = this.option("searchValue");
        var expr = this.option("searchExpr");
        var mode = this.option("searchMode");
        this.callBase();
        if (this._dataSource) {
          value2 && value2.length && this._dataSource.searchValue(value2);
          mode.length && this._dataSource.searchOperation(ui_search_box_mixin_default.getOperationBySearchMode(mode));
          expr && this._dataSource.searchExpr(expr);
        }
      }
    });
    ui_list_edit_search_default = ListSearch;
  }
});

// node_modules/devextreme/esm/ui/list.js
var list_default;
var init_list = __esm({
  "node_modules/devextreme/esm/ui/list.js"() {
    init_ui_list_edit_search();
    init_component_registrator();
    component_registrator_default("dxList", ui_list_edit_search_default);
    list_default = ui_list_edit_search_default;
  }
});

// node_modules/devextreme/esm/ui/grid_core/ui.grid_core.state_storing_core.js
var DATE_REGEX, parseDates, StateStoringController;
var init_ui_grid_core_state_storing_core = __esm({
  "node_modules/devextreme/esm/ui/grid_core/ui.grid_core.state_storing_core.js"() {
    init_events_engine();
    init_window();
    init_ui_grid_core_modules();
    init_ui_errors();
    init_browser();
    init_storage();
    init_extend();
    init_iterator();
    init_type();
    init_deferred();
    DATE_REGEX = /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/;
    parseDates = function parseDates2(state) {
      if (!state) {
        return;
      }
      each(state, function(key, value2) {
        if (isPlainObject(value2) || Array.isArray(value2)) {
          parseDates2(value2);
        } else if ("string" === typeof value2) {
          var date = DATE_REGEX.exec(value2);
          if (date) {
            state[key] = new Date(Date.UTC(+date[1], +date[2] - 1, +date[3], +date[4], +date[5], +date[6]));
          }
        }
      });
    };
    StateStoringController = ui_grid_core_modules_default.ViewController.inherit(/* @__PURE__ */ function() {
      var getStorage = function(options2) {
        var storage = "sessionStorage" === options2.type ? getSessionStorage() : getWindow().localStorage;
        if (!storage) {
          if ("file:" === getWindow().location.protocol && browser_default.msie) {
            throw new Error("E1038");
          } else {
            throw new Error("E1007");
          }
        }
        return storage;
      };
      var getUniqueStorageKey = function(options2) {
        return isDefined(options2.storageKey) ? options2.storageKey : "storage";
      };
      return {
        _loadState: function() {
          var options2 = this.option("stateStoring");
          if ("custom" === options2.type) {
            return options2.customLoad && options2.customLoad();
          }
          try {
            return JSON.parse(getStorage(options2).getItem(getUniqueStorageKey(options2)));
          } catch (e) {
            ui_errors_default.log(e.message);
          }
        },
        _saveState: function(state) {
          var options2 = this.option("stateStoring");
          if ("custom" === options2.type) {
            options2.customSave && options2.customSave(state);
            return;
          }
          try {
            getStorage(options2).setItem(getUniqueStorageKey(options2), JSON.stringify(state));
          } catch (e) {
            ui_errors_default.log(e.message);
          }
        },
        publicMethods: function() {
          return ["state"];
        },
        isEnabled: function() {
          return this.option("stateStoring.enabled");
        },
        init: function() {
          var that = this;
          that._state = {};
          that._isLoaded = false;
          that._isLoading = false;
          that._windowUnloadHandler = function() {
            if (void 0 !== that._savingTimeoutID) {
              that._saveState(that.state());
            }
          };
          events_engine_default.on(getWindow(), "unload", that._windowUnloadHandler);
          return that;
        },
        isLoaded: function() {
          return this._isLoaded;
        },
        isLoading: function() {
          return this._isLoading;
        },
        load: function() {
          this._isLoading = true;
          var loadResult = fromPromise(this._loadState());
          loadResult.always(() => {
            this._isLoaded = true;
            this._isLoading = false;
          }).done((state) => {
            if (null !== state && !isEmptyObject(state)) {
              this.state(state);
            }
          });
          return loadResult;
        },
        state: function(_state) {
          var that = this;
          if (!arguments.length) {
            return extend2(true, {}, that._state);
          } else {
            that._state = extend2({}, _state);
            parseDates(that._state);
          }
        },
        save: function() {
          var that = this;
          clearTimeout(that._savingTimeoutID);
          that._savingTimeoutID = setTimeout(function() {
            that._saveState(that.state());
            that._savingTimeoutID = void 0;
          }, that.option("stateStoring.savingTimeout"));
        },
        optionChanged: function(args) {
          switch (args.name) {
            case "stateStoring":
              if (this.isEnabled() && !this.isLoading()) {
                this.load();
              }
              args.handled = true;
              break;
            default:
              this.callBase(args);
          }
        },
        dispose: function() {
          clearTimeout(this._savingTimeoutID);
          events_engine_default.off(getWindow(), "unload", this._windowUnloadHandler);
        }
      };
    }());
  }
});

// node_modules/devextreme/esm/ui/grid_core/ui.grid_core.state_storing.js
var getDataState, processLoadState, DEFAULT_FILTER_VALUE, getFilterValue, stateStoringModule;
var init_ui_grid_core_state_storing = __esm({
  "node_modules/devextreme/esm/ui/grid_core/ui.grid_core.state_storing.js"() {
    init_common();
    init_type();
    init_extend();
    init_ui_grid_core_state_storing_core();
    init_deferred();
    getDataState = (that) => {
      var pagerView = that.getView("pagerView");
      var dataController = that.getController("data");
      var state = {
        allowedPageSizes: pagerView ? pagerView.getPageSizes() : void 0,
        filterPanel: {
          filterEnabled: that.option("filterPanel.filterEnabled")
        },
        filterValue: that.option("filterValue"),
        focusedRowKey: that.option("focusedRowEnabled") ? that.option("focusedRowKey") : void 0
      };
      return extend2(state, dataController.getUserState());
    };
    processLoadState = (that) => {
      var columnsController = that.getController("columns");
      var selectionController = that.getController("selection");
      var exportController = that.getController("export");
      var dataController = that.getController("data");
      if (columnsController) {
        columnsController.columnsChanged.add(function() {
          that.updateState({
            columns: columnsController.getUserState()
          });
        });
      }
      if (selectionController) {
        selectionController.selectionChanged.add(function(e) {
          that.updateState({
            selectedRowKeys: e.selectedRowKeys,
            selectionFilter: e.selectionFilter
          });
        });
      }
      if (dataController) {
        that._initialPageSize = that.option("paging.pageSize");
        that._initialFilterValue = that.option("filterValue");
        dataController.changed.add(function() {
          var state = getDataState(that);
          that.updateState(state);
        });
      }
      if (exportController) {
        exportController.selectionOnlyChanged.add(function() {
          that.updateState({
            exportSelectionOnly: exportController.selectionOnly()
          });
        });
      }
    };
    DEFAULT_FILTER_VALUE = null;
    getFilterValue = (that, state) => {
      var filterSyncController = that.getController("filterSync");
      var columnsController = that.getController("columns");
      var hasFilterState = state.columns || void 0 !== state.filterValue;
      if (filterSyncController) {
        if (hasFilterState) {
          return state.filterValue || filterSyncController.getFilterValueFromColumns(state.columns);
        } else {
          return that._initialFilterValue || filterSyncController.getFilterValueFromColumns(columnsController.getColumns());
        }
      }
      return DEFAULT_FILTER_VALUE;
    };
    stateStoringModule = {
      defaultOptions: function() {
        return {
          stateStoring: {
            enabled: false,
            storageKey: null,
            type: "localStorage",
            customLoad: null,
            customSave: null,
            savingTimeout: 2e3
          }
        };
      },
      controllers: {
        stateStoring: StateStoringController
      },
      extenders: {
        views: {
          rowsView: {
            init: function() {
              var that = this;
              var dataController = that.getController("data");
              that.callBase();
              dataController.stateLoaded.add(function() {
                if (dataController.isLoaded() && !dataController.getDataSource()) {
                  that.setLoading(false);
                  that.renderNoDataText();
                  var columnHeadersView = that.component.getView("columnHeadersView");
                  columnHeadersView && columnHeadersView.render();
                  that.component._fireContentReadyAction();
                }
              });
            }
          }
        },
        controllers: {
          stateStoring: {
            init: function() {
              this.callBase.apply(this, arguments);
              processLoadState(this);
            },
            isLoading: function() {
              return this.callBase() || this.getController("data").isStateLoading();
            },
            state: function(_state) {
              var result2 = this.callBase.apply(this, arguments);
              if (void 0 !== _state) {
                this.applyState(extend2({}, _state));
              }
              return result2;
            },
            updateState: function(state) {
              if (this.isEnabled()) {
                var oldState = this.state();
                var newState = extend2({}, oldState, state);
                var oldStateHash = getKeyHash(oldState);
                var newStateHash = getKeyHash(newState);
                if (!equalByValue(oldStateHash, newStateHash)) {
                  extend2(this._state, state);
                  this.save();
                }
              } else {
                extend2(this._state, state);
              }
            },
            applyState: function(state) {
              var allowedPageSizes = state.allowedPageSizes;
              var searchText = state.searchText;
              var selectedRowKeys = state.selectedRowKeys;
              var selectionFilter = state.selectionFilter;
              var exportController = this.getController("export");
              var columnsController = this.getController("columns");
              var dataController = this.getController("data");
              var scrollingMode = this.option("scrolling.mode");
              var isVirtualScrollingMode = "virtual" === scrollingMode || "infinite" === scrollingMode;
              var showPageSizeSelector = true === this.option("pager.visible") && this.option("pager.showPageSizeSelector");
              this.component.beginUpdate();
              if (columnsController) {
                columnsController.setUserState(state.columns);
              }
              if (exportController) {
                exportController.selectionOnly(state.exportSelectionOnly);
              }
              if (!this.option("selection.deferred")) {
                this.option("selectedRowKeys", selectedRowKeys || []);
              }
              this.option("selectionFilter", selectionFilter);
              if (allowedPageSizes && "auto" === this.option("pager.allowedPageSizes")) {
                this.option("pager").allowedPageSizes = allowedPageSizes;
              }
              if (this.option("focusedRowEnabled")) {
                this.option("focusedRowIndex", -1);
                this.option("focusedRowKey", state.focusedRowKey || null);
              }
              this.component.endUpdate();
              this.option("searchPanel.text", searchText || "");
              this.option("filterValue", getFilterValue(this, state));
              this.option("filterPanel.filterEnabled", state.filterPanel ? state.filterPanel.filterEnabled : true);
              this.option("paging.pageSize", (!isVirtualScrollingMode || showPageSizeSelector) && isDefined(state.pageSize) ? state.pageSize : this._initialPageSize);
              this.option("paging.pageIndex", state.pageIndex || 0);
              dataController && dataController.reset();
            }
          },
          columns: {
            getVisibleColumns: function() {
              var visibleColumns = this.callBase.apply(this, arguments);
              var stateStoringController = this.getController("stateStoring");
              return stateStoringController.isEnabled() && !stateStoringController.isLoaded() ? [] : visibleColumns;
            }
          },
          data: {
            callbackNames: function() {
              return this.callBase().concat(["stateLoaded"]);
            },
            _refreshDataSource: function() {
              var callBase = this.callBase;
              var stateStoringController = this.getController("stateStoring");
              if (stateStoringController.isEnabled() && !stateStoringController.isLoaded()) {
                clearTimeout(this._restoreStateTimeoutID);
                var deferred = new Deferred();
                this._restoreStateTimeoutID = setTimeout(() => {
                  stateStoringController.load().always(() => {
                    this._restoreStateTimeoutID = null;
                  }).done(() => {
                    callBase.call(this);
                    this.stateLoaded.fire();
                    deferred.resolve();
                  }).fail((error) => {
                    this.stateLoaded.fire();
                    this._handleLoadError(error || "Unknown error");
                    deferred.reject();
                  });
                });
                return deferred.promise();
              } else if (!this.isStateLoading()) {
                callBase.call(this);
              }
            },
            isLoading: function() {
              var stateStoringController = this.getController("stateStoring");
              return this.callBase() || stateStoringController.isLoading();
            },
            isStateLoading: function() {
              return isDefined(this._restoreStateTimeoutID);
            },
            isLoaded: function() {
              return this.callBase() && !this.isStateLoading();
            },
            dispose: function() {
              clearTimeout(this._restoreStateTimeoutID);
              this.callBase();
            }
          },
          selection: {
            _fireSelectionChanged: function(options2) {
              var stateStoringController = this.getController("stateStoring");
              var isDeferredSelection = this.option("selection.deferred");
              if (stateStoringController.isLoading() && isDeferredSelection) {
                return;
              }
              this.callBase.apply(this, arguments);
            }
          }
        }
      }
    };
  }
});

// node_modules/devextreme/esm/ui/grid_core/ui.grid_core.selection.js
var EDITOR_CELL_CLASS, ROW_CLASS2, ROW_SELECTION_CLASS, SELECT_CHECKBOX_CLASS2, CHECKBOXES_HIDDEN_CLASS, COMMAND_SELECT_CLASS, SELECTION_DISABLED_CLASS, DATA_ROW_CLASS, SHOW_CHECKBOXES_MODE, SELECTION_MODE, processLongTap, SelectionController, selectionModule;
var init_ui_grid_core_selection = __esm({
  "node_modules/devextreme/esm/ui/grid_core/ui.grid_core.selection.js"() {
    init_renderer();
    init_events_engine();
    init_ui_data_grid_core();
    init_ui_grid_core_utils();
    init_type();
    init_iterator();
    init_extend();
    init_support();
    init_click();
    init_message();
    init_utils2();
    init_hold();
    init_selection();
    init_deferred();
    init_ui_errors();
    EDITOR_CELL_CLASS = "dx-editor-cell";
    ROW_CLASS2 = "dx-row";
    ROW_SELECTION_CLASS = "dx-selection";
    SELECT_CHECKBOX_CLASS2 = "dx-select-checkbox";
    CHECKBOXES_HIDDEN_CLASS = "dx-select-checkboxes-hidden";
    COMMAND_SELECT_CLASS = "dx-command-select";
    SELECTION_DISABLED_CLASS = "dx-selection-disabled";
    DATA_ROW_CLASS = "dx-data-row";
    SHOW_CHECKBOXES_MODE = "selection.showCheckBoxesMode";
    SELECTION_MODE = "selection.mode";
    processLongTap = function(that, dxEvent) {
      var selectionController = that.getController("selection");
      var rowsView = that.getView("rowsView");
      var $row = renderer_default(dxEvent.target).closest("." + DATA_ROW_CLASS);
      var rowIndex = rowsView.getRowIndex($row);
      if (rowIndex < 0) {
        return;
      }
      if ("onLongTap" === that.option(SHOW_CHECKBOXES_MODE)) {
        if (selectionController.isSelectionWithCheckboxes()) {
          selectionController.stopSelectionWithCheckboxes();
        } else {
          selectionController.startSelectionWithCheckboxes();
        }
      } else {
        if ("onClick" === that.option(SHOW_CHECKBOXES_MODE)) {
          selectionController.startSelectionWithCheckboxes();
        }
        if ("always" !== that.option(SHOW_CHECKBOXES_MODE)) {
          selectionController.changeItemSelection(rowIndex, {
            control: true
          });
        }
      }
    };
    SelectionController = ui_data_grid_core_default.Controller.inherit(/* @__PURE__ */ function() {
      var selectionCellTemplate = (container, options2) => {
        var component = options2.component;
        var rowsView = component.getView("rowsView");
        if (component.option("renderAsync") && !component.option("selection.deferred")) {
          options2.value = component.isRowSelected(options2.row.key);
        }
        rowsView.renderSelectCheckBoxContainer(renderer_default(container), options2);
      };
      var selectionHeaderTemplate = (container, options2) => {
        var column = options2.column;
        var $cellElement = renderer_default(container);
        var columnHeadersView = options2.component.getView("columnHeadersView");
        $cellElement.addClass(EDITOR_CELL_CLASS);
        columnHeadersView._renderSelectAllCheckBox($cellElement, column);
        columnHeadersView._attachSelectAllCheckBoxClickEvent($cellElement);
      };
      return {
        init: function() {
          var {
            deferred,
            selectAllMode,
            mode
          } = this.option("selection") || {};
          if ("infinite" === this.option("scrolling.mode") && !deferred && "multiple" === mode && "allPages" === selectAllMode) {
            ui_errors_default.log("W1018");
          }
          this._dataController = this.getController("data");
          this._selectionMode = mode;
          this._isSelectionWithCheckboxes = false;
          this._selection = this._createSelection();
          this._updateSelectColumn();
          this.createAction("onSelectionChanged", {
            excludeValidators: ["disabled", "readOnly"]
          });
          this._dataController && this._dataController.pushed.add(this._handleDataPushed.bind(this));
        },
        _handleDataPushed: function(changes) {
          var removedKeys = changes.filter((change) => "remove" === change.type).map((change) => change.key);
          removedKeys.length && this.deselectRows(removedKeys);
        },
        _getSelectionConfig: function() {
          var dataController = this._dataController;
          var selectionOptions = this.option("selection") || {};
          var deferred = selectionOptions.deferred;
          return {
            selectedKeys: this.option("selectedRowKeys"),
            mode: this._selectionMode,
            deferred,
            maxFilterLengthInRequest: selectionOptions.maxFilterLengthInRequest,
            selectionFilter: this.option("selectionFilter"),
            ignoreDisabledItems: true,
            key: function() {
              return null === dataController || void 0 === dataController ? void 0 : dataController.key();
            },
            keyOf: function(item) {
              return null === dataController || void 0 === dataController ? void 0 : dataController.keyOf(item);
            },
            dataFields: function() {
              var _dataController$dataS;
              return null === (_dataController$dataS = dataController.dataSource()) || void 0 === _dataController$dataS ? void 0 : _dataController$dataS.select();
            },
            load: function(options2) {
              var _dataController$dataS2;
              return (null === (_dataController$dataS2 = dataController.dataSource()) || void 0 === _dataController$dataS2 ? void 0 : _dataController$dataS2.load(options2)) || new Deferred().resolve([]);
            },
            plainItems: function() {
              return dataController.items(true);
            },
            isItemSelected: function(item) {
              return item.selected;
            },
            isSelectableItem: function(item) {
              return "data" === (null === item || void 0 === item ? void 0 : item.rowType) && !item.isNewRow;
            },
            getItemData: function(item) {
              return (null === item || void 0 === item ? void 0 : item.oldData) || (null === item || void 0 === item ? void 0 : item.data) || item;
            },
            filter: function() {
              return dataController.getCombinedFilter(deferred);
            },
            totalCount: () => dataController.totalCount(),
            onSelectionChanged: this._updateSelectedItems.bind(this)
          };
        },
        _updateSelectColumn: function() {
          var columnsController = this.getController("columns");
          var isSelectColumnVisible = this.isSelectColumnVisible();
          columnsController.addCommandColumn({
            type: "selection",
            command: "select",
            visible: isSelectColumnVisible,
            visibleIndex: -1,
            dataType: "boolean",
            alignment: "center",
            cssClass: COMMAND_SELECT_CLASS,
            width: "auto",
            cellTemplate: selectionCellTemplate,
            headerCellTemplate: selectionHeaderTemplate
          });
          columnsController.columnOption("command:select", "visible", isSelectColumnVisible);
        },
        _createSelection: function() {
          var options2 = this._getSelectionConfig();
          return new selection_default(options2);
        },
        _fireSelectionChanged: function(options2) {
          var argument = this.option("selection.deferred") ? {
            selectionFilter: this.option("selectionFilter")
          } : {
            selectedRowKeys: this.option("selectedRowKeys")
          };
          this.selectionChanged.fire(argument);
          if (options2) {
            this.executeAction("onSelectionChanged", options2);
          }
        },
        _updateCheckboxesState: function(options2) {
          var isDeferredMode = options2.isDeferredMode;
          var selectionFilter = options2.selectionFilter;
          var selectedItemKeys = options2.selectedItemKeys;
          var removedItemKeys = options2.removedItemKeys;
          if ("onClick" === this.option(SHOW_CHECKBOXES_MODE)) {
            if (isDeferredMode ? selectionFilter && function(that, selectionFilter2) {
              var keyIndex = 0;
              var store = that._dataController.store();
              var key = store && store.key();
              var isComplexKey = Array.isArray(key);
              if (!selectionFilter2.length) {
                return false;
              }
              if (isComplexKey && Array.isArray(selectionFilter2[0]) && "and" === selectionFilter2[1]) {
                for (var i = 0; i < selectionFilter2.length; i++) {
                  if (Array.isArray(selectionFilter2[i])) {
                    if (selectionFilter2[i][0] !== key[keyIndex] || "=" !== selectionFilter2[i][1]) {
                      return true;
                    }
                    keyIndex++;
                  }
                }
                return false;
              }
              return key !== selectionFilter2[0];
            }(this, selectionFilter) : selectedItemKeys.length > 1) {
              this.startSelectionWithCheckboxes();
            } else if (isDeferredMode ? selectionFilter && !selectionFilter.length : 0 === selectedItemKeys.length && removedItemKeys.length) {
              this.stopSelectionWithCheckboxes();
            }
          }
        },
        _updateSelectedItems: function(args) {
          var selectionChangedOptions;
          var isDeferredMode = this.option("selection.deferred");
          var selectionFilter = this._selection.selectionFilter();
          var dataController = this._dataController;
          var items = dataController.items();
          if (!items) {
            return;
          }
          var isSelectionWithCheckboxes = this.isSelectionWithCheckboxes();
          var changedItemIndexes = this.getChangedItemIndexes(items);
          this._updateCheckboxesState({
            selectedItemKeys: args.selectedItemKeys,
            removedItemKeys: args.removedItemKeys,
            selectionFilter,
            isDeferredMode
          });
          if (changedItemIndexes.length || isSelectionWithCheckboxes !== this.isSelectionWithCheckboxes()) {
            dataController.updateItems({
              changeType: "updateSelection",
              itemIndexes: changedItemIndexes
            });
          }
          if (isDeferredMode) {
            this.option("selectionFilter", selectionFilter);
            selectionChangedOptions = {};
          } else if (args.addedItemKeys.length || args.removedItemKeys.length) {
            this._selectedItemsInternalChange = true;
            this.option("selectedRowKeys", args.selectedItemKeys.slice(0));
            this._selectedItemsInternalChange = false;
            selectionChangedOptions = {
              selectedRowsData: args.selectedItems.slice(0),
              selectedRowKeys: args.selectedItemKeys.slice(0),
              currentSelectedRowKeys: args.addedItemKeys.slice(0),
              currentDeselectedRowKeys: args.removedItemKeys.slice(0)
            };
          }
          this._fireSelectionChanged(selectionChangedOptions);
        },
        getChangedItemIndexes: function(items) {
          var itemIndexes = [];
          var isDeferredSelection = this.option("selection.deferred");
          for (var i = 0, length = items.length; i < length; i++) {
            var row = items[i];
            var isItemSelected = this.isRowSelected(isDeferredSelection ? row.data : row.key);
            if (this._selection.isDataItem(row) && row.isSelected !== isItemSelected) {
              itemIndexes.push(i);
            }
          }
          return itemIndexes;
        },
        callbackNames: function() {
          return ["selectionChanged"];
        },
        optionChanged: function(args) {
          this.callBase(args);
          switch (args.name) {
            case "selection":
              var oldSelectionMode = this._selectionMode;
              this.init();
              if ("selection.showCheckBoxesMode" !== args.fullName) {
                var selectionMode = this._selectionMode;
                var selectedRowKeys = this.option("selectedRowKeys");
                if (oldSelectionMode !== selectionMode) {
                  if ("single" === selectionMode) {
                    if (selectedRowKeys.length > 1) {
                      selectedRowKeys = [selectedRowKeys[0]];
                    }
                  } else if ("multiple" !== selectionMode) {
                    selectedRowKeys = [];
                  }
                }
                this.selectRows(selectedRowKeys).always(() => {
                  this._fireSelectionChanged();
                });
              }
              this.getController("columns").updateColumns();
              args.handled = true;
              break;
            case "selectionFilter":
              this._selection.selectionFilter(args.value);
              args.handled = true;
              break;
            case "selectedRowKeys":
              var value2 = args.value || [];
              if (Array.isArray(value2) && !this._selectedItemsInternalChange && (this.component.getDataSource() || !value2.length)) {
                this.selectRows(value2);
              }
              args.handled = true;
          }
        },
        publicMethods: function() {
          return ["selectRows", "deselectRows", "selectRowsByIndexes", "getSelectedRowKeys", "getSelectedRowsData", "clearSelection", "selectAll", "deselectAll", "startSelectionWithCheckboxes", "stopSelectionWithCheckboxes", "isRowSelected"];
        },
        isRowSelected: function(arg) {
          return this._selection.isItemSelected(arg);
        },
        isSelectColumnVisible: function() {
          return "multiple" === this.option(SELECTION_MODE) && ("always" === this.option(SHOW_CHECKBOXES_MODE) || "onClick" === this.option(SHOW_CHECKBOXES_MODE) || this._isSelectionWithCheckboxes);
        },
        _isOnePageSelectAll: function() {
          return "page" === this.option("selection.selectAllMode");
        },
        isSelectAll: function() {
          return this._selection.getSelectAllState(this._isOnePageSelectAll());
        },
        selectAll: function() {
          if ("onClick" === this.option(SHOW_CHECKBOXES_MODE)) {
            this.startSelectionWithCheckboxes();
          }
          return this._selection.selectAll(this._isOnePageSelectAll());
        },
        deselectAll: function() {
          return this._selection.deselectAll(this._isOnePageSelectAll());
        },
        clearSelection: function() {
          return this.selectedItemKeys([]);
        },
        refresh: function() {
          var selectedRowKeys = this.option("selectedRowKeys") || [];
          if (!this.option("selection.deferred") && selectedRowKeys.length) {
            return this.selectedItemKeys(selectedRowKeys);
          }
          return new Deferred().resolve().promise();
        },
        selectedItemKeys: function(value2, preserve, isDeselect, isSelectAll) {
          return this._selection.selectedItemKeys(value2, preserve, isDeselect, isSelectAll);
        },
        getSelectedRowKeys: function() {
          return this._selection.getSelectedItemKeys();
        },
        selectRows: function(keys, preserve) {
          return this.selectedItemKeys(keys, preserve);
        },
        deselectRows: function(keys) {
          return this.selectedItemKeys(keys, true, true);
        },
        selectRowsByIndexes: function(indexes) {
          var items = this._dataController.items();
          var keys = [];
          if (!Array.isArray(indexes)) {
            indexes = Array.prototype.slice.call(arguments, 0);
          }
          each(indexes, function() {
            var item = items[this];
            if (item && "data" === item.rowType) {
              keys.push(item.key);
            }
          });
          return this.selectRows(keys);
        },
        getSelectedRowsData: function() {
          return this._selection.getSelectedItems();
        },
        changeItemSelection: function(itemIndex, keys, setFocusOnly) {
          keys = keys || {};
          if (this.isSelectionWithCheckboxes()) {
            keys.control = true;
          }
          return this._selection.changeItemSelection(this._dataController.getRowIndexDelta() + itemIndex, keys, setFocusOnly);
        },
        focusedItemIndex: function(itemIndex) {
          if (isDefined(itemIndex)) {
            this._selection._focusedItemIndex = itemIndex;
          } else {
            return this._selection._focusedItemIndex;
          }
        },
        isSelectionWithCheckboxes: function() {
          return "multiple" === this.option(SELECTION_MODE) && ("always" === this.option(SHOW_CHECKBOXES_MODE) || this._isSelectionWithCheckboxes);
        },
        startSelectionWithCheckboxes: function() {
          if ("multiple" === this.option(SELECTION_MODE) && !this.isSelectionWithCheckboxes()) {
            this._isSelectionWithCheckboxes = true;
            this._updateSelectColumn();
            return true;
          }
          return false;
        },
        stopSelectionWithCheckboxes: function() {
          if (this._isSelectionWithCheckboxes) {
            this._isSelectionWithCheckboxes = false;
            this._updateSelectColumn();
            return true;
          }
          return false;
        }
      };
    }());
    selectionModule = {
      defaultOptions: function() {
        return {
          selection: {
            mode: "none",
            showCheckBoxesMode: "onClick",
            allowSelectAll: true,
            selectAllMode: "allPages",
            maxFilterLengthInRequest: 1500,
            deferred: false
          },
          selectionFilter: [],
          selectedRowKeys: []
        };
      },
      controllers: {
        selection: SelectionController
      },
      extenders: {
        controllers: {
          data: {
            init: function() {
              var selectionController = this.getController("selection");
              var isDeferredMode = this.option("selection.deferred");
              this.callBase.apply(this, arguments);
              if (isDeferredMode) {
                selectionController._updateCheckboxesState({
                  isDeferredMode: true,
                  selectionFilter: this.option("selectionFilter")
                });
              }
            },
            _loadDataSource: function() {
              var that = this;
              return that.callBase().done(function() {
                that.getController("selection").refresh();
              });
            },
            _processDataItem: function(item, options2) {
              var that = this;
              var selectionController = that.getController("selection");
              var hasSelectColumn = selectionController.isSelectColumnVisible();
              var isDeferredSelection = options2.isDeferredSelection = void 0 === options2.isDeferredSelection ? this.option("selection.deferred") : options2.isDeferredSelection;
              var dataItem = this.callBase.apply(this, arguments);
              dataItem.isSelected = selectionController.isRowSelected(isDeferredSelection ? dataItem.data : dataItem.key);
              if (hasSelectColumn && dataItem.values) {
                for (var i = 0; i < options2.visibleColumns.length; i++) {
                  if ("select" === options2.visibleColumns[i].command) {
                    dataItem.values[i] = dataItem.isSelected;
                    break;
                  }
                }
              }
              return dataItem;
            },
            refresh: function(options2) {
              var that = this;
              var d = new Deferred();
              this.callBase.apply(this, arguments).done(function() {
                if (!options2 || options2.selection) {
                  that.getController("selection").refresh().done(d.resolve).fail(d.reject);
                } else {
                  d.resolve();
                }
              }).fail(d.reject);
              return d.promise();
            },
            _handleDataChanged: function(e) {
              this.callBase.apply(this, arguments);
              if ((!e || "refresh" === e.changeType) && !this._repaintChangesOnly) {
                this.getController("selection").focusedItemIndex(-1);
              }
            },
            _applyChange: function(change) {
              if (change && "updateSelection" === change.changeType) {
                change.items.forEach((item, index2) => {
                  var currentItem = this._items[index2];
                  if (currentItem) {
                    currentItem.isSelected = item.isSelected;
                    currentItem.values = item.values;
                  }
                });
                return;
              }
              return this.callBase.apply(this, arguments);
            },
            _endUpdateCore: function() {
              var changes = this._changes;
              var isUpdateSelection = changes.length > 1 && changes.every((change) => "updateSelection" === change.changeType);
              if (isUpdateSelection) {
                var itemIndexes = changes.map((change) => change.itemIndexes || []).reduce((a, b) => a.concat(b));
                this._changes = [{
                  changeType: "updateSelection",
                  itemIndexes
                }];
              }
              this.callBase.apply(this, arguments);
            }
          },
          contextMenu: {
            _contextMenuPrepared: function(options2) {
              var dxEvent = options2.event;
              if (dxEvent.originalEvent && "dxhold" !== dxEvent.originalEvent.type || options2.items && options2.items.length > 0) {
                return;
              }
              processLongTap(this, dxEvent);
            }
          }
        },
        views: {
          columnHeadersView: {
            init: function() {
              this.callBase();
              this.getController("selection").selectionChanged.add(this._updateSelectAllValue.bind(this));
            },
            _updateSelectAllValue: function() {
              var $element = this.element();
              var $editor = $element && $element.find("." + SELECT_CHECKBOX_CLASS2);
              if ($element && $editor.length && "multiple" === this.option("selection.mode")) {
                var selectAllValue = this.getController("selection").isSelectAll();
                var hasSelection = false !== selectAllValue;
                var isVisible2 = this.option("selection.allowSelectAll") ? !this.getController("data").isEmpty() : hasSelection;
                $editor.dxCheckBox("instance").option({
                  visible: isVisible2,
                  value: selectAllValue
                });
              }
            },
            _handleDataChanged: function(e) {
              this.callBase(e);
              if (!e || "refresh" === e.changeType) {
                this._updateSelectAllValue();
              }
            },
            _renderSelectAllCheckBox: function($container, column) {
              var that = this;
              var selectionController = that.getController("selection");
              var isEmptyData = that.getController("data").isEmpty();
              var groupElement = renderer_default("<div>").appendTo($container).addClass(SELECT_CHECKBOX_CLASS2);
              that.setAria("label", message_default.format("dxDataGrid-ariaSelectAll"), $container);
              that.getController("editorFactory").createEditor(groupElement, extend2({}, column, {
                parentType: "headerRow",
                dataType: "boolean",
                value: selectionController.isSelectAll(),
                editorOptions: {
                  visible: !isEmptyData && (that.option("selection.allowSelectAll") || false !== selectionController.isSelectAll())
                },
                tabIndex: that.option("useLegacyKeyboardNavigation") ? -1 : that.option("tabIndex") || 0,
                setValue: function(value2, e) {
                  var allowSelectAll = that.option("selection.allowSelectAll");
                  e.component.option("visible", allowSelectAll || false !== e.component.option("value"));
                  if (!e.event || selectionController.isSelectAll() === value2) {
                    return;
                  }
                  if (e.value && !allowSelectAll) {
                    e.component.option("value", false);
                  } else {
                    e.value ? selectionController.selectAll() : selectionController.deselectAll();
                  }
                  e.event.preventDefault();
                }
              }));
              return groupElement;
            },
            _attachSelectAllCheckBoxClickEvent: function($element) {
              events_engine_default.on($element, CLICK_EVENT_NAME, this.createAction(function(e) {
                var event = e.event;
                if (!renderer_default(event.target).closest("." + SELECT_CHECKBOX_CLASS2).length) {
                  events_engine_default.trigger(renderer_default(event.currentTarget).children("." + SELECT_CHECKBOX_CLASS2), CLICK_EVENT_NAME);
                }
                event.preventDefault();
              }));
            }
          },
          rowsView: {
            renderSelectCheckBoxContainer: function($container, options2) {
              if ("data" === options2.rowType && !options2.row.isNewRow) {
                $container.addClass(EDITOR_CELL_CLASS);
                this._attachCheckBoxClickEvent($container);
                this.setAria("label", message_default.format("dxDataGrid-ariaSelectRow"), $container);
                this._renderSelectCheckBox($container, options2);
              } else {
                ui_grid_core_utils_default.setEmptyText($container);
              }
            },
            _renderSelectCheckBox: function(container, options2) {
              var groupElement = renderer_default("<div>").addClass(SELECT_CHECKBOX_CLASS2).appendTo(container);
              this.getController("editorFactory").createEditor(groupElement, extend2({}, options2.column, {
                parentType: "dataRow",
                dataType: "boolean",
                lookup: null,
                value: options2.value,
                setValue: function(value2, e) {
                  var _e$event;
                  if ("keydown" === (null === e || void 0 === e ? void 0 : null === (_e$event = e.event) || void 0 === _e$event ? void 0 : _e$event.type)) {
                    events_engine_default.trigger(e.element, CLICK_EVENT_NAME, e);
                  }
                },
                row: options2.row
              }));
              return groupElement;
            },
            _attachCheckBoxClickEvent: function($element) {
              events_engine_default.on($element, CLICK_EVENT_NAME, this.createAction(function(e) {
                var selectionController = this.getController("selection");
                var event = e.event;
                var rowIndex = this.getRowIndex(renderer_default(event.currentTarget).closest("." + ROW_CLASS2));
                if (rowIndex >= 0) {
                  selectionController.startSelectionWithCheckboxes();
                  selectionController.changeItemSelection(rowIndex, {
                    shift: event.shiftKey
                  });
                  if (renderer_default(event.target).closest("." + SELECT_CHECKBOX_CLASS2).length) {
                    this.getController("data").updateItems({
                      changeType: "updateSelection",
                      itemIndexes: [rowIndex]
                    });
                  }
                }
              }));
            },
            _update: function(change) {
              var that = this;
              var tableElements = that.getTableElements();
              if ("updateSelection" === change.changeType) {
                if (tableElements.length > 0) {
                  each(tableElements, function(_2, tableElement) {
                    each(change.itemIndexes || [], function(_3, index2) {
                      var $row;
                      if (change.items[index2]) {
                        $row = that._getRowElements(renderer_default(tableElement)).eq(index2);
                        if ($row.length) {
                          var isSelected = change.items[index2].isSelected;
                          $row.toggleClass(ROW_SELECTION_CLASS, void 0 === isSelected ? false : isSelected).find("." + SELECT_CHECKBOX_CLASS2).dxCheckBox("option", "value", isSelected);
                          that.setAria("selected", isSelected, $row);
                        }
                      }
                    });
                  });
                  that._updateCheckboxesClass();
                }
              } else {
                that.callBase(change);
              }
            },
            _createTable: function() {
              var that = this;
              var selectionMode = that.option("selection.mode");
              var $table = that.callBase.apply(that, arguments);
              if ("none" !== selectionMode) {
                if ("onLongTap" === that.option(SHOW_CHECKBOXES_MODE) || !touch) {
                  events_engine_default.on($table, addNamespace2(hold_default.name, "dxDataGridRowsView"), "." + DATA_ROW_CLASS, that.createAction(function(e) {
                    processLongTap(that.component, e.event);
                    e.event.stopPropagation();
                  }));
                }
                events_engine_default.on($table, "mousedown selectstart", that.createAction(function(e) {
                  var event = e.event;
                  if (event.shiftKey) {
                    event.preventDefault();
                  }
                }));
              }
              return $table;
            },
            _createRow: function(row) {
              var $row = this.callBase(row);
              if (row) {
                var isSelected = row.isSelected;
                if (isSelected) {
                  $row.addClass(ROW_SELECTION_CLASS);
                }
                this.setAria("selected", isSelected, $row);
              }
              return $row;
            },
            _rowClick: function(e) {
              var dxEvent = e.event;
              var isSelectionDisabled = renderer_default(dxEvent.target).closest("." + SELECTION_DISABLED_CLASS).length;
              if (!this.isClickableElement(renderer_default(dxEvent.target))) {
                if (!isSelectionDisabled && ("multiple" !== this.option(SELECTION_MODE) || "always" !== this.option(SHOW_CHECKBOXES_MODE))) {
                  if (this.getController("selection").changeItemSelection(e.rowIndex, {
                    control: isCommandKeyPressed(dxEvent),
                    shift: dxEvent.shiftKey
                  })) {
                    dxEvent.preventDefault();
                    e.handled = true;
                  }
                }
                this.callBase(e);
              }
            },
            isClickableElement: function($target) {
              var isCommandSelect = $target.closest("." + COMMAND_SELECT_CLASS).length;
              return !!isCommandSelect;
            },
            _renderCore: function(change) {
              this.callBase(change);
              this._updateCheckboxesClass();
            },
            _updateCheckboxesClass: function() {
              var tableElements = this.getTableElements();
              var selectionController = this.getController("selection");
              var isCheckBoxesHidden = selectionController.isSelectColumnVisible() && !selectionController.isSelectionWithCheckboxes();
              each(tableElements, function(_2, tableElement) {
                renderer_default(tableElement).toggleClass(CHECKBOXES_HIDDEN_CLASS, isCheckBoxesHidden);
              });
            }
          }
        }
      }
    };
  }
});

// node_modules/devextreme/esm/ui/tree_view/ui.tree_view.base.js
var WIDGET_CLASS, NODE_CLASS, NODE_CONTAINER_CLASS, NODE_LOAD_INDICATOR_CLASS, OPENED_NODE_CONTAINER_CLASS, IS_LEAF, ITEM_CLASS3, ITEM_WITH_CHECKBOX_CLASS, ITEM_WITHOUT_CHECKBOX_CLASS, ITEM_DATA_KEY2, TOGGLE_ITEM_VISIBILITY_CLASS, LOAD_INDICATOR_CLASS, LOAD_INDICATOR_WRAPPER_CLASS, TOGGLE_ITEM_VISIBILITY_OPENED_CLASS, SELECT_ALL_ITEM_CLASS, INVISIBLE_STATE_CLASS3, DISABLED_STATE_CLASS4, SELECTED_ITEM_CLASS2, EXPAND_EVENT_NAMESPACE, DATA_ITEM_ID, TreeViewBase, ui_tree_view_base_default;
var init_ui_tree_view_base = __esm({
  "node_modules/devextreme/esm/ui/tree_view/ui.tree_view.base.js"() {
    init_renderer();
    init_dom_adapter();
    init_events_engine();
    init_message();
    init_click();
    init_common();
    init_window();
    init_type();
    init_extend();
    init_iterator();
    init_element();
    init_check_box();
    init_ui_hierarchical_collection_widget();
    init_utils2();
    init_pointer();
    init_double_click();
    init_fx();
    init_ui_scrollable();
    init_load_indicator();
    init_deferred();
    init_ui_errors();
    init_support();
    init_get_relative_offset();
    init_consts();
    WIDGET_CLASS = "dx-treeview";
    NODE_CLASS = "".concat(WIDGET_CLASS, "-node");
    NODE_CONTAINER_CLASS = "".concat(NODE_CLASS, "-container");
    NODE_LOAD_INDICATOR_CLASS = "".concat(NODE_CLASS, "-loadindicator");
    OPENED_NODE_CONTAINER_CLASS = "".concat(NODE_CLASS, "-container-opened");
    IS_LEAF = "".concat(NODE_CLASS, "-is-leaf");
    ITEM_CLASS3 = "".concat(WIDGET_CLASS, "-item");
    ITEM_WITH_CHECKBOX_CLASS = "".concat(ITEM_CLASS3, "-with-checkbox");
    ITEM_WITHOUT_CHECKBOX_CLASS = "".concat(ITEM_CLASS3, "-without-checkbox");
    ITEM_DATA_KEY2 = "".concat(ITEM_CLASS3, "-data");
    TOGGLE_ITEM_VISIBILITY_CLASS = "".concat(WIDGET_CLASS, "-toggle-item-visibility");
    LOAD_INDICATOR_CLASS = "".concat(WIDGET_CLASS, "-loadindicator");
    LOAD_INDICATOR_WRAPPER_CLASS = "".concat(WIDGET_CLASS, "-loadindicator-wrapper");
    TOGGLE_ITEM_VISIBILITY_OPENED_CLASS = "".concat(WIDGET_CLASS, "-toggle-item-visibility-opened");
    SELECT_ALL_ITEM_CLASS = "".concat(WIDGET_CLASS, "-select-all-item");
    INVISIBLE_STATE_CLASS3 = "dx-state-invisible";
    DISABLED_STATE_CLASS4 = "dx-state-disabled";
    SELECTED_ITEM_CLASS2 = "dx-state-selected";
    EXPAND_EVENT_NAMESPACE = "dxTreeView_expand";
    DATA_ITEM_ID = "data-item-id";
    TreeViewBase = ui_hierarchical_collection_widget_default.inherit({
      _supportedKeys: function(e) {
        var click2 = (e2) => {
          var $itemElement = renderer_default(this.option("focusedElement"));
          if (!$itemElement.length) {
            return;
          }
          e2.target = $itemElement;
          e2.currentTarget = $itemElement;
          this._itemClickHandler(e2, $itemElement.children("." + ITEM_CLASS3));
          var expandEventName = this._getEventNameByOption(this.option("expandEvent"));
          var expandByClick = expandEventName === addNamespace2(CLICK_EVENT_NAME, EXPAND_EVENT_NAMESPACE);
          if (expandByClick) {
            this._expandEventHandler(e2);
          }
        };
        var select = (e2) => {
          e2.preventDefault();
          var $focusedElement = renderer_default(this.option("focusedElement"));
          var checkboxInstance = this._getCheckBoxInstance($focusedElement);
          if (!checkboxInstance.option("disabled")) {
            var currentState = checkboxInstance.option("value");
            this._updateItemSelection(!currentState, $focusedElement.find("." + ITEM_CLASS3).get(0), true);
          }
        };
        var toggleExpandedNestedItems = function(state, e2) {
          if (!this.option("expandAllEnabled")) {
            return;
          }
          e2.preventDefault();
          var $rootElement = renderer_default(this.option("focusedElement"));
          if (!$rootElement.length) {
            return;
          }
          var rootItem = this._getItemData($rootElement.find(".".concat(ITEM_CLASS3)));
          this._toggleExpandedNestedItems([rootItem], state);
        };
        return extend2(this.callBase(), {
          enter: this._showCheckboxes() ? select : click2,
          space: this._showCheckboxes() ? select : click2,
          asterisk: toggleExpandedNestedItems.bind(this, true),
          minus: toggleExpandedNestedItems.bind(this, false)
        });
      },
      _toggleExpandedNestedItems: function(items, state) {
        if (!items) {
          return;
        }
        for (var i = 0, len = items.length; i < len; i++) {
          var item = items[i];
          var node = this._dataAdapter.getNodeByItem(item);
          this._toggleExpandedState(node, state);
          this._toggleExpandedNestedItems(item.items, state);
        }
      },
      _getNodeElement: function(node, cache) {
        var key = this._encodeString(node.internalFields.key);
        if (cache) {
          if (!cache.$nodeByKey) {
            cache.$nodeByKey = {};
            this.$element().find(".".concat(NODE_CLASS)).each(function() {
              var $node = renderer_default(this);
              var key2 = $node.attr(DATA_ITEM_ID);
              cache.$nodeByKey[key2] = $node;
            });
          }
          return cache.$nodeByKey[key] || renderer_default();
        }
        var element = this.$element().get(0).querySelector("[".concat(DATA_ITEM_ID, '="').concat(key, '"]'));
        return renderer_default(element);
      },
      _activeStateUnit: "." + ITEM_CLASS3,
      _widgetClass: function() {
        return WIDGET_CLASS;
      },
      _getDefaultOptions: function() {
        var defaultOptions = extend2(this.callBase(), {
          animationEnabled: true,
          dataStructure: "tree",
          deferRendering: true,
          expandAllEnabled: false,
          hasItemsExpr: "hasItems",
          selectNodesRecursive: true,
          expandNodesRecursive: true,
          showCheckBoxesMode: "none",
          selectAllText: message_default.format("dxList-selectAll"),
          onItemSelectionChanged: null,
          onItemExpanded: null,
          onItemCollapsed: null,
          scrollDirection: "vertical",
          useNativeScrolling: true,
          virtualModeEnabled: false,
          rootValue: 0,
          focusStateEnabled: false,
          selectionMode: "multiple",
          expandEvent: "dblclick",
          selectByClick: false,
          createChildren: null,
          onSelectAllValueChanged: null
        });
        return extend2(true, defaultOptions, {
          integrationOptions: {
            useDeferUpdateForTemplates: false
          }
        });
      },
      _defaultOptionsRules: function() {
        return this.callBase().concat([{
          device: function() {
            return !nativeScrolling;
          },
          options: {
            useNativeScrolling: false
          }
        }]);
      },
      _initSelectedItems: noop2,
      _syncSelectionOptions: asyncNoop,
      _fireSelectionChanged: function() {
        var selectionChangePromise = this._selectionChangePromise;
        when(selectionChangePromise).done((function() {
          this._createActionByOption("onSelectionChanged", {
            excludeValidators: ["disabled", "readOnly"]
          })();
        }).bind(this));
      },
      _createSelectAllValueChangedAction: function() {
        this._selectAllValueChangedAction = this._createActionByOption("onSelectAllValueChanged", {
          excludeValidators: ["disabled", "readOnly"]
        });
      },
      _fireSelectAllValueChanged: function(value2) {
        this._selectAllValueChangedAction({
          value: value2
        });
      },
      _checkBoxModeChange: function(value2, previousValue) {
        if ("none" === previousValue || "none" === value2) {
          this.repaint();
          return;
        }
        var selectAllExists = this._$selectAllItem && this._$selectAllItem.length;
        switch (value2) {
          case "selectAll":
            if (!selectAllExists) {
              this._createSelectAllValueChangedAction();
              this._renderSelectAllItem();
            }
            break;
          case "normal":
            if (selectAllExists) {
              this._$selectAllItem.remove();
              delete this._$selectAllItem;
            }
        }
      },
      _removeSelection: function() {
        var that = this;
        each(this._dataAdapter.getFullData(), function(_2, node) {
          if (!that._hasChildren(node)) {
            return;
          }
          that._dataAdapter.toggleSelection(node.internalFields.key, false, true);
        });
      },
      _optionChanged: function(args) {
        var {
          name: name2,
          value: value2,
          previousValue
        } = args;
        switch (name2) {
          case "selectAllText":
            if (this._$selectAllItem) {
              this._$selectAllItem.dxCheckBox("instance").option("text", value2);
            }
            break;
          case "showCheckBoxesMode":
            this._checkBoxModeChange(value2, previousValue);
            break;
          case "scrollDirection":
            this.getScrollable().option("direction", value2);
            break;
          case "useNativeScrolling":
            this.getScrollable().option("useNative", value2);
            break;
          case "items":
            delete this._$selectAllItem;
            this.callBase(args);
            break;
          case "dataSource":
            this.callBase(args);
            this._initDataAdapter();
            this._filter = {};
            break;
          case "hasItemsExpr":
            this._initAccessors();
            this.repaint();
            break;
          case "expandEvent":
            this._initExpandEvent();
            break;
          case "deferRendering":
          case "dataStructure":
          case "rootValue":
          case "createChildren":
          case "expandNodesRecursive":
          case "onItemSelectionChanged":
          case "onItemExpanded":
          case "onItemCollapsed":
          case "expandAllEnabled":
          case "animationEnabled":
          case "virtualModeEnabled":
          case "selectByClick":
            break;
          case "selectionMode":
            this._initDataAdapter();
            this.callBase(args);
            break;
          case "onSelectAllValueChanged":
            this._createSelectAllValueChangedAction();
            break;
          case "selectNodesRecursive":
            this._dataAdapter.setOption("recursiveSelection", args.value);
            this.repaint();
            break;
          default:
            this.callBase(args);
        }
      },
      _initDataSource: function() {
        if (this._useCustomChildrenLoader()) {
          this._loadChildrenByCustomLoader(null).done((function(newItems) {
            if (newItems && newItems.length) {
              this.option("items", newItems);
            }
          }).bind(this));
        } else {
          this.callBase();
          this._isVirtualMode() && this._initVirtualMode();
        }
      },
      _initVirtualMode: function() {
        var filter = this._filter;
        if (!filter.custom) {
          filter.custom = this._dataSource.filter();
        }
        if (!filter.internal) {
          filter.internal = [this.option("parentIdExpr"), this.option("rootValue")];
        }
      },
      _useCustomChildrenLoader: function() {
        return isFunction(this.option("createChildren")) && this._isDataStructurePlain();
      },
      _loadChildrenByCustomLoader: function(parentNode) {
        var invocationResult = this.option("createChildren").call(this, parentNode);
        if (Array.isArray(invocationResult)) {
          return new Deferred().resolve(invocationResult).promise();
        }
        if (invocationResult && isFunction(invocationResult.then)) {
          return fromPromise(invocationResult);
        }
        return new Deferred().resolve([]).promise();
      },
      _combineFilter: function() {
        if (!this._filter.custom || !this._filter.custom.length) {
          return this._filter.internal;
        }
        return [this._filter.custom, this._filter.internal];
      },
      _dataSourceLoadErrorHandler: function() {
        this._renderEmptyMessage();
      },
      _init: function() {
        this._filter = {};
        this.callBase();
        this._initStoreChangeHandlers();
      },
      _dataSourceChangedHandler: function(newItems) {
        var items = this.option("items");
        if (this._initialized && this._isVirtualMode() && items.length) {
          return;
        }
        this.option("items", newItems);
      },
      _removeTreeViewLoadIndicator: function() {
        if (!this._treeViewLoadIndicator) {
          return;
        }
        this._treeViewLoadIndicator.remove();
        this._treeViewLoadIndicator = null;
      },
      _createTreeViewLoadIndicator: function() {
        this._treeViewLoadIndicator = renderer_default("<div>").addClass(LOAD_INDICATOR_CLASS);
        this._createComponent(this._treeViewLoadIndicator, load_indicator_default, {});
        return this._treeViewLoadIndicator;
      },
      _dataSourceLoadingChangedHandler: function(isLoading) {
        var resultFilter;
        if (this._isVirtualMode()) {
          resultFilter = this._combineFilter();
          this._dataSource.filter(resultFilter);
        }
        if (isLoading && !this._dataSource.isLoaded()) {
          this.option("items", []);
          var $wrapper = renderer_default("<div>").addClass(LOAD_INDICATOR_WRAPPER_CLASS);
          this._createTreeViewLoadIndicator().appendTo($wrapper);
          this.itemsContainer().append($wrapper);
          if (this._isVirtualMode() && this._dataSource.filter() !== resultFilter) {
            this._dataSource.filter([]);
          }
        } else {
          this._removeTreeViewLoadIndicator();
        }
      },
      _initStoreChangeHandlers: function() {
        if ("plain" !== this.option("dataStructure")) {
          return;
        }
        this._dataSource && this._dataSource.store().on("inserted", (newItem) => {
          this.option().items = this.option("items").concat(newItem);
          this._dataAdapter.addItem(newItem);
          if (!this._dataAdapter.isFiltered(newItem)) {
            return;
          }
          this._updateLevel(this._parentIdGetter(newItem));
        }).on("removed", (removedKey) => {
          var node = this._dataAdapter.getNodeByKey(removedKey);
          if (isDefined(node)) {
            this.option("items")[this._dataAdapter.getIndexByKey(node.internalFields.key)] = 0;
            this._markChildrenItemsToRemove(node);
            this._removeItems();
            this._dataAdapter.removeItem(removedKey);
            this._updateLevel(this._parentIdGetter(node));
          }
        });
      },
      _markChildrenItemsToRemove: function(node) {
        var keys = node.internalFields.childrenKeys;
        each(keys, (_2, key) => {
          this.option("items")[this._dataAdapter.getIndexByKey(key)] = 0;
          this._markChildrenItemsToRemove(this._dataAdapter.getNodeByKey(key));
        });
      },
      _removeItems: function() {
        var items = extend2(true, [], this.option("items"));
        var counter = 0;
        each(items, (index2, item) => {
          if (!item) {
            this.option("items").splice(index2 - counter, 1);
            counter++;
          }
        });
      },
      _updateLevel: function(parentId) {
        var $container = this._getContainerByParentKey(parentId);
        this._renderItems($container, this._dataAdapter.getChildrenNodes(parentId));
      },
      _getOldContainer: function($itemElement) {
        if ($itemElement.length) {
          return $itemElement.children(".".concat(NODE_CONTAINER_CLASS));
        }
        var scrollable = this.getScrollable();
        if (scrollable) {
          return renderer_default(scrollable.content()).children();
        }
        return renderer_default();
      },
      _getContainerByParentKey: function(parentId) {
        var node = this._dataAdapter.getNodeByKey(parentId);
        var $itemElement = node ? this._getNodeElement(node) : [];
        this._getOldContainer($itemElement).remove();
        var $container = this._renderNodeContainer($itemElement);
        if (this._isRootLevel(parentId)) {
          var scrollable = this.getScrollable();
          if (!scrollable) {
            this._renderScrollableContainer();
          }
          renderer_default(scrollable.content()).append($container);
        }
        return $container;
      },
      _isRootLevel: function(parentId) {
        return parentId === this.option("rootValue");
      },
      _getAccessors: function() {
        var accessors = this.callBase();
        accessors.push("hasItems");
        return accessors;
      },
      _getDataAdapterOptions: function() {
        return {
          rootValue: this.option("rootValue"),
          multipleSelection: !this._isSingleSelection(),
          recursiveSelection: this._isRecursiveSelection(),
          recursiveExpansion: this.option("expandNodesRecursive"),
          selectionRequired: this.option("selectionRequired"),
          dataType: this.option("dataStructure"),
          sort: this._dataSource && this._dataSource.sort()
        };
      },
      _initMarkup: function() {
        this._renderScrollableContainer();
        this._renderEmptyMessage(this._dataAdapter.getRootNodes());
        this.callBase();
        this.setAria("role", "tree");
      },
      _renderContentImpl: function() {
        var $nodeContainer = this._renderNodeContainer();
        renderer_default(this.getScrollable().content()).append($nodeContainer);
        if (!this.option("items") || !this.option("items").length) {
          return;
        }
        this._renderItems($nodeContainer, this._dataAdapter.getRootNodes());
        this._initExpandEvent();
        if (this._selectAllEnabled()) {
          this._createSelectAllValueChangedAction();
          this._renderSelectAllItem($nodeContainer);
        }
      },
      _isVirtualMode: function() {
        return this.option("virtualModeEnabled") && this._isDataStructurePlain() && !!this.option("dataSource");
      },
      _isDataStructurePlain: function() {
        return "plain" === this.option("dataStructure");
      },
      _fireContentReadyAction: function() {
        var dataSource = this.getDataSource();
        var skipContentReadyAction = dataSource && !dataSource.isLoaded();
        var scrollable = this.getScrollable();
        if (scrollable && hasWindow()) {
          scrollable.update();
        }
        if (!skipContentReadyAction) {
          this.callBase();
        }
        if (scrollable && hasWindow()) {
          scrollable.update();
        }
      },
      _renderScrollableContainer: function() {
        this._scrollable = this._createComponent(renderer_default("<div>").appendTo(this.$element()), ui_scrollable_default, {
          useNative: this.option("useNativeScrolling"),
          direction: this.option("scrollDirection"),
          useKeyboard: false
        });
      },
      _renderNodeContainer: function($parent) {
        var $container = renderer_default("<ul>").addClass(NODE_CONTAINER_CLASS);
        this.setAria("role", "group", $container);
        if ($parent && $parent.length) {
          var itemData = this._getItemData($parent.children("." + ITEM_CLASS3));
          if (this._expandedGetter(itemData)) {
            $container.addClass(OPENED_NODE_CONTAINER_CLASS);
          }
          $container.appendTo($parent);
        }
        return $container;
      },
      _createDOMElement: function($nodeContainer, node) {
        var $node = renderer_default("<li>").addClass(NODE_CLASS).attr(DATA_ITEM_ID, this._encodeString(node.internalFields.key)).prependTo($nodeContainer);
        this.setAria({
          role: "treeitem",
          label: this._displayGetter(node.internalFields.item) || "",
          expanded: node.internalFields.expanded || false,
          level: this._getLevel($nodeContainer)
        }, $node);
        return $node;
      },
      _getLevel: function($nodeContainer) {
        var parent = $nodeContainer.parent();
        return parent.hasClass("dx-scrollable-content") ? 1 : parseInt(parent.attr("aria-level")) + 1;
      },
      _showCheckboxes: function() {
        return "none" !== this.option("showCheckBoxesMode");
      },
      _selectAllEnabled: function() {
        return "selectAll" === this.option("showCheckBoxesMode") && !this._isSingleSelection();
      },
      _renderItems: function($nodeContainer, nodes) {
        var length = nodes.length - 1;
        for (var i = length; i >= 0; i--) {
          this._renderItem(i, nodes[i], $nodeContainer);
        }
        this._renderedItemsCount += nodes.length;
      },
      _renderItem: function(nodeIndex, node, $nodeContainer) {
        var $node = this._createDOMElement($nodeContainer, node);
        var nodeData = node.internalFields;
        var showCheckBox = this._showCheckboxes();
        $node.addClass(showCheckBox ? ITEM_WITH_CHECKBOX_CLASS : ITEM_WITHOUT_CHECKBOX_CLASS);
        $node.toggleClass(INVISIBLE_STATE_CLASS3, false === nodeData.item.visible);
        showCheckBox && this._renderCheckBox($node, node);
        this.setAria("selected", nodeData.selected, $node);
        this._toggleSelectedClass($node, nodeData.selected);
        this.callBase(this._renderedItemsCount + nodeIndex, nodeData.item, $node);
        if (false !== nodeData.item.visible) {
          this._renderChildren($node, node);
        }
      },
      _setAriaSelected: function() {
      },
      _renderChildren: function($node, node) {
        if (!this._hasChildren(node)) {
          this._addLeafClass($node);
          return;
        }
        this._renderToggleItemVisibilityIcon($node, node);
        if (this.option("deferRendering") && !node.internalFields.expanded) {
          return;
        }
        this._loadSublevel(node).done((childNodes) => {
          this._renderSublevel($node, this._getActualNode(node), childNodes);
        });
      },
      _getActualNode: function(cachedNode) {
        return this._dataAdapter.getNodeByKey(cachedNode.internalFields.key);
      },
      _hasChildren: function(node) {
        if (this._isVirtualMode() || this._useCustomChildrenLoader()) {
          return false !== this._hasItemsGetter(node.internalFields.item);
        }
        return this.callBase(node);
      },
      _loadSublevel: function(node) {
        var deferred = new Deferred();
        var childrenNodes = this._getChildNodes(node);
        if (childrenNodes.length) {
          deferred.resolve(childrenNodes);
        } else {
          this._loadNestedItems(node).done((items) => {
            deferred.resolve(this._dataAdapter.getNodesByItems(items));
          });
        }
        return deferred.promise();
      },
      _renderSublevel: function($node, node, childNodes) {
        var $nestedNodeContainer = this._renderNodeContainer($node, node);
        var childNodesByChildrenKeys = childNodes.filter((childNode) => -1 !== node.internalFields.childrenKeys.indexOf(childNode.internalFields.key));
        this._renderItems($nestedNodeContainer, childNodesByChildrenKeys);
        if (childNodesByChildrenKeys.length && !node.internalFields.selected) {
          var firstChild = childNodesByChildrenKeys[0];
          this._updateParentsState(firstChild, this._getNodeElement(firstChild));
        }
        this._normalizeIconState($node, childNodesByChildrenKeys.length);
        if (node.internalFields.expanded) {
          $nestedNodeContainer.addClass(OPENED_NODE_CONTAINER_CLASS);
        }
      },
      _executeItemRenderAction: function(itemIndex, itemData, itemElement) {
        var node = this._getNode(itemElement);
        this._getItemRenderAction()({
          itemElement,
          itemIndex,
          itemData,
          node: this._dataAdapter.getPublicNode(node)
        });
      },
      _addLeafClass: function($node) {
        $node.addClass(IS_LEAF);
      },
      _expandEventHandler: function(e) {
        var $nodeElement = renderer_default(e.currentTarget.parentNode);
        if (!$nodeElement.hasClass(IS_LEAF)) {
          this._toggleExpandedState(e.currentTarget, void 0, e);
        }
      },
      _initExpandEvent: function() {
        var expandedEventName = this._getEventNameByOption(this.option("expandEvent"));
        var $itemsContainer = this._itemContainer();
        var itemSelector = this._itemSelector();
        events_engine_default.off($itemsContainer, "." + EXPAND_EVENT_NAMESPACE, itemSelector);
        events_engine_default.on($itemsContainer, expandedEventName, itemSelector, this._expandEventHandler.bind(this));
      },
      _getEventNameByOption: function(name2) {
        var event = "click" === name2 ? CLICK_EVENT_NAME : DBLCLICK_EVENT_NAME;
        return addNamespace2(event, EXPAND_EVENT_NAMESPACE);
      },
      _getNode: function(identifier) {
        if (!isDefined(identifier)) {
          return null;
        }
        if (identifier.internalFields) {
          return identifier;
        }
        if (isPrimitive(identifier)) {
          return this._dataAdapter.getNodeByKey(identifier);
        }
        var itemElement = renderer_default(identifier).get(0);
        if (!itemElement) {
          return null;
        }
        if (dom_adapter_default.isElementNode(itemElement)) {
          return this._getNodeByElement(itemElement);
        }
        return this._dataAdapter.getNodeByItem(itemElement);
      },
      _getNodeByElement: function(itemElement) {
        var $node = renderer_default(itemElement).closest("." + NODE_CLASS);
        var key = this._decodeString($node.attr(DATA_ITEM_ID));
        return this._dataAdapter.getNodeByKey(key);
      },
      _toggleExpandedState: function(itemElement, state, e) {
        var node = this._getNode(itemElement);
        if (!node) {
          return new Deferred().reject().promise();
        }
        if (node.internalFields.disabled) {
          return new Deferred().reject().promise();
        }
        var currentState = node.internalFields.expanded;
        if (currentState === state) {
          return new Deferred().resolve().promise();
        }
        if (this._hasChildren(node)) {
          var $node = this._getNodeElement(node);
          if ($node.find(".".concat(NODE_LOAD_INDICATOR_CLASS, ":not(.").concat(INVISIBLE_STATE_CLASS3, ")")).length) {
            return new Deferred().reject().promise();
          }
          this._createLoadIndicator($node);
        }
        if (!isDefined(state)) {
          state = !currentState;
        }
        this._dataAdapter.toggleExpansion(node.internalFields.key, state);
        return this._updateExpandedItemsUI(node, state, e);
      },
      _createLoadIndicator: function($node) {
        var $icon = $node.children("." + TOGGLE_ITEM_VISIBILITY_CLASS);
        var $nodeContainer = $node.children(".".concat(NODE_CONTAINER_CLASS));
        if ($icon.hasClass(TOGGLE_ITEM_VISIBILITY_OPENED_CLASS) || $nodeContainer.not(":empty").length) {
          return;
        }
        this._createComponent(renderer_default("<div>").addClass(NODE_LOAD_INDICATOR_CLASS), load_indicator_default, {}).$element().appendTo($node);
        $icon.hide();
      },
      _renderToggleItemVisibilityIcon: function($node, node) {
        var $icon = renderer_default("<div>").addClass(TOGGLE_ITEM_VISIBILITY_CLASS).appendTo($node);
        if (node.internalFields.expanded) {
          $icon.addClass(TOGGLE_ITEM_VISIBILITY_OPENED_CLASS);
          $node.parent().addClass(OPENED_NODE_CONTAINER_CLASS);
        }
        if (node.internalFields.disabled) {
          $icon.addClass(DISABLED_STATE_CLASS4);
        }
        this._renderToggleItemVisibilityIconClick($icon, node);
      },
      _renderToggleItemVisibilityIconClick: function($icon, node) {
        var eventName = addNamespace2(CLICK_EVENT_NAME, this.NAME);
        events_engine_default.off($icon, eventName);
        events_engine_default.on($icon, eventName, (e) => {
          this._toggleExpandedState(node.internalFields.key, void 0, e);
        });
      },
      _updateExpandedItemsUI: function(node, state, e) {
        var $node = this._getNodeElement(node);
        var isHiddenNode = !$node.length || state && $node.is(":hidden");
        if (this.option("expandNodesRecursive") && isHiddenNode) {
          var parentNode = this._getNode(node.internalFields.parentKey);
          if (parentNode) {
            this._updateExpandedItemsUI(parentNode, state, e);
          }
        }
        var $icon = $node.children("." + TOGGLE_ITEM_VISIBILITY_CLASS);
        var $nodeContainer = $node.children(".".concat(NODE_CONTAINER_CLASS));
        $icon.toggleClass(TOGGLE_ITEM_VISIBILITY_OPENED_CLASS, state);
        var nodeContainerExists = $nodeContainer.length > 0;
        var completionCallback = new Deferred();
        if (!state || nodeContainerExists && !$nodeContainer.is(":empty")) {
          this._animateNodeContainer(node, state, e, completionCallback);
          return completionCallback.promise();
        }
        if (0 === node.internalFields.childrenKeys.length && (this._isVirtualMode() || this._useCustomChildrenLoader())) {
          this._loadNestedItemsWithUpdate(node, state, e, completionCallback);
          return completionCallback.promise();
        }
        this._renderSublevel($node, node, this._getChildNodes(node));
        this._fireContentReadyAction();
        this._animateNodeContainer(node, state, e, completionCallback);
        return completionCallback.promise();
      },
      _loadNestedItemsWithUpdate: function(node, state, e, completionCallback) {
        var $node = this._getNodeElement(node);
        this._loadNestedItems(node).done((items) => {
          var actualNodeData = this._getActualNode(node);
          this._renderSublevel($node, actualNodeData, this._dataAdapter.getNodesByItems(items));
          if (!items || !items.length) {
            return;
          }
          this._fireContentReadyAction();
          this._animateNodeContainer(actualNodeData, state, e, completionCallback);
        });
      },
      _loadNestedItems: function(node) {
        if (this._useCustomChildrenLoader()) {
          var publicNode = this._dataAdapter.getPublicNode(node);
          return this._loadChildrenByCustomLoader(publicNode).done((newItems) => {
            if (!this._areNodesExists(newItems)) {
              this._appendItems(newItems);
            }
          });
        }
        if (!this._isVirtualMode()) {
          return new Deferred().resolve([]).promise();
        }
        this._filter.internal = [this.option("parentIdExpr"), node.internalFields.key];
        this._dataSource.filter(this._combineFilter());
        return this._dataSource.load().done((newItems) => {
          if (!this._areNodesExists(newItems)) {
            this._appendItems(newItems);
          }
        });
      },
      _areNodesExists: function(newItems, items) {
        var keyOfRootItem = this.keyOf(newItems[0]);
        var fullData = this._dataAdapter.getFullData();
        return !!this._dataAdapter.getNodeByKey(keyOfRootItem, fullData);
      },
      _appendItems: function(newItems) {
        this.option().items = this.option("items").concat(newItems);
        this._initDataAdapter();
      },
      _animateNodeContainer: function(node, state, e, completionCallback) {
        var $node = this._getNodeElement(node);
        var $nodeContainer = $node.children(".".concat(NODE_CONTAINER_CLASS));
        if (node && completionCallback && 0 === $nodeContainer.length) {
          completionCallback.resolve();
        }
        $nodeContainer.addClass(OPENED_NODE_CONTAINER_CLASS);
        var nodeHeight = $nodeContainer.height();
        fx_default.stop($nodeContainer, true);
        fx_default.animate($nodeContainer, {
          type: "custom",
          duration: this.option("animationEnabled") ? 400 : 0,
          from: {
            maxHeight: state ? 0 : nodeHeight
          },
          to: {
            maxHeight: state ? nodeHeight : 0
          },
          complete: (function() {
            $nodeContainer.css("maxHeight", "none");
            $nodeContainer.toggleClass(OPENED_NODE_CONTAINER_CLASS, state);
            this.setAria("expanded", state, $node);
            this.getScrollable().update();
            this._fireExpandedStateUpdatedEvent(state, node, e);
            if (completionCallback) {
              completionCallback.resolve();
            }
          }).bind(this)
        });
      },
      _fireExpandedStateUpdatedEvent: function(isExpanded, node, e) {
        if (!this._hasChildren(node)) {
          return;
        }
        var optionName = isExpanded ? "onItemExpanded" : "onItemCollapsed";
        if (isDefined(e)) {
          this._itemDXEventHandler(e, optionName, {
            node: this._dataAdapter.getPublicNode(node)
          });
        } else {
          var target = this._getNodeElement(node);
          this._itemEventHandler(target, optionName, {
            event: e,
            node: this._dataAdapter.getPublicNode(node)
          });
        }
      },
      _normalizeIconState: function($node, hasNewItems) {
        var $loadIndicator = $node.find(".".concat(NODE_LOAD_INDICATOR_CLASS));
        $loadIndicator.length && load_indicator_default.getInstance($loadIndicator).option("visible", false);
        if (hasNewItems) {
          var $icon = $node.find("." + TOGGLE_ITEM_VISIBILITY_CLASS);
          $icon.show();
          return;
        }
        $node.find("." + TOGGLE_ITEM_VISIBILITY_CLASS).removeClass(TOGGLE_ITEM_VISIBILITY_CLASS);
        $node.addClass(IS_LEAF);
      },
      _emptyMessageContainer: function() {
        var scrollable = this.getScrollable();
        return scrollable ? renderer_default(scrollable.content()) : this.callBase();
      },
      _renderContent: function() {
        var items = this.option("items");
        if (items && items.length) {
          this._contentAlreadyRendered = true;
        }
        this.callBase();
      },
      _renderSelectAllItem: function($container) {
        $container = $container || this.$element().find(".".concat(NODE_CONTAINER_CLASS)).first();
        this._$selectAllItem = renderer_default("<div>").addClass(SELECT_ALL_ITEM_CLASS);
        var value2 = this._dataAdapter.isAllSelected();
        this._createComponent(this._$selectAllItem, check_box_default, {
          value: value2,
          text: this.option("selectAllText"),
          onValueChanged: this._onSelectAllCheckboxValueChanged.bind(this)
        });
        this._toggleSelectedClass(this._$selectAllItem, value2);
        $container.before(this._$selectAllItem);
      },
      _onSelectAllCheckboxValueChanged: function(args) {
        this._toggleSelectAll(args);
        this._fireSelectAllValueChanged(args.value);
      },
      _toggleSelectAll: function(args) {
        this._dataAdapter.toggleSelectAll(args.value);
        this._updateItemsUI();
        this._fireSelectionChanged();
      },
      _renderCheckBox: function($node, node) {
        var $checkbox = renderer_default("<div>").appendTo($node);
        this._createComponent($checkbox, check_box_default, {
          value: node.internalFields.selected,
          onValueChanged: this._changeCheckboxValue.bind(this),
          focusStateEnabled: false,
          disabled: this._disabledGetter(node)
        });
      },
      _toggleSelectedClass: function($node, value2) {
        $node.toggleClass(SELECTED_ITEM_CLASS2, !!value2);
      },
      _toggleNodeDisabledState: function(node, state) {
        var $node = this._getNodeElement(node);
        var $item = $node.find("." + ITEM_CLASS3).eq(0);
        this._dataAdapter.toggleNodeDisabledState(node.internalFields.key, state);
        $item.toggleClass(DISABLED_STATE_CLASS4, !!state);
        if (this._showCheckboxes()) {
          var checkbox = this._getCheckBoxInstance($node);
          checkbox.option("disabled", !!state);
        }
      },
      _itemOptionChanged: function(item, property, value2) {
        var node = this._dataAdapter.getNodeByItem(item);
        if (property === this.option("disabledExpr")) {
          this._toggleNodeDisabledState(node, value2);
        }
      },
      _changeCheckboxValue: function(e) {
        var $node = renderer_default(e.element).parent("." + NODE_CLASS);
        var $item = $node.children("." + ITEM_CLASS3);
        var item = this._getItemData($item);
        var node = this._getNodeByElement($item);
        var value2 = e.value;
        if (node && node.internalFields.selected === value2) {
          return;
        }
        this._updateItemSelection(value2, item, e.event);
      },
      _isSingleSelection: function() {
        return "single" === this.option("selectionMode");
      },
      _isRecursiveSelection: function() {
        return this.option("selectNodesRecursive") && "single" !== this.option("selectionMode");
      },
      _isLastSelectedBranch: function(publicNode, selectedNodesKeys, deep) {
        var keyIndex = selectedNodesKeys.indexOf(publicNode.key);
        if (keyIndex >= 0) {
          selectedNodesKeys.splice(keyIndex, 1);
        }
        if (deep) {
          each(publicNode.children, (function(_2, childNode) {
            this._isLastSelectedBranch(childNode, selectedNodesKeys, true);
          }).bind(this));
        }
        if (publicNode.parent) {
          this._isLastSelectedBranch(publicNode.parent, selectedNodesKeys);
        }
        return 0 === selectedNodesKeys.length;
      },
      _isLastRequired: function(node) {
        var selectionRequired = this.option("selectionRequired");
        var isSingleMode = this._isSingleSelection();
        var selectedNodesKeys = this.getSelectedNodeKeys();
        if (!selectionRequired) {
          return;
        }
        if (isSingleMode) {
          return 1 === selectedNodesKeys.length;
        } else {
          return this._isLastSelectedBranch(node.internalFields.publicNode, selectedNodesKeys.slice(), true);
        }
      },
      _updateItemSelection: function(value2, itemElement, dxEvent) {
        var node = this._getNode(itemElement);
        if (!node || false === node.visible) {
          return false;
        }
        if (node.internalFields.selected === value2) {
          return true;
        }
        if (!value2 && this._isLastRequired(node)) {
          if (this._showCheckboxes()) {
            var $node = this._getNodeElement(node);
            this._getCheckBoxInstance($node).option("value", true);
          }
          return false;
        }
        if (value2 && this._isSingleSelection()) {
          var selectedKeys = this.getSelectedNodeKeys();
          each(selectedKeys, (index2, key) => {
            this._dataAdapter.toggleSelection(key, false);
            this._updateItemsUI();
            this._fireItemSelectionChanged(this._getNode(key));
          });
        }
        this._dataAdapter.toggleSelection(node.internalFields.key, value2);
        var isAllSelected = this._dataAdapter.isAllSelected();
        var needFireSelectAllChanged = this._selectAllEnabled() && this._$selectAllItem.dxCheckBox("instance").option("value") !== isAllSelected;
        this._updateItemsUI();
        this._fireItemSelectionChanged(node, dxEvent);
        this._fireSelectionChanged();
        if (needFireSelectAllChanged) {
          this._fireSelectAllValueChanged(isAllSelected);
        }
        return true;
      },
      _fireItemSelectionChanged: function(node, dxEvent) {
        var initiator = dxEvent || this._findItemElementByItem(node.internalFields.item);
        var handler = dxEvent ? this._itemDXEventHandler : this._itemEventHandler;
        handler.call(this, initiator, "onItemSelectionChanged", {
          node: this._dataAdapter.getPublicNode(node),
          itemData: node.internalFields.item
        });
      },
      _getCheckBoxInstance: function($node) {
        return $node.children(".dx-checkbox").dxCheckBox("instance");
      },
      _updateItemsUI: function() {
        var cache = {};
        each(this._dataAdapter.getData(), (_2, node) => {
          var $node = this._getNodeElement(node, cache);
          var nodeSelection = node.internalFields.selected;
          if (!$node.length) {
            return;
          }
          this._toggleSelectedClass($node, nodeSelection);
          this.setAria("selected", nodeSelection, $node);
          if (this._showCheckboxes()) {
            this._getCheckBoxInstance($node).option("value", nodeSelection);
          }
        });
        if (this._selectAllEnabled()) {
          var selectAllCheckbox = this._$selectAllItem.dxCheckBox("instance");
          selectAllCheckbox.option("onValueChanged", void 0);
          selectAllCheckbox.option("value", this._dataAdapter.isAllSelected());
          selectAllCheckbox.option("onValueChanged", this._onSelectAllCheckboxValueChanged.bind(this));
        }
      },
      _updateParentsState: function(node, $node) {
        if (!$node) {
          return;
        }
        var parentNode = this._dataAdapter.getNodeByKey(node.internalFields.parentKey);
        var $parentNode = renderer_default($node.parents("." + NODE_CLASS)[0]);
        if (this._showCheckboxes()) {
          var parentValue = parentNode.internalFields.selected;
          this._getCheckBoxInstance($parentNode).option("value", parentValue);
          this._toggleSelectedClass($parentNode, parentValue);
        }
        if (parentNode.internalFields.parentKey !== this.option("rootValue")) {
          this._updateParentsState(parentNode, $parentNode);
        }
      },
      _itemEventHandlerImpl: function(initiator, action, actionArgs) {
        var $itemElement = renderer_default(initiator).closest("." + NODE_CLASS).children("." + ITEM_CLASS3);
        return action(extend2(this._extendActionArgs($itemElement), actionArgs));
      },
      _itemContextMenuHandler: function(e) {
        this._createEventHandler("onItemContextMenu", e);
      },
      _itemHoldHandler: function(e) {
        this._createEventHandler("onItemHold", e);
      },
      _createEventHandler: function(eventName, e) {
        var node = this._getNodeByElement(e.currentTarget);
        this._itemDXEventHandler(e, eventName, {
          node: this._dataAdapter.getPublicNode(node)
        });
      },
      _itemClass: function() {
        return ITEM_CLASS3;
      },
      _itemDataKey: function() {
        return ITEM_DATA_KEY2;
      },
      _attachClickEvent: function() {
        var clickSelector = "." + this._itemClass();
        var pointerDownSelector = "." + NODE_CLASS + ", ." + SELECT_ALL_ITEM_CLASS;
        var eventName = addNamespace2(CLICK_EVENT_NAME, this.NAME);
        var pointerDownEvent = addNamespace2(pointer_default.down, this.NAME);
        var $itemContainer = this._itemContainer();
        var that = this;
        events_engine_default.off($itemContainer, eventName, clickSelector);
        events_engine_default.off($itemContainer, pointerDownEvent, pointerDownSelector);
        events_engine_default.on($itemContainer, eventName, clickSelector, function(e) {
          that._itemClickHandler(e, renderer_default(this));
        });
        events_engine_default.on($itemContainer, pointerDownEvent, pointerDownSelector, function(e) {
          that._itemPointerDownHandler(e);
        });
      },
      _itemClickHandler: function(e, $item) {
        var itemData = this._getItemData($item);
        var node = this._getNodeByElement($item);
        this._itemDXEventHandler(e, "onItemClick", {
          node: this._dataAdapter.getPublicNode(node)
        });
        if (this.option("selectByClick") && !e.isDefaultPrevented()) {
          this._updateItemSelection(!node.internalFields.selected, itemData, e);
        }
      },
      _updateSelectionToFirstItem: function($items, startIndex) {
        var itemIndex = startIndex;
        while (itemIndex >= 0) {
          var $item = renderer_default($items[itemIndex]);
          this._updateItemSelection(true, $item.find("." + ITEM_CLASS3).get(0));
          itemIndex--;
        }
      },
      _updateSelectionToLastItem: function($items, startIndex) {
        var length = $items.length;
        var itemIndex = startIndex;
        while (itemIndex < length) {
          var $item = renderer_default($items[itemIndex]);
          this._updateItemSelection(true, $item.find("." + ITEM_CLASS3).get(0));
          itemIndex++;
        }
      },
      _focusInHandler: function(e) {
        this._updateFocusState(e, true);
        if (this.option("focusedElement")) {
          clearTimeout(this._setFocusedItemTimeout);
          this._setFocusedItemTimeout = setTimeout(() => {
            this._setFocusedItem(renderer_default(this.option("focusedElement")));
          });
          return;
        }
        var $activeItem = this._getActiveItem();
        this.option("focusedElement", getPublicElement($activeItem.closest("." + NODE_CLASS)));
      },
      _setFocusedItem: function($target) {
        if (!$target || !$target.length) {
          return;
        }
        if (!$target.children().hasClass(DISABLED_STATE_CLASS4)) {
          this.callBase($target);
        }
      },
      _itemPointerDownHandler: function(e) {
        if (!this.option("focusStateEnabled")) {
          return;
        }
        var $target = renderer_default(e.target).closest("." + NODE_CLASS + ", ." + SELECT_ALL_ITEM_CLASS);
        if (!$target.length) {
          return;
        }
        var itemElement = $target.hasClass(DISABLED_STATE_CLASS4) ? null : $target;
        this.option("focusedElement", getPublicElement(itemElement));
      },
      _findNonDisabledNodes: function($nodes) {
        return $nodes.not(function() {
          return renderer_default(this).children("." + ITEM_CLASS3).hasClass(DISABLED_STATE_CLASS4);
        });
      },
      _moveFocus: function(location, e) {
        var FOCUS_UP4 = "up";
        var FOCUS_DOWN4 = "down";
        var FOCUS_FIRST3 = "first";
        var FOCUS_LAST3 = "last";
        var FOCUS_LEFT4 = this.option("rtlEnabled") ? "right" : "left";
        var FOCUS_RIGHT4 = this.option("rtlEnabled") ? "left" : "right";
        this.$element().find(".".concat(NODE_CONTAINER_CLASS)).each(function() {
          fx_default.stop(this, true);
        });
        var $items = this._findNonDisabledNodes(this._nodeElements());
        if (!$items || !$items.length) {
          return;
        }
        switch (location) {
          case FOCUS_UP4:
            var $prevItem = this._prevItem($items);
            this.option("focusedElement", getPublicElement($prevItem));
            var prevItemElement = this._getNodeItemElement($prevItem);
            this.getScrollable().scrollToElement(prevItemElement);
            if (e.shiftKey && this._showCheckboxes()) {
              this._updateItemSelection(true, prevItemElement);
            }
            break;
          case FOCUS_DOWN4:
            var $nextItem = this._nextItem($items);
            this.option("focusedElement", getPublicElement($nextItem));
            var nextItemElement = this._getNodeItemElement($nextItem);
            this.getScrollable().scrollToElement(nextItemElement);
            if (e.shiftKey && this._showCheckboxes()) {
              this._updateItemSelection(true, nextItemElement);
            }
            break;
          case FOCUS_FIRST3:
            var $firstItem = $items.first();
            if (e.shiftKey && this._showCheckboxes()) {
              this._updateSelectionToFirstItem($items, $items.index(this._prevItem($items)));
            }
            this.option("focusedElement", getPublicElement($firstItem));
            this.getScrollable().scrollToElement(this._getNodeItemElement($firstItem));
            break;
          case FOCUS_LAST3:
            var $lastItem = $items.last();
            if (e.shiftKey && this._showCheckboxes()) {
              this._updateSelectionToLastItem($items, $items.index(this._nextItem($items)));
            }
            this.option("focusedElement", getPublicElement($lastItem));
            this.getScrollable().scrollToElement(this._getNodeItemElement($lastItem));
            break;
          case FOCUS_RIGHT4:
            this._expandFocusedContainer();
            break;
          case FOCUS_LEFT4:
            this._collapseFocusedContainer();
            break;
          default:
            this.callBase.apply(this, arguments);
            return;
        }
      },
      _getNodeItemElement: function($node) {
        return $node.find("." + ITEM_CLASS3).get(0);
      },
      _nodeElements: function() {
        return this.$element().find("." + NODE_CLASS).not(":hidden");
      },
      _expandFocusedContainer: function() {
        var $focusedNode = renderer_default(this.option("focusedElement"));
        if (!$focusedNode.length || $focusedNode.hasClass(IS_LEAF)) {
          return;
        }
        var $node = $focusedNode.find(".".concat(NODE_CONTAINER_CLASS)).eq(0);
        if ($node.hasClass(OPENED_NODE_CONTAINER_CLASS)) {
          var $nextItem = this._nextItem(this._findNonDisabledNodes(this._nodeElements()));
          this.option("focusedElement", getPublicElement($nextItem));
          this.getScrollable().scrollToElement(this._getNodeItemElement($nextItem));
          return;
        }
        var node = this._getNodeByElement($focusedNode.children("." + ITEM_CLASS3));
        this._toggleExpandedState(node, true);
      },
      _getClosestNonDisabledNode: function($node) {
        do {
          $node = $node.parent().closest("." + NODE_CLASS);
        } while ($node.children(".dx-treeview-item.dx-state-disabled").length);
        return $node;
      },
      _collapseFocusedContainer: function() {
        var $focusedNode = renderer_default(this.option("focusedElement"));
        if (!$focusedNode.length) {
          return;
        }
        var nodeElement = $focusedNode.find(".".concat(NODE_CONTAINER_CLASS)).eq(0);
        if (!$focusedNode.hasClass(IS_LEAF) && nodeElement.hasClass(OPENED_NODE_CONTAINER_CLASS)) {
          var node = this._getNodeByElement($focusedNode.children("." + ITEM_CLASS3));
          this._toggleExpandedState(node, false);
        } else {
          var collapsedNode = this._getClosestNonDisabledNode($focusedNode);
          collapsedNode.length && this.option("focusedElement", getPublicElement(collapsedNode));
          this.getScrollable().scrollToElement(this._getNodeItemElement(collapsedNode));
        }
      },
      _encodeString: function(value2) {
        return isString2(value2) ? encodeURI(value2) : value2;
      },
      _decodeString: function(value2) {
        return isString2(value2) ? decodeURI(value2) : value2;
      },
      getScrollable: function() {
        return this._scrollable;
      },
      updateDimensions: function() {
        var deferred = new Deferred();
        var scrollable = this.getScrollable();
        if (scrollable) {
          scrollable.update().done(() => {
            deferred.resolveWith(this);
          });
        } else {
          deferred.resolveWith(this);
        }
        return deferred.promise();
      },
      selectItem: function(itemElement) {
        return this._updateItemSelection(true, itemElement);
      },
      unselectItem: function(itemElement) {
        return this._updateItemSelection(false, itemElement);
      },
      expandItem: function(itemElement) {
        return this._toggleExpandedState(itemElement, true);
      },
      collapseItem: function(itemElement) {
        return this._toggleExpandedState(itemElement, false);
      },
      getNodes: function() {
        return this._dataAdapter.getTreeNodes();
      },
      getSelectedNodes: function() {
        return this.getSelectedNodeKeys().map((key) => {
          var node = this._dataAdapter.getNodeByKey(key);
          return this._dataAdapter.getPublicNode(node);
        });
      },
      getSelectedNodesKeys: function() {
        ui_errors_default.log("W0002", "dxTreeView", "getSelectedNodesKeys", "20.1", "Use the 'getSelectedNodeKeys' method instead");
        return this.getSelectedNodeKeys();
      },
      getSelectedNodeKeys: function() {
        return this._dataAdapter.getSelectedNodesKeys();
      },
      selectAll: function() {
        if (this._selectAllEnabled()) {
          this._$selectAllItem.dxCheckBox("instance").option("value", true);
        } else {
          this._toggleSelectAll({
            value: true
          });
        }
      },
      unselectAll: function() {
        if (this._selectAllEnabled()) {
          this._$selectAllItem.dxCheckBox("instance").option("value", false);
        } else {
          this._toggleSelectAll({
            value: false
          });
        }
      },
      expandAll: function() {
        var dataAdapter = this._dataAdapter;
        each(dataAdapter.getData(), (_2, node) => dataAdapter.toggleExpansion(node.internalFields.key, true));
        this.repaint();
      },
      collapseAll: function() {
        each(this._dataAdapter.getExpandedNodesKeys(), (function(_2, key) {
          this._toggleExpandedState(key, false);
        }).bind(this));
      },
      scrollToItem: function(keyOrItemOrElement) {
        var node = this._getNode(keyOrItemOrElement);
        if (!node) {
          return new Deferred().reject().promise();
        }
        var nodeKeysToExpand = [];
        var parentNode = node.internalFields.publicNode.parent;
        while (null != parentNode) {
          if (!parentNode.expanded) {
            nodeKeysToExpand.push(parentNode.key);
          }
          parentNode = parentNode.parent;
        }
        var scrollCallback = new Deferred();
        this._expandNodes(nodeKeysToExpand.reverse()).always(() => {
          var $element = this._getNodeElement(node);
          if ($element && $element.length) {
            this.scrollToElementTopLeft($element.get(0));
            scrollCallback.resolve();
          } else {
            scrollCallback.reject();
          }
        });
        return scrollCallback.promise();
      },
      scrollToElementTopLeft: function(targetElement) {
        var scrollable = this.getScrollable();
        var {
          scrollDirection,
          rtlEnabled
        } = this.option();
        var targetLocation = {
          top: 0,
          left: 0
        };
        var relativeOffset = getRelativeOffset(SCROLLABLE_CONTENT_CLASS, targetElement);
        if (scrollDirection !== DIRECTION_VERTICAL) {
          var containerElement = renderer_default(scrollable.container()).get(0);
          targetLocation.left = rtlEnabled ? relativeOffset.left + targetElement.offsetWidth - containerElement.clientWidth : relativeOffset.left;
        }
        if (scrollDirection !== DIRECTION_HORIZONTAL) {
          targetLocation.top = relativeOffset.top;
        }
        scrollable.scrollTo(targetLocation);
      },
      _expandNodes: function(keysToExpand) {
        if (!keysToExpand || 0 === keysToExpand.length) {
          return new Deferred().resolve().promise();
        }
        var resultCallback = new Deferred();
        var callbacksByNodes = keysToExpand.map((key) => this.expandItem(key));
        when.apply(renderer_default, callbacksByNodes).done(() => resultCallback.resolve()).fail(() => resultCallback.reject());
        return resultCallback.promise();
      },
      _dispose: function() {
        this.callBase();
        clearTimeout(this._setFocusedItemTimeout);
      }
    });
    ui_tree_view_base_default = TreeViewBase;
  }
});

// node_modules/devextreme/esm/ui/tree_view/ui.tree_view.search.js
var WIDGET_CLASS2, NODE_CONTAINER_CLASS2, TreeViewSearch, ui_tree_view_search_default;
var init_ui_tree_view_search = __esm({
  "node_modules/devextreme/esm/ui/tree_view/ui.tree_view.search.js"() {
    init_renderer();
    init_component_registrator();
    init_ui_search_box_mixin();
    init_extend();
    init_ui_tree_view_base();
    WIDGET_CLASS2 = "dx-treeview";
    NODE_CONTAINER_CLASS2 = "".concat(WIDGET_CLASS2, "-node-container");
    TreeViewSearch = ui_tree_view_base_default.inherit(ui_search_box_mixin_default).inherit({
      _addWidgetPrefix: function(className) {
        return "".concat(WIDGET_CLASS2, "-").concat(className);
      },
      _optionChanged: function(args) {
        switch (args.name) {
          case "searchValue":
            if (this._showCheckboxes() && this._isRecursiveSelection()) {
              this._removeSelection();
            }
            this._initDataAdapter();
            this._updateSearch();
            this._repaintContainer();
            this.option("focusedElement", null);
            break;
          case "searchExpr":
            this._initDataAdapter();
            this.repaint();
            break;
          case "searchMode":
            this.option("expandNodesRecursive") ? this._updateDataAdapter() : this._initDataAdapter();
            this.repaint();
            break;
          default:
            this.callBase(args);
        }
      },
      _updateDataAdapter: function() {
        this._setOptionWithoutOptionChange("expandNodesRecursive", false);
        this._initDataAdapter();
        this._setOptionWithoutOptionChange("expandNodesRecursive", true);
      },
      _getDataAdapterOptions: function() {
        return extend2(this.callBase(), {
          searchValue: this.option("searchValue"),
          searchMode: this.option("searchMode") || "contains",
          searchExpr: this.option("searchExpr")
        });
      },
      _updateSearch: function() {
        if (this._searchEditor) {
          var editorOptions = this._getSearchEditorOptions();
          this._searchEditor.option(editorOptions);
        }
      },
      _repaintContainer: function() {
        var $container = this.$element().find(".".concat(NODE_CONTAINER_CLASS2)).first();
        var rootNodes;
        if ($container.length) {
          $container.empty();
          rootNodes = this._dataAdapter.getRootNodes();
          this._renderEmptyMessage(rootNodes);
          this._renderItems($container, rootNodes);
          this._fireContentReadyAction();
        }
      },
      _itemContainer: function(isSearchMode) {
        if (this._scrollable && isSearchMode) {
          return renderer_default(this._scrollable.content());
        }
        return this.callBase();
      },
      _addWidgetClass: function() {
        this.$element().addClass(this._widgetClass());
      },
      _clean: function() {
        this.callBase();
        this._removeSearchBox();
      }
    });
    component_registrator_default("dxTreeView", TreeViewSearch);
    ui_tree_view_search_default = TreeViewSearch;
  }
});

// node_modules/devextreme/esm/ui/tree_view.js
var tree_view_default;
var init_tree_view = __esm({
  "node_modules/devextreme/esm/ui/tree_view.js"() {
    init_ui_tree_view_search();
    tree_view_default = ui_tree_view_search_default;
  }
});

// node_modules/devextreme/esm/ui/grid_core/ui.grid_core.column_chooser.js
var COLUMN_CHOOSER_CLASS, COLUMN_CHOOSER_BUTTON_CLASS, NOTOUCH_ACTION_CLASS, COLUMN_CHOOSER_LIST_CLASS, COLUMN_CHOOSER_PLAIN_CLASS, COLUMN_CHOOSER_DRAG_CLASS, COLUMN_CHOOSER_SELECT_CLASS, COLUMN_CHOOSER_ICON_NAME, COLUMN_CHOOSER_ITEM_CLASS, TREEVIEW_NODE_SELECTOR, CHECKBOX_SELECTOR, CLICK_TIMEOUT, processItems, ColumnChooserController, ColumnChooserView, columnChooserModule;
var init_ui_grid_core_column_chooser = __esm({
  "node_modules/devextreme/esm/ui/grid_core/ui.grid_core.column_chooser.js"() {
    init_renderer();
    init_common();
    init_ui_grid_core_modules();
    init_ui_grid_core_columns_view();
    init_message();
    init_themes();
    init_button();
    init_tree_view();
    init_devices();
    init_popup();
    init_type();
    init_extend();
    init_iterator();
    COLUMN_CHOOSER_CLASS = "column-chooser";
    COLUMN_CHOOSER_BUTTON_CLASS = "column-chooser-button";
    NOTOUCH_ACTION_CLASS = "notouch-action";
    COLUMN_CHOOSER_LIST_CLASS = "column-chooser-list";
    COLUMN_CHOOSER_PLAIN_CLASS = "column-chooser-plain";
    COLUMN_CHOOSER_DRAG_CLASS = "column-chooser-mode-drag";
    COLUMN_CHOOSER_SELECT_CLASS = "column-chooser-mode-select";
    COLUMN_CHOOSER_ICON_NAME = "column-chooser";
    COLUMN_CHOOSER_ITEM_CLASS = "dx-column-chooser-item";
    TREEVIEW_NODE_SELECTOR = ".dx-treeview-node";
    CHECKBOX_SELECTOR = ".dx-checkbox";
    CLICK_TIMEOUT = 300;
    processItems = function(that, chooserColumns) {
      var items = [];
      var isSelectMode = "select" === that.option("columnChooser.mode");
      if (chooserColumns.length) {
        each(chooserColumns, function(index2, column) {
          var item = {
            text: column.caption,
            cssClass: column.cssClass,
            allowHiding: column.allowHiding,
            expanded: true,
            id: column.index,
            disabled: false,
            disableCheckBox: false === column.allowHiding,
            parentId: isDefined(column.ownerBand) ? column.ownerBand : null
          };
          if (isSelectMode) {
            item.selected = column.visible;
          }
          items.push(item);
        });
      }
      return items;
    };
    ColumnChooserController = ui_grid_core_modules_default.ViewController.inherit({
      renderShowColumnChooserButton: function($element) {
        var that = this;
        var columnChooserButtonClass = that.addWidgetPrefix(COLUMN_CHOOSER_BUTTON_CLASS);
        var columnChooserEnabled = that.option("columnChooser.enabled");
        var $showColumnChooserButton = $element.find("." + columnChooserButtonClass);
        var $columnChooserButton;
        if (columnChooserEnabled) {
          if (!$showColumnChooserButton.length) {
            $columnChooserButton = renderer_default("<div>").addClass(columnChooserButtonClass).appendTo($element);
            that._createComponent($columnChooserButton, button_default, {
              icon: COLUMN_CHOOSER_ICON_NAME,
              onClick: function() {
                that.getView("columnChooserView").showColumnChooser();
              },
              hint: that.option("columnChooser.title"),
              integrationOptions: {}
            });
          } else {
            $showColumnChooserButton.show();
          }
        } else {
          $showColumnChooserButton.hide();
        }
      },
      getPosition: function() {
        var rowsView = this.getView("rowsView");
        return {
          my: "right bottom",
          at: "right bottom",
          of: rowsView && rowsView.element(),
          collision: "fit",
          offset: "-2 -2",
          boundaryOffset: "2 2"
        };
      }
    });
    ColumnChooserView = ColumnsView.inherit({
      _resizeCore: noop2,
      _isWinDevice: function() {
        return !!devices_default.real().win;
      },
      _updateList: function(change) {
        var items;
        var $popupContent = this._popupContainer.$content();
        var isSelectMode = "select" === this.option("columnChooser.mode");
        var columnChooserList = this._columnChooserList;
        var chooserColumns = this._columnsController.getChooserColumns(isSelectMode);
        if (isSelectMode && columnChooserList && change && "selection" === change.changeType) {
          items = processItems(this, chooserColumns);
          for (var i = 0; i < items.length; i++) {
            var selected = items[i].selected;
            var id = items[i].id;
            if (id === change.columnIndex) {
              if (selected) {
                columnChooserList.selectItem(id, selected);
              } else {
                columnChooserList.unselectItem(id, selected);
              }
            }
          }
        } else if (!isSelectMode || !columnChooserList || "full" === change) {
          this._popupContainer.$wrapper().toggleClass(this.addWidgetPrefix(COLUMN_CHOOSER_DRAG_CLASS), !isSelectMode).toggleClass(this.addWidgetPrefix(COLUMN_CHOOSER_SELECT_CLASS), isSelectMode);
          items = processItems(this, chooserColumns);
          this._renderTreeView($popupContent, items);
        }
      },
      _initializePopupContainer: function() {
        var that = this;
        var $element = that.element().addClass(that.addWidgetPrefix(COLUMN_CHOOSER_CLASS));
        var columnChooserOptions = that.option("columnChooser");
        var themeName = current();
        var isGenericTheme = isGeneric(themeName);
        var isMaterial2 = isMaterial(themeName);
        var dxPopupOptions = {
          visible: false,
          shading: false,
          showCloseButton: false,
          dragEnabled: true,
          resizeEnabled: true,
          toolbarItems: [{
            text: columnChooserOptions.title,
            toolbar: "top",
            location: isGenericTheme || isMaterial2 ? "before" : "center"
          }],
          position: that.getController("columnChooser").getPosition(),
          width: columnChooserOptions.width,
          height: columnChooserOptions.height,
          rtlEnabled: that.option("rtlEnabled"),
          onHidden: function() {
            if (that._isWinDevice()) {
              renderer_default("body").removeClass(that.addWidgetPrefix(NOTOUCH_ACTION_CLASS));
            }
          },
          container: columnChooserOptions.container
        };
        if (isGenericTheme || isMaterial2) {
          extend2(dxPopupOptions, {
            showCloseButton: true
          });
        } else {
          dxPopupOptions.toolbarItems[dxPopupOptions.toolbarItems.length] = {
            shortcut: "cancel"
          };
        }
        if (!isDefined(this._popupContainer)) {
          that._popupContainer = that._createComponent($element, popup_default, dxPopupOptions);
          that._popupContainer.on("optionChanged", function(args) {
            if ("visible" === args.name) {
              that.renderCompleted.fire();
            }
          });
        } else {
          this._popupContainer.option(dxPopupOptions);
        }
      },
      _renderCore: function(change) {
        if (this._popupContainer) {
          this._updateList(change);
        }
      },
      _renderTreeView: function($container, items) {
        var that = this;
        var columnChooser = this.option("columnChooser");
        var isSelectMode = "select" === columnChooser.mode;
        var treeViewConfig = {
          items,
          dataStructure: "plain",
          activeStateEnabled: true,
          focusStateEnabled: true,
          hoverStateEnabled: true,
          itemTemplate: "item",
          showCheckBoxesMode: "none",
          rootValue: null,
          searchEnabled: columnChooser.allowSearch,
          searchTimeout: columnChooser.searchTimeout,
          onItemRendered: function(e) {
            if (e.itemData.disableCheckBox) {
              var $treeViewNode = renderer_default(e.itemElement).closest(TREEVIEW_NODE_SELECTOR);
              var $checkBox;
              if ($treeViewNode.length) {
                $checkBox = $treeViewNode.find(CHECKBOX_SELECTOR);
                if ($checkBox.length) {
                  var checkBoxInstance = $checkBox.data("dxCheckBox");
                  checkBoxInstance && checkBoxInstance.option("disabled", true);
                }
              }
            }
          }
        };
        var scrollableInstance = $container.find(".dx-scrollable").data("dxScrollable");
        var scrollTop = scrollableInstance && scrollableInstance.scrollTop();
        if (isSelectMode && !this._columnsController.isBandColumnsUsed()) {
          $container.addClass(this.addWidgetPrefix(COLUMN_CHOOSER_PLAIN_CLASS));
        }
        treeViewConfig.onContentReady = function(e) {
          deferUpdate(function() {
            if (scrollTop) {
              var scrollable = renderer_default(e.element).find(".dx-scrollable").data("dxScrollable");
              scrollable && scrollable.scrollTo({
                y: scrollTop
              });
            }
            that.renderCompleted.fire();
          });
        };
        if (this._isWinDevice()) {
          treeViewConfig.useNativeScrolling = false;
        }
        extend2(treeViewConfig, isSelectMode ? this._prepareSelectModeConfig() : this._prepareDragModeConfig());
        if (this._columnChooserList) {
          if (!treeViewConfig.searchEnabled) {
            treeViewConfig.searchValue = "";
          }
          this._columnChooserList.option(treeViewConfig);
        } else {
          this._columnChooserList = this._createComponent($container, tree_view_default, treeViewConfig);
          $container.addClass(this.addWidgetPrefix(COLUMN_CHOOSER_LIST_CLASS));
        }
      },
      _prepareDragModeConfig: function() {
        var columnChooserOptions = this.option("columnChooser");
        return {
          noDataText: columnChooserOptions.emptyPanelText,
          activeStateEnabled: false,
          focusStateEnabled: false,
          hoverStateEnabled: false,
          itemTemplate: function(data2, index2, item) {
            renderer_default(item).text(data2.text).parent().addClass(data2.cssClass).addClass(COLUMN_CHOOSER_ITEM_CLASS);
          }
        };
      },
      _prepareSelectModeConfig: function() {
        var that = this;
        return {
          selectNodesRecursive: false,
          showCheckBoxesMode: "normal",
          onItemSelectionChanged: function(e) {
            var visibleColumns = that._columnsController.getVisibleColumns().filter(function(item) {
              return !item.command;
            });
            var isLastColumnUnselected = 1 === visibleColumns.length && !e.itemData.selected;
            if (isLastColumnUnselected) {
              e.component.selectItem(e.itemElement);
            } else {
              setTimeout(function() {
                that._columnsController.columnOption(e.itemData.id, "visible", e.itemData.selected);
              }, CLICK_TIMEOUT);
            }
          }
        };
      },
      _columnOptionChanged: function(e) {
        var changeTypes = e.changeTypes;
        var optionNames = e.optionNames;
        var isSelectMode = "select" === this.option("columnChooser.mode");
        this.callBase(e);
        if (isSelectMode) {
          var needPartialRender = optionNames.visible && 1 === optionNames.length && void 0 !== e.columnIndex;
          var needFullRender = optionNames.showInColumnChooser || optionNames.caption || optionNames.visible || changeTypes.columns && optionNames.all;
          if (needPartialRender) {
            this.render(null, {
              changeType: "selection",
              columnIndex: e.columnIndex
            });
          } else if (needFullRender) {
            this.render(null, "full");
          }
        }
      },
      optionChanged: function(args) {
        switch (args.name) {
          case "columnChooser":
            this._initializePopupContainer();
            this.render(null, "full");
            break;
          default:
            this.callBase(args);
        }
      },
      getColumnElements: function() {
        var result2 = [];
        var $node;
        var isSelectMode = "select" === this.option("columnChooser.mode");
        var chooserColumns = this._columnsController.getChooserColumns(isSelectMode);
        var $content = this._popupContainer && this._popupContainer.$content();
        var $nodes = $content && $content.find(".dx-treeview-node");
        if ($nodes) {
          chooserColumns.forEach(function(column) {
            $node = $nodes.filter("[data-item-id = '" + column.index + "']");
            var item = $node.length ? $node.children("." + COLUMN_CHOOSER_ITEM_CLASS).get(0) : null;
            result2.push(item);
          });
        }
        return renderer_default(result2);
      },
      getName: function() {
        return "columnChooser";
      },
      getColumns: function() {
        return this._columnsController.getChooserColumns();
      },
      allowDragging: function(column, sourceLocation) {
        var columnVisible = column && column.allowHiding && ("columnChooser" !== sourceLocation || !column.visible && this._columnsController.isParentColumnVisible(column.index));
        return this.isColumnChooserVisible() && columnVisible;
      },
      getBoundingRect: function() {
        var container = this._popupContainer && this._popupContainer.$overlayContent();
        if (container && container.is(":visible")) {
          var offset2 = container.offset();
          return {
            left: offset2.left,
            top: offset2.top,
            right: offset2.left + container.outerWidth(),
            bottom: offset2.top + container.outerHeight()
          };
        }
        return null;
      },
      showColumnChooser: function() {
        if (!this._popupContainer) {
          this._initializePopupContainer();
          this.render();
        }
        this._popupContainer.show();
        if (this._isWinDevice()) {
          renderer_default("body").addClass(this.addWidgetPrefix(NOTOUCH_ACTION_CLASS));
        }
      },
      hideColumnChooser: function() {
        if (this._popupContainer) {
          this._popupContainer.hide();
        }
      },
      isColumnChooserVisible: function() {
        var popupContainer = this._popupContainer;
        return popupContainer && popupContainer.option("visible");
      },
      publicMethods: function() {
        return ["showColumnChooser", "hideColumnChooser"];
      }
    });
    columnChooserModule = {
      defaultOptions: function() {
        return {
          columnChooser: {
            enabled: false,
            allowSearch: false,
            searchTimeout: 500,
            mode: "dragAndDrop",
            width: 250,
            height: 260,
            title: message_default.format("dxDataGrid-columnChooserTitle"),
            emptyPanelText: message_default.format("dxDataGrid-columnChooserEmptyText"),
            container: void 0
          }
        };
      },
      controllers: {
        columnChooser: ColumnChooserController
      },
      views: {
        columnChooserView: ColumnChooserView
      },
      extenders: {
        views: {
          headerPanel: {
            _getToolbarItems: function() {
              var items = this.callBase();
              return this._appendColumnChooserItem(items);
            },
            _appendColumnChooserItem: function(items) {
              var that = this;
              var columnChooserEnabled = that.option("columnChooser.enabled");
              if (columnChooserEnabled) {
                var hintText = that.option("columnChooser.title");
                var toolbarItem = {
                  widget: "dxButton",
                  options: {
                    icon: COLUMN_CHOOSER_ICON_NAME,
                    onClick: function() {
                      that.component.getView("columnChooserView").showColumnChooser();
                    },
                    hint: hintText,
                    text: hintText,
                    onInitialized: function(e) {
                      renderer_default(e.element).addClass(that._getToolbarButtonClass(that.addWidgetPrefix(COLUMN_CHOOSER_BUTTON_CLASS)));
                    }
                  },
                  showText: "inMenu",
                  location: "after",
                  name: "columnChooserButton",
                  locateInMenu: "auto",
                  sortIndex: 40
                };
                items.push(toolbarItem);
              }
              return items;
            },
            optionChanged: function(args) {
              switch (args.name) {
                case "columnChooser":
                  this._invalidate();
                  args.handled = true;
                  break;
                default:
                  this.callBase(args);
              }
            },
            isVisible: function() {
              var columnChooserEnabled = this.option("columnChooser.enabled");
              return this.callBase() || columnChooserEnabled;
            }
          }
        },
        controllers: {
          columns: {
            allowMoveColumn: function(fromVisibleIndex, toVisibleIndex, sourceLocation, targetLocation) {
              var columnChooserMode = this.option("columnChooser.mode");
              var isMoveColumnDisallowed = "select" === columnChooserMode && "columnChooser" === targetLocation;
              return isMoveColumnDisallowed ? false : this.callBase(fromVisibleIndex, toVisibleIndex, sourceLocation, targetLocation);
            }
          }
        }
      }
    };
  }
});

// node_modules/devextreme/esm/ui/grid_core/ui.grid_core.master_detail.js
var MASTER_DETAIL_CELL_CLASS, MASTER_DETAIL_ROW_CLASS, CELL_FOCUS_DISABLED_CLASS, ROW_LINES_CLASS, masterDetailModule;
var init_ui_grid_core_master_detail = __esm({
  "node_modules/devextreme/esm/ui/grid_core/ui.grid_core.master_detail.js"() {
    init_renderer();
    init_ui_grid_core_utils();
    init_common();
    init_iterator();
    init_type();
    init_deferred();
    MASTER_DETAIL_CELL_CLASS = "dx-master-detail-cell";
    MASTER_DETAIL_ROW_CLASS = "dx-master-detail-row";
    CELL_FOCUS_DISABLED_CLASS = "dx-cell-focus-disabled";
    ROW_LINES_CLASS = "dx-row-lines";
    masterDetailModule = {
      defaultOptions: function() {
        return {
          masterDetail: {
            enabled: false,
            autoExpandAll: false,
            template: null
          }
        };
      },
      extenders: {
        controllers: {
          columns: {
            _getExpandColumnsCore: function() {
              var expandColumns = this.callBase();
              if (this.option("masterDetail.enabled")) {
                expandColumns.push({
                  type: "detailExpand",
                  cellTemplate: ui_grid_core_utils_default.getExpandCellTemplate()
                });
              }
              return expandColumns;
            }
          },
          data: /* @__PURE__ */ function() {
            var initMasterDetail = function(that) {
              that._expandedItems = [];
              that._isExpandAll = that.option("masterDetail.autoExpandAll");
            };
            return {
              init: function() {
                initMasterDetail(this);
                this.callBase();
              },
              expandAll: function(groupIndex) {
                var that = this;
                if (groupIndex < 0) {
                  that._isExpandAll = true;
                  that._expandedItems = [];
                  that.updateItems();
                } else {
                  that.callBase.apply(that, arguments);
                }
              },
              collapseAll: function(groupIndex) {
                var that = this;
                if (groupIndex < 0) {
                  that._isExpandAll = false;
                  that._expandedItems = [];
                  that.updateItems();
                } else {
                  that.callBase.apply(that, arguments);
                }
              },
              isRowExpanded: function(key) {
                var that = this;
                var expandIndex = ui_grid_core_utils_default.getIndexByKey(key, that._expandedItems);
                if (Array.isArray(key)) {
                  return that.callBase.apply(that, arguments);
                } else {
                  return !!(that._isExpandAll ^ (expandIndex >= 0 && that._expandedItems[expandIndex].visible));
                }
              },
              _getRowIndicesForExpand: function(key) {
                var rowIndex = this.getRowIndexByKey(key);
                return [rowIndex, rowIndex + 1];
              },
              _changeRowExpandCore: function(key) {
                var that = this;
                var result2;
                if (Array.isArray(key)) {
                  result2 = that.callBase.apply(that, arguments);
                } else {
                  var expandIndex = ui_grid_core_utils_default.getIndexByKey(key, that._expandedItems);
                  if (expandIndex >= 0) {
                    var visible2 = that._expandedItems[expandIndex].visible;
                    that._expandedItems[expandIndex].visible = !visible2;
                  } else {
                    that._expandedItems.push({
                      key,
                      visible: true
                    });
                  }
                  that.updateItems({
                    changeType: "update",
                    rowIndices: that._getRowIndicesForExpand(key)
                  });
                  result2 = new Deferred().resolve();
                }
                return result2;
              },
              _processDataItem: function(data2, options2) {
                var that = this;
                var dataItem = that.callBase.apply(that, arguments);
                dataItem.isExpanded = that.isRowExpanded(dataItem.key);
                if (void 0 === options2.detailColumnIndex) {
                  options2.detailColumnIndex = -1;
                  each(options2.visibleColumns, function(index2, column) {
                    if ("expand" === column.command && !isDefined(column.groupIndex)) {
                      options2.detailColumnIndex = index2;
                      return false;
                    }
                  });
                }
                if (options2.detailColumnIndex >= 0) {
                  dataItem.values[options2.detailColumnIndex] = dataItem.isExpanded;
                }
                return dataItem;
              },
              _processItems: function(items, change) {
                var that = this;
                var changeType = change.changeType;
                var result2 = [];
                items = that.callBase.apply(that, arguments);
                if ("loadingAll" === changeType) {
                  return items;
                }
                if ("refresh" === changeType) {
                  that._expandedItems = grep(that._expandedItems, function(item) {
                    return item.visible;
                  });
                }
                each(items, function(index2, item) {
                  result2.push(item);
                  var expandIndex = ui_grid_core_utils_default.getIndexByKey(item.key, that._expandedItems);
                  if ("data" === item.rowType && (item.isExpanded || expandIndex >= 0) && !item.isNewRow) {
                    result2.push({
                      visible: item.isExpanded,
                      rowType: "detail",
                      key: item.key,
                      data: item.data,
                      values: []
                    });
                  }
                });
                return result2;
              },
              optionChanged: function(args) {
                var isEnabledChanged;
                var isAutoExpandAllChanged;
                if ("masterDetail" === args.name) {
                  args.name = "dataSource";
                  switch (args.fullName) {
                    case "masterDetail":
                      var value2 = args.value || {};
                      var previousValue = args.previousValue || {};
                      isEnabledChanged = value2.enabled !== previousValue.enabled;
                      isAutoExpandAllChanged = value2.autoExpandAll !== previousValue.autoExpandAll;
                      break;
                    case "masterDetail.template":
                      initMasterDetail(this);
                      break;
                    case "masterDetail.enabled":
                      isEnabledChanged = true;
                      break;
                    case "masterDetail.autoExpandAll":
                      isAutoExpandAllChanged = true;
                  }
                  if (isEnabledChanged || isAutoExpandAllChanged) {
                    initMasterDetail(this);
                  }
                }
                this.callBase(args);
              }
            };
          }(),
          resizing: {
            fireContentReadyAction: function() {
              this.callBase.apply(this, arguments);
              this._updateParentDataGrids(this.component.$element());
            },
            _updateParentDataGrids: function($element) {
              var $masterDetailRow = $element.closest("." + MASTER_DETAIL_ROW_CLASS);
              if ($masterDetailRow.length) {
                when(this._updateMasterDataGrid($masterDetailRow, $element)).done(() => {
                  this._updateParentDataGrids($masterDetailRow.parent());
                });
              }
            },
            _updateMasterDataGrid: function($masterDetailRow, $detailElement) {
              var masterRowOptions = renderer_default($masterDetailRow).data("options");
              var masterDataGrid = renderer_default($masterDetailRow).closest("." + this.getWidgetContainerClass()).parent().data("dxDataGrid");
              if (masterRowOptions && masterDataGrid) {
                if (masterDataGrid.getView("rowsView").isFixedColumns()) {
                  return this._updateFixedMasterDetailGrids(masterDataGrid, masterRowOptions.rowIndex, $detailElement);
                } else {
                  if (true === masterDataGrid.option("scrolling.useNative")) {
                    return masterDataGrid.updateDimensions();
                  }
                  var scrollable = masterDataGrid.getScrollable();
                  return null === scrollable || void 0 === scrollable ? void 0 : scrollable.update();
                }
              }
            },
            _updateFixedMasterDetailGrids: function(masterDataGrid, masterRowIndex, $detailElement) {
              var $rows = renderer_default(masterDataGrid.getRowElement(masterRowIndex));
              var $tables = renderer_default(masterDataGrid.getView("rowsView").getTableElements());
              var rowsNotEqual = 2 === (null === $rows || void 0 === $rows ? void 0 : $rows.length) && $rows.eq(0).height() !== $rows.eq(1).height();
              var tablesNotEqual = 2 === (null === $tables || void 0 === $tables ? void 0 : $tables.length) && $tables.eq(0).height() !== $tables.eq(1).height();
              if (rowsNotEqual || tablesNotEqual) {
                var detailElementWidth = $detailElement.width();
                return masterDataGrid.updateDimensions().done(() => {
                  var isDetailHorizontalScrollCanBeShown = this.option("columnAutoWidth") && true === masterDataGrid.option("scrolling.useNative");
                  var isDetailGridWidthChanged = isDetailHorizontalScrollCanBeShown && detailElementWidth !== $detailElement.width();
                  if (isDetailHorizontalScrollCanBeShown && isDetailGridWidthChanged) {
                    this.updateDimensions();
                  }
                });
              }
            },
            _toggleBestFitMode: function(isBestFit) {
              this.callBase.apply(this, arguments);
              if (this.option("masterDetail.template")) {
                var $rowsTable = this._rowsView.getTableElement();
                if ($rowsTable) {
                  $rowsTable.find(".dx-master-detail-cell").css("maxWidth", isBestFit ? 0 : "");
                }
              }
            }
          }
        },
        views: {
          rowsView: {
            _getCellTemplate: function(options2) {
              var that = this;
              var column = options2.column;
              var editingController = that.getController("editing");
              var isEditRow = editingController && editingController.isEditRow(options2.rowIndex);
              var template;
              if ("detail" === column.command && !isEditRow) {
                template = that.option("masterDetail.template") || {
                  allowRenderToDetachedContainer: false,
                  render: that._getDefaultTemplate(column)
                };
              } else {
                template = that.callBase.apply(that, arguments);
              }
              return template;
            },
            _isDetailRow: function(row) {
              return row && row.rowType && 0 === row.rowType.indexOf("detail");
            },
            _createRow: function(row) {
              var $row = this.callBase(row);
              if (row && this._isDetailRow(row)) {
                this.option("showRowLines") && $row.addClass(ROW_LINES_CLASS);
                $row.addClass(MASTER_DETAIL_ROW_CLASS);
                if (isDefined(row.visible)) {
                  $row.toggle(row.visible);
                }
              }
              return $row;
            },
            _renderCells: function($row, options2) {
              var row = options2.row;
              var $detailCell;
              var visibleColumns = this._columnsController.getVisibleColumns();
              if (row.rowType && this._isDetailRow(row)) {
                if (this._needRenderCell(0, options2.columnIndices)) {
                  $detailCell = this._renderCell($row, {
                    value: null,
                    row,
                    rowIndex: row.rowIndex,
                    column: {
                      command: "detail"
                    },
                    columnIndex: 0
                  });
                  $detailCell.addClass(CELL_FOCUS_DISABLED_CLASS).addClass(MASTER_DETAIL_CELL_CLASS).attr("colSpan", visibleColumns.length);
                }
              } else {
                this.callBase.apply(this, arguments);
              }
            }
          }
        }
      }
    };
  }
});

// node_modules/devextreme/esm/ui/dialog.js
var window21, DEFAULT_BUTTON, DX_DIALOG_CLASSNAME, DX_DIALOG_WRAPPER_CLASSNAME, DX_DIALOG_ROOT_CLASSNAME, DX_DIALOG_CONTENT_CLASSNAME, DX_DIALOG_MESSAGE_CLASSNAME, DX_DIALOG_BUTTONS_CLASSNAME, DX_DIALOG_BUTTON_CLASSNAME, DX_BUTTON_CLASSNAME, FakeDialogComponent, title, custom, confirm;
var init_dialog = __esm({
  "node_modules/devextreme/esm/ui/dialog.js"() {
    init_renderer();
    init_component();
    init_action();
    init_devices();
    init_config();
    init_dom();
    init_deferred();
    init_type();
    init_iterator();
    init_extend();
    init_window();
    init_events_engine();
    init_view_port();
    init_message();
    init_ui_errors();
    init_popup();
    init_common();
    window21 = getWindow();
    DEFAULT_BUTTON = {
      text: "OK",
      onClick: function() {
        return true;
      }
    };
    DX_DIALOG_CLASSNAME = "dx-dialog";
    DX_DIALOG_WRAPPER_CLASSNAME = "".concat(DX_DIALOG_CLASSNAME, "-wrapper");
    DX_DIALOG_ROOT_CLASSNAME = "".concat(DX_DIALOG_CLASSNAME, "-root");
    DX_DIALOG_CONTENT_CLASSNAME = "".concat(DX_DIALOG_CLASSNAME, "-content");
    DX_DIALOG_MESSAGE_CLASSNAME = "".concat(DX_DIALOG_CLASSNAME, "-message");
    DX_DIALOG_BUTTONS_CLASSNAME = "".concat(DX_DIALOG_CLASSNAME, "-buttons");
    DX_DIALOG_BUTTON_CLASSNAME = "".concat(DX_DIALOG_CLASSNAME, "-button");
    DX_BUTTON_CLASSNAME = "dx-button";
    FakeDialogComponent = Component.inherit({
      ctor: function(element, options2) {
        this.callBase(options2);
      },
      _defaultOptionsRules: function() {
        return this.callBase().concat([{
          device: {
            platform: "ios"
          },
          options: {
            width: 276
          }
        }, {
          device: {
            platform: "android"
          },
          options: {
            lWidth: "60%",
            pWidth: "80%"
          }
        }]);
      }
    });
    title = "";
    custom = function(options2) {
      var deferred = new Deferred();
      var defaultOptions = new FakeDialogComponent().option();
      options2 = extend2(defaultOptions, options2);
      var $element = renderer_default("<div>").addClass(DX_DIALOG_CLASSNAME).appendTo(value());
      var isMessageDefined = "message" in options2;
      var isMessageHtmlDefined = "messageHtml" in options2;
      if (isMessageDefined) {
        ui_errors_default.log("W1013");
      }
      var messageHtml = String(isMessageHtmlDefined ? options2.messageHtml : options2.message);
      var $message = renderer_default("<div>").addClass(DX_DIALOG_MESSAGE_CLASSNAME).html(messageHtml);
      var popupToolbarItems = [];
      each(options2.buttons || [DEFAULT_BUTTON], function() {
        var action = new Action(this.onClick, {
          context: popupInstance
        });
        popupToolbarItems.push({
          toolbar: "bottom",
          location: devices_default.current().android ? "after" : "center",
          widget: "dxButton",
          options: extend2({}, this, {
            onClick: function() {
              var result2 = action.execute(...arguments);
              hide(result2);
            }
          })
        });
      });
      var popupInstance = new popup_default($element, extend2({
        title: options2.title || title,
        showTitle: ensureDefined(options2.showTitle, true),
        dragEnabled: ensureDefined(options2.dragEnabled, true),
        height: "auto",
        width: function() {
          var isPortrait = renderer_default(window21).height() > renderer_default(window21).width();
          var key = (isPortrait ? "p" : "l") + "Width";
          var widthOption = Object.prototype.hasOwnProperty.call(options2, key) ? options2[key] : options2.width;
          return isFunction(widthOption) ? widthOption() : widthOption;
        },
        showCloseButton: options2.showCloseButton || false,
        ignoreChildEvents: false,
        onContentReady: function(args) {
          args.component.$content().addClass(DX_DIALOG_CONTENT_CLASSNAME).append($message);
        },
        onShowing: function(e) {
          e.component.bottomToolbar().addClass(DX_DIALOG_BUTTONS_CLASSNAME).find(".".concat(DX_BUTTON_CLASSNAME)).addClass(DX_DIALOG_BUTTON_CLASSNAME);
          resetActiveElement();
        },
        onShown: function(e) {
          var $firstButton = e.component.bottomToolbar().find(".".concat(DX_BUTTON_CLASSNAME)).first();
          events_engine_default.trigger($firstButton, "focus");
        },
        onHiding: function() {
          deferred.reject();
        },
        toolbarItems: popupToolbarItems,
        animation: {
          show: {
            type: "pop",
            duration: 400
          },
          hide: {
            type: "pop",
            duration: 400,
            to: {
              opacity: 0,
              scale: 0
            },
            from: {
              opacity: 1,
              scale: 1
            }
          }
        },
        rtlEnabled: config_default().rtlEnabled,
        boundaryOffset: {
          h: 10,
          v: 0
        }
      }, options2.popupOptions));
      popupInstance.$wrapper().addClass(DX_DIALOG_WRAPPER_CLASSNAME);
      if (options2.position) {
        popupInstance.option("position", options2.position);
      }
      popupInstance.$wrapper().addClass(DX_DIALOG_ROOT_CLASSNAME);
      function hide(value2) {
        deferred.resolve(value2);
        popupInstance.hide().done(function() {
          popupInstance.$element().remove();
        });
      }
      return {
        show: function() {
          popupInstance.show();
          return deferred.promise();
        },
        hide
      };
    };
    confirm = function(messageHtml, title2, showTitle) {
      var options2 = isPlainObject(messageHtml) ? messageHtml : {
        title: title2,
        messageHtml,
        showTitle,
        buttons: [{
          text: message_default.format("Yes"),
          onClick: function() {
            return true;
          }
        }, {
          text: message_default.format("No"),
          onClick: function() {
            return false;
          }
        }],
        dragEnabled: showTitle
      };
      return custom(options2).show();
    };
  }
});

// node_modules/devextreme/esm/ui/grid_core/ui.grid_core.editing_constants.js
var EDITOR_CELL_CLASS2, ROW_CLASS3, ROW_SELECTED_CLASS, EDIT_FORM_CLASS, DATA_EDIT_DATA_INSERT_TYPE, DATA_EDIT_DATA_REMOVE_TYPE, EDITING_POPUP_OPTION_NAME, EDITING_FORM_OPTION_NAME, EDITING_EDITROWKEY_OPTION_NAME, EDITING_EDITCOLUMNNAME_OPTION_NAME, TARGET_COMPONENT_NAME, EDITORS_INPUT_SELECTOR, FOCUSABLE_ELEMENT_SELECTOR, EDIT_MODE_BATCH, EDIT_MODE_ROW, EDIT_MODE_CELL, EDIT_MODE_FORM, EDIT_MODE_POPUP, EDIT_MODES, ROW_BASED_MODES, MODES_WITH_DELAYED_FOCUS;
var init_ui_grid_core_editing_constants = __esm({
  "node_modules/devextreme/esm/ui/grid_core/ui.grid_core.editing_constants.js"() {
    EDITOR_CELL_CLASS2 = "dx-editor-cell";
    ROW_CLASS3 = "dx-row";
    ROW_SELECTED_CLASS = "dx-selection";
    EDIT_FORM_CLASS = "edit-form";
    DATA_EDIT_DATA_INSERT_TYPE = "insert";
    DATA_EDIT_DATA_REMOVE_TYPE = "remove";
    EDITING_POPUP_OPTION_NAME = "editing.popup";
    EDITING_FORM_OPTION_NAME = "editing.form";
    EDITING_EDITROWKEY_OPTION_NAME = "editing.editRowKey";
    EDITING_EDITCOLUMNNAME_OPTION_NAME = "editing.editColumnName";
    TARGET_COMPONENT_NAME = "targetComponent";
    EDITORS_INPUT_SELECTOR = "input:not([type='hidden'])";
    FOCUSABLE_ELEMENT_SELECTOR = "[tabindex], " + EDITORS_INPUT_SELECTOR;
    EDIT_MODE_BATCH = "batch";
    EDIT_MODE_ROW = "row";
    EDIT_MODE_CELL = "cell";
    EDIT_MODE_FORM = "form";
    EDIT_MODE_POPUP = "popup";
    EDIT_MODES = [EDIT_MODE_BATCH, EDIT_MODE_ROW, EDIT_MODE_CELL, EDIT_MODE_FORM, EDIT_MODE_POPUP];
    ROW_BASED_MODES = [EDIT_MODE_ROW, EDIT_MODE_FORM, EDIT_MODE_POPUP];
    MODES_WITH_DELAYED_FOCUS = [EDIT_MODE_ROW, EDIT_MODE_FORM];
  }
});

// node_modules/devextreme/esm/ui/grid_core/ui.grid_core.editing.js
var READONLY_CLASS, LINK_CLASS, ROW_SELECTED, EDIT_BUTTON_CLASS, COMMAND_EDIT_CLASS, COMMAND_EDIT_WITH_ICONS_CLASS, INSERT_INDEX, ROW_INSERTED, ROW_MODIFIED, CELL_MODIFIED, EDITING_NAMESPACE, CELL_FOCUS_DISABLED_CLASS2, DATA_EDIT_DATA_UPDATE_TYPE, DEFAULT_START_EDIT_ACTION, EDIT_LINK_CLASS, EDIT_ICON_CLASS, METHOD_NAMES, ACTION_OPTION_NAMES, BUTTON_NAMES, EDITING_CHANGES_OPTION_NAME, NEW_SCROLLING_MODE, createFailureHandler, isEditingCell, isEditingOrShowEditorAlwaysDataCell, EditingController, editingModule;
var init_ui_grid_core_editing = __esm({
  "node_modules/devextreme/esm/ui/grid_core/ui.grid_core.editing.js"() {
    init_extends();
    init_renderer();
    init_dom_adapter();
    init_events_engine();
    init_guid();
    init_dom();
    init_type();
    init_iterator();
    init_extend();
    init_ui_grid_core_modules();
    init_click();
    init_pointer();
    init_ui_grid_core_utils();
    init_array_utils();
    init_utils2();
    init_dialog();
    init_message();
    init_devices();
    init_deferred();
    init_common();
    init_icon();
    init_ui_grid_core_editing_constants();
    READONLY_CLASS = "readonly";
    LINK_CLASS = "dx-link";
    ROW_SELECTED = "dx-selection";
    EDIT_BUTTON_CLASS = "dx-edit-button";
    COMMAND_EDIT_CLASS = "dx-command-edit";
    COMMAND_EDIT_WITH_ICONS_CLASS = COMMAND_EDIT_CLASS + "-with-icons";
    INSERT_INDEX = "__DX_INSERT_INDEX__";
    ROW_INSERTED = "dx-row-inserted";
    ROW_MODIFIED = "dx-row-modified";
    CELL_MODIFIED = "dx-cell-modified";
    EDITING_NAMESPACE = "dxDataGridEditing";
    CELL_FOCUS_DISABLED_CLASS2 = "dx-cell-focus-disabled";
    DATA_EDIT_DATA_UPDATE_TYPE = "update";
    DEFAULT_START_EDIT_ACTION = "click";
    EDIT_LINK_CLASS = {
      save: "dx-link-save",
      cancel: "dx-link-cancel",
      edit: "dx-link-edit",
      undelete: "dx-link-undelete",
      delete: "dx-link-delete",
      add: "dx-link-add"
    };
    EDIT_ICON_CLASS = {
      save: "save",
      cancel: "revert",
      edit: "edit",
      undelete: "revert",
      delete: "trash",
      add: "add"
    };
    METHOD_NAMES = {
      edit: "editRow",
      delete: "deleteRow",
      undelete: "undeleteRow",
      save: "saveEditData",
      cancel: "cancelEditData",
      add: "addRowByRowIndex"
    };
    ACTION_OPTION_NAMES = {
      add: "allowAdding",
      edit: "allowUpdating",
      delete: "allowDeleting"
    };
    BUTTON_NAMES = ["edit", "save", "cancel", "delete", "undelete"];
    EDITING_CHANGES_OPTION_NAME = "editing.changes";
    NEW_SCROLLING_MODE = "scrolling.newMode";
    createFailureHandler = function(deferred) {
      return function(arg) {
        var error = arg instanceof Error ? arg : new Error(arg && String(arg) || "Unknown error");
        deferred.reject(error);
      };
    };
    isEditingCell = function(isEditRow, cellOptions) {
      return cellOptions.isEditing || isEditRow && cellOptions.column.allowEditing;
    };
    isEditingOrShowEditorAlwaysDataCell = function(isEditRow, cellOptions) {
      var isCommandCell = !!cellOptions.column.command;
      var isEditing = isEditingCell(isEditRow, cellOptions);
      var isEditorCell2 = !isCommandCell && (isEditing || cellOptions.column.showEditorAlways);
      return "data" === cellOptions.rowType && isEditorCell2;
    };
    EditingController = ui_grid_core_modules_default.ViewController.inherit(/* @__PURE__ */ function() {
      var getButtonIndex = (buttons, name2) => {
        var result2 = -1;
        buttons.some((button, index2) => {
          if (getButtonName(button) === name2) {
            result2 = index2;
            return true;
          }
        });
        return result2;
      };
      function getButtonName(button) {
        return isObject2(button) ? button.name : button;
      }
      return {
        init: function() {
          this._columnsController = this.getController("columns");
          this._dataController = this.getController("data");
          this._rowsView = this.getView("rowsView");
          this._lastOperation = null;
          if (this._deferreds) {
            this._deferreds.forEach((d) => d.reject("cancel"));
          }
          this._deferreds = [];
          if (!this._dataChangedHandler) {
            this._dataChangedHandler = this._handleDataChanged.bind(this);
            this._dataController.changed.add(this._dataChangedHandler);
          }
          if (!this._saveEditorHandler) {
            this.createAction("onInitNewRow", {
              excludeValidators: ["disabled", "readOnly"]
            });
            this.createAction("onRowInserting", {
              excludeValidators: ["disabled", "readOnly"]
            });
            this.createAction("onRowInserted", {
              excludeValidators: ["disabled", "readOnly"]
            });
            this.createAction("onEditingStart", {
              excludeValidators: ["disabled", "readOnly"]
            });
            this.createAction("onRowUpdating", {
              excludeValidators: ["disabled", "readOnly"]
            });
            this.createAction("onRowUpdated", {
              excludeValidators: ["disabled", "readOnly"]
            });
            this.createAction("onRowRemoving", {
              excludeValidators: ["disabled", "readOnly"]
            });
            this.createAction("onRowRemoved", {
              excludeValidators: ["disabled", "readOnly"]
            });
            this.createAction("onSaved", {
              excludeValidators: ["disabled", "readOnly"]
            });
            this.createAction("onSaving", {
              excludeValidators: ["disabled", "readOnly"]
            });
            this.createAction("onEditCanceling", {
              excludeValidators: ["disabled", "readOnly"]
            });
            this.createAction("onEditCanceled", {
              excludeValidators: ["disabled", "readOnly"]
            });
          }
          this._updateEditColumn();
          this._updateEditButtons();
          if (!this._internalState) {
            this._internalState = [];
          }
          this.component._optionsByReference[EDITING_EDITROWKEY_OPTION_NAME] = true;
          this.component._optionsByReference[EDITING_CHANGES_OPTION_NAME] = true;
        },
        getEditMode: function() {
          var editMode = this.option("editing.mode");
          if (-1 !== EDIT_MODES.indexOf(editMode)) {
            return editMode;
          }
          return EDIT_MODE_ROW;
        },
        _getDefaultEditorTemplate: function() {
          return (container, options2) => {
            var $editor = renderer_default("<div>").appendTo(container);
            this.getController("editorFactory").createEditor($editor, extend2({}, options2.column, {
              value: options2.value,
              setValue: options2.setValue,
              row: options2.row,
              parentType: "dataRow",
              width: null,
              readOnly: !options2.setValue,
              isOnForm: options2.isOnForm,
              id: options2.id
            }));
          };
        },
        getChanges: function() {
          return this.option(EDITING_CHANGES_OPTION_NAME);
        },
        resetChanges: function() {
          var changes = this.getChanges();
          var needReset = null === changes || void 0 === changes ? void 0 : changes.length;
          if (needReset) {
            this._silentOption(EDITING_CHANGES_OPTION_NAME, []);
          }
        },
        _getInternalData: function(key) {
          return this._internalState.filter((item) => equalByValue(item.key, key))[0];
        },
        _addInternalData: function(params) {
          var internalData = this._getInternalData(params.key);
          if (internalData) {
            return extend2(internalData, params);
          }
          this._internalState.push(params);
          return params;
        },
        _getOldData: function(key) {
          var _this$_getInternalDat;
          return null === (_this$_getInternalDat = this._getInternalData(key)) || void 0 === _this$_getInternalDat ? void 0 : _this$_getInternalDat.oldData;
        },
        getUpdatedData: function(data2) {
          var key = this._dataController.keyOf(data2);
          var changes = this.getChanges();
          var editIndex = ui_grid_core_utils_default.getIndexByKey(key, changes);
          if (changes[editIndex]) {
            return createObjectWithChanges(data2, changes[editIndex].data);
          }
          return data2;
        },
        getInsertedData: function() {
          return this.getChanges().filter((change) => change.data && change.type === DATA_EDIT_DATA_INSERT_TYPE).map((change) => change.data);
        },
        getRemovedData: function() {
          return this.getChanges().filter((change) => this._getOldData(change.key) && change.type === DATA_EDIT_DATA_REMOVE_TYPE).map((change) => this._getOldData(change.key));
        },
        _fireDataErrorOccurred: function(arg) {
          if ("cancel" === arg) {
            return;
          }
          var $popupContent = this.getPopupContent();
          this._dataController.dataErrorOccurred.fire(arg, $popupContent);
        },
        _needToCloseEditableCell: noop2,
        _closeEditItem: noop2,
        _handleDataChanged: noop2,
        _isDefaultButtonVisible: function(button, options2) {
          var result2 = true;
          switch (button.name) {
            case "delete":
              result2 = this.allowDeleting(options2);
              break;
            case "undelete":
              result2 = false;
          }
          return result2;
        },
        _isButtonVisible: function(button, options2) {
          var visible2 = button.visible;
          if (!isDefined(visible2)) {
            return this._isDefaultButtonVisible(button, options2);
          }
          return isFunction(visible2) ? visible2.call(button, {
            component: options2.component,
            row: options2.row,
            column: options2.column
          }) : visible2;
        },
        _getButtonConfig: function(button, options2) {
          var config2 = isObject2(button) ? button : {};
          var buttonName = getButtonName(button);
          var editingTexts = ((options3) => {
            var editingTexts2 = options3.component.option("editing.texts") || {};
            return {
              save: editingTexts2.saveRowChanges,
              cancel: editingTexts2.cancelRowChanges,
              edit: editingTexts2.editRow,
              undelete: editingTexts2.undeleteRow,
              delete: editingTexts2.deleteRow,
              add: editingTexts2.addRowToNode
            };
          })(options2);
          var methodName = METHOD_NAMES[buttonName];
          var editingOptions = this.option("editing");
          var actionName = ACTION_OPTION_NAMES[buttonName];
          var allowAction = actionName ? editingOptions[actionName] : true;
          return extend2({
            name: buttonName,
            text: editingTexts[buttonName],
            cssClass: EDIT_LINK_CLASS[buttonName]
          }, {
            onClick: methodName && ((e) => {
              var event = e.event;
              event.stopPropagation();
              event.preventDefault();
              setTimeout(() => {
                options2.row && allowAction && this[methodName] && this[methodName](options2.row.rowIndex);
              });
            })
          }, config2);
        },
        _getEditingButtons: function(options2) {
          var buttonIndex;
          var haveCustomButtons = !!options2.column.buttons;
          var buttons = (options2.column.buttons || []).slice();
          if (haveCustomButtons) {
            buttonIndex = getButtonIndex(buttons, "edit");
            if (buttonIndex >= 0) {
              if (getButtonIndex(buttons, "save") < 0) {
                buttons.splice(buttonIndex + 1, 0, "save");
              }
              if (getButtonIndex(buttons, "cancel") < 0) {
                buttons.splice(getButtonIndex(buttons, "save") + 1, 0, "cancel");
              }
            }
            buttonIndex = getButtonIndex(buttons, "delete");
            if (buttonIndex >= 0 && getButtonIndex(buttons, "undelete") < 0) {
              buttons.splice(buttonIndex + 1, 0, "undelete");
            }
          } else {
            buttons = BUTTON_NAMES.slice();
          }
          return buttons.map((button) => this._getButtonConfig(button, options2));
        },
        _renderEditingButtons: function($container, buttons, options2) {
          buttons.forEach((button) => {
            if (this._isButtonVisible(button, options2)) {
              this._createButton($container, button, options2);
            }
          });
        },
        _getEditCommandCellTemplate: function() {
          return (container, options2) => {
            var $container = renderer_default(container);
            if ("data" === options2.rowType) {
              var buttons = this._getEditingButtons(options2);
              this._renderEditingButtons($container, buttons, options2);
              options2.watch && options2.watch(() => buttons.map((button) => this._isButtonVisible(button, options2)), () => {
                $container.empty();
                this._renderEditingButtons($container, buttons, options2);
              });
            } else {
              ui_grid_core_utils_default.setEmptyText($container);
            }
          };
        },
        isRowBasedEditMode: function() {
          var editMode = this.getEditMode();
          return -1 !== ROW_BASED_MODES.indexOf(editMode);
        },
        getFirstEditableColumnIndex: function() {
          var columnsController = this.getController("columns");
          var columnIndex;
          var visibleColumns = columnsController.getVisibleColumns();
          each(visibleColumns, function(index2, column) {
            if (column.allowEditing) {
              columnIndex = index2;
              return false;
            }
          });
          return columnIndex;
        },
        getFirstEditableCellInRow: function(rowIndex) {
          var rowsView = this.getView("rowsView");
          return rowsView && rowsView._getCellElement(rowIndex ? rowIndex : 0, this.getFirstEditableColumnIndex());
        },
        getFocusedCellInRow: function(rowIndex) {
          return this.getFirstEditableCellInRow(rowIndex);
        },
        getIndexByKey: function(key, items) {
          return ui_grid_core_utils_default.getIndexByKey(key, items);
        },
        hasChanges: function(rowIndex) {
          var changes = this.getChanges();
          var result2 = false;
          for (var i = 0; i < (null === changes || void 0 === changes ? void 0 : changes.length); i++) {
            if (changes[i].type && (!isDefined(rowIndex) || this._dataController.getRowIndexByKey(changes[i].key) === rowIndex)) {
              result2 = true;
              break;
            }
          }
          return result2;
        },
        dispose: function() {
          this.callBase();
          clearTimeout(this._inputFocusTimeoutID);
          events_engine_default.off(dom_adapter_default.getDocument(), pointer_default.up, this._pointerUpEditorHandler);
          events_engine_default.off(dom_adapter_default.getDocument(), pointer_default.down, this._pointerDownEditorHandler);
          events_engine_default.off(dom_adapter_default.getDocument(), CLICK_EVENT_NAME, this._saveEditorHandler);
        },
        optionChanged: function(args) {
          if ("editing" === args.name) {
            var fullName = args.fullName;
            if (fullName === EDITING_EDITROWKEY_OPTION_NAME) {
              this._handleEditRowKeyChange(args);
            } else if (fullName === EDITING_CHANGES_OPTION_NAME) {
              this._handleChangesChange(args);
            } else if (!args.handled) {
              this._columnsController.reinit();
              this.init();
              this.resetChanges();
              this._resetEditColumnName();
              this._resetEditRowKey();
            }
            args.handled = true;
          } else {
            this.callBase(args);
          }
        },
        _handleEditRowKeyChange: function(args) {
          var rowIndex = this._dataController.getRowIndexByKey(args.value);
          var oldRowIndexCorrection = this._getEditRowIndexCorrection();
          var oldRowIndex = this._dataController.getRowIndexByKey(args.previousValue) + oldRowIndexCorrection;
          if (isDefined(args.value)) {
            if (args.value !== args.previousValue) {
              this._editRowFromOptionChanged(rowIndex, oldRowIndex);
            }
          } else {
            this.cancelEditData();
          }
        },
        _handleChangesChange: function(args) {
          var dataController = this._dataController;
          if (!args.value.length && !args.previousValue.length) {
            return;
          }
          this._processInsertChanges(args.value);
          dataController.updateItems({
            repaintChangesOnly: true,
            isLiveUpdate: false
          });
        },
        _processInsertChanges: function(changes) {
          changes.forEach((change) => {
            if ("insert" === change.type) {
              this._addInsertInfo(change);
            }
          });
        },
        publicMethods: function() {
          return ["addRow", "deleteRow", "undeleteRow", "editRow", "saveEditData", "cancelEditData", "hasEditData"];
        },
        refresh: function() {
          if (!isDefined(this._pageIndex)) {
            return;
          }
          this._refreshCore.apply(this, arguments);
        },
        _refreshCore: noop2,
        isEditing: function() {
          var isEditRowKeyDefined = isDefined(this.option(EDITING_EDITROWKEY_OPTION_NAME));
          return isEditRowKeyDefined;
        },
        isEditRow: function() {
          return false;
        },
        _setEditRowKey: function(value2, silent) {
          if (silent) {
            this._silentOption(EDITING_EDITROWKEY_OPTION_NAME, value2);
          } else {
            this.option(EDITING_EDITROWKEY_OPTION_NAME, value2);
          }
        },
        _setEditRowKeyByIndex: function(rowIndex, silent) {
          var key = this._dataController.getKeyByRowIndex(rowIndex);
          if (void 0 === key) {
            this._dataController.fireError("E1043");
            return;
          }
          this._setEditRowKey(key, silent);
        },
        getEditRowIndex: function() {
          return this._getVisibleEditRowIndex();
        },
        getEditFormRowIndex: function() {
          return -1;
        },
        isEditRowByIndex(rowIndex) {
          var key = this._dataController.getKeyByRowIndex(rowIndex);
          var isKeyEqual = isDefined(key) && equalByValue(this.option(EDITING_EDITROWKEY_OPTION_NAME), key);
          if (isKeyEqual) {
            return this._getVisibleEditRowIndex() === rowIndex;
          }
          return isKeyEqual;
        },
        isEditCell: function(visibleRowIndex, columnIndex) {
          return this.isEditRowByIndex(visibleRowIndex) && this._getVisibleEditColumnIndex() === columnIndex;
        },
        getPopupContent: noop2,
        _needInsertItem: function(change, changeType) {
          var dataController = this._dataController;
          var dataSource = dataController.dataSource();
          var scrollingMode = this.option("scrolling.mode");
          var pageIndex = dataSource.pageIndex();
          var beginPageIndex = dataSource.beginPageIndex ? dataSource.beginPageIndex() : pageIndex;
          var endPageIndex = dataSource.endPageIndex ? dataSource.endPageIndex() : pageIndex;
          var isLastPage = endPageIndex === dataSource.pageCount() - 1;
          if ("standard" !== scrollingMode) {
            var pageSize = dataSource.pageSize() || 1;
            var changePageIndex = Math.floor(change.index / pageSize);
            var needInsertOnLastPosition = isLastPage && -1 === change.index;
            switch (changeType) {
              case "append":
                return changePageIndex === endPageIndex || needInsertOnLastPosition;
              case "prepend":
                return changePageIndex === beginPageIndex;
              default:
                var _dataController$topIt, _dataController$botto;
                var topItemIndex = null === (_dataController$topIt = dataController.topItemIndex) || void 0 === _dataController$topIt ? void 0 : _dataController$topIt.call(dataController);
                var bottomItemIndex = null === (_dataController$botto = dataController.bottomItemIndex) || void 0 === _dataController$botto ? void 0 : _dataController$botto.call(dataController);
                if (this.option(NEW_SCROLLING_MODE) && isDefined(topItemIndex)) {
                  return change.index >= topItemIndex && change.index <= bottomItemIndex || needInsertOnLastPosition;
                }
                return changePageIndex >= beginPageIndex && changePageIndex <= endPageIndex || needInsertOnLastPosition;
            }
          }
          return change.pageIndex === pageIndex || -1 === change.pageIndex && isLastPage;
        },
        _generateNewItem: function(key) {
          var _this$_getInternalDat2;
          var item = {
            key
          };
          var insertInfo = null === (_this$_getInternalDat2 = this._getInternalData(key)) || void 0 === _this$_getInternalDat2 ? void 0 : _this$_getInternalDat2.insertInfo;
          if (null !== insertInfo && void 0 !== insertInfo && insertInfo[INSERT_INDEX]) {
            item[INSERT_INDEX] = insertInfo[INSERT_INDEX];
          }
          return item;
        },
        _getLoadedRowIndex: function(items, change, key) {
          var dataController = this._dataController;
          var loadedRowIndexOffset = dataController.getRowIndexOffset(true);
          var changes = this.getChanges();
          var index2 = change ? changes.filter((editChange) => equalByValue(editChange.key, key))[0].index : 0;
          var loadedRowIndex = index2 - loadedRowIndexOffset;
          if ("append" === change.changeType) {
            loadedRowIndex -= dataController.items(true).length;
            if (change.removeCount) {
              loadedRowIndex += change.removeCount;
            }
          }
          for (var i = 0; i < loadedRowIndex; i++) {
            if (items[i] && items[i][INSERT_INDEX]) {
              loadedRowIndex++;
            }
          }
          return loadedRowIndex;
        },
        processItems: function(items, e) {
          var changeType = e.changeType;
          this.update(changeType);
          var changes = this.getChanges();
          changes.forEach((change) => {
            var _this$_getInternalDat3;
            var isInsert = change.type === DATA_EDIT_DATA_INSERT_TYPE;
            if (!isInsert) {
              return;
            }
            var key = change.key;
            var insertInfo = null === (_this$_getInternalDat3 = this._getInternalData(key)) || void 0 === _this$_getInternalDat3 ? void 0 : _this$_getInternalDat3.insertInfo;
            if (!isDefined(change.key) || !isDefined(insertInfo)) {
              var keys = this._addInsertInfo(change);
              key = keys.key;
              insertInfo = keys.insertInfo;
            }
            var loadedRowIndex = this._getLoadedRowIndex(items, e, key);
            var item = this._generateNewItem(key);
            if ((loadedRowIndex >= 0 || -1 === change.index) && this._needInsertItem(change, changeType, items, item)) {
              if (-1 !== change.index) {
                items.splice(change.index ? loadedRowIndex : 0, 0, item);
              } else {
                items.push(item);
              }
            }
          });
          return items;
        },
        processDataItem: function(item, options2, generateDataValues) {
          var columns = options2.visibleColumns;
          var key = item.data[INSERT_INDEX] ? item.data.key : item.key;
          var changes = this.getChanges();
          var editIndex = ui_grid_core_utils_default.getIndexByKey(key, changes);
          item.isEditing = false;
          if (editIndex >= 0) {
            this._processDataItemCore(item, changes[editIndex], key, columns, generateDataValues);
          }
        },
        _processDataItemCore: function(item, change, key, columns, generateDataValues) {
          var {
            data: data2,
            type: type2
          } = change;
          switch (type2) {
            case DATA_EDIT_DATA_INSERT_TYPE:
              item.isNewRow = true;
              item.key = key;
              item.data = data2;
              break;
            case DATA_EDIT_DATA_UPDATE_TYPE:
              item.modified = true;
              item.oldData = item.data;
              item.data = createObjectWithChanges(item.data, data2);
              item.modifiedValues = generateDataValues(data2, columns, true);
              break;
            case DATA_EDIT_DATA_REMOVE_TYPE:
              item.removed = true;
          }
        },
        _initNewRow: function(options2) {
          this.executeAction("onInitNewRow", options2);
          if (options2.promise) {
            var deferred = new Deferred();
            when(fromPromise(options2.promise)).done(deferred.resolve).fail(createFailureHandler(deferred)).fail((arg) => this._fireDataErrorOccurred(arg));
            return deferred;
          }
        },
        _calculateIndex: function(rowIndex) {
          var dataController = this._dataController;
          var rows = dataController.items();
          return dataController.getRowIndexOffset() + rows.filter(function(row, index2) {
            return index2 < rowIndex && ("data" === row.rowType && !row.isNewRow || "group" === row.rowType);
          }).length;
        },
        _createInsertInfo: function() {
          var insertInfo = {};
          insertInfo[INSERT_INDEX] = this._getInsertIndex();
          return insertInfo;
        },
        _getCorrectedInsertRowIndex: function(parentKey) {
          var rowIndex = this._getInsertRowIndex(parentKey);
          var dataController = this._dataController;
          var rows = dataController.items();
          var row = rows[rowIndex];
          if (row && (!row.isEditing && "detail" === row.rowType || "detailAdaptive" === row.rowType)) {
            rowIndex++;
          }
          return rowIndex;
        },
        _addInsertInfo: function(change, parentKey) {
          var _this$_getInternalDat4;
          var insertInfo;
          var rowIndex;
          var {
            key
          } = change;
          if (!isDefined(key)) {
            key = String(new guid_default());
            change.key = key;
          }
          insertInfo = null === (_this$_getInternalDat4 = this._getInternalData(key)) || void 0 === _this$_getInternalDat4 ? void 0 : _this$_getInternalDat4.insertInfo;
          if (!isDefined(insertInfo)) {
            rowIndex = this._getCorrectedInsertRowIndex(parentKey);
            insertInfo = this._createInsertInfo();
            this._setIndexes(change, rowIndex);
          }
          this._addInternalData({
            insertInfo,
            key
          });
          return {
            insertInfo,
            key,
            rowIndex
          };
        },
        _setIndexes: function(change, rowIndex) {
          var _change$index;
          var dataController = this._dataController;
          change.index = null !== (_change$index = change.index) && void 0 !== _change$index ? _change$index : this._calculateIndex(rowIndex);
          if ("virtual" !== this.option("scrolling.mode")) {
            var _change$pageIndex;
            change.pageIndex = null !== (_change$pageIndex = change.pageIndex) && void 0 !== _change$pageIndex ? _change$pageIndex : dataController.pageIndex();
          }
        },
        _getInsertRowIndex: function(parentKey) {
          var rowsView = this.getView("rowsView");
          var parentRowIndex = this._dataController.getRowIndexByKey(parentKey);
          if (parentRowIndex >= 0) {
            return parentRowIndex + 1;
          }
          if (rowsView) {
            return rowsView.getTopVisibleItemIndex(true);
          }
          return 0;
        },
        _getInsertIndex: function() {
          var maxInsertIndex = 0;
          this.getChanges().forEach((editItem) => {
            var _this$_getInternalDat5;
            var insertInfo = null === (_this$_getInternalDat5 = this._getInternalData(editItem.key)) || void 0 === _this$_getInternalDat5 ? void 0 : _this$_getInternalDat5.insertInfo;
            if (isDefined(insertInfo) && editItem.type === DATA_EDIT_DATA_INSERT_TYPE && insertInfo[INSERT_INDEX] > maxInsertIndex) {
              maxInsertIndex = insertInfo[INSERT_INDEX];
            }
          });
          return maxInsertIndex + 1;
        },
        addRow: function(parentKey) {
          var dataController = this._dataController;
          var store = dataController.store();
          if (!store) {
            dataController.fireError("E1052", this.component.NAME);
            return new Deferred().reject();
          }
          return this._addRow(parentKey);
        },
        _addRow: function(parentKey) {
          var dataController = this._dataController;
          var store = dataController.store();
          var key = store && store.key();
          var param = {
            data: {}
          };
          var oldEditRowIndex = this._getVisibleEditRowIndex();
          var deferred = new Deferred();
          this.refresh({
            allowCancelEditing: true
          });
          if (!this._allowRowAdding()) {
            return deferred.reject("cancel");
          }
          if (!key) {
            param.data.__KEY__ = String(new guid_default());
          }
          when(this._initNewRow(param, parentKey)).done(() => {
            if (this._allowRowAdding()) {
              when(this._addRowCore(param.data, parentKey, oldEditRowIndex)).done(deferred.resolve).fail(deferred.reject);
            } else {
              deferred.reject("cancel");
            }
          }).fail(deferred.reject);
          return deferred.promise();
        },
        _allowRowAdding: function() {
          var insertIndex = this._getInsertIndex();
          if (insertIndex > 1) {
            return false;
          }
          return true;
        },
        _addRowCore: function(data2, parentKey, initialOldEditRowIndex) {
          var oldEditRowIndex = this._getVisibleEditRowIndex();
          var change = {
            data: data2,
            type: DATA_EDIT_DATA_INSERT_TYPE
          };
          var {
            key,
            rowIndex
          } = this._addInsertInfo(change, parentKey);
          this._setEditRowKey(key, true);
          this._addChange(change);
          this._dataController.updateItems({
            changeType: "update",
            rowIndices: [initialOldEditRowIndex, oldEditRowIndex, rowIndex]
          });
          this._showAddedRow(rowIndex);
          this._afterInsertRow({
            key,
            data: data2
          });
          return new Deferred().resolve();
        },
        _showAddedRow: function(rowIndex) {
          this._focusFirstEditableCellInRow(rowIndex);
        },
        _beforeFocusElementInRow: noop2,
        _focusFirstEditableCellInRow: function(rowIndex) {
          var $firstCell = this.getFirstEditableCellInRow(rowIndex);
          this._editCellInProgress = true;
          this._delayedInputFocus($firstCell, () => {
            this._editCellInProgress = false;
            this._beforeFocusElementInRow(rowIndex);
          });
        },
        _isEditingStart: function(options2) {
          this.executeAction("onEditingStart", options2);
          return options2.cancel;
        },
        _beforeUpdateItems: noop2,
        _getVisibleEditColumnIndex: function() {
          var editColumnName = this.option(EDITING_EDITCOLUMNNAME_OPTION_NAME);
          if (!isDefined(editColumnName)) {
            return -1;
          }
          return this._columnsController.getVisibleColumnIndex(editColumnName);
        },
        _setEditColumnNameByIndex: function(index2, silent) {
          var _visibleColumns$index;
          var visibleColumns = this._columnsController.getVisibleColumns();
          this._setEditColumnName(null === (_visibleColumns$index = visibleColumns[index2]) || void 0 === _visibleColumns$index ? void 0 : _visibleColumns$index.name, silent);
        },
        _setEditColumnName: function(name2, silent) {
          if (silent) {
            this._silentOption(EDITING_EDITCOLUMNNAME_OPTION_NAME, name2);
          } else {
            this.option(EDITING_EDITCOLUMNNAME_OPTION_NAME, name2);
          }
        },
        _resetEditColumnName: function() {
          this._setEditColumnName(null, true);
        },
        _getEditColumn: function() {
          var editColumnName = this.option(EDITING_EDITCOLUMNNAME_OPTION_NAME);
          return this._getColumnByName(editColumnName);
        },
        _getColumnByName: function(name2) {
          var visibleColumns = this._columnsController.getVisibleColumns();
          var editColumn;
          isDefined(name2) && visibleColumns.some((column) => {
            if (column.name === name2) {
              editColumn = column;
              return true;
            }
          });
          return editColumn;
        },
        _getVisibleEditRowIndex: function(columnName) {
          var dataController = this._dataController;
          var editRowKey = this.option(EDITING_EDITROWKEY_OPTION_NAME);
          var rowIndex = dataController.getRowIndexByKey(editRowKey);
          if (-1 === rowIndex) {
            return rowIndex;
          }
          return rowIndex + this._getEditRowIndexCorrection(columnName);
        },
        _getEditRowIndexCorrection: function(columnName) {
          var editColumn = columnName ? this._getColumnByName(columnName) : this._getEditColumn();
          var isColumnHidden = "adaptiveHidden" === (null === editColumn || void 0 === editColumn ? void 0 : editColumn.visibleWidth);
          return isColumnHidden ? 1 : 0;
        },
        _resetEditRowKey: function() {
          this._setEditRowKey(null, true);
        },
        _resetEditIndices: function() {
          this._resetEditColumnName();
          this._resetEditRowKey();
        },
        editRow: function(rowIndex) {
          var _item$oldData;
          var dataController = this._dataController;
          var items = dataController.items();
          var item = items[rowIndex];
          var params = {
            data: item && item.data,
            cancel: false
          };
          var oldRowIndex = this._getVisibleEditRowIndex();
          if (!item) {
            return;
          }
          if (rowIndex === oldRowIndex) {
            return true;
          }
          if (void 0 === item.key) {
            this._dataController.fireError("E1043");
            return;
          }
          if (!item.isNewRow) {
            params.key = item.key;
          }
          if (this._isEditingStart(params)) {
            return;
          }
          this.resetChanges();
          this.init();
          this._resetEditColumnName();
          this._pageIndex = dataController.pageIndex();
          this._addInternalData({
            key: item.key,
            oldData: null !== (_item$oldData = item.oldData) && void 0 !== _item$oldData ? _item$oldData : item.data
          });
          this._setEditRowKey(item.key);
        },
        _editRowFromOptionChanged: function(rowIndex, oldRowIndex) {
          var rowIndices = [oldRowIndex, rowIndex];
          this._beforeUpdateItems(rowIndices, rowIndex, oldRowIndex);
          this._editRowFromOptionChangedCore(rowIndices, rowIndex);
        },
        _editRowFromOptionChangedCore: function(rowIndices, rowIndex, preventRendering) {
          this._needFocusEditor = true;
          this._dataController.updateItems({
            changeType: "update",
            rowIndices,
            cancel: preventRendering
          });
        },
        _focusEditorIfNeed: noop2,
        _showEditPopup: noop2,
        _repaintEditPopup: noop2,
        _getEditPopupHiddenHandler: function() {
          return (e) => {
            if (this.isEditing()) {
              this.cancelEditData();
            }
          };
        },
        _getPopupEditFormTemplate: noop2,
        _getSaveButtonConfig: function() {
          return {
            text: this.option("editing.texts.saveRowChanges"),
            onClick: this.saveEditData.bind(this)
          };
        },
        _getCancelButtonConfig: function() {
          return {
            text: this.option("editing.texts.cancelRowChanges"),
            onClick: this.cancelEditData.bind(this)
          };
        },
        _removeInternalData: function(key) {
          var internalData = this._getInternalData(key);
          var index2 = this._internalState.indexOf(internalData);
          if (index2 > -1) {
            this._internalState.splice(index2, 1);
          }
        },
        _removeChange: function(index2) {
          if (index2 >= 0) {
            var changes = [...this.getChanges()];
            var key = changes[index2].key;
            this._removeInternalData(key);
            changes.splice(index2, 1);
            this._silentOption(EDITING_CHANGES_OPTION_NAME, changes);
            if (equalByValue(this.option(EDITING_EDITROWKEY_OPTION_NAME), key)) {
              this._resetEditIndices();
            }
          }
        },
        executeOperation: function(deferred, func) {
          this._lastOperation && this._lastOperation.reject();
          this._lastOperation = deferred;
          this.waitForDeferredOperations().done(() => {
            if ("rejected" === deferred.state()) {
              return;
            }
            func();
            this._lastOperation = null;
          }).fail(() => {
            deferred.reject();
            this._lastOperation = null;
          });
        },
        waitForDeferredOperations: function() {
          return when(...this._deferreds);
        },
        _processCanceledEditingCell: noop2,
        _repaintEditCell: function(column, oldColumn, oldEditRowIndex) {
          this._needFocusEditor = true;
          if (!column || !column.showEditorAlways || oldColumn && !oldColumn.showEditorAlways) {
            this._editCellInProgress = true;
            this.getController("editorFactory").loseFocus();
            this._dataController.updateItems({
              changeType: "update",
              rowIndices: [oldEditRowIndex, this._getVisibleEditRowIndex()]
            });
          } else if (column !== oldColumn) {
            this._dataController.updateItems({
              changeType: "update",
              rowIndices: []
            });
          }
        },
        _delayedInputFocus: function($cell, beforeFocusCallback, callBeforeFocusCallbackAlways) {
          var inputFocus = () => {
            if (beforeFocusCallback) {
              beforeFocusCallback();
            }
            if ($cell) {
              var $focusableElement = $cell.find(FOCUSABLE_ELEMENT_SELECTOR).first();
              ui_grid_core_utils_default.focusAndSelectElement(this, $focusableElement);
            }
            this._beforeFocusCallback = null;
          };
          if (devices_default.real().ios || devices_default.real().android) {
            inputFocus();
          } else {
            if (this._beforeFocusCallback) {
              this._beforeFocusCallback();
            }
            clearTimeout(this._inputFocusTimeoutID);
            if (callBeforeFocusCallbackAlways) {
              this._beforeFocusCallback = beforeFocusCallback;
            }
            this._inputFocusTimeoutID = setTimeout(inputFocus);
          }
        },
        _focusEditingCell: function(beforeFocusCallback, $editCell, callBeforeFocusCallbackAlways) {
          var rowsView = this.getView("rowsView");
          var editColumnIndex = this._getVisibleEditColumnIndex();
          $editCell = $editCell || rowsView && rowsView._getCellElement(this._getVisibleEditRowIndex(), editColumnIndex);
          if ($editCell) {
            this._delayedInputFocus($editCell, beforeFocusCallback, callBeforeFocusCallbackAlways);
          }
        },
        deleteRow: function(rowIndex) {
          this._checkAndDeleteRow(rowIndex);
        },
        _checkAndDeleteRow: function(rowIndex) {
          var editingOptions = this.option("editing");
          var editingTexts = null === editingOptions || void 0 === editingOptions ? void 0 : editingOptions.texts;
          var confirmDelete = null === editingOptions || void 0 === editingOptions ? void 0 : editingOptions.confirmDelete;
          var confirmDeleteMessage = null === editingTexts || void 0 === editingTexts ? void 0 : editingTexts.confirmDeleteMessage;
          var item = this._dataController.items()[rowIndex];
          var allowDeleting = !this.isEditing() || item.isNewRow;
          if (item && allowDeleting) {
            if (!confirmDelete || !confirmDeleteMessage) {
              this._deleteRowCore(rowIndex);
            } else {
              var confirmDeleteTitle = editingTexts && editingTexts.confirmDeleteTitle;
              var showDialogTitle = isDefined(confirmDeleteTitle) && confirmDeleteTitle.length > 0;
              confirm(confirmDeleteMessage, confirmDeleteTitle, showDialogTitle).done((confirmResult) => {
                if (confirmResult) {
                  this._deleteRowCore(rowIndex);
                }
              });
            }
          }
        },
        _deleteRowCore: function(rowIndex) {
          var dataController = this._dataController;
          var item = dataController.items()[rowIndex];
          var key = item && item.key;
          var oldEditRowIndex = this._getVisibleEditRowIndex();
          this.refresh();
          var changes = this.getChanges();
          var editIndex = ui_grid_core_utils_default.getIndexByKey(key, changes);
          if (editIndex >= 0) {
            if (changes[editIndex].type === DATA_EDIT_DATA_INSERT_TYPE) {
              this._removeChange(editIndex);
            } else {
              this._addChange({
                key,
                type: DATA_EDIT_DATA_REMOVE_TYPE
              });
            }
          } else {
            this._addChange({
              key,
              oldData: item.data,
              type: DATA_EDIT_DATA_REMOVE_TYPE
            });
          }
          return this._afterDeleteRow(rowIndex, oldEditRowIndex);
        },
        _afterDeleteRow: function(rowIndex, oldEditRowIndex) {
          return this.saveEditData();
        },
        undeleteRow: function(rowIndex) {
          var dataController = this._dataController;
          var item = dataController.items()[rowIndex];
          var oldEditRowIndex = this._getVisibleEditRowIndex();
          var key = item && item.key;
          var changes = this.getChanges();
          if (item) {
            var editIndex = ui_grid_core_utils_default.getIndexByKey(key, changes);
            if (editIndex >= 0) {
              var {
                data: data2
              } = changes[editIndex];
              if (isEmptyObject(data2)) {
                this._removeChange(editIndex);
              } else {
                this._addChange({
                  key,
                  type: DATA_EDIT_DATA_UPDATE_TYPE
                });
              }
              dataController.updateItems({
                changeType: "update",
                rowIndices: [oldEditRowIndex, rowIndex]
              });
            }
          }
        },
        _fireOnSaving: function() {
          var onSavingParams = {
            cancel: false,
            promise: null,
            changes: [...this.getChanges()]
          };
          this.executeAction("onSaving", onSavingParams);
          var d = new Deferred();
          when(fromPromise(onSavingParams.promise)).done(() => {
            d.resolve(onSavingParams);
          }).fail((arg) => {
            createFailureHandler(d);
            this._fireDataErrorOccurred(arg);
            d.resolve({
              cancel: true
            });
          });
          return d;
        },
        _executeEditingAction: function(actionName, params, func) {
          if (this.component._disposed) {
            return null;
          }
          var deferred = new Deferred();
          this.executeAction(actionName, params);
          when(fromPromise(params.cancel)).done(function(cancel2) {
            if (cancel2) {
              setTimeout(function() {
                deferred.resolve("cancel");
              });
            } else {
              func(params).done(deferred.resolve).fail(createFailureHandler(deferred));
            }
          }).fail(createFailureHandler(deferred));
          return deferred;
        },
        _processChanges: function(deferreds, results, dataChanges, changes) {
          var store = this._dataController.store();
          each(changes, (index2, change) => {
            var oldData = this._getOldData(change.key);
            var {
              data: data2,
              type: type2
            } = change;
            var changeCopy = _extends({}, change);
            var deferred;
            var params;
            if (this._beforeSaveEditData(change, index2)) {
              return;
            }
            switch (type2) {
              case DATA_EDIT_DATA_REMOVE_TYPE:
                params = {
                  data: oldData,
                  key: change.key,
                  cancel: false
                };
                deferred = this._executeEditingAction("onRowRemoving", params, function() {
                  return store.remove(change.key).done(function(key) {
                    dataChanges.push({
                      type: "remove",
                      key
                    });
                  });
                });
                break;
              case DATA_EDIT_DATA_INSERT_TYPE:
                params = {
                  data: data2,
                  cancel: false
                };
                deferred = this._executeEditingAction("onRowInserting", params, function() {
                  return store.insert(params.data).done(function(data3, key) {
                    if (isDefined(key)) {
                      changeCopy.key = key;
                    }
                    if (data3 && isObject2(data3) && data3 !== params.data) {
                      changeCopy.data = data3;
                    }
                    dataChanges.push({
                      type: "insert",
                      data: data3,
                      index: 0
                    });
                  });
                });
                break;
              case DATA_EDIT_DATA_UPDATE_TYPE:
                params = {
                  newData: data2,
                  oldData,
                  key: change.key,
                  cancel: false
                };
                deferred = this._executeEditingAction("onRowUpdating", params, function() {
                  return store.update(change.key, params.newData).done(function(data3, key) {
                    if (data3 && isObject2(data3) && data3 !== params.newData) {
                      changeCopy.data = data3;
                    }
                    dataChanges.push({
                      type: "update",
                      key,
                      data: data3
                    });
                  });
                });
            }
            changes[index2] = changeCopy;
            if (deferred) {
              var doneDeferred = new Deferred();
              deferred.always(function(data3) {
                results.push({
                  key: change.key,
                  result: data3
                });
              }).always(doneDeferred.resolve);
              deferreds.push(doneDeferred.promise());
            }
          });
        },
        _processRemoveIfError: function(changes, editIndex) {
          var change = changes[editIndex];
          if ((null === change || void 0 === change ? void 0 : change.type) === DATA_EDIT_DATA_REMOVE_TYPE) {
            if (editIndex >= 0) {
              changes.splice(editIndex, 1);
            }
          }
          return true;
        },
        _processRemove: function(changes, editIndex, cancel2) {
          var change = changes[editIndex];
          if (!cancel2 || !change || change.type === DATA_EDIT_DATA_REMOVE_TYPE) {
            return this._processRemoveCore(changes, editIndex, !cancel2 || !change);
          }
        },
        _processRemoveCore: function(changes, editIndex) {
          if (editIndex >= 0) {
            changes.splice(editIndex, 1);
          }
          return true;
        },
        _processSaveEditDataResult: function(results) {
          var hasSavedData = false;
          var changes = [...this.getChanges()];
          var changesLength = changes.length;
          for (var i = 0; i < results.length; i++) {
            var arg = results[i].result;
            var cancel2 = "cancel" === arg;
            var editIndex = ui_grid_core_utils_default.getIndexByKey(results[i].key, changes);
            var change = changes[editIndex];
            var isError = arg && arg instanceof Error;
            if (isError) {
              if (change) {
                this._addInternalData({
                  key: change.key,
                  error: arg
                });
              }
              this._fireDataErrorOccurred(arg);
              if (this._processRemoveIfError(changes, editIndex)) {
                break;
              }
            } else if (this._processRemove(changes, editIndex, cancel2)) {
              hasSavedData = !cancel2;
            }
          }
          if (changes.length < changesLength) {
            this._silentOption(EDITING_CHANGES_OPTION_NAME, changes);
          }
          return hasSavedData;
        },
        _fireSaveEditDataEvents: function(changes) {
          each(changes, (_2, _ref) => {
            var {
              data: data2,
              key,
              type: type2
            } = _ref;
            var internalData = this._addInternalData({
              key
            });
            var params = {
              key,
              data: data2
            };
            if (internalData.error) {
              params.error = internalData.error;
            }
            switch (type2) {
              case DATA_EDIT_DATA_REMOVE_TYPE:
                this.executeAction("onRowRemoved", extend2({}, params, {
                  data: internalData.oldData
                }));
                break;
              case DATA_EDIT_DATA_INSERT_TYPE:
                this.executeAction("onRowInserted", params);
                break;
              case DATA_EDIT_DATA_UPDATE_TYPE:
                this.executeAction("onRowUpdated", params);
            }
          });
          this.executeAction("onSaved", {
            changes
          });
        },
        saveEditData: function() {
          var deferred = new Deferred();
          this.waitForDeferredOperations().done(() => {
            if (this.isSaving()) {
              this._resolveAfterSave(deferred);
              return;
            }
            when(this._beforeSaveEditData()).done((cancel2) => {
              if (cancel2) {
                this._resolveAfterSave(deferred, {
                  cancel: cancel2
                });
                return;
              }
              this._saving = true;
              var options2 = {};
              this._saveEditDataInner(options2).always(() => {
                this._saving = false;
                options2.needFocusEditCell && this._focusEditingCell();
              }).done(deferred.resolve).fail(deferred.reject);
            }).fail(deferred.reject);
          }).fail(deferred.reject);
          return deferred.promise();
        },
        _resolveAfterSave: function(deferred) {
          var {
            cancel: cancel2,
            error
          } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
          when(this._afterSaveEditData(cancel2)).done(function() {
            deferred.resolve(error);
          }).fail(deferred.reject);
        },
        _saveEditDataInner: function(options2) {
          var results = [];
          var deferreds = [];
          var dataChanges = [];
          var dataController = this._dataController;
          var dataSource = dataController.dataSource();
          var result2 = new Deferred();
          when(this._fireOnSaving()).done((_ref2) => {
            var {
              cancel: cancel2,
              changes
            } = _ref2;
            if (cancel2) {
              return result2.resolve().promise();
            }
            this._processChanges(deferreds, results, dataChanges, changes);
            if (deferreds.length) {
              null === dataSource || void 0 === dataSource ? void 0 : dataSource.beginLoading();
              when(...deferreds).done(() => {
                if (this._processSaveEditDataResult(results)) {
                  this._endSaving(dataChanges, changes, result2);
                } else {
                  null === dataSource || void 0 === dataSource ? void 0 : dataSource.endLoading();
                  result2.resolve();
                }
              }).fail((error) => {
                null === dataSource || void 0 === dataSource ? void 0 : dataSource.endLoading();
                result2.resolve(error);
              });
              return result2.always(() => {
                options2.needFocusEditCell = true;
              }).promise();
            }
            this._cancelSaving(result2);
          }).fail(result2.reject);
          return result2.promise();
        },
        _beforeEndSaving: function(changes) {
          this._resetEditIndices();
        },
        _endSaving: function(dataChanges, changes, deferred) {
          var dataSource = this._dataController.dataSource();
          this._beforeEndSaving(changes);
          null === dataSource || void 0 === dataSource ? void 0 : dataSource.endLoading();
          this._refreshDataAfterSave(dataChanges, changes, deferred);
        },
        _cancelSaving: function(result2) {
          this.executeAction("onSaved", {
            changes: []
          });
          this._resolveAfterSave(result2);
        },
        _refreshDataAfterSave: function(dataChanges, changes, deferred) {
          var dataController = this._dataController;
          var refreshMode = this.option("editing.refreshMode");
          var isFullRefresh = "reshape" !== refreshMode && "repaint" !== refreshMode;
          if (!isFullRefresh) {
            dataController.push(dataChanges);
          }
          when(dataController.refresh({
            selection: isFullRefresh,
            reload: isFullRefresh,
            load: "reshape" === refreshMode,
            changesOnly: this.option("repaintChangesOnly")
          })).always(() => {
            this._fireSaveEditDataEvents(changes);
          }).done(() => {
            this._resolveAfterSave(deferred);
          }).fail((error) => {
            this._resolveAfterSave(deferred, {
              error
            });
          });
        },
        isSaving: function() {
          return this._saving;
        },
        _updateEditColumn: function() {
          var isEditColumnVisible = this._isEditColumnVisible();
          var useIcons = this.option("editing.useIcons");
          var cssClass = COMMAND_EDIT_CLASS + (useIcons ? " " + COMMAND_EDIT_WITH_ICONS_CLASS : "");
          this._columnsController.addCommandColumn({
            type: "buttons",
            command: "edit",
            visible: isEditColumnVisible,
            cssClass,
            width: "auto",
            alignment: "center",
            cellTemplate: this._getEditCommandCellTemplate(),
            fixedPosition: "right"
          });
          this._columnsController.columnOption("command:edit", {
            visible: isEditColumnVisible,
            cssClass
          });
        },
        _isEditColumnVisible: function() {
          var editingOptions = this.option("editing");
          return editingOptions.allowDeleting;
        },
        _isEditButtonDisabled: function() {
          var hasChanges = this.hasChanges();
          var isEditRowDefined = isDefined(this.option("editing.editRowKey"));
          return !(isEditRowDefined || hasChanges);
        },
        _updateEditButtons: function() {
          var headerPanel = this.getView("headerPanel");
          var isButtonDisabled = this._isEditButtonDisabled();
          if (headerPanel) {
            headerPanel.setToolbarItemDisabled("saveButton", isButtonDisabled);
            headerPanel.setToolbarItemDisabled("revertButton", isButtonDisabled);
          }
        },
        _applyModified: function($element) {
          $element && $element.addClass(CELL_MODIFIED);
        },
        _beforeCloseEditCellInBatchMode: noop2,
        cancelEditData: function() {
          var changes = this.getChanges();
          var params = {
            cancel: false,
            changes
          };
          this.executeAction("onEditCanceling", params);
          if (!params.cancel) {
            this._cancelEditDataCore();
            this.executeAction("onEditCanceled", {
              changes
            });
          }
        },
        _cancelEditDataCore: function() {
          var rowIndex = this._getVisibleEditRowIndex();
          this._beforeCancelEditData();
          this.init();
          this.resetChanges();
          this._resetEditColumnName();
          this._resetEditRowKey();
          this._afterCancelEditData(rowIndex);
        },
        _afterCancelEditData: function(rowIndex) {
          var dataController = this._dataController;
          dataController.updateItems({
            repaintChangesOnly: this.option("repaintChangesOnly")
          });
        },
        _hideEditPopup: noop2,
        hasEditData: function() {
          return this.hasChanges();
        },
        update: function(changeType) {
          var dataController = this._dataController;
          if (dataController && this._pageIndex !== dataController.pageIndex()) {
            if ("refresh" === changeType) {
              this.refresh({
                isPageChanged: true
              });
            }
            this._pageIndex = dataController.pageIndex();
          }
          this._updateEditButtons();
        },
        _getRowIndicesForCascadeUpdating: function(row, skipCurrentRow) {
          return skipCurrentRow ? [] : [row.rowIndex];
        },
        addDeferred: function(deferred) {
          if (this._deferreds.indexOf(deferred) < 0) {
            this._deferreds.push(deferred);
            deferred.always(() => {
              var index2 = this._deferreds.indexOf(deferred);
              if (index2 >= 0) {
                this._deferreds.splice(index2, 1);
              }
            });
          }
        },
        _prepareChange: function(options2, value2, text) {
          var _options$row;
          var newData = {};
          var oldData = null === (_options$row = options2.row) || void 0 === _options$row ? void 0 : _options$row.data;
          var rowKey = options2.key;
          var deferred = new Deferred();
          if (void 0 !== rowKey) {
            options2.value = value2;
            var setCellValueResult = fromPromise(options2.column.setCellValue(newData, value2, extend2(true, {}, oldData), text));
            setCellValueResult.done(function() {
              deferred.resolve({
                data: newData,
                key: rowKey,
                oldData,
                type: DATA_EDIT_DATA_UPDATE_TYPE
              });
            }).fail(createFailureHandler(deferred)).fail((arg) => this._fireDataErrorOccurred(arg));
            if (isDefined(text) && options2.column.displayValueMap) {
              options2.column.displayValueMap[value2] = text;
            }
            this._updateRowValues(options2);
            this.addDeferred(deferred);
          }
          return deferred;
        },
        _updateRowValues: function(options2) {
          if (options2.values) {
            var dataController = this._dataController;
            var rowIndex = dataController.getRowIndexByKey(options2.key);
            var row = dataController.getVisibleRows()[rowIndex];
            if (row) {
              options2.values = row.values;
            }
            options2.values[options2.columnIndex] = options2.value;
          }
        },
        updateFieldValue: function(options2, value2, text, forceUpdateRow) {
          var rowKey = options2.key;
          var deferred = new Deferred();
          if (void 0 === rowKey) {
            this._dataController.fireError("E1043");
          }
          if (options2.column.setCellValue) {
            this._prepareChange(options2, value2, text).done((params) => {
              when(this._applyChange(options2, params, forceUpdateRow)).always(() => {
                deferred.resolve();
              });
            });
          } else {
            deferred.resolve();
          }
          return deferred.promise();
        },
        _focusPreviousEditingCellIfNeed: function(options2) {
          if (this.hasEditData() && !this.isEditCell(options2.rowIndex, options2.columnIndex)) {
            this._focusEditingCell();
            this._updateEditRow(options2.row, true);
            return true;
          }
        },
        _needUpdateRow: function(column) {
          var visibleColumns = this._columnsController.getVisibleColumns();
          if (!column) {
            column = this._getEditColumn();
          }
          var isCustomSetCellValue = column && column.setCellValue !== column.defaultSetCellValue;
          var isCustomCalculateCellValue = visibleColumns.some((visibleColumn) => visibleColumn.calculateCellValue !== visibleColumn.defaultCalculateCellValue);
          return isCustomSetCellValue || isCustomCalculateCellValue;
        },
        _applyChange: function(options2, params, forceUpdateRow) {
          var changeOptions = _extends({}, options2, {
            forceUpdateRow
          });
          this._addChange(params, changeOptions);
          this._updateEditButtons();
          return this._applyChangeCore(options2, changeOptions.forceUpdateRow);
        },
        _applyChangeCore: function(options2, forceUpdateRow) {
          var isCustomSetCellValue = options2.column.setCellValue !== options2.column.defaultSetCellValue;
          var row = options2.row;
          if (row) {
            if (forceUpdateRow || isCustomSetCellValue) {
              this._updateEditRow(row, forceUpdateRow, isCustomSetCellValue);
            } else if (row.update) {
              row.update();
            }
          }
        },
        _updateEditRowCore: function(row, skipCurrentRow, isCustomSetCellValue) {
          this._dataController.updateItems({
            changeType: "update",
            rowIndices: this._getRowIndicesForCascadeUpdating(row, skipCurrentRow)
          });
        },
        _updateEditRow: function(row, forceUpdateRow, isCustomSetCellValue) {
          if (forceUpdateRow) {
            this._updateRowImmediately(row, forceUpdateRow, isCustomSetCellValue);
          } else {
            this._updateRowWithDelay(row, isCustomSetCellValue);
          }
        },
        _updateRowImmediately: function(row, forceUpdateRow, isCustomSetCellValue) {
          this._updateEditRowCore(row, !forceUpdateRow, isCustomSetCellValue);
          this._validateEditFormAfterUpdate(row, isCustomSetCellValue);
          if (!forceUpdateRow) {
            this._focusEditingCell();
          }
        },
        _updateRowWithDelay: function(row, isCustomSetCellValue) {
          var deferred = new Deferred();
          this.addDeferred(deferred);
          setTimeout(() => {
            var $focusedElement = renderer_default(dom_adapter_default.getActiveElement());
            var columnIndex = this._rowsView.getCellIndex($focusedElement, row.rowIndex);
            var focusedElement = $focusedElement.get(0);
            var selectionRange = ui_grid_core_utils_default.getSelectionRange(focusedElement);
            this._updateEditRowCore(row, false, isCustomSetCellValue);
            this._validateEditFormAfterUpdate(row, isCustomSetCellValue);
            if (columnIndex >= 0) {
              var $focusedItem = this._rowsView._getCellElement(row.rowIndex, columnIndex);
              this._delayedInputFocus($focusedItem, () => {
                setTimeout(() => {
                  focusedElement = dom_adapter_default.getActiveElement();
                  if (selectionRange.selectionStart >= 0) {
                    ui_grid_core_utils_default.setSelectionRange(focusedElement, selectionRange);
                  }
                });
              });
            }
            deferred.resolve();
          });
        },
        _validateEditFormAfterUpdate: noop2,
        _addChange: function(changeParams, options2) {
          var _this$getChanges;
          var row = null === options2 || void 0 === options2 ? void 0 : options2.row;
          var changes = [...this.getChanges()];
          var index2 = ui_grid_core_utils_default.getIndexByKey(changeParams.key, changes);
          if (index2 < 0) {
            index2 = changes.length;
            this._addInternalData({
              key: changeParams.key,
              oldData: changeParams.oldData
            });
            delete changeParams.oldData;
            changes.push(changeParams);
          }
          var change = _extends({}, changes[index2]);
          if (change) {
            if (changeParams.data) {
              change.data = createObjectWithChanges(change.data, changeParams.data);
            }
            if ((!change.type || !changeParams.data) && changeParams.type) {
              change.type = changeParams.type;
            }
            if (row) {
              row.oldData = this._getOldData(row.key);
              row.data = createObjectWithChanges(row.data, changeParams.data);
            }
          }
          changes[index2] = change;
          this._silentOption(EDITING_CHANGES_OPTION_NAME, changes);
          if (options2 && change !== (null === (_this$getChanges = this.getChanges()) || void 0 === _this$getChanges ? void 0 : _this$getChanges[index2])) {
            options2.forceUpdateRow = true;
          }
          return index2;
        },
        _getFormEditItemTemplate: function(cellOptions, column) {
          return column.editCellTemplate || this._getDefaultEditorTemplate();
        },
        getColumnTemplate: function(options2) {
          var column = options2.column;
          var rowIndex = options2.row && options2.row.rowIndex;
          var template;
          var isRowMode = this.isRowBasedEditMode();
          var isRowEditing = this.isEditRow(rowIndex);
          var isCellEditing = this.isEditCell(rowIndex, options2.columnIndex);
          var editingStartOptions;
          if ((column.showEditorAlways || column.setCellValue && (isRowEditing && column.allowEditing || isCellEditing)) && ("data" === options2.rowType || "detailAdaptive" === options2.rowType) && !column.command) {
            var allowUpdating = this.allowUpdating(options2);
            if (((allowUpdating || isRowEditing) && column.allowEditing || isCellEditing) && (isRowEditing || !isRowMode)) {
              if (column.showEditorAlways && !isRowMode) {
                editingStartOptions = {
                  cancel: false,
                  key: options2.row.isNewRow ? void 0 : options2.row.key,
                  data: options2.row.data,
                  column
                };
                this._isEditingStart(editingStartOptions);
              }
              if (!editingStartOptions || !editingStartOptions.cancel) {
                options2.setValue = (value2, text) => {
                  this.updateFieldValue(options2, value2, text);
                };
              }
            }
            template = column.editCellTemplate || this._getDefaultEditorTemplate();
          } else if ("detail" === column.command && "detail" === options2.rowType && isRowEditing) {
            template = null === this || void 0 === this ? void 0 : this.getEditFormTemplate(options2);
          }
          return template;
        },
        _createButton: function($container, button, options2) {
          var icon = EDIT_ICON_CLASS[button.name];
          var useIcons = this.option("editing.useIcons");
          var useLegacyColumnButtonTemplate = this.option("useLegacyColumnButtonTemplate");
          var $button = renderer_default("<a>").attr("href", "#").addClass(LINK_CLASS).addClass(button.cssClass);
          if (button.template && useLegacyColumnButtonTemplate) {
            this._rowsView.renderTemplate($container, button.template, options2, true);
          } else {
            if (button.template) {
              $button = renderer_default("<span>").addClass(button.cssClass);
            } else if (useIcons && icon || button.icon) {
              icon = button.icon || icon;
              var iconType = getImageSourceType(icon);
              if ("image" === iconType || "svg" === iconType) {
                $button = getImageContainer(icon).addClass(button.cssClass);
              } else {
                $button.addClass("dx-icon" + ("dxIcon" === iconType ? "-" : " ") + icon).attr("title", button.text);
              }
              $button.addClass("dx-link-icon");
              $container.addClass(COMMAND_EDIT_WITH_ICONS_CLASS);
              var localizationName = this.getButtonLocalizationNames()[button.name];
              localizationName && $button.attr("aria-label", message_default.format(localizationName));
            } else {
              $button.text(button.text);
            }
            if (isDefined(button.hint)) {
              $button.attr("title", button.hint);
            }
            if (!button.template || button.onClick) {
              events_engine_default.on($button, addNamespace2("click", EDITING_NAMESPACE), this.createAction(function(e) {
                var _button$onClick;
                null === (_button$onClick = button.onClick) || void 0 === _button$onClick ? void 0 : _button$onClick.call(button, extend2({}, e, {
                  row: options2.row,
                  column: options2.column
                }));
                e.event.preventDefault();
                e.event.stopPropagation();
              }));
            }
            $container.append($button, "&nbsp;");
            if (button.template) {
              this._rowsView.renderTemplate($button, button.template, options2, true);
            }
          }
        },
        getButtonLocalizationNames: () => ({
          edit: "dxDataGrid-editingEditRow",
          save: "dxDataGrid-editingSaveRowChanges",
          delete: "dxDataGrid-editingDeleteRow",
          undelete: "dxDataGrid-editingUndeleteRow",
          cancel: "dxDataGrid-editingCancelRowChanges"
        }),
        prepareButtonItem: function(headerPanel, name2, methodName, sortIndex) {
          var editingTexts = this.option("editing.texts") || {};
          var titleButtonTextByClassNames = {
            revert: editingTexts.cancelAllChanges,
            save: editingTexts.saveAllChanges,
            addRow: editingTexts.addRow
          };
          var className = {
            revert: "cancel",
            save: "save",
            addRow: "addrow"
          }[name2];
          var hintText = titleButtonTextByClassNames[name2];
          var isButtonDisabled = ("save" === className || "cancel" === className) && this._isEditButtonDisabled();
          return {
            widget: "dxButton",
            options: {
              onInitialized: (e) => {
                renderer_default(e.element).addClass(headerPanel._getToolbarButtonClass(EDIT_BUTTON_CLASS + " " + this.addWidgetPrefix(className) + "-button"));
              },
              icon: "edit-button-" + className,
              disabled: isButtonDisabled,
              onClick: () => {
                setTimeout(() => {
                  this[methodName]();
                });
              },
              text: hintText,
              hint: hintText
            },
            showText: "inMenu",
            name: name2 + "Button",
            location: "after",
            locateInMenu: "auto",
            sortIndex
          };
        },
        prepareEditButtons: function(headerPanel) {
          var editingOptions = this.option("editing") || {};
          var buttonItems = [];
          if (editingOptions.allowAdding) {
            buttonItems.push(this.prepareButtonItem(headerPanel, "addRow", "addRow", 20));
          }
          return buttonItems;
        },
        highlightDataCell: function($cell, parameters) {
          var cellModified = this.isCellModified(parameters);
          var shouldHighlight = cellModified && parameters.column.setCellValue && (this.getEditMode() !== EDIT_MODE_ROW || !parameters.row.isEditing);
          shouldHighlight && $cell.addClass(CELL_MODIFIED);
        },
        _afterInsertRow: noop2,
        _beforeSaveEditData: function(change) {
          if (change && !isDefined(change.key) && isDefined(change.type)) {
            return true;
          }
        },
        _afterSaveEditData: noop2,
        _beforeCancelEditData: noop2,
        _allowEditAction: function(actionName, options2) {
          var allowEditAction = this.option("editing." + actionName);
          if (isFunction(allowEditAction)) {
            allowEditAction = allowEditAction({
              component: this.component,
              row: options2.row
            });
          }
          return allowEditAction;
        },
        allowUpdating: function(options2, eventName) {
          var startEditAction = this.option("editing.startEditAction") || DEFAULT_START_EDIT_ACTION;
          var needCallback = arguments.length > 1 ? startEditAction === eventName || "down" === eventName : true;
          return needCallback && this._allowEditAction("allowUpdating", options2);
        },
        allowDeleting: function(options2) {
          return this._allowEditAction("allowDeleting", options2);
        },
        isCellModified: function(parameters) {
          var columnIndex = parameters.columnIndex;
          var modifiedValues = parameters.row && (parameters.row.isNewRow ? parameters.row.values : parameters.row.modifiedValues);
          return !!modifiedValues && void 0 !== modifiedValues[columnIndex];
        },
        isNewRowInEditMode: function() {
          var visibleEditRowIndex = this._getVisibleEditRowIndex();
          var rows = this._dataController.items();
          return visibleEditRowIndex >= 0 ? rows[visibleEditRowIndex].isNewRow : false;
        }
      };
    }());
    editingModule = {
      defaultOptions: function() {
        return {
          editing: {
            mode: "row",
            refreshMode: "full",
            allowAdding: false,
            allowUpdating: false,
            allowDeleting: false,
            useIcons: false,
            selectTextOnEditStart: false,
            confirmDelete: true,
            texts: {
              editRow: message_default.format("dxDataGrid-editingEditRow"),
              saveAllChanges: message_default.format("dxDataGrid-editingSaveAllChanges"),
              saveRowChanges: message_default.format("dxDataGrid-editingSaveRowChanges"),
              cancelAllChanges: message_default.format("dxDataGrid-editingCancelAllChanges"),
              cancelRowChanges: message_default.format("dxDataGrid-editingCancelRowChanges"),
              addRow: message_default.format("dxDataGrid-editingAddRow"),
              deleteRow: message_default.format("dxDataGrid-editingDeleteRow"),
              undeleteRow: message_default.format("dxDataGrid-editingUndeleteRow"),
              confirmDeleteMessage: message_default.format("dxDataGrid-editingConfirmDeleteMessage"),
              confirmDeleteTitle: ""
            },
            form: {
              colCount: 2
            },
            popup: {},
            startEditAction: "click",
            editRowKey: null,
            editColumnName: null,
            changes: []
          },
          useLegacyColumnButtonTemplate: true
        };
      },
      controllers: {
        editing: EditingController
      },
      extenders: {
        controllers: {
          data: {
            init: function() {
              this._editingController = this.getController("editing");
              this.callBase();
            },
            reload: function(full, repaintChangesOnly) {
              !repaintChangesOnly && this._editingController.refresh();
              return this.callBase.apply(this, arguments);
            },
            repaintRows: function() {
              if (this.getController("editing").isSaving()) {
                return;
              }
              return this.callBase.apply(this, arguments);
            },
            _updateEditRow: function(items) {
              var editRowKey = this.option(EDITING_EDITROWKEY_OPTION_NAME);
              var editRowIndex = ui_grid_core_utils_default.getIndexByKey(editRowKey, items);
              var editItem = items[editRowIndex];
              if (editItem) {
                var _this$_updateEditItem;
                editItem.isEditing = true;
                null === (_this$_updateEditItem = this._updateEditItem) || void 0 === _this$_updateEditItem ? void 0 : _this$_updateEditItem.call(this, editItem);
              }
            },
            _updateItemsCore: function(change) {
              this.callBase(change);
              this._updateEditRow(this.items(true));
            },
            _applyChangeUpdate: function(change) {
              this._updateEditRow(change.items);
              this.callBase(change);
            },
            _applyChangesOnly: function(change) {
              this._updateEditRow(change.items);
              this.callBase(change);
            },
            _processItems: function(items, change) {
              items = this._editingController.processItems(items, change);
              return this.callBase(items, change);
            },
            _processDataItem: function(dataItem, options2) {
              this._editingController.processDataItem(dataItem, options2, this.generateDataValues);
              return this.callBase(dataItem, options2);
            },
            _processItem: function(item, options2) {
              item = this.callBase(item, options2);
              if (item.isNewRow) {
                options2.dataIndex--;
                delete item.dataIndex;
              }
              return item;
            },
            _getChangedColumnIndices: function(oldItem, newItem, rowIndex, isLiveUpdate) {
              if (oldItem.isNewRow !== newItem.isNewRow || oldItem.removed !== newItem.removed) {
                return;
              }
              return this.callBase.apply(this, arguments);
            },
            _isCellChanged: function(oldRow, newRow, visibleRowIndex, columnIndex, isLiveUpdate) {
              var editingController = this.getController("editing");
              var cell = oldRow.cells && oldRow.cells[columnIndex];
              var isEditing = editingController && editingController.isEditCell(visibleRowIndex, columnIndex);
              if (isLiveUpdate && isEditing) {
                return false;
              }
              if (cell && cell.column && !cell.column.showEditorAlways && cell.isEditing !== isEditing) {
                return true;
              }
              return this.callBase.apply(this, arguments);
            }
          }
        },
        views: {
          rowsView: {
            init: function() {
              this.callBase();
              this._editingController = this.getController("editing");
            },
            getCellIndex: function($cell, rowIndex) {
              if (!$cell.is("td") && rowIndex >= 0) {
                var $cellElements = this.getCellElements(rowIndex);
                var cellIndex = -1;
                each($cellElements, function(index2, cellElement) {
                  if (renderer_default(cellElement).find($cell).length) {
                    cellIndex = index2;
                  }
                });
                return cellIndex;
              }
              return this.callBase.apply(this, arguments);
            },
            publicMethods: function() {
              return this.callBase().concat(["cellValue"]);
            },
            _getCellTemplate: function(options2) {
              var template = this._editingController.getColumnTemplate(options2);
              return template || this.callBase(options2);
            },
            _isNativeClick: function() {
              return (devices_default.real().ios || devices_default.real().android) && this.option("editing.allowUpdating");
            },
            _createRow: function(row) {
              var $row = this.callBase(row);
              if (row) {
                var isRowRemoved = !!row.removed;
                var isRowInserted = !!row.isNewRow;
                var isRowModified = !!row.modified;
                isRowInserted && $row.addClass(ROW_INSERTED);
                isRowModified && $row.addClass(ROW_MODIFIED);
                if (isRowInserted || isRowRemoved) {
                  $row.removeClass(ROW_SELECTED);
                }
              }
              return $row;
            },
            _getColumnIndexByElement: function($element) {
              var $tableElement = $element.closest("table");
              var $tableElements = this.getTableElements();
              while ($tableElement.length && !$tableElements.filter($tableElement).length) {
                $element = $tableElement.closest("td");
                $tableElement = $element.closest("table");
              }
              return this._getColumnIndexByElementCore($element);
            },
            _getColumnIndexByElementCore: function($element) {
              var $targetElement = $element.closest("." + ROW_CLASS3 + "> td:not(.dx-master-detail-cell)");
              return this.getCellIndex($targetElement);
            },
            _editCellByClick: function(e, eventName) {
              var editingController = this._editingController;
              var $targetElement = renderer_default(e.event.target);
              var columnIndex = this._getColumnIndexByElement($targetElement);
              var row = this._dataController.items()[e.rowIndex];
              var allowUpdating = editingController.allowUpdating({
                row
              }, eventName) || row && row.isNewRow;
              var column = this._columnsController.getVisibleColumns()[columnIndex];
              var isEditedCell = editingController.isEditCell(e.rowIndex, columnIndex);
              var allowEditing = allowUpdating && column && (column.allowEditing || isEditedCell);
              var startEditAction = this.option("editing.startEditAction") || "click";
              if ("down" === eventName) {
                if ((devices_default.real().ios || devices_default.real().android) && !isEditedCell) {
                  resetActiveElement();
                }
                return column && column.showEditorAlways && allowEditing && editingController.editCell(e.rowIndex, columnIndex);
              }
              if ("click" === eventName && "dblClick" === startEditAction && !isEditedCell) {
                var withoutSaveEditData = null === row || void 0 === row ? void 0 : row.isNewRow;
                editingController.closeEditCell(false, withoutSaveEditData);
              }
              if (allowEditing && eventName === startEditAction) {
                return editingController.editCell(e.rowIndex, columnIndex) || editingController.isEditRow(e.rowIndex);
              }
            },
            _rowPointerDown: function(e) {
              this._pointerDownTimeout = setTimeout(() => {
                this._editCellByClick(e, "down");
              });
            },
            _rowClick: function(e) {
              var isEditForm = renderer_default(e.rowElement).hasClass(this.addWidgetPrefix(EDIT_FORM_CLASS));
              e.event[TARGET_COMPONENT_NAME] = this.component;
              if (!this._editCellByClick(e, "click") && !isEditForm) {
                this.callBase.apply(this, arguments);
              }
            },
            _rowDblClick: function(e) {
              if (!this._editCellByClick(e, "dblClick")) {
                this.callBase.apply(this, arguments);
              }
            },
            _cellPrepared: function($cell, parameters) {
              var editingController = this._editingController;
              var isCommandCell = !!parameters.column.command;
              var isEditableCell = parameters.setValue;
              var isEditRow = editingController.isEditRow(parameters.rowIndex);
              var isEditing = isEditingCell(isEditRow, parameters);
              if (isEditingOrShowEditorAlwaysDataCell(isEditRow, parameters)) {
                var alignment = parameters.column.alignment;
                $cell.toggleClass(this.addWidgetPrefix(READONLY_CLASS), !isEditableCell).toggleClass(CELL_FOCUS_DISABLED_CLASS2, !isEditableCell);
                if (alignment) {
                  $cell.find(EDITORS_INPUT_SELECTOR).first().css("textAlign", alignment);
                }
              }
              if (isEditing) {
                this._editCellPrepared($cell);
              }
              if (parameters.column && !isCommandCell) {
                editingController.highlightDataCell($cell, parameters);
              }
              this.callBase.apply(this, arguments);
            },
            _editCellPrepared: noop2,
            _formItemPrepared: noop2,
            _getCellOptions: function(options2) {
              var cellOptions = this.callBase(options2);
              cellOptions.isEditing = this._editingController.isEditCell(cellOptions.rowIndex, cellOptions.columnIndex);
              return cellOptions;
            },
            _createCell: function(options2) {
              var $cell = this.callBase(options2);
              var isEditRow = this._editingController.isEditRow(options2.rowIndex);
              isEditingOrShowEditorAlwaysDataCell(isEditRow, options2) && $cell.addClass(EDITOR_CELL_CLASS2);
              return $cell;
            },
            cellValue: function(rowIndex, columnIdentifier, value2, text) {
              var cellOptions = this.getCellOptions(rowIndex, columnIdentifier);
              if (cellOptions) {
                if (void 0 === value2) {
                  return cellOptions.value;
                } else {
                  this._editingController.updateFieldValue(cellOptions, value2, text, true);
                }
              }
            },
            dispose: function() {
              this.callBase.apply(this, arguments);
              clearTimeout(this._pointerDownTimeout);
            },
            _renderCore: function() {
              this.callBase.apply(this, arguments);
              this._editingController._focusEditorIfNeed();
            }
          },
          headerPanel: {
            _getToolbarItems: function() {
              var items = this.callBase();
              var editButtonItems = this.getController("editing").prepareEditButtons(this);
              return editButtonItems.concat(items);
            },
            optionChanged: function(args) {
              var fullName = args.fullName;
              switch (args.name) {
                case "editing":
                  var excludedOptions = [EDITING_POPUP_OPTION_NAME, EDITING_CHANGES_OPTION_NAME, EDITING_EDITCOLUMNNAME_OPTION_NAME, EDITING_EDITROWKEY_OPTION_NAME];
                  var shouldInvalidate = fullName && !excludedOptions.some((optionName) => optionName === fullName);
                  shouldInvalidate && this._invalidate();
                  this.callBase(args);
                  break;
                case "useLegacyColumnButtonTemplate":
                  args.handled = true;
                  break;
                default:
                  this.callBase(args);
              }
            },
            isVisible: function() {
              var editingOptions = this.getController("editing").option("editing");
              return this.callBase() || (null === editingOptions || void 0 === editingOptions ? void 0 : editingOptions.allowAdding);
            }
          }
        }
      }
    };
  }
});

// node_modules/devextreme/esm/ui/grid_core/ui.grid_core.editing_row_based.js
var EDIT_ROW, editingRowBasedModule;
var init_ui_grid_core_editing_row_based = __esm({
  "node_modules/devextreme/esm/ui/grid_core/ui.grid_core.editing_row_based.js"() {
    init_ui_grid_core_editing_constants();
    EDIT_ROW = "dx-edit-row";
    editingRowBasedModule = {
      extenders: {
        controllers: {
          editing: {
            isRowEditMode: function() {
              return this.getEditMode() === EDIT_MODE_ROW;
            },
            _afterCancelEditData: function(rowIndex) {
              var dataController = this._dataController;
              if (this.isRowBasedEditMode() && rowIndex >= 0) {
                dataController.updateItems({
                  changeType: "update",
                  rowIndices: [rowIndex, rowIndex + 1]
                });
              } else {
                this.callBase.apply(this, arguments);
              }
            },
            _isDefaultButtonVisible: function(button, options2) {
              var isRowMode = this.isRowBasedEditMode();
              var isEditRow = options2.row && options2.row.rowIndex === this._getVisibleEditRowIndex();
              if (isRowMode) {
                switch (button.name) {
                  case "edit":
                    return !isEditRow && this.allowUpdating(options2);
                  case "delete":
                    return this.callBase.apply(this, arguments) && !isEditRow;
                  case "save":
                  case "cancel":
                    return isEditRow;
                  default:
                    return this.callBase.apply(this, arguments);
                }
              }
              return this.callBase.apply(this, arguments);
            },
            isEditRow: function(rowIndex) {
              return this.isRowBasedEditMode() && this.isEditRowByIndex(rowIndex);
            },
            _cancelSaving: function() {
              if (this.isRowBasedEditMode()) {
                if (!this.hasChanges()) {
                  this._cancelEditDataCore();
                }
              }
              this.callBase.apply(this, arguments);
            },
            _refreshCore: function(params) {
              var {
                allowCancelEditing
              } = null !== params && void 0 !== params ? params : {};
              if (this.isRowBasedEditMode()) {
                var hasUpdateChanges = this.getChanges().filter((it) => "update" === it.type).length > 0;
                this.init();
                allowCancelEditing && hasUpdateChanges && this._cancelEditDataCore();
              }
              this.callBase.apply(this, arguments);
            },
            _isEditColumnVisible: function() {
              var result2 = this.callBase.apply(this, arguments);
              var editingOptions = this.option("editing");
              var isRowEditMode = this.isRowEditMode();
              var isVisibleInRowEditMode = editingOptions.allowUpdating || editingOptions.allowAdding;
              return result2 || isRowEditMode && isVisibleInRowEditMode;
            },
            _focusEditorIfNeed: function() {
              var editMode = this.getEditMode();
              if (this._needFocusEditor) {
                if (-1 !== MODES_WITH_DELAYED_FOCUS.indexOf(editMode)) {
                  var $editingCell = this.getFocusedCellInRow(this._getVisibleEditRowIndex());
                  this._delayedInputFocus($editingCell, () => {
                    $editingCell && this.component.focus($editingCell);
                  });
                }
                this._needFocusEditor = false;
              }
            }
          },
          data: {
            _getChangedColumnIndices: function(oldItem, newItem, rowIndex, isLiveUpdate) {
              var editingController = this.getController("editing");
              if (editingController.isRowBasedEditMode() && oldItem.isEditing !== newItem.isEditing) {
                return;
              }
              return this.callBase.apply(this, arguments);
            }
          }
        },
        views: {
          rowsView: {
            _createRow: function(row) {
              var $row = this.callBase(row);
              if (row) {
                var editingController = this._editingController;
                var isEditRow = editingController.isEditRow(row.rowIndex);
                if (isEditRow) {
                  $row.addClass(EDIT_ROW);
                  $row.removeClass(ROW_SELECTED_CLASS);
                  if ("detail" === row.rowType) {
                    $row.addClass(this.addWidgetPrefix(EDIT_FORM_CLASS));
                  }
                }
              }
              return $row;
            },
            _update: function(change) {
              this.callBase(change);
              if ("updateSelection" === change.changeType) {
                this.getTableElements().children("tbody").children("." + EDIT_ROW).removeClass(ROW_SELECTED_CLASS);
              }
            }
          }
        }
      }
    };
  }
});

// node_modules/devextreme/esm/ui/form/ui.form.items_runtime_info.js
var FormItemsRunTimeInfo;
var init_ui_form_items_runtime_info = __esm({
  "node_modules/devextreme/esm/ui/form/ui.form.items_runtime_info.js"() {
    init_guid();
    init_iterator();
    init_extend();
    init_type();
    FormItemsRunTimeInfo = class {
      constructor() {
        this._map = {};
      }
      _findWidgetInstance(condition) {
        var result2;
        each(this._map, function(guid2, _ref) {
          var {
            widgetInstance,
            item
          } = _ref;
          if (condition(item)) {
            result2 = widgetInstance;
            return false;
          }
        });
        return result2;
      }
      _findFieldByCondition(callback, valueExpr) {
        var result2;
        each(this._map, function(key, value2) {
          if (callback(value2)) {
            result2 = "guid" === valueExpr ? key : value2[valueExpr];
            return false;
          }
        });
        return result2;
      }
      clear() {
        this._map = {};
      }
      removeItemsByItems(itemsRunTimeInfo) {
        each(itemsRunTimeInfo.getItems(), (guid2) => this.removeItemByKey(guid2));
      }
      removeItemByKey(key) {
        delete this._map[key];
      }
      add(options2) {
        var key = options2.guid || new guid_default();
        this._map[key] = options2;
        return key;
      }
      addItemsOrExtendFrom(itemsRunTimeInfo) {
        itemsRunTimeInfo.each((key, itemRunTimeInfo) => {
          if (this._map[key]) {
            if (itemRunTimeInfo.widgetInstance) {
              this._map[key].widgetInstance = itemRunTimeInfo.widgetInstance;
            }
            this._map[key].$itemContainer = itemRunTimeInfo.$itemContainer;
          } else {
            this.add({
              item: itemRunTimeInfo.item,
              widgetInstance: itemRunTimeInfo.widgetInstance,
              guid: key,
              $itemContainer: itemRunTimeInfo.$itemContainer
            });
          }
        });
      }
      extendRunTimeItemInfoByKey(key, options2) {
        if (this._map[key]) {
          this._map[key] = extend2(this._map[key], options2);
        }
      }
      findWidgetInstanceByItem(item) {
        return this._findWidgetInstance((storedItem) => storedItem === item);
      }
      getGroupOrTabLayoutManagerByPath(targetPath) {
        return this._findFieldByCondition((_ref2) => {
          var {
            path
          } = _ref2;
          return path === targetPath;
        }, "layoutManager");
      }
      getKeyByPath(targetPath) {
        return this._findFieldByCondition((_ref3) => {
          var {
            path
          } = _ref3;
          return path === targetPath;
        }, "guid");
      }
      findWidgetInstanceByName(name2) {
        return this._findWidgetInstance((item) => name2 === item.name);
      }
      findWidgetInstanceByDataField(dataField) {
        return this._findWidgetInstance((item) => dataField === (isString2(item) ? item : item.dataField));
      }
      findItemContainerByItem(item) {
        for (var key in this._map) {
          if (this._map[key].item === item) {
            return this._map[key].$itemContainer;
          }
        }
        return null;
      }
      findItemIndexByItem(targetItem) {
        return this._findFieldByCondition((_ref4) => {
          var {
            item
          } = _ref4;
          return item === targetItem;
        }, "itemIndex");
      }
      getItems() {
        return this._map;
      }
      each(handler) {
        each(this._map, function(key, itemRunTimeInfo) {
          handler(key, itemRunTimeInfo);
        });
      }
      removeItemsByPathStartWith(path) {
        var keys = Object.keys(this._map);
        var filteredKeys = keys.filter((key) => this._map[key].path.indexOf(path, 0) > -1);
        filteredKeys.forEach((key) => this.removeItemByKey(key));
      }
    };
  }
});

// node_modules/devextreme/esm/ui/multi_view/ui.multi_view.animation.js
var _translator, animation2;
var init_ui_multi_view_animation = __esm({
  "node_modules/devextreme/esm/ui/multi_view/ui.multi_view.animation.js"() {
    init_fx();
    init_translator();
    _translator = {
      move($element, position3) {
        move($element, {
          left: position3
        });
      }
    };
    animation2 = {
      moveTo($element, position3, duration, completeAction) {
        fx_default.animate($element, {
          type: "slide",
          to: {
            left: position3
          },
          duration,
          complete: completeAction
        });
      },
      complete($element) {
        fx_default.stop($element, true);
      }
    };
  }
});

// node_modules/devextreme/esm/events/gesture/swipeable.js
var DX_SWIPEABLE, SWIPEABLE_CLASS, ACTION_TO_EVENT_MAP, Swipeable, swipeable_default;
var init_swipeable = __esm({
  "node_modules/devextreme/esm/events/gesture/swipeable.js"() {
    init_swipe();
    init_events_engine();
    init_dom_component();
    init_iterator();
    init_utils2();
    init_extend();
    init_public_component();
    DX_SWIPEABLE = "dxSwipeable";
    SWIPEABLE_CLASS = "dx-swipeable";
    ACTION_TO_EVENT_MAP = {
      onStart: SWIPE_START_EVENT,
      onUpdated: SWIPE_EVENT,
      onEnd: SWIPE_END_EVENT,
      onCancel: "dxswipecancel"
    };
    Swipeable = dom_component_default.inherit({
      _getDefaultOptions: function() {
        return extend2(this.callBase(), {
          elastic: true,
          immediate: false,
          direction: "horizontal",
          itemSizeFunc: null,
          onStart: null,
          onUpdated: null,
          onEnd: null,
          onCancel: null
        });
      },
      _render: function() {
        this.callBase();
        this.$element().addClass(SWIPEABLE_CLASS);
        this._attachEventHandlers();
      },
      _attachEventHandlers: function() {
        this._detachEventHandlers();
        if (this.option("disabled")) {
          return;
        }
        var NAME = this.NAME;
        this._createEventData();
        each(ACTION_TO_EVENT_MAP, (function(actionName, eventName) {
          var action = this._createActionByOption(actionName, {
            context: this
          });
          eventName = addNamespace2(eventName, NAME);
          events_engine_default.on(this.$element(), eventName, this._eventData, function(e) {
            return action({
              event: e
            });
          });
        }).bind(this));
      },
      _createEventData: function() {
        this._eventData = {
          elastic: this.option("elastic"),
          itemSizeFunc: this.option("itemSizeFunc"),
          direction: this.option("direction"),
          immediate: this.option("immediate")
        };
      },
      _detachEventHandlers: function() {
        events_engine_default.off(this.$element(), "." + DX_SWIPEABLE);
      },
      _optionChanged: function(args) {
        switch (args.name) {
          case "disabled":
          case "onStart":
          case "onUpdated":
          case "onEnd":
          case "onCancel":
          case "elastic":
          case "immediate":
          case "itemSizeFunc":
          case "direction":
            this._detachEventHandlers();
            this._attachEventHandlers();
            break;
          case "rtlEnabled":
            break;
          default:
            this.callBase(args);
        }
      },
      _useTemplates: function() {
        return false;
      }
    });
    getName(Swipeable, DX_SWIPEABLE);
    swipeable_default = Swipeable;
  }
});

// node_modules/devextreme/esm/ui/multi_view.js
var MULTIVIEW_CLASS, MULTIVIEW_WRAPPER_CLASS, MULTIVIEW_ITEM_CONTAINER_CLASS, MULTIVIEW_ITEM_CLASS, MULTIVIEW_ITEM_HIDDEN_CLASS, MULTIVIEW_ITEM_DATA_KEY, MULTIVIEW_ANIMATION_DURATION, toNumber, position2, MultiView, multi_view_default;
var init_multi_view = __esm({
  "node_modules/devextreme/esm/ui/multi_view.js"() {
    init_renderer();
    init_translator();
    init_ui_multi_view_animation();
    init_math();
    init_extend();
    init_common();
    init_visibility_change();
    init_element();
    init_type();
    init_devices();
    init_component_registrator();
    init_ui_collection_widget_live_update();
    init_swipeable();
    init_deferred();
    MULTIVIEW_CLASS = "dx-multiview";
    MULTIVIEW_WRAPPER_CLASS = "dx-multiview-wrapper";
    MULTIVIEW_ITEM_CONTAINER_CLASS = "dx-multiview-item-container";
    MULTIVIEW_ITEM_CLASS = "dx-multiview-item";
    MULTIVIEW_ITEM_HIDDEN_CLASS = "dx-multiview-item-hidden";
    MULTIVIEW_ITEM_DATA_KEY = "dxMultiViewItemData";
    MULTIVIEW_ANIMATION_DURATION = 200;
    toNumber = (value2) => +value2;
    position2 = ($element) => locate($element).left;
    MultiView = ui_collection_widget_live_update_default.inherit({
      _activeStateUnit: "." + MULTIVIEW_ITEM_CLASS,
      _supportedKeys: function() {
        return extend2(this.callBase(), {
          pageUp: noop2,
          pageDown: noop2
        });
      },
      _getDefaultOptions: function() {
        return extend2(this.callBase(), {
          selectedIndex: 0,
          swipeEnabled: true,
          animationEnabled: true,
          loop: false,
          deferRendering: true,
          _itemAttributes: {
            role: "tabpanel"
          },
          loopItemFocus: false,
          selectOnFocus: true,
          selectionMode: "single",
          selectionRequired: true,
          selectionByClick: false
        });
      },
      _defaultOptionsRules: function() {
        return this.callBase().concat([{
          device: function() {
            return "desktop" === devices_default.real().deviceType && !devices_default.isSimulator();
          },
          options: {
            focusStateEnabled: true
          }
        }]);
      },
      _itemClass: function() {
        return MULTIVIEW_ITEM_CLASS;
      },
      _itemDataKey: function() {
        return MULTIVIEW_ITEM_DATA_KEY;
      },
      _itemContainer: function() {
        return this._$itemContainer;
      },
      _itemElements: function() {
        return this._itemContainer().children(this._itemSelector());
      },
      _itemWidth: function() {
        if (!this._itemWidthValue) {
          this._itemWidthValue = this._$wrapper.width();
        }
        return this._itemWidthValue;
      },
      _clearItemWidthCache: function() {
        delete this._itemWidthValue;
      },
      _itemsCount: function() {
        return this.option("items").length;
      },
      _normalizeIndex: function(index2) {
        var count = this._itemsCount();
        if (index2 < 0) {
          index2 += count;
        }
        if (index2 >= count) {
          index2 -= count;
        }
        return index2;
      },
      _getRTLSignCorrection: function() {
        return this.option("rtlEnabled") ? -1 : 1;
      },
      _init: function() {
        this.callBase.apply(this, arguments);
        var $element = this.$element();
        $element.addClass(MULTIVIEW_CLASS);
        this._$wrapper = renderer_default("<div>").addClass(MULTIVIEW_WRAPPER_CLASS);
        this._$wrapper.appendTo($element);
        this._$itemContainer = renderer_default("<div>").addClass(MULTIVIEW_ITEM_CONTAINER_CLASS);
        this._$itemContainer.appendTo(this._$wrapper);
        this.option("loopItemFocus", this.option("loop"));
        this._initSwipeable();
      },
      _initMarkup: function() {
        this._deferredItems = [];
        this.callBase();
        var selectedItemIndices = this._getSelectedItemIndices();
        this._updateItemsVisibility(selectedItemIndices[0]);
      },
      _afterItemElementDeleted: function($item, deletedActionArgs) {
        this.callBase($item, deletedActionArgs);
        if (this._deferredItems) {
          this._deferredItems.splice(deletedActionArgs.itemIndex, 1);
        }
      },
      _beforeItemElementInserted: function(change) {
        this.callBase.apply(this, arguments);
        if (this._deferredItems) {
          this._deferredItems.splice(change.index, 0, null);
        }
      },
      _executeItemRenderAction: function(index2, itemData, itemElement) {
        index2 = (this.option("items") || []).indexOf(itemData);
        this.callBase(index2, itemData, itemElement);
      },
      _renderItemContent: function(args) {
        var renderContentDeferred = new Deferred();
        var that = this;
        var callBase = this.callBase;
        var deferred = new Deferred();
        deferred.done(function() {
          var $itemContent = callBase.call(that, args);
          renderContentDeferred.resolve($itemContent);
        });
        this._deferredItems[args.index] = deferred;
        this.option("deferRendering") || deferred.resolve();
        return renderContentDeferred.promise();
      },
      _render: function() {
        this.callBase();
        deferRender(() => {
          var selectedItemIndices = this._getSelectedItemIndices();
          this._updateItems(selectedItemIndices[0]);
        });
      },
      _updateItems: function(selectedIndex, newIndex) {
        this._updateItemsPosition(selectedIndex, newIndex);
        this._updateItemsVisibility(selectedIndex, newIndex);
      },
      _modifyByChanges: function() {
        this.callBase.apply(this, arguments);
        var selectedItemIndices = this._getSelectedItemIndices();
        this._updateItemsVisibility(selectedItemIndices[0]);
      },
      _updateItemsPosition: function(selectedIndex, newIndex) {
        var $itemElements = this._itemElements();
        var positionSign = isDefined(newIndex) ? -this._animationDirection(newIndex, selectedIndex) : void 0;
        var $selectedItem = $itemElements.eq(selectedIndex);
        _translator.move($selectedItem, 0);
        if (isDefined(newIndex)) {
          _translator.move($itemElements.eq(newIndex), 100 * positionSign + "%");
        }
      },
      _updateItemsVisibility: function(selectedIndex, newIndex) {
        var $itemElements = this._itemElements();
        $itemElements.each((function(itemIndex, item) {
          var $item = renderer_default(item);
          var isHidden = itemIndex !== selectedIndex && itemIndex !== newIndex;
          if (!isHidden) {
            this._renderSpecificItem(itemIndex);
          }
          $item.toggleClass(MULTIVIEW_ITEM_HIDDEN_CLASS, isHidden);
          this.setAria("hidden", isHidden || void 0, $item);
        }).bind(this));
      },
      _renderSpecificItem: function(index2) {
        var $item = this._itemElements().eq(index2);
        var hasItemContent = $item.find(this._itemContentClass()).length > 0;
        if (isDefined(index2) && !hasItemContent) {
          this._deferredItems[index2].resolve();
          triggerResizeEvent($item);
        }
      },
      _refreshItem: function($item, item) {
        this.callBase($item, item);
        this._updateItemsVisibility(this.option("selectedIndex"));
      },
      _setAriaSelected: noop2,
      _updateSelection: function(addedSelection, removedSelection) {
        var newIndex = addedSelection[0];
        var prevIndex = removedSelection[0];
        animation2.complete(this._$itemContainer);
        this._updateItems(prevIndex, newIndex);
        var animationDirection = this._animationDirection(newIndex, prevIndex);
        this._animateItemContainer(animationDirection * this._itemWidth(), (function() {
          _translator.move(this._$itemContainer, 0);
          this._updateItems(newIndex);
          this._$itemContainer.width();
        }).bind(this));
      },
      _animateItemContainer: function(position3, completeCallback) {
        var duration = this.option("animationEnabled") ? MULTIVIEW_ANIMATION_DURATION : 0;
        animation2.moveTo(this._$itemContainer, position3, duration, completeCallback);
      },
      _animationDirection: function(newIndex, prevIndex) {
        var containerPosition = position2(this._$itemContainer);
        var indexDifference = (prevIndex - newIndex) * this._getRTLSignCorrection() * this._getItemFocusLoopSignCorrection();
        var isSwipePresent = 0 !== containerPosition;
        var directionSignVariable = isSwipePresent ? containerPosition : indexDifference;
        return sign(directionSignVariable);
      },
      _getSwipeDisabledState() {
        return !this.option("swipeEnabled") || this._itemsCount() <= 1;
      },
      _initSwipeable() {
        this._createComponent(this.$element(), swipeable_default, {
          disabled: this._getSwipeDisabledState(),
          elastic: false,
          itemSizeFunc: this._itemWidth.bind(this),
          onStart: (args) => this._swipeStartHandler(args.event),
          onUpdated: (args) => this._swipeUpdateHandler(args.event),
          onEnd: (args) => this._swipeEndHandler(args.event)
        });
      },
      _swipeStartHandler: function(e) {
        animation2.complete(this._$itemContainer);
        var selectedIndex = this.option("selectedIndex");
        var loop = this.option("loop");
        var lastIndex = this._itemsCount() - 1;
        var rtl = this.option("rtlEnabled");
        e.maxLeftOffset = toNumber(loop || (rtl ? selectedIndex > 0 : selectedIndex < lastIndex));
        e.maxRightOffset = toNumber(loop || (rtl ? selectedIndex < lastIndex : selectedIndex > 0));
        this._swipeDirection = null;
      },
      _swipeUpdateHandler: function(e) {
        var offset2 = e.offset;
        var swipeDirection = sign(offset2) * this._getRTLSignCorrection();
        _translator.move(this._$itemContainer, offset2 * this._itemWidth());
        if (swipeDirection !== this._swipeDirection) {
          this._swipeDirection = swipeDirection;
          var selectedIndex = this.option("selectedIndex");
          var newIndex = this._normalizeIndex(selectedIndex - swipeDirection);
          this._updateItems(selectedIndex, newIndex);
        }
      },
      _swipeEndHandler: function(e) {
        var targetOffset = e.targetOffset * this._getRTLSignCorrection();
        if (targetOffset) {
          this.option("selectedIndex", this._normalizeIndex(this.option("selectedIndex") - targetOffset));
          var $selectedElement = this.itemElements().filter(".dx-item-selected");
          this.option("focusStateEnabled") && this.option("focusedElement", getPublicElement($selectedElement));
        } else {
          this._animateItemContainer(0, noop2);
        }
      },
      _getItemFocusLoopSignCorrection: function() {
        return this._itemFocusLooped ? -1 : 1;
      },
      _moveFocus: function() {
        this.callBase.apply(this, arguments);
        this._itemFocusLooped = false;
      },
      _prevItem: function($items) {
        var $result = this.callBase.apply(this, arguments);
        this._itemFocusLooped = $result.is($items.last());
        return $result;
      },
      _nextItem: function($items) {
        var $result = this.callBase.apply(this, arguments);
        this._itemFocusLooped = $result.is($items.first());
        return $result;
      },
      _dimensionChanged: function() {
        this._clearItemWidthCache();
      },
      _visibilityChanged: function(visible2) {
        if (visible2) {
          this._dimensionChanged();
        }
      },
      _updateSwipeDisabledState() {
        var disabled = this._getSwipeDisabledState();
        swipeable_default.getInstance(this.$element()).option("disabled", disabled);
      },
      _optionChanged: function(args) {
        var value2 = args.value;
        switch (args.name) {
          case "loop":
            this.option("loopItemFocus", value2);
            break;
          case "animationEnabled":
            break;
          case "swipeEnabled":
            this._updateSwipeDisabledState();
            break;
          case "deferRendering":
            this._invalidate();
            break;
          case "items":
            this._updateSwipeDisabledState();
            this.callBase(args);
            break;
          default:
            this.callBase(args);
        }
      }
    });
    component_registrator_default("dxMultiView", MultiView);
    multi_view_default = MultiView;
  }
});

// node_modules/devextreme/esm/ui/tabs/item.js
var TABS_ITEM_BADGE_CLASS, BADGE_CLASS2, TabsItem, item_default3;
var init_item3 = __esm({
  "node_modules/devextreme/esm/ui/tabs/item.js"() {
    init_renderer();
    init_item();
    TABS_ITEM_BADGE_CLASS = "dx-tabs-item-badge";
    BADGE_CLASS2 = "dx-badge";
    TabsItem = item_default.inherit({
      _renderWatchers: function() {
        this.callBase();
        this._startWatcher("badge", this._renderBadge.bind(this));
      },
      _renderBadge: function(badge) {
        this._$element.children("." + BADGE_CLASS2).remove();
        if (!badge) {
          return;
        }
        var $badge = renderer_default("<div>").addClass(TABS_ITEM_BADGE_CLASS).addClass(BADGE_CLASS2).text(badge);
        this._$element.append($badge);
      }
    });
    item_default3 = TabsItem;
  }
});

// node_modules/devextreme/esm/ui/tabs/constants.js
var TABS_EXPANDED_CLASS;
var init_constants2 = __esm({
  "node_modules/devextreme/esm/ui/tabs/constants.js"() {
    TABS_EXPANDED_CLASS = "dx-tabs-expanded";
  }
});

// node_modules/devextreme/esm/renovation/ui/scroll_view/utils/get_scroll_left_max.js
function getScrollLeftMax(element) {
  return element.scrollWidth - element.clientWidth;
}
var init_get_scroll_left_max = __esm({
  "node_modules/devextreme/esm/renovation/ui/scroll_view/utils/get_scroll_left_max.js"() {
  }
});

// node_modules/devextreme/esm/renovation/ui/scroll_view/utils/get_scroll_top_max.js
var init_get_scroll_top_max = __esm({
  "node_modules/devextreme/esm/renovation/ui/scroll_view/utils/get_scroll_top_max.js"() {
  }
});

// node_modules/devextreme/esm/renovation/ui/scroll_view/utils/scroll_direction.js
var init_scroll_direction = __esm({
  "node_modules/devextreme/esm/renovation/ui/scroll_view/utils/scroll_direction.js"() {
    init_consts();
  }
});

// node_modules/devextreme/esm/renovation/ui/scroll_view/utils/get_boundary_props.js
function isReachedLeft(scrollOffsetLeft, epsilon) {
  return Math.round(scrollOffsetLeft) <= epsilon;
}
function isReachedRight(element, scrollOffsetLeft, epsilon) {
  return Math.round(getScrollLeftMax(element) - scrollOffsetLeft) <= epsilon;
}
var init_get_boundary_props = __esm({
  "node_modules/devextreme/esm/renovation/ui/scroll_view/utils/get_boundary_props.js"() {
    init_get_scroll_left_max();
    init_get_scroll_top_max();
    init_scroll_direction();
  }
});

// node_modules/devextreme/esm/ui/tabs.js
var TABS_CLASS, TABS_WRAPPER_CLASS, TABS_STRETCHED_CLASS, TABS_SCROLLABLE_CLASS, TABS_NAV_BUTTONS_CLASS, OVERFLOW_HIDDEN_CLASS, TABS_ITEM_CLASS, TABS_ITEM_SELECTED_CLASS, TABS_NAV_BUTTON_CLASS, TABS_LEFT_NAV_BUTTON_CLASS, TABS_RIGHT_NAV_BUTTON_CLASS, TABS_ITEM_TEXT_CLASS, TABS_ITEM_DATA_KEY, BUTTON_NEXT_ICON, BUTTON_PREV_ICON, FEEDBACK_HIDE_TIMEOUT, FEEDBACK_DURATION_INTERVAL, FEEDBACK_SCROLL_TIMEOUT, TAB_OFFSET, Tabs, tabs_default;
var init_tabs = __esm({
  "node_modules/devextreme/esm/ui/tabs.js"() {
    init_renderer();
    init_events_engine();
    init_devices();
    init_component_registrator();
    init_button();
    init_utils_ink_ripple();
    init_utils2();
    init_extend();
    init_type();
    init_pointer();
    init_iterator();
    init_item3();
    init_constants2();
    init_themes();
    init_hold();
    init_ui_scrollable();
    init_ui_collection_widget_live_update();
    init_icon();
    init_bindable_template();
    init_deferred();
    init_get_boundary_props();
    init_get_scroll_left_max();
    TABS_CLASS = "dx-tabs";
    TABS_WRAPPER_CLASS = "dx-tabs-wrapper";
    TABS_STRETCHED_CLASS = "dx-tabs-stretched";
    TABS_SCROLLABLE_CLASS = "dx-tabs-scrollable";
    TABS_NAV_BUTTONS_CLASS = "dx-tabs-nav-buttons";
    OVERFLOW_HIDDEN_CLASS = "dx-overflow-hidden";
    TABS_ITEM_CLASS = "dx-tab";
    TABS_ITEM_SELECTED_CLASS = "dx-tab-selected";
    TABS_NAV_BUTTON_CLASS = "dx-tabs-nav-button";
    TABS_LEFT_NAV_BUTTON_CLASS = "dx-tabs-nav-button-left";
    TABS_RIGHT_NAV_BUTTON_CLASS = "dx-tabs-nav-button-right";
    TABS_ITEM_TEXT_CLASS = "dx-tab-text";
    TABS_ITEM_DATA_KEY = "dxTabData";
    BUTTON_NEXT_ICON = "chevronnext";
    BUTTON_PREV_ICON = "chevronprev";
    FEEDBACK_HIDE_TIMEOUT = 100;
    FEEDBACK_DURATION_INTERVAL = 5;
    FEEDBACK_SCROLL_TIMEOUT = 300;
    TAB_OFFSET = 30;
    Tabs = ui_collection_widget_live_update_default.inherit({
      _activeStateUnit: "." + TABS_ITEM_CLASS,
      _getDefaultOptions: function() {
        return extend2(this.callBase(), {
          hoverStateEnabled: true,
          showNavButtons: true,
          scrollByContent: true,
          scrollingEnabled: true,
          selectionMode: "single",
          activeStateEnabled: true,
          selectionRequired: false,
          selectOnFocus: true,
          loopItemFocus: false,
          useInkRipple: false,
          badgeExpr: function(data2) {
            return data2 ? data2.badge : void 0;
          },
          _itemAttributes: {
            role: "tab"
          }
        });
      },
      _defaultOptionsRules: function() {
        var themeName = current();
        return this.callBase().concat([{
          device: function() {
            return "desktop" !== devices_default.real().deviceType;
          },
          options: {
            showNavButtons: false
          }
        }, {
          device: {
            deviceType: "desktop"
          },
          options: {
            scrollByContent: false
          }
        }, {
          device: function() {
            return "desktop" === devices_default.real().deviceType && !devices_default.isSimulator();
          },
          options: {
            focusStateEnabled: true
          }
        }, {
          device: function() {
            return isMaterial(themeName);
          },
          options: {
            useInkRipple: true,
            selectOnFocus: false
          }
        }]);
      },
      _init: function() {
        this.callBase();
        this.setAria("role", "tablist");
        this.$element().addClass(TABS_CLASS);
        this._renderWrapper();
        this._renderMultiple();
        this._feedbackHideTimeout = FEEDBACK_HIDE_TIMEOUT;
      },
      _initTemplates: function() {
        this.callBase();
        this._templateManager.addDefaultTemplates({
          item: new BindableTemplate((function($container, data2) {
            if (isPlainObject(data2)) {
              this._prepareDefaultItemTemplate(data2, $container);
            } else {
              $container.text(String(data2));
            }
            var $iconElement = getImageContainer(data2.icon);
            $iconElement && $iconElement.prependTo($container);
            $container.wrapInner(renderer_default("<span>").addClass(TABS_ITEM_TEXT_CLASS));
          }).bind(this), ["text", "html", "icon"], this.option("integrationOptions.watchMethod"))
        });
      },
      _createItemByTemplate: function(itemTemplate, renderArgs) {
        var {
          itemData,
          container,
          index: index2
        } = renderArgs;
        this._deferredTemplates[index2] = new Deferred();
        return itemTemplate.render({
          model: itemData,
          container,
          index: index2,
          onRendered: () => this._deferredTemplates[index2].resolve()
        });
      },
      _itemClass: function() {
        return TABS_ITEM_CLASS;
      },
      _selectedItemClass: function() {
        return TABS_ITEM_SELECTED_CLASS;
      },
      _itemDataKey: function() {
        return TABS_ITEM_DATA_KEY;
      },
      _initMarkup: function() {
        this._deferredTemplates = [];
        this.callBase();
        this.option("useInkRipple") && this._renderInkRipple();
        this.$element().addClass(OVERFLOW_HIDDEN_CLASS);
      },
      _render: function() {
        this.callBase();
        this._deferRenderScrolling();
      },
      _deferRenderScrolling() {
        when.apply(this, this._deferredTemplates).done(() => this._renderScrolling());
      },
      _renderScrolling: function() {
        var removeClasses = [TABS_STRETCHED_CLASS, TABS_EXPANDED_CLASS, OVERFLOW_HIDDEN_CLASS];
        this.$element().removeClass(removeClasses.join(" "));
        if (this.option("scrollingEnabled") && this._isItemsWidthExceeded()) {
          if (!this._scrollable) {
            this._renderScrollable();
            this._renderNavButtons();
          }
          var scrollable = this.getScrollable();
          scrollable.update();
          if (this.option("rtlEnabled")) {
            var maxLeftOffset = getScrollLeftMax(renderer_default(this.getScrollable().container()).get(0));
            scrollable.scrollTo({
              left: maxLeftOffset
            });
          }
          this._updateNavButtonsVisibility();
          this._scrollToItem(this.option("selectedItem"));
        }
        if (!(this.option("scrollingEnabled") && this._isItemsWidthExceeded())) {
          this._cleanScrolling();
          if (this._needStretchItems() && !this._isItemsWidthExceeded()) {
            this.$element().addClass(TABS_STRETCHED_CLASS);
          }
          this.$element().removeClass(TABS_NAV_BUTTONS_CLASS).addClass(TABS_EXPANDED_CLASS);
        }
      },
      _isItemsWidthExceeded: function() {
        var tabItemsWidth = this._getSummaryItemsWidth(this._getVisibleItems(), true);
        return tabItemsWidth - 1 > this.$element().width();
      },
      _needStretchItems: function() {
        var $visibleItems = this._getVisibleItems();
        var elementWidth = this.$element().width();
        var itemsWidth = [];
        each($visibleItems, (_2, item) => {
          itemsWidth.push(renderer_default(item).outerWidth(true));
        });
        var maxTabWidth = Math.max.apply(null, itemsWidth);
        return maxTabWidth > elementWidth / $visibleItems.length;
      },
      _cleanNavButtons: function() {
        if (!this._leftButton || !this._rightButton) {
          return;
        }
        this._leftButton.$element().remove();
        this._rightButton.$element().remove();
        this._leftButton = null;
        this._rightButton = null;
      },
      _cleanScrolling: function() {
        if (!this._scrollable) {
          return;
        }
        this._$wrapper.appendTo(this.$element());
        this._scrollable.$element().remove();
        this._scrollable = null;
        this._cleanNavButtons();
      },
      _renderInkRipple: function() {
        this._inkRipple = render();
      },
      _toggleActiveState: function($element, value2, e) {
        this.callBase.apply(this, arguments);
        if (!this._inkRipple) {
          return;
        }
        var config2 = {
          element: $element,
          event: e
        };
        if (value2) {
          this._inkRipple.showWave(config2);
        } else {
          this._inkRipple.hideWave(config2);
        }
      },
      _renderMultiple: function() {
        if ("multiple" === this.option("selectionMode")) {
          this.option("selectOnFocus", false);
        }
      },
      _renderWrapper: function() {
        this._$wrapper = renderer_default("<div>").addClass(TABS_WRAPPER_CLASS);
        this.$element().append(this._$wrapper);
      },
      _itemContainer: function() {
        return this._$wrapper;
      },
      _renderScrollable: function() {
        var $itemContainer = this.$element().wrapInner(renderer_default("<div>").addClass(TABS_SCROLLABLE_CLASS)).children();
        this._scrollable = this._createComponent($itemContainer, ui_scrollable_default, {
          direction: "horizontal",
          showScrollbar: false,
          useKeyboard: false,
          useNative: false,
          scrollByContent: this.option("scrollByContent"),
          onScroll: () => {
            this._updateNavButtonsVisibility();
          }
        });
        this.$element().append(this._scrollable.$element());
      },
      _scrollToItem: function(itemData) {
        if (!this._scrollable) {
          return;
        }
        var $item = this._editStrategy.getItemElement(itemData);
        this._scrollable.scrollToElement($item);
      },
      _renderNavButtons: function() {
        this.$element().toggleClass(TABS_NAV_BUTTONS_CLASS, this.option("showNavButtons"));
        if (!this.option("showNavButtons")) {
          return;
        }
        var rtlEnabled = this.option("rtlEnabled");
        this._leftButton = this._createNavButton(-TAB_OFFSET, rtlEnabled ? BUTTON_NEXT_ICON : BUTTON_PREV_ICON);
        var $leftButton = this._leftButton.$element();
        $leftButton.addClass(TABS_LEFT_NAV_BUTTON_CLASS);
        this.$element().prepend($leftButton);
        this._rightButton = this._createNavButton(TAB_OFFSET, rtlEnabled ? BUTTON_PREV_ICON : BUTTON_NEXT_ICON);
        var $rightButton = this._rightButton.$element();
        $rightButton.addClass(TABS_RIGHT_NAV_BUTTON_CLASS);
        this.$element().append($rightButton);
      },
      _updateNavButtonsVisibility: function() {
        var scrollable = this.getScrollable();
        this._leftButton && this._leftButton.option("disabled", isReachedLeft(scrollable.scrollLeft(), 1));
        this._rightButton && this._rightButton.option("disabled", isReachedRight(renderer_default(scrollable.container()).get(0), scrollable.scrollLeft(), 1));
      },
      _updateScrollPosition: function(offset2, duration) {
        this._scrollable.update();
        this._scrollable.scrollBy(offset2 / duration);
      },
      _createNavButton: function(offset2, icon) {
        var that = this;
        var holdAction = that._createAction(function() {
          that._holdInterval = setInterval(function() {
            that._updateScrollPosition(offset2, FEEDBACK_DURATION_INTERVAL);
          }, FEEDBACK_DURATION_INTERVAL);
        });
        var holdEventName = addNamespace2(hold_default.name, "dxNavButton");
        var pointerUpEventName = addNamespace2(pointer_default.up, "dxNavButton");
        var pointerOutEventName = addNamespace2(pointer_default.out, "dxNavButton");
        var navButton = this._createComponent(renderer_default("<div>").addClass(TABS_NAV_BUTTON_CLASS), button_default, {
          focusStateEnabled: false,
          icon,
          onClick: function() {
            that._updateScrollPosition(offset2, 1);
          },
          integrationOptions: {}
        });
        var $navButton = navButton.$element();
        events_engine_default.on($navButton, holdEventName, {
          timeout: FEEDBACK_SCROLL_TIMEOUT
        }, (function(e) {
          holdAction({
            event: e
          });
        }).bind(this));
        events_engine_default.on($navButton, pointerUpEventName, function() {
          that._clearInterval();
        });
        events_engine_default.on($navButton, pointerOutEventName, function() {
          that._clearInterval();
        });
        return navButton;
      },
      _clearInterval: function() {
        if (this._holdInterval) {
          clearInterval(this._holdInterval);
        }
      },
      _updateSelection: function(addedSelection) {
        this._scrollable && this._scrollable.scrollToElement(this.itemElements().eq(addedSelection[0]), {
          left: 1,
          right: 1
        });
      },
      _visibilityChanged: function(visible2) {
        if (visible2) {
          this._dimensionChanged();
        }
      },
      _dimensionChanged: function() {
        this._renderScrolling();
      },
      _itemSelectHandler: function(e) {
        if ("single" === this.option("selectionMode") && this.isItemSelected(e.currentTarget)) {
          return;
        }
        this.callBase(e);
      },
      _clean: function() {
        this._deferredTemplates = [];
        this._cleanScrolling();
        this.callBase();
      },
      _optionChanged: function(args) {
        switch (args.name) {
          case "useInkRipple":
          case "scrollingEnabled":
          case "showNavButtons":
            this._invalidate();
            break;
          case "scrollByContent":
            this._scrollable && this._scrollable.option(args.name, args.value);
            break;
          case "width":
            this.callBase(args);
            this._dimensionChanged();
            break;
          case "selectionMode":
            this._renderMultiple();
            this.callBase(args);
            break;
          case "badgeExpr":
            this._invalidate();
            break;
          default:
            this.callBase(args);
        }
      },
      _afterItemElementInserted() {
        this.callBase();
        this._deferRenderScrolling();
      },
      _afterItemElementDeleted($item, deletedActionArgs) {
        this.callBase($item, deletedActionArgs);
        this._renderScrolling();
      },
      getScrollable() {
        return this._scrollable;
      }
    });
    Tabs.ItemClass = item_default3;
    component_registrator_default("dxTabs", Tabs);
    tabs_default = Tabs;
  }
});

// node_modules/devextreme/esm/ui/tab_panel/item.js
var TabPanelItem;
var init_item4 = __esm({
  "node_modules/devextreme/esm/ui/tab_panel/item.js"() {
    init_item();
    init_common();
    TabPanelItem = class extends item_default {
      _renderWatchers() {
        this._startWatcher("badge", noop2);
        return super._renderWatchers();
      }
    };
  }
});

// node_modules/devextreme/esm/ui/tab_panel.js
var TABPANEL_CLASS, TABPANEL_TABS_CLASS, TABPANEL_CONTAINER_CLASS, TABS_ITEM_TEXT_CLASS2, TabPanel, tab_panel_default;
var init_tab_panel = __esm({
  "node_modules/devextreme/esm/ui/tab_panel.js"() {
    init_renderer();
    init_support();
    init_extend();
    init_devices();
    init_dom_adapter();
    init_component_registrator();
    init_multi_view();
    init_tabs();
    init_item4();
    init_icon();
    init_element();
    init_type();
    init_bindable_template();
    init_window();
    TABPANEL_CLASS = "dx-tabpanel";
    TABPANEL_TABS_CLASS = "dx-tabpanel-tabs";
    TABPANEL_CONTAINER_CLASS = "dx-tabpanel-container";
    TABS_ITEM_TEXT_CLASS2 = "dx-tab-text";
    TabPanel = multi_view_default.inherit({
      _getDefaultOptions: function() {
        return extend2(this.callBase(), {
          itemTitleTemplate: "title",
          hoverStateEnabled: true,
          showNavButtons: false,
          scrollByContent: true,
          scrollingEnabled: true,
          onTitleClick: null,
          onTitleHold: null,
          onTitleRendered: null,
          badgeExpr: function(data2) {
            return data2 ? data2.badge : void 0;
          }
        });
      },
      _defaultOptionsRules: function() {
        return this.callBase().concat([{
          device: function() {
            return "desktop" === devices_default.real().deviceType && !devices_default.isSimulator();
          },
          options: {
            focusStateEnabled: true
          }
        }, {
          device: function() {
            return !touch;
          },
          options: {
            swipeEnabled: false
          }
        }, {
          device: {
            platform: "generic"
          },
          options: {
            animationEnabled: false
          }
        }]);
      },
      _init: function() {
        this.callBase();
        this.$element().addClass(TABPANEL_CLASS);
        this.setAria("role", "tabpanel");
      },
      _initMarkup: function() {
        this.callBase();
        this._createTitleActions();
        this._renderLayout();
      },
      _initTemplates: function() {
        this.callBase();
        this._templateManager.addDefaultTemplates({
          title: new BindableTemplate(function($container, data2) {
            if (isPlainObject(data2)) {
              var $iconElement = getImageContainer(data2.icon);
              if ($iconElement) {
                $container.append($iconElement);
              }
              if (isDefined(data2.title) && !isPlainObject(data2.title)) {
                $container.append(dom_adapter_default.createTextNode(data2.title));
              }
            } else if (isDefined(data2)) {
              $container.text(String(data2));
            }
            $container.wrapInner(renderer_default("<span>").addClass(TABS_ITEM_TEXT_CLASS2));
          }, ["title", "icon"], this.option("integrationOptions.watchMethod"))
        });
      },
      _createTitleActions: function() {
        this._createTitleClickAction();
        this._createTitleHoldAction();
        this._createTitleRenderedAction();
      },
      _createTitleClickAction: function() {
        this._titleClickAction = this._createActionByOption("onTitleClick");
      },
      _createTitleHoldAction: function() {
        this._titleHoldAction = this._createActionByOption("onTitleHold");
      },
      _createTitleRenderedAction: function() {
        this._titleRenderedAction = this._createActionByOption("onTitleRendered");
      },
      _renderContent: function() {
        var that = this;
        this.callBase();
        if (this.option("templatesRenderAsynchronously")) {
          this._resizeEventTimer = setTimeout(function() {
            that._updateLayout();
          }, 0);
        }
      },
      _renderLayout: function() {
        if (this._tabs) {
          this._updateLayout();
          return;
        }
        var $element = this.$element();
        this._$tabContainer = renderer_default("<div>").addClass(TABPANEL_TABS_CLASS).appendTo($element);
        var $tabs = renderer_default("<div>").appendTo(this._$tabContainer);
        this._tabs = this._createComponent($tabs, tabs_default, this._tabConfig());
        this._$container = renderer_default("<div>").addClass(TABPANEL_CONTAINER_CLASS).appendTo($element);
        this._$container.append(this._$wrapper);
        this._updateLayout();
      },
      _updateLayout: function() {
        if (hasWindow()) {
          var tabsHeight = this._$tabContainer.outerHeight();
          this._$container.css({
            marginTop: -tabsHeight,
            paddingTop: tabsHeight
          });
        }
      },
      _refreshActiveDescendant: function() {
        if (!this._tabs) {
          return;
        }
        var tabs = this._tabs;
        var tabItems = tabs.itemElements();
        var $activeTab = renderer_default(tabItems[tabs.option("selectedIndex")]);
        var id = this.getFocusedItemId();
        this.setAria("controls", void 0, renderer_default(tabItems));
        this.setAria("controls", id, $activeTab);
      },
      _tabConfig: function() {
        return {
          selectOnFocus: true,
          focusStateEnabled: this.option("focusStateEnabled"),
          hoverStateEnabled: this.option("hoverStateEnabled"),
          repaintChangesOnly: this.option("repaintChangesOnly"),
          tabIndex: this.option("tabIndex"),
          selectedIndex: this.option("selectedIndex"),
          badgeExpr: this.option("badgeExpr"),
          onItemClick: this._titleClickAction.bind(this),
          onItemHold: this._titleHoldAction.bind(this),
          itemHoldTimeout: this.option("itemHoldTimeout"),
          onSelectionChanged: (function(e) {
            this.option("selectedIndex", e.component.option("selectedIndex"));
            this._refreshActiveDescendant();
          }).bind(this),
          onItemRendered: this._titleRenderedAction.bind(this),
          itemTemplate: this._getTemplateByOption("itemTitleTemplate"),
          items: this.option("items"),
          noDataText: null,
          scrollingEnabled: this.option("scrollingEnabled"),
          scrollByContent: this.option("scrollByContent"),
          showNavButtons: this.option("showNavButtons"),
          itemTemplateProperty: "tabTemplate",
          loopItemFocus: this.option("loop"),
          selectionRequired: true,
          onOptionChanged: (function(args) {
            if ("focusedElement" === args.name) {
              if (args.value) {
                var $value = renderer_default(args.value);
                var $newItem = this._itemElements().eq($value.index());
                this.option("focusedElement", getPublicElement($newItem));
              } else {
                this.option("focusedElement", args.value);
              }
            }
          }).bind(this),
          onFocusIn: (function(args) {
            this._focusInHandler(args.event);
          }).bind(this),
          onFocusOut: (function(args) {
            if (!this._isFocusOutHandlerExecuting) {
              this._focusOutHandler(args.event);
            }
          }).bind(this)
        };
      },
      _renderFocusTarget: function() {
        this._focusTarget().attr("tabIndex", -1);
      },
      _updateFocusState: function(e, isFocused) {
        this.callBase(e, isFocused);
        if (e.target === this._tabs._focusTarget().get(0)) {
          this._toggleFocusClass(isFocused, this._focusTarget());
        }
      },
      _focusOutHandler: function(e) {
        this._isFocusOutHandlerExecuting = true;
        this.callBase.apply(this, arguments);
        this._tabs._focusOutHandler(e);
        this._isFocusOutHandlerExecuting = false;
      },
      _setTabsOption: function(name2, value2) {
        if (this._tabs) {
          this._tabs.option(name2, value2);
        }
      },
      _visibilityChanged: function(visible2) {
        if (visible2) {
          this._tabs._dimensionChanged();
          this._updateLayout();
        }
      },
      registerKeyHandler: function(key, handler) {
        this.callBase(key, handler);
        if (this._tabs) {
          this._tabs.registerKeyHandler(key, handler);
        }
      },
      repaint: function() {
        this.callBase();
        this._tabs.repaint();
      },
      _optionChanged: function(args) {
        var name2 = args.name;
        var value2 = args.value;
        var fullName = args.fullName;
        switch (name2) {
          case "dataSource":
            this.callBase(args);
            break;
          case "items":
            this._setTabsOption(name2, this.option(name2));
            this._updateLayout();
            if (!this.option("repaintChangesOnly")) {
              this._tabs.repaint();
            }
            this.callBase(args);
            break;
          case "width":
            this.callBase(args);
            this._tabs.repaint();
            break;
          case "selectedIndex":
          case "selectedItem":
            this._setTabsOption(fullName, value2);
            this.callBase(args);
            if (true === this.option("focusStateEnabled")) {
              var selectedIndex = this.option("selectedIndex");
              var selectedTabContent = this._itemElements().eq(selectedIndex);
              this.option("focusedElement", getPublicElement(selectedTabContent));
            }
            break;
          case "itemHoldTimeout":
          case "focusStateEnabled":
          case "hoverStateEnabled":
            this._setTabsOption(fullName, value2);
            this.callBase(args);
            break;
          case "scrollingEnabled":
          case "scrollByContent":
          case "showNavButtons":
            this._setTabsOption(fullName, value2);
            break;
          case "focusedElement":
            var id = value2 ? renderer_default(value2).index() : value2;
            var newItem = value2 ? this._tabs._itemElements().eq(id) : value2;
            this._setTabsOption("focusedElement", getPublicElement(newItem));
            this.callBase(args);
            break;
          case "itemTitleTemplate":
            this._setTabsOption("itemTemplate", this._getTemplateByOption("itemTitleTemplate"));
            break;
          case "onTitleClick":
            this._createTitleClickAction();
            this._setTabsOption("onItemClick", this._titleClickAction.bind(this));
            break;
          case "onTitleHold":
            this._createTitleHoldAction();
            this._setTabsOption("onItemHold", this._titleHoldAction.bind(this));
            break;
          case "onTitleRendered":
            this._createTitleRenderedAction();
            this._setTabsOption("onItemRendered", this._titleRenderedAction.bind(this));
            break;
          case "loop":
            this._setTabsOption("loopItemFocus", value2);
            break;
          case "badgeExpr":
            this._invalidate();
            break;
          default:
            this.callBase(args);
        }
      },
      _clean: function() {
        clearTimeout(this._resizeEventTimer);
        this.callBase();
      }
    });
    TabPanel.ItemClass = TabPanelItem;
    component_registrator_default("dxTabPanel", TabPanel);
    tab_panel_default = TabPanel;
  }
});

// node_modules/devextreme/esm/ui/form/ui.form.item_option_action.js
var ItemOptionAction;
var init_ui_form_item_option_action = __esm({
  "node_modules/devextreme/esm/ui/form/ui.form.item_option_action.js"() {
    init_class();
    ItemOptionAction = class {
      constructor(options2) {
        this._options = options2;
        this._itemsRunTimeInfo = this._options.itemsRunTimeInfo;
      }
      findInstance() {
        return this._itemsRunTimeInfo.findWidgetInstanceByItem(this._options.item);
      }
      findItemContainer() {
        return this._itemsRunTimeInfo.findItemContainerByItem(this._options.item);
      }
      tryExecute() {
        class_default.abstract();
      }
    };
  }
});

// node_modules/devextreme/esm/ui/form/ui.form.utils.js
var createItemPathByIndex, concatPaths, getTextWithoutSpaces, isExpectedItem, getFullOptionName, getOptionNameFromFullName, tryGetTabPath, isFullPathContainsTabs, getItemPath;
var init_ui_form_utils = __esm({
  "node_modules/devextreme/esm/ui/form/ui.form.utils.js"() {
    init_type();
    createItemPathByIndex = (index2, isTabs) => "".concat(isTabs ? "tabs" : "items", "[").concat(index2, "]");
    concatPaths = (path1, path2) => {
      if (isDefined(path1) && isDefined(path2)) {
        return "".concat(path1, ".").concat(path2);
      }
      return path1 || path2;
    };
    getTextWithoutSpaces = (text) => text ? text.replace(/\s/g, "") : void 0;
    isExpectedItem = (item, fieldName) => item && (item.dataField === fieldName || item.name === fieldName || getTextWithoutSpaces(item.title) === fieldName || "group" === item.itemType && getTextWithoutSpaces(item.caption) === fieldName);
    getFullOptionName = (path, optionName) => "".concat(path, ".").concat(optionName);
    getOptionNameFromFullName = (fullName) => {
      var parts = fullName.split(".");
      return parts[parts.length - 1].replace(/\[\d+]/, "");
    };
    tryGetTabPath = (fullPath) => {
      var pathParts = fullPath.split(".");
      var resultPathParts = [...pathParts];
      for (var i = pathParts.length - 1; i >= 0; i--) {
        if (isFullPathContainsTabs(pathParts[i])) {
          return resultPathParts.join(".");
        }
        resultPathParts.splice(i, 1);
      }
      return "";
    };
    isFullPathContainsTabs = (fullPath) => fullPath.indexOf("tabs") > -1;
    getItemPath = (items, item, isTabs) => {
      var index2 = items.indexOf(item);
      if (index2 > -1) {
        return createItemPathByIndex(index2, isTabs);
      }
      for (var i = 0; i < items.length; i++) {
        var targetItem = items[i];
        var tabOrGroupItems = targetItem.tabs || targetItem.items;
        if (tabOrGroupItems) {
          var itemPath = getItemPath(tabOrGroupItems, item, targetItem.tabs);
          if (itemPath) {
            return concatPaths(createItemPathByIndex(i, isTabs), itemPath);
          }
        }
      }
    };
  }
});

// node_modules/devextreme/esm/ui/form/ui.form.item_options_actions.js
var WidgetOptionItemOptionAction, TabOptionItemOptionAction, TabsOptionItemOptionAction, ValidationRulesItemOptionAction, CssClassItemOptionAction, tryCreateItemOptionAction, ui_form_item_options_actions_default;
var init_ui_form_item_options_actions = __esm({
  "node_modules/devextreme/esm/ui/form/ui.form.item_options_actions.js"() {
    init_ui_form_item_option_action();
    init_element_data();
    init_extend();
    init_ui_form_utils();
    WidgetOptionItemOptionAction = class extends ItemOptionAction {
      tryExecute() {
        var {
          value: value2
        } = this._options;
        var instance = this.findInstance();
        if (instance) {
          instance.option(value2);
          return true;
        }
        return false;
      }
    };
    TabOptionItemOptionAction = class extends ItemOptionAction {
      tryExecute() {
        var tabPanel = this.findInstance();
        if (tabPanel) {
          var {
            optionName,
            item,
            value: value2
          } = this._options;
          var itemIndex = this._itemsRunTimeInfo.findItemIndexByItem(item);
          if (itemIndex >= 0) {
            tabPanel.option(getFullOptionName("items[".concat(itemIndex, "]"), optionName), value2);
            return true;
          }
        }
        return false;
      }
    };
    TabsOptionItemOptionAction = class extends ItemOptionAction {
      tryExecute() {
        var tabPanel = this.findInstance();
        if (tabPanel) {
          var {
            value: value2
          } = this._options;
          tabPanel.option("dataSource", value2);
          return true;
        }
        return false;
      }
    };
    ValidationRulesItemOptionAction = class extends ItemOptionAction {
      tryExecute() {
        var {
          item
        } = this._options;
        var instance = this.findInstance();
        var validator = instance && data(instance.$element()[0], "dxValidator");
        if (validator && item) {
          var filterRequired = (item2) => "required" === item2.type;
          var oldContainsRequired = (validator.option("validationRules") || []).some(filterRequired);
          var newContainsRequired = (item.validationRules || []).some(filterRequired);
          if (!oldContainsRequired && !newContainsRequired || oldContainsRequired && newContainsRequired) {
            validator.option("validationRules", item.validationRules);
            return true;
          }
        }
        return false;
      }
    };
    CssClassItemOptionAction = class extends ItemOptionAction {
      tryExecute() {
        var $itemContainer = this.findItemContainer();
        var {
          previousValue,
          value: value2
        } = this._options;
        if ($itemContainer) {
          $itemContainer.removeClass(previousValue).addClass(value2);
          return true;
        }
        return false;
      }
    };
    tryCreateItemOptionAction = (optionName, itemActionOptions) => {
      switch (optionName) {
        case "editorOptions":
        case "buttonOptions":
          return new WidgetOptionItemOptionAction(itemActionOptions);
        case "validationRules":
          return new ValidationRulesItemOptionAction(itemActionOptions);
        case "cssClass":
          return new CssClassItemOptionAction(itemActionOptions);
        case "badge":
        case "disabled":
        case "icon":
        case "template":
        case "tabTemplate":
        case "title":
          return new TabOptionItemOptionAction(extend2(itemActionOptions, {
            optionName
          }));
        case "tabs":
          return new TabsOptionItemOptionAction(itemActionOptions);
        default:
          return null;
      }
    };
    ui_form_item_options_actions_default = tryCreateItemOptionAction;
  }
});

// node_modules/devextreme/esm/ui/box.js
var BOX_CLASS, BOX_SELECTOR, BOX_ITEM_CLASS, BOX_ITEM_DATA_KEY, IS_IE112, MINSIZE_MAP, MAXSIZE_MAP, SHRINK, FLEX_JUSTIFY_CONTENT_MAP, FLEX_ALIGN_ITEMS_MAP, FLEX_DIRECTION_MAP, setFlexProp, BOX_EVENTNAMESPACE, UPDATE_EVENT, FALLBACK_BOX_ITEM, FALLBACK_WRAP_MAP, FALLBACK_MAIN_SIZE_MAP, FALLBACK_CROSS_SIZE_MAP, FALLBACK_PRE_MARGIN_MAP, FALLBACK_POST_MARGIN_MAP, FALLBACK_CROSS_PRE_MARGIN_MAP, FALLBACK_CROSS_POST_MARGIN_MAP, MARGINS_RTL_FLIP_MAP, BoxItem, FlexLayoutStrategy, FallbackLayoutStrategy, Box, box_default;
var init_box = __esm({
  "node_modules/devextreme/esm/ui/box.js"() {
    init_renderer();
    init_events_engine();
    init_component_registrator();
    init_extend();
    init_common();
    init_window();
    init_inflector();
    init_type();
    init_style();
    init_iterator();
    init_browser();
    init_item();
    init_ui_collection_widget_edit();
    BOX_CLASS = "dx-box";
    BOX_SELECTOR = ".dx-box";
    BOX_ITEM_CLASS = "dx-box-item";
    BOX_ITEM_DATA_KEY = "dxBoxItemData";
    IS_IE112 = browser_default.msie && 11 === parseInt(browser_default.version);
    MINSIZE_MAP = {
      row: "minWidth",
      col: "minHeight"
    };
    MAXSIZE_MAP = {
      row: "maxWidth",
      col: "maxHeight"
    };
    SHRINK = 1;
    FLEX_JUSTIFY_CONTENT_MAP = {
      start: "flex-start",
      end: "flex-end",
      center: "center",
      "space-between": "space-between",
      "space-around": "space-around"
    };
    FLEX_ALIGN_ITEMS_MAP = {
      start: "flex-start",
      end: "flex-end",
      center: "center",
      stretch: "stretch"
    };
    FLEX_DIRECTION_MAP = {
      row: "row",
      col: "column"
    };
    setFlexProp = (element, prop, value2) => {
      value2 = normalizeStyleProp(prop, value2);
      element.style[styleProp(prop)] = value2;
      if (!hasWindow()) {
        if ("" === value2 || !isDefined(value2)) {
          return;
        }
        var cssName = dasherize(prop);
        var styleExpr = cssName + ": " + value2 + ";";
        if (!element.attributes.style) {
          element.setAttribute("style", styleExpr);
        } else if (element.attributes.style.value.indexOf(styleExpr) < 0) {
          element.attributes.style.value += " " + styleExpr;
        }
      }
    };
    BOX_EVENTNAMESPACE = "dxBox";
    UPDATE_EVENT = "dxupdate." + BOX_EVENTNAMESPACE;
    FALLBACK_BOX_ITEM = "dx-box-fallback-item";
    FALLBACK_WRAP_MAP = {
      row: "nowrap",
      col: "normal"
    };
    FALLBACK_MAIN_SIZE_MAP = {
      row: "width",
      col: "height"
    };
    FALLBACK_CROSS_SIZE_MAP = {
      row: "height",
      col: "width"
    };
    FALLBACK_PRE_MARGIN_MAP = {
      row: "marginLeft",
      col: "marginTop"
    };
    FALLBACK_POST_MARGIN_MAP = {
      row: "marginRight",
      col: "marginBottom"
    };
    FALLBACK_CROSS_PRE_MARGIN_MAP = {
      row: "marginTop",
      col: "marginLeft"
    };
    FALLBACK_CROSS_POST_MARGIN_MAP = {
      row: "marginBottom",
      col: "marginRight"
    };
    MARGINS_RTL_FLIP_MAP = {
      marginLeft: "marginRight",
      marginRight: "marginLeft"
    };
    BoxItem = class extends item_default {
      _renderVisible(value2, oldValue) {
        super._renderVisible(value2);
        if (isDefined(oldValue)) {
          this._options.fireItemStateChangedAction({
            name: "visible",
            state: value2,
            oldState: oldValue
          });
        }
      }
    };
    FlexLayoutStrategy = class {
      constructor($element, option) {
        this._$element = $element;
        this._option = option;
        this.initSize = noop2;
        this.update = noop2;
      }
      renderBox() {
        this._$element.css({
          display: stylePropPrefix("flexDirection") + "flex"
        });
        setFlexProp(this._$element.get(0), "flexDirection", FLEX_DIRECTION_MAP[this._option("direction")]);
      }
      renderAlign() {
        this._$element.css({
          justifyContent: this._normalizedAlign()
        });
      }
      _normalizedAlign() {
        var align = this._option("align");
        return align in FLEX_JUSTIFY_CONTENT_MAP ? FLEX_JUSTIFY_CONTENT_MAP[align] : align;
      }
      renderCrossAlign() {
        this._$element.css({
          alignItems: this._normalizedCrossAlign()
        });
      }
      _normalizedCrossAlign() {
        var crossAlign = this._option("crossAlign");
        return crossAlign in FLEX_ALIGN_ITEMS_MAP ? FLEX_ALIGN_ITEMS_MAP[crossAlign] : crossAlign;
      }
      renderItems($items) {
        var flexPropPrefix = stylePropPrefix("flexDirection");
        var direction = this._option("direction");
        each($items, function() {
          var $item = renderer_default(this);
          var item = $item.data(BOX_ITEM_DATA_KEY);
          $item.css({
            display: flexPropPrefix + "flex"
          }).css(MAXSIZE_MAP[direction], item.maxSize || "none").css(MINSIZE_MAP[direction], item.minSize || "0");
          setFlexProp($item.get(0), "flexBasis", item.baseSize || 0);
          setFlexProp($item.get(0), "flexGrow", item.ratio);
          setFlexProp($item.get(0), "flexShrink", isDefined(item.shrink) ? item.shrink : SHRINK);
          $item.children().each((_2, itemContent) => {
            renderer_default(itemContent).css({
              width: "auto",
              height: "auto",
              display: stylePropPrefix("flexDirection") + "flex",
              flexBasis: IS_IE112 && item._forceItemFlexSizeCorrectionInIE ? "auto" : 0
            });
            setFlexProp(itemContent, "flexGrow", 1);
            setFlexProp(itemContent, "flexDirection", renderer_default(itemContent)[0].style.flexDirection || "column");
          });
        });
      }
    };
    FallbackLayoutStrategy = class {
      constructor($element, option) {
        this._$element = $element;
        this._option = option;
      }
      renderBox() {
        this._$element.css({
          fontSize: 0,
          whiteSpace: FALLBACK_WRAP_MAP[this._option("direction")],
          verticalAlign: "top"
        });
        events_engine_default.off(this._$element, UPDATE_EVENT);
        events_engine_default.on(this._$element, UPDATE_EVENT, this.update.bind(this));
      }
      renderAlign() {
        var $items = this._$items;
        if (!$items) {
          return;
        }
        var align = this._option("align");
        var totalItemSize = this.totalItemSize;
        var direction = this._option("direction");
        var boxSize = this._$element[FALLBACK_MAIN_SIZE_MAP[direction]]();
        var freeSpace = boxSize - totalItemSize;
        var shift = 0;
        this._setItemsMargins($items, direction, 0);
        switch (align) {
          case "start":
            break;
          case "end":
            shift = freeSpace;
            $items.first().css(this._chooseMarginSide(FALLBACK_PRE_MARGIN_MAP[direction]), shift);
            break;
          case "center":
            shift = 0.5 * freeSpace;
            $items.first().css(this._chooseMarginSide(FALLBACK_PRE_MARGIN_MAP[direction]), shift);
            $items.last().css(this._chooseMarginSide(FALLBACK_POST_MARGIN_MAP[direction]), shift);
            break;
          case "space-between":
            shift = 0.5 * freeSpace / ($items.length - 1);
            this._setItemsMargins($items, direction, shift);
            $items.first().css(this._chooseMarginSide(FALLBACK_PRE_MARGIN_MAP[direction]), 0);
            $items.last().css(this._chooseMarginSide(FALLBACK_POST_MARGIN_MAP[direction]), 0);
            break;
          case "space-around":
            shift = 0.5 * freeSpace / $items.length;
            this._setItemsMargins($items, direction, shift);
        }
      }
      _setItemsMargins($items, direction, shift) {
        $items.css(this._chooseMarginSide(FALLBACK_PRE_MARGIN_MAP[direction]), shift).css(this._chooseMarginSide(FALLBACK_POST_MARGIN_MAP[direction]), shift);
      }
      renderCrossAlign() {
        var $items = this._$items;
        if (!$items) {
          return;
        }
        var crossAlign = this._option("crossAlign");
        var direction = this._option("direction");
        var size = this._$element[FALLBACK_CROSS_SIZE_MAP[direction]]();
        var that = this;
        switch (crossAlign) {
          case "start":
            break;
          case "end":
            each($items, function() {
              var $item = renderer_default(this);
              var itemSize = $item[FALLBACK_CROSS_SIZE_MAP[direction]]();
              var shift = size - itemSize;
              $item.css(that._chooseMarginSide(FALLBACK_CROSS_PRE_MARGIN_MAP[direction]), shift);
            });
            break;
          case "center":
            each($items, function() {
              var $item = renderer_default(this);
              var itemSize = $item[FALLBACK_CROSS_SIZE_MAP[direction]]();
              var shift = 0.5 * (size - itemSize);
              $item.css(that._chooseMarginSide(FALLBACK_CROSS_PRE_MARGIN_MAP[direction]), shift).css(that._chooseMarginSide(FALLBACK_CROSS_POST_MARGIN_MAP[direction]), shift);
            });
            break;
          case "stretch":
            $items.css(that._chooseMarginSide(FALLBACK_CROSS_PRE_MARGIN_MAP[direction]), 0).css(that._chooseMarginSide(FALLBACK_CROSS_POST_MARGIN_MAP[direction]), 0).css(FALLBACK_CROSS_SIZE_MAP[direction], "100%");
        }
      }
      _chooseMarginSide(value2) {
        if (!this._option("rtlEnabled")) {
          return value2;
        }
        return MARGINS_RTL_FLIP_MAP[value2] || value2;
      }
      renderItems($items) {
        this._$items = $items;
        var direction = this._option("direction");
        var totalRatio = 0;
        var totalWeightedShrink = 0;
        var totalBaseSize = 0;
        each($items, (_2, item) => {
          var $item = renderer_default(item);
          $item.css({
            display: "inline-block",
            verticalAlign: "top"
          });
          $item[FALLBACK_MAIN_SIZE_MAP[direction]]("auto");
          $item.removeClass(FALLBACK_BOX_ITEM);
          var itemData = $item.data(BOX_ITEM_DATA_KEY);
          var ratio = itemData.ratio || 0;
          var size = this._baseSize($item);
          var shrink = isDefined(itemData.shrink) ? itemData.shrink : SHRINK;
          totalRatio += ratio;
          totalWeightedShrink += shrink * size;
          totalBaseSize += size;
        });
        var freeSpaceSize = this._boxSize() - totalBaseSize;
        var itemSize = ($item) => {
          var itemData = $item.data(BOX_ITEM_DATA_KEY);
          var size = this._baseSize($item);
          var factor = freeSpaceSize >= 0 ? itemData.ratio || 0 : (isDefined(itemData.shrink) ? itemData.shrink : SHRINK) * size;
          var totalFactor = freeSpaceSize >= 0 ? totalRatio : totalWeightedShrink;
          var shift = totalFactor ? Math.round(freeSpaceSize * factor / totalFactor) : 0;
          return size + shift;
        };
        var totalItemSize = 0;
        each($items, (_2, item) => {
          var $item = renderer_default(item);
          var itemData = renderer_default(item).data(BOX_ITEM_DATA_KEY);
          var size = itemSize($item);
          totalItemSize += size;
          $item.css(MAXSIZE_MAP[direction], itemData.maxSize || "none").css(MINSIZE_MAP[direction], itemData.minSize || "0").css(FALLBACK_MAIN_SIZE_MAP[direction], size);
          $item.addClass(FALLBACK_BOX_ITEM);
        });
        this.totalItemSize = totalItemSize;
      }
      _baseSize(item) {
        var itemData = renderer_default(item).data(BOX_ITEM_DATA_KEY);
        return null == itemData.baseSize ? 0 : "auto" === itemData.baseSize ? this._contentSize(item) : this._parseSize(itemData.baseSize);
      }
      _contentSize(item) {
        return renderer_default(item)[FALLBACK_MAIN_SIZE_MAP[this._option("direction")]]();
      }
      _parseSize(size) {
        return String(size).match(/.+%$/) ? 0.01 * parseFloat(size) * this._boxSizeValue : size;
      }
      _boxSize(value2) {
        if (!arguments.length) {
          this._boxSizeValue = this._boxSizeValue || this._totalBaseSize();
          return this._boxSizeValue;
        }
        this._boxSizeValue = value2;
      }
      _totalBaseSize() {
        var result2 = 0;
        each(this._$items, (_2, item) => {
          result2 += this._baseSize(item);
        });
        return result2;
      }
      initSize() {
        this._boxSize(this._$element[FALLBACK_MAIN_SIZE_MAP[this._option("direction")]]());
      }
      update() {
        if (!this._$items || this._$element.is(":hidden")) {
          return;
        }
        this._$items.detach();
        this.initSize();
        this._$element.append(this._$items);
        this.renderItems(this._$items);
        this.renderAlign();
        this.renderCrossAlign();
        var element = this._$element.get(0);
        this._$items.find(BOX_SELECTOR).each(function() {
          if (element === renderer_default(this).parent().closest(BOX_SELECTOR).get(0)) {
            events_engine_default.triggerHandler(this, UPDATE_EVENT);
          }
        });
      }
    };
    Box = class _Box extends ui_collection_widget_edit_default {
      _getDefaultOptions() {
        return extend2(super._getDefaultOptions(), {
          direction: "row",
          align: "start",
          crossAlign: "stretch",
          activeStateEnabled: false,
          focusStateEnabled: false,
          onItemStateChanged: void 0,
          _layoutStrategy: "flex",
          _queue: void 0
        });
      }
      _defaultOptionsRules() {
        return super._defaultOptionsRules().concat([{
          device: function() {
            return browser_default.msie;
          },
          options: {
            _layoutStrategy: "fallback"
          }
        }]);
      }
      _itemClass() {
        return BOX_ITEM_CLASS;
      }
      _itemDataKey() {
        return BOX_ITEM_DATA_KEY;
      }
      _itemElements() {
        return this._itemContainer().children(this._itemSelector());
      }
      _init() {
        super._init();
        this.$element().addClass("".concat(BOX_CLASS, "-").concat(this.option("_layoutStrategy")));
        this._initLayout();
        this._initBoxQueue();
      }
      _initLayout() {
        this._layout = "fallback" === this.option("_layoutStrategy") ? new FallbackLayoutStrategy(this.$element(), this.option.bind(this)) : new FlexLayoutStrategy(this.$element(), this.option.bind(this));
      }
      _initBoxQueue() {
        this._queue = this.option("_queue") || [];
      }
      _queueIsNotEmpty() {
        return this.option("_queue") ? false : !!this._queue.length;
      }
      _pushItemToQueue($item, config2) {
        this._queue.push({
          $item,
          config: config2
        });
      }
      _shiftItemFromQueue() {
        return this._queue.shift();
      }
      _initMarkup() {
        this.$element().addClass(BOX_CLASS);
        this._layout.renderBox();
        super._initMarkup();
        this._renderAlign();
        this._renderActions();
      }
      _renderActions() {
        this._onItemStateChanged = this._createActionByOption("onItemStateChanged");
      }
      _renderAlign() {
        this._layout.renderAlign();
        this._layout.renderCrossAlign();
      }
      _renderItems(items) {
        this._layout.initSize();
        super._renderItems(items);
        while (this._queueIsNotEmpty()) {
          var item = this._shiftItemFromQueue();
          this._createComponent(item.$item, _Box, extend2({
            _layoutStrategy: this.option("_layoutStrategy"),
            itemTemplate: this.option("itemTemplate"),
            itemHoldTimeout: this.option("itemHoldTimeout"),
            onItemHold: this.option("onItemHold"),
            onItemClick: this.option("onItemClick"),
            onItemContextMenu: this.option("onItemContextMenu"),
            onItemRendered: this.option("onItemRendered"),
            _queue: this._queue
          }, item.config));
        }
        this._layout.renderItems(this._itemElements());
        clearTimeout(this._updateTimer);
        this._updateTimer = setTimeout(() => {
          if (!this._isUpdated) {
            this._layout.update();
          }
          this._isUpdated = false;
          this._updateTimer = null;
        });
      }
      _renderItemContent(args) {
        var $itemNode = args.itemData && args.itemData.node;
        if ($itemNode) {
          return this._renderItemContentByNode(args, $itemNode);
        }
        return super._renderItemContent(args);
      }
      _postprocessRenderItem(args) {
        var boxConfig = args.itemData.box;
        if (!boxConfig) {
          return;
        }
        this._pushItemToQueue(args.itemContent, boxConfig);
      }
      _createItemByTemplate(itemTemplate, args) {
        if (args.itemData.box) {
          return itemTemplate.source ? itemTemplate.source() : renderer_default();
        }
        return super._createItemByTemplate(itemTemplate, args);
      }
      _visibilityChanged(visible2) {
        if (visible2) {
          this._dimensionChanged();
        }
      }
      _dimensionChanged() {
        if (this._updateTimer) {
          return;
        }
        this._isUpdated = true;
        this._layout.update();
      }
      _dispose() {
        clearTimeout(this._updateTimer);
        super._dispose.apply(this, arguments);
      }
      _itemOptionChanged(item, property, value2, oldValue) {
        if ("visible" === property) {
          this._onItemStateChanged({
            name: property,
            state: value2,
            oldState: false !== oldValue
          });
        }
        super._itemOptionChanged(item, property, value2);
      }
      _optionChanged(args) {
        switch (args.name) {
          case "_layoutStrategy":
          case "_queue":
          case "direction":
            this._invalidate();
            break;
          case "align":
            this._layout.renderAlign();
            break;
          case "crossAlign":
            this._layout.renderCrossAlign();
            break;
          default:
            super._optionChanged(args);
        }
      }
      _itemOptions() {
        var options2 = super._itemOptions();
        options2.fireItemStateChangedAction = (e) => {
          this._onItemStateChanged(e);
        };
        return options2;
      }
      repaint() {
        this._dimensionChanged();
      }
    };
    Box.ItemClass = BoxItem;
    component_registrator_default("dxBox", Box);
    box_default = Box;
  }
});

// node_modules/devextreme/esm/ui/responsive_box.js
var window22, RESPONSIVE_BOX_CLASS, SCREEN_SIZE_CLASS_PREFIX, BOX_ITEM_CLASS2, BOX_ITEM_DATA_KEY2, HD_SCREEN_WIDTH, ResponsiveBox, responsive_box_default;
var init_responsive_box = __esm({
  "node_modules/devextreme/esm/ui/responsive_box.js"() {
    init_renderer();
    init_events_engine();
    init_common();
    init_type();
    init_ui_errors();
    init_window();
    init_iterator();
    init_extend();
    init_component_registrator();
    init_box();
    init_ui_collection_widget_edit();
    window22 = getWindow();
    RESPONSIVE_BOX_CLASS = "dx-responsivebox";
    SCREEN_SIZE_CLASS_PREFIX = RESPONSIVE_BOX_CLASS + "-screen-";
    BOX_ITEM_CLASS2 = "dx-box-item";
    BOX_ITEM_DATA_KEY2 = "dxBoxItemData";
    HD_SCREEN_WIDTH = 1920;
    ResponsiveBox = ui_collection_widget_edit_default.inherit({
      _getDefaultOptions: function() {
        return extend2(this.callBase(), {
          rows: [],
          cols: [],
          screenByWidth: null,
          singleColumnScreen: "",
          height: "100%",
          width: "100%",
          activeStateEnabled: false,
          focusStateEnabled: false,
          onItemStateChanged: void 0,
          onLayoutChanged: null,
          currentScreenFactor: void 0,
          _layoutStrategy: void 0
        });
      },
      _init: function() {
        if (!this.option("screenByWidth")) {
          this._options.silent("screenByWidth", defaultScreenFactorFunc);
        }
        this.callBase();
        this._initLayoutChangedAction();
      },
      _initLayoutChangedAction: function() {
        this._layoutChangedAction = this._createActionByOption("onLayoutChanged", {
          excludeValidators: ["disabled", "readonly"]
        });
      },
      _itemClass: function() {
        return BOX_ITEM_CLASS2;
      },
      _itemDataKey: function() {
        return BOX_ITEM_DATA_KEY2;
      },
      _initMarkup: function() {
        this.callBase();
        this.$element().addClass(RESPONSIVE_BOX_CLASS);
        this._updateRootBox();
      },
      _updateRootBox: function() {
        clearTimeout(this._updateTimer);
        this._updateTimer = setTimeout((function() {
          if (this._$root) {
            events_engine_default.triggerHandler(this._$root, "dxupdate");
          }
        }).bind(this));
      },
      _renderItems: function() {
        this._setScreenSize();
        this._screenItems = this._itemsByScreen();
        this._prepareGrid();
        this._spreadItems();
        this._layoutItems();
        this._linkNodeToItem();
      },
      _itemOptionChanged: function(item) {
        var $item = this._findItemElementByItem(item);
        if (!$item.length) {
          return;
        }
        this._refreshItem($item, item);
        this._clearItemNodeTemplates();
        this._update(true);
      },
      _setScreenSize: function() {
        var currentScreen = this._getCurrentScreen();
        this._removeScreenSizeClass();
        this.$element().addClass(SCREEN_SIZE_CLASS_PREFIX + currentScreen);
        this.option("currentScreenFactor", currentScreen);
      },
      _removeScreenSizeClass: function() {
        var currentScreenFactor = this.option("currentScreenFactor");
        currentScreenFactor && this.$element().removeClass(SCREEN_SIZE_CLASS_PREFIX + currentScreenFactor);
      },
      _prepareGrid: function() {
        var grid = this._grid = [];
        this._prepareRowsAndCols();
        each(this._rows, (function() {
          var row = [];
          grid.push(row);
          each(this._cols, (function() {
            row.push(this._createEmptyCell());
          }).bind(this));
        }).bind(this));
      },
      getSingleColumnRows: function() {
        var rows = this.option("rows");
        var screenItemsLength = this._screenItems.length;
        if (rows.length) {
          var filteredRows = this._filterByScreen(rows);
          var result2 = [];
          for (var i = 0; i < screenItemsLength; i++) {
            var sizeConfig = this._defaultSizeConfig();
            if (i < filteredRows.length && isDefined(filteredRows[i].shrink)) {
              sizeConfig.shrink = filteredRows[i].shrink;
            }
            result2.push(sizeConfig);
          }
          return result2;
        } else {
          return this._defaultSizeConfig(screenItemsLength);
        }
      },
      _prepareRowsAndCols: function() {
        if (this._isSingleColumnScreen()) {
          this._prepareSingleColumnScreenItems();
          this._rows = this.getSingleColumnRows();
          this._cols = this._defaultSizeConfig(1);
        } else {
          this._rows = this._sizesByScreen(this.option("rows"));
          this._cols = this._sizesByScreen(this.option("cols"));
        }
      },
      _isSingleColumnScreen: function() {
        return this._screenRegExp().test(this.option("singleColumnScreen")) || !this.option("rows").length || !this.option("cols").length;
      },
      _prepareSingleColumnScreenItems: function() {
        this._screenItems.sort(function(item1, item2) {
          return item1.location.row - item2.location.row || item1.location.col - item2.location.col;
        });
        each(this._screenItems, function(index2, item) {
          extend2(item.location, {
            row: index2,
            col: 0,
            rowspan: 1,
            colspan: 1
          });
        });
      },
      _sizesByScreen: function(sizeConfigs) {
        return map(this._filterByScreen(sizeConfigs), (function(sizeConfig) {
          return extend2(this._defaultSizeConfig(), sizeConfig);
        }).bind(this));
      },
      _createDefaultSizeConfig: function() {
        return {
          ratio: 1,
          baseSize: 0,
          minSize: 0,
          maxSize: 0
        };
      },
      _defaultSizeConfig: function(size) {
        var defaultSizeConfig = this._createDefaultSizeConfig();
        if (!arguments.length) {
          return defaultSizeConfig;
        }
        var result2 = [];
        for (var i = 0; i < size; i++) {
          result2.push(defaultSizeConfig);
        }
        return result2;
      },
      _filterByScreen: function(items) {
        var screenRegExp = this._screenRegExp();
        return grep(items, function(item) {
          return !item.screen || screenRegExp.test(item.screen);
        });
      },
      _screenRegExp: function() {
        var screen = this._getCurrentScreen();
        return new RegExp("(^|\\s)" + screen + "($|\\s)", "i");
      },
      _getCurrentScreen: function() {
        var width = this._screenWidth();
        return this.option("screenByWidth")(width);
      },
      _screenWidth: function() {
        return hasWindow() ? renderer_default(window22).width() : HD_SCREEN_WIDTH;
      },
      _createEmptyCell: function() {
        return {
          item: {},
          location: {
            colspan: 1,
            rowspan: 1
          }
        };
      },
      _spreadItems: function() {
        each(this._screenItems, (function(_2, itemInfo) {
          var location = itemInfo.location || {};
          var itemCol = location.col;
          var itemRow = location.row;
          var row = this._grid[itemRow];
          var itemCell = row && row[itemCol];
          this._occupyCells(itemCell, itemInfo);
        }).bind(this));
      },
      _itemsByScreen: function() {
        return this.option("items").reduce((result2, item) => {
          var locations = item.location || {};
          locations = isPlainObject(locations) ? [locations] : locations;
          this._filterByScreen(locations).forEach((location) => {
            result2.push({
              item,
              location: extend2({
                rowspan: 1,
                colspan: 1
              }, location)
            });
          });
          return result2;
        }, []);
      },
      _occupyCells: function(itemCell, itemInfo) {
        if (!itemCell || this._isItemCellOccupied(itemCell, itemInfo)) {
          return;
        }
        extend2(itemCell, itemInfo);
        this._markSpanningCell(itemCell);
      },
      _isItemCellOccupied: function(itemCell, itemInfo) {
        if (!isEmptyObject(itemCell.item)) {
          return true;
        }
        var result2 = false;
        this._loopOverSpanning(itemInfo.location, function(cell) {
          result2 = result2 || !isEmptyObject(cell.item);
        });
        return result2;
      },
      _loopOverSpanning: function(location, callback) {
        var rowEnd = location.row + location.rowspan - 1;
        var colEnd = location.col + location.colspan - 1;
        var boundRowEnd = Math.min(rowEnd, this._rows.length - 1);
        var boundColEnd = Math.min(colEnd, this._cols.length - 1);
        location.rowspan -= rowEnd - boundRowEnd;
        location.colspan -= colEnd - boundColEnd;
        for (var rowIndex = location.row; rowIndex <= boundRowEnd; rowIndex++) {
          for (var colIndex = location.col; colIndex <= boundColEnd; colIndex++) {
            if (rowIndex !== location.row || colIndex !== location.col) {
              callback(this._grid[rowIndex][colIndex]);
            }
          }
        }
      },
      _markSpanningCell: function(itemCell) {
        this._loopOverSpanning(itemCell.location, function(cell) {
          extend2(cell, {
            item: itemCell.item,
            spanningCell: itemCell
          });
        });
      },
      _linkNodeToItem: function() {
        each(this._itemElements(), function(_2, itemNode) {
          var $item = renderer_default(itemNode);
          var item = $item.data(BOX_ITEM_DATA_KEY2);
          if (!item.box) {
            item.node = $item.children();
          }
        });
      },
      _layoutItems: function() {
        var rowsCount = this._grid.length;
        var colsCount = rowsCount && this._grid[0].length;
        if (!rowsCount && !colsCount) {
          return;
        }
        var result2 = this._layoutBlock({
          direction: "col",
          row: {
            start: 0,
            end: rowsCount - 1
          },
          col: {
            start: 0,
            end: colsCount - 1
          }
        });
        var rootBox = this._prepareBoxConfig(result2.box || {
          direction: "row",
          items: [extend2(result2, {
            ratio: 1
          })]
        });
        extend2(rootBox, this._rootBoxConfig(rootBox.items));
        this._$root = renderer_default("<div>").appendTo(this._itemContainer());
        this._createComponent(this._$root, box_default, rootBox);
      },
      _rootBoxConfig: function(items) {
        var rootItems = each(items, (function(index2, item) {
          this._needApplyAutoBaseSize(item) && extend2(item, {
            baseSize: "auto"
          });
        }).bind(this));
        return extend2({
          width: "100%",
          height: "100%",
          items: rootItems,
          itemTemplate: this._getTemplateByOption("itemTemplate"),
          itemHoldTimeout: this.option("itemHoldTimeout"),
          onItemHold: this._createActionByOption("onItemHold"),
          onItemClick: this._createActionByOption("onItemClick"),
          onItemContextMenu: this._createActionByOption("onItemContextMenu"),
          onItemRendered: this._createActionByOption("onItemRendered")
        }, {
          _layoutStrategy: this.option("_layoutStrategy")
        });
      },
      _needApplyAutoBaseSize: function(item) {
        return !item.baseSize && (!item.minSize || "auto" === item.minSize) && (!item.maxSize || "auto" === item.maxSize);
      },
      _prepareBoxConfig: function(config2) {
        return extend2(config2 || {}, {
          crossAlign: "stretch",
          onItemStateChanged: this.option("onItemStateChanged")
        });
      },
      _layoutBlock: function(options2) {
        if (this._isSingleItem(options2)) {
          return this._itemByCell(options2.row.start, options2.col.start);
        }
        return this._layoutDirection(options2);
      },
      _isSingleItem: function(options2) {
        var firstCellLocation = this._grid[options2.row.start][options2.col.start].location;
        var isItemRowSpanned = options2.row.end - options2.row.start === firstCellLocation.rowspan - 1;
        var isItemColSpanned = options2.col.end - options2.col.start === firstCellLocation.colspan - 1;
        return isItemRowSpanned && isItemColSpanned;
      },
      _itemByCell: function(rowIndex, colIndex) {
        var itemCell = this._grid[rowIndex][colIndex];
        return itemCell.spanningCell ? null : itemCell.item;
      },
      _layoutDirection: function(options2) {
        var items = [];
        var direction = options2.direction;
        var crossDirection = this._crossDirection(direction);
        var block;
        while (block = this._nextBlock(options2)) {
          if (this._isBlockIndivisible(options2.prevBlockOptions, block)) {
            throw ui_errors_default.Error("E1025");
          }
          var item = this._layoutBlock({
            direction: crossDirection,
            row: block.row,
            col: block.col,
            prevBlockOptions: options2
          });
          if (item) {
            extend2(item, this._blockSize(block, crossDirection));
            items.push(item);
          }
          options2[crossDirection].start = block[crossDirection].end + 1;
        }
        return {
          box: this._prepareBoxConfig({
            direction,
            items
          })
        };
      },
      _isBlockIndivisible: function(options2, block) {
        return options2 && options2.col.start === block.col.start && options2.col.end === block.col.end && options2.row.start === block.row.start && options2.row.end === block.row.end;
      },
      _crossDirection: function(direction) {
        return "col" === direction ? "row" : "col";
      },
      _nextBlock: function(options2) {
        var direction = options2.direction;
        var crossDirection = this._crossDirection(direction);
        var startIndex = options2[direction].start;
        var endIndex = options2[direction].end;
        var crossStartIndex = options2[crossDirection].start;
        if (crossStartIndex > options2[crossDirection].end) {
          return null;
        }
        var crossSpan = 1;
        for (var crossIndex = crossStartIndex; crossIndex < crossStartIndex + crossSpan; crossIndex++) {
          var lineCrossSpan = 1;
          for (var index2 = startIndex; index2 <= endIndex; index2++) {
            var cell = this._cellByDirection(direction, index2, crossIndex);
            lineCrossSpan = Math.max(lineCrossSpan, cell.location[crossDirection + "span"]);
          }
          var lineCrossEndIndex = crossIndex + lineCrossSpan;
          var crossEndIndex = crossStartIndex + crossSpan;
          if (lineCrossEndIndex > crossEndIndex) {
            crossSpan += lineCrossEndIndex - crossEndIndex;
          }
        }
        var result2 = {};
        result2[direction] = {
          start: startIndex,
          end: endIndex
        };
        result2[crossDirection] = {
          start: crossStartIndex,
          end: crossStartIndex + crossSpan - 1
        };
        return result2;
      },
      _cellByDirection: function(direction, index2, crossIndex) {
        return "col" === direction ? this._grid[crossIndex][index2] : this._grid[index2][crossIndex];
      },
      _blockSize: function(block, direction) {
        var defaultMinSize = "row" === direction ? "auto" : 0;
        var sizeConfigs = "row" === direction ? this._rows : this._cols;
        var result2 = extend2(this._createDefaultSizeConfig(), {
          ratio: 0
        });
        for (var index2 = block[direction].start; index2 <= block[direction].end; index2++) {
          var sizeConfig = sizeConfigs[index2];
          result2.ratio += sizeConfig.ratio;
          result2.baseSize += sizeConfig.baseSize;
          result2.minSize += sizeConfig.minSize;
          result2.maxSize += sizeConfig.maxSize;
          if (isDefined(sizeConfig.shrink)) {
            result2.shrink = sizeConfig.shrink;
          }
        }
        result2.minSize = result2.minSize ? result2.minSize : defaultMinSize;
        result2.maxSize = result2.maxSize ? result2.maxSize : "auto";
        this._isSingleColumnScreen() && (result2.baseSize = "auto");
        return result2;
      },
      _update: function(forceRemoveRoot) {
        var $existingRoot = this._$root;
        this._renderItems();
        if ($existingRoot) {
          if (forceRemoveRoot) {
            $existingRoot.remove();
          } else {
            $existingRoot.detach();
            this._saveAssistantRoot($existingRoot);
          }
        }
        this._layoutChangedAction();
        this._updateRootBox();
      },
      _saveAssistantRoot: function($root) {
        this._assistantRoots = this._assistantRoots || [];
        this._assistantRoots.push($root);
      },
      _dispose: function() {
        clearTimeout(this._updateTimer);
        this._clearItemNodeTemplates();
        this._cleanUnusedRoots();
        this.callBase.apply(this, arguments);
      },
      _cleanUnusedRoots: function() {
        if (!this._assistantRoots) {
          return;
        }
        each(this._assistantRoots, function(_2, item) {
          renderer_default(item).remove();
        });
      },
      _clearItemNodeTemplates: function() {
        each(this.option("items"), function() {
          delete this.node;
        });
      },
      _toggleVisibility: function(visible2) {
        this.callBase(visible2);
        if (visible2) {
          this._updateRootBox();
        }
      },
      _attachClickEvent: noop2,
      _optionChanged: function(args) {
        switch (args.name) {
          case "rows":
          case "cols":
          case "screenByWidth":
          case "_layoutStrategy":
          case "singleColumnScreen":
            this._clearItemNodeTemplates();
            this._invalidate();
            break;
          case "width":
          case "height":
            this.callBase(args);
            this._update();
            break;
          case "onLayoutChanged":
            this._initLayoutChangedAction();
            break;
          case "itemTemplate":
            this._clearItemNodeTemplates();
            this.callBase(args);
            break;
          case "currentScreenFactor":
            break;
          default:
            this.callBase(args);
        }
      },
      _dimensionChanged: function() {
        if (this._getCurrentScreen() !== this.option("currentScreenFactor")) {
          this._update();
        }
      },
      repaint: function() {
        this._update();
      }
    });
    component_registrator_default("dxResponsiveBox", ResponsiveBox);
    responsive_box_default = ResponsiveBox;
  }
});

// node_modules/devextreme/esm/ui/form/constants.js
var WIDGET_CLASS3, FORM_CLASS, FORM_GROUP_CLASS, FORM_GROUP_CAPTION_CLASS, FORM_FIELD_ITEM_COL_CLASS, FIELD_ITEM_CLASS, LAYOUT_MANAGER_ONE_COLUMN, FIELD_ITEM_LABEL_CONTENT_CLASS, FORM_LAYOUT_MANAGER_CLASS, FIELD_ITEM_LABEL_CLASS, FIELD_ITEM_CONTENT_CLASS, SINGLE_COLUMN_ITEM_CONTENT, ROOT_SIMPLE_ITEM_CLASS, FORM_GROUP_CONTENT_CLASS, FIELD_ITEM_CONTENT_HAS_GROUP_CLASS, FIELD_ITEM_CONTENT_HAS_TABS_CLASS, FORM_GROUP_WITH_CAPTION_CLASS, FIELD_ITEM_TAB_CLASS, GROUP_COL_COUNT_CLASS, GROUP_COL_COUNT_ATTR, FORM_VALIDATION_SUMMARY, SIMPLE_ITEM_TYPE;
var init_constants3 = __esm({
  "node_modules/devextreme/esm/ui/form/constants.js"() {
    WIDGET_CLASS3 = "dx-widget";
    FORM_CLASS = "dx-form";
    FORM_GROUP_CLASS = "dx-form-group";
    FORM_GROUP_CAPTION_CLASS = "dx-form-group-caption";
    FORM_FIELD_ITEM_COL_CLASS = "dx-col-";
    FIELD_ITEM_CLASS = "dx-field-item";
    LAYOUT_MANAGER_ONE_COLUMN = "dx-layout-manager-one-col";
    FIELD_ITEM_LABEL_CONTENT_CLASS = "dx-field-item-label-content";
    FORM_LAYOUT_MANAGER_CLASS = "dx-layout-manager";
    FIELD_ITEM_LABEL_CLASS = "dx-field-item-label";
    FIELD_ITEM_CONTENT_CLASS = "dx-field-item-content";
    SINGLE_COLUMN_ITEM_CONTENT = "dx-single-column-item-content";
    ROOT_SIMPLE_ITEM_CLASS = "dx-root-simple-item";
    FORM_GROUP_CONTENT_CLASS = "dx-form-group-content";
    FIELD_ITEM_CONTENT_HAS_GROUP_CLASS = "dx-field-item-has-group";
    FIELD_ITEM_CONTENT_HAS_TABS_CLASS = "dx-field-item-has-tabs";
    FORM_GROUP_WITH_CAPTION_CLASS = "dx-form-group-with-caption";
    FIELD_ITEM_TAB_CLASS = "dx-field-item-tab";
    GROUP_COL_COUNT_CLASS = "dx-group-colcount-";
    GROUP_COL_COUNT_ATTR = "group-col-count";
    FORM_VALIDATION_SUMMARY = "dx-form-validation-summary";
    SIMPLE_ITEM_TYPE = "simple";
  }
});

// node_modules/devextreme/esm/ui/number_box/utils.js
var getRealSeparatorIndex, getNthOccurrence, splitByIndex, adjustPercentValue;
var init_utils6 = __esm({
  "node_modules/devextreme/esm/ui/number_box/utils.js"() {
    init_math();
    getRealSeparatorIndex = function(str) {
      var quoteBalance = 0;
      var separatorCount = 0;
      for (var i = 0; i < str.length; ++i) {
        if ("'" === str[i]) {
          quoteBalance++;
        }
        if ("." === str[i]) {
          ++separatorCount;
          if (quoteBalance % 2 === 0) {
            return {
              occurrence: separatorCount,
              index: i
            };
          }
        }
      }
      return {
        occurrence: 1,
        index: -1
      };
    };
    getNthOccurrence = function(str, c, n) {
      var i = -1;
      while (n-- && i++ < str.length) {
        i = str.indexOf(c, i);
      }
      return i;
    };
    splitByIndex = function(str, index2) {
      if (-1 === index2) {
        return [str];
      }
      return [str.slice(0, index2), str.slice(index2 + 1)];
    };
    adjustPercentValue = function(rawValue, precision) {
      return rawValue && adjust(rawValue / 100, precision);
    };
  }
});

// node_modules/devextreme/esm/ui/number_box/number_box.caret.js
function isSeparatorBasedString(text) {
  return 1 === text.length && !!text.match(/^[,.][0-9]*$/g);
}
function getCaretInBoundaries(caret3, text, format2) {
  caret3 = getCaretWithOffset(caret3, 0);
  var boundaries = getCaretBoundaries(text, format2);
  var adjustedCaret = {
    start: fitIntoRange(caret3.start, boundaries.start, boundaries.end),
    end: fitIntoRange(caret3.end, boundaries.start, boundaries.end)
  };
  return adjustedCaret;
}
var getCaretBoundaries, _getDigitCountBeforeIndex, _reverseText, _getDigitPositionByIndex, _trimNonNumericCharsFromEnd, getCaretWithOffset, getCaretAfterFormat, isCaretInBoundaries, getCaretOffset;
var init_number_box_caret = __esm({
  "node_modules/devextreme/esm/ui/number_box/number_box.caret.js"() {
    init_math();
    init_common();
    init_number3();
    init_utils6();
    getCaretBoundaries = function(text, format2) {
      if ("string" === typeof format2) {
        var signParts = format2.split(";");
        var sign2 = number_default2.getSign(text, format2);
        signParts[1] = signParts[1] || "-" + signParts[0];
        format2 = signParts[sign2 < 0 ? 1 : 0];
        format2 = (str = format2, str.replace(/'([^']*)'/g, (str2) => str2.split("").map(() => " ").join("").substr(2)));
        var prefixStubLength = /^[^#0.,]*/.exec(format2)[0].length;
        var postfixStubLength = /[^#0.,]*$/.exec(format2)[0].length;
        return {
          start: prefixStubLength,
          end: text.length - postfixStubLength
        };
      } else {
        return {
          start: 0,
          end: text.length
        };
      }
      var str;
    };
    _getDigitCountBeforeIndex = function(index2, text) {
      var decimalSeparator = number_default2.getDecimalSeparator();
      var regExp2 = new RegExp("[^0-9" + escapeRegExp(decimalSeparator) + "]", "g");
      var textBeforePosition = text.slice(0, index2);
      return textBeforePosition.replace(regExp2, "").length;
    };
    _reverseText = function(text) {
      return text.split("").reverse().join("");
    };
    _getDigitPositionByIndex = function(digitIndex, text) {
      if (!digitIndex) {
        return -1;
      }
      var regExp2 = /[0-9]/g;
      var counter = 1;
      var index2 = null;
      var result2 = regExp2.exec(text);
      while (result2) {
        index2 = result2.index;
        if (counter >= digitIndex) {
          return index2;
        }
        counter++;
        result2 = regExp2.exec(text);
      }
      return null === index2 ? text.length : index2;
    };
    _trimNonNumericCharsFromEnd = function(text) {
      return text.replace(/[^0-9e]+$/, "");
    };
    getCaretWithOffset = function(caret3, offset2) {
      if (void 0 === caret3.start) {
        caret3 = {
          start: caret3,
          end: caret3
        };
      }
      return {
        start: caret3.start + offset2,
        end: caret3.end + offset2
      };
    };
    getCaretAfterFormat = function(text, formatted, caret3, format2) {
      caret3 = getCaretWithOffset(caret3, 0);
      var point = number_default2.getDecimalSeparator();
      var isSeparatorBasedText = isSeparatorBasedString(text);
      var realSeparatorOccurrenceIndex = getRealSeparatorIndex(format2).occurrence;
      var pointPosition = isSeparatorBasedText ? 0 : getNthOccurrence(text, point, realSeparatorOccurrenceIndex);
      var newPointPosition = getNthOccurrence(formatted, point, realSeparatorOccurrenceIndex);
      var textParts = splitByIndex(text, pointPosition);
      var formattedParts = splitByIndex(formatted, newPointPosition);
      var isCaretOnFloat = -1 !== pointPosition && caret3.start > pointPosition;
      if (isCaretOnFloat) {
        var relativeIndex = caret3.start - pointPosition - 1;
        var digitsBefore = _getDigitCountBeforeIndex(relativeIndex, textParts[1]);
        var newPosition = formattedParts[1] ? newPointPosition + 1 + _getDigitPositionByIndex(digitsBefore, formattedParts[1]) + 1 : formatted.length;
        return getCaretInBoundaries(newPosition, formatted, format2);
      } else {
        var formattedIntPart = _trimNonNumericCharsFromEnd(formattedParts[0]);
        var positionFromEnd = textParts[0].length - caret3.start;
        var digitsFromEnd = _getDigitCountBeforeIndex(positionFromEnd, _reverseText(textParts[0]));
        var newPositionFromEnd = _getDigitPositionByIndex(digitsFromEnd, _reverseText(formattedIntPart));
        var newPositionFromBegin = formattedIntPart.length - (newPositionFromEnd + 1);
        return getCaretInBoundaries(newPositionFromBegin, formatted, format2);
      }
    };
    isCaretInBoundaries = function(caret3, text, format2) {
      caret3 = getCaretWithOffset(caret3, 0);
      var boundaries = getCaretInBoundaries(caret3, text, format2);
      return caret3.start >= boundaries.start && caret3.end <= boundaries.end;
    };
    getCaretOffset = function(previousText, newText, format2) {
      var previousBoundaries = getCaretBoundaries(previousText, format2);
      var newBoundaries = getCaretBoundaries(newText, format2);
      return newBoundaries.start - previousBoundaries.start;
    };
  }
});

// node_modules/devextreme/esm/ui/number_box/number_box.spin.js
var SPIN_CLASS, SPIN_BUTTON_CLASS, SPIN_HOLD_DELAY, NUMBER_BOX, POINTERUP_EVENT_NAME, POINTERCANCEL_EVENT_NAME, SpinButton, number_box_spin_default;
var init_number_box_spin = __esm({
  "node_modules/devextreme/esm/ui/number_box/number_box.spin.js"() {
    init_renderer();
    init_dom_adapter();
    init_events_engine();
    init_ui_widget();
    init_extend();
    init_utils2();
    init_pointer();
    init_emitter_feedback();
    init_hold();
    init_deferred();
    SPIN_CLASS = "dx-numberbox-spin";
    SPIN_BUTTON_CLASS = "dx-numberbox-spin-button";
    SPIN_HOLD_DELAY = 100;
    NUMBER_BOX = "dxNumberBox";
    POINTERUP_EVENT_NAME = addNamespace2(pointer_default.up, NUMBER_BOX);
    POINTERCANCEL_EVENT_NAME = addNamespace2(pointer_default.cancel, NUMBER_BOX);
    SpinButton = ui_widget_default.inherit({
      _getDefaultOptions: function() {
        return extend2(this.callBase(), {
          direction: "up",
          onChange: null,
          activeStateEnabled: true,
          hoverStateEnabled: true
        });
      },
      _initMarkup: function() {
        this.callBase();
        var direction = SPIN_CLASS + "-" + this.option("direction");
        this.$element().addClass(SPIN_BUTTON_CLASS).addClass(direction);
        this._spinIcon = renderer_default("<div>").addClass(direction + "-icon").appendTo(this.$element());
      },
      _render: function() {
        this.callBase();
        var eventName = addNamespace2(pointer_default.down, this.NAME);
        var $element = this.$element();
        events_engine_default.off($element, eventName);
        events_engine_default.on($element, eventName, this._spinDownHandler.bind(this));
        this._spinChangeHandler = this._createActionByOption("onChange");
      },
      _spinDownHandler: function(e) {
        e.preventDefault();
        this._clearTimer();
        events_engine_default.on(this.$element(), hold_default.name, (function() {
          this._feedBackDeferred = new Deferred();
          lock(this._feedBackDeferred);
          this._spinChangeHandler({
            event: e
          });
          this._holdTimer = setInterval(this._spinChangeHandler, SPIN_HOLD_DELAY, {
            event: e
          });
        }).bind(this));
        var document2 = dom_adapter_default.getDocument();
        events_engine_default.on(document2, POINTERUP_EVENT_NAME, this._clearTimer.bind(this));
        events_engine_default.on(document2, POINTERCANCEL_EVENT_NAME, this._clearTimer.bind(this));
        this._spinChangeHandler({
          event: e
        });
      },
      _dispose: function() {
        this._clearTimer();
        this.callBase();
      },
      _clearTimer: function() {
        events_engine_default.off(this.$element(), hold_default.name);
        var document2 = dom_adapter_default.getDocument();
        events_engine_default.off(document2, POINTERUP_EVENT_NAME);
        events_engine_default.off(document2, POINTERCANCEL_EVENT_NAME);
        if (this._feedBackDeferred) {
          this._feedBackDeferred.resolve();
        }
        if (this._holdTimer) {
          clearInterval(this._holdTimer);
        }
      },
      _optionChanged: function(args) {
        switch (args.name) {
          case "onChange":
          case "direction":
            this._invalidate();
            break;
          default:
            this.callBase(args);
        }
      }
    });
    number_box_spin_default = SpinButton;
  }
});

// node_modules/devextreme/esm/ui/number_box/number_box.spins.js
var SPIN_CLASS2, SPIN_CONTAINER_CLASS, SPIN_TOUCH_FRIENDLY_CLASS, SpinButtons;
var init_number_box_spins = __esm({
  "node_modules/devextreme/esm/ui/number_box/number_box.spins.js"() {
    init_renderer();
    init_events_engine();
    init_button2();
    init_number_box_spin();
    init_utils2();
    init_pointer();
    init_extend();
    SPIN_CLASS2 = "dx-numberbox-spin";
    SPIN_CONTAINER_CLASS = "dx-numberbox-spin-container";
    SPIN_TOUCH_FRIENDLY_CLASS = "dx-numberbox-spin-touch-friendly";
    SpinButtons = class extends TextEditorButton {
      _attachEvents(instance, $spinContainer) {
        var {
          editor
        } = this;
        var eventName = addNamespace2(pointer_default.down, editor.NAME);
        var $spinContainerChildren = $spinContainer.children();
        var pointerDownAction = editor._createAction((e) => editor._spinButtonsPointerDownHandler(e));
        events_engine_default.off($spinContainer, eventName);
        events_engine_default.on($spinContainer, eventName, (e) => pointerDownAction({
          event: e
        }));
        number_box_spin_default.getInstance($spinContainerChildren.eq(0)).option("onChange", (e) => editor._spinUpChangeHandler(e));
        number_box_spin_default.getInstance($spinContainerChildren.eq(1)).option("onChange", (e) => editor._spinDownChangeHandler(e));
      }
      _create() {
        var {
          editor
        } = this;
        var $spinContainer = renderer_default("<div>").addClass(SPIN_CONTAINER_CLASS);
        var $spinUp = renderer_default("<div>").appendTo($spinContainer);
        var $spinDown = renderer_default("<div>").appendTo($spinContainer);
        var options2 = this._getOptions();
        this._addToContainer($spinContainer);
        editor._createComponent($spinUp, number_box_spin_default, extend2({
          direction: "up"
        }, options2));
        editor._createComponent($spinDown, number_box_spin_default, extend2({
          direction: "down"
        }, options2));
        this._legacyRender(editor.$element(), this._isTouchFriendly(), options2.visible);
        return {
          instance: $spinContainer,
          $element: $spinContainer
        };
      }
      _getOptions() {
        var {
          editor
        } = this;
        var visible2 = this._isVisible();
        var disabled = editor.option("disabled");
        return {
          visible: visible2,
          disabled
        };
      }
      _isVisible() {
        var {
          editor
        } = this;
        return super._isVisible() && editor.option("showSpinButtons");
      }
      _isTouchFriendly() {
        var {
          editor
        } = this;
        return editor.option("showSpinButtons") && editor.option("useLargeSpinButtons");
      }
      _legacyRender($editor, isTouchFriendly, isVisible2) {
        $editor.toggleClass(SPIN_TOUCH_FRIENDLY_CLASS, isTouchFriendly);
        $editor.toggleClass(SPIN_CLASS2, isVisible2);
      }
      update() {
        var shouldUpdate = super.update();
        if (shouldUpdate) {
          var {
            editor,
            instance
          } = this;
          var $editor = editor.$element();
          var isVisible2 = this._isVisible();
          var isTouchFriendly = this._isTouchFriendly();
          var $spinButtons = instance.children();
          var spinUp = number_box_spin_default.getInstance($spinButtons.eq(0));
          var spinDown = number_box_spin_default.getInstance($spinButtons.eq(1));
          var options2 = this._getOptions();
          spinUp.option(options2);
          spinDown.option(options2);
          this._legacyRender($editor, isTouchFriendly, isVisible2);
        }
      }
    };
  }
});

// node_modules/devextreme/esm/ui/number_box/number_box.base.js
var math2, WIDGET_CLASS4, FIREFOX_CONTROL_KEYS, FORCE_VALUECHANGE_EVENT_NAMESPACE, NumberBoxBase, number_box_base_default;
var init_number_box_base = __esm({
  "node_modules/devextreme/esm/ui/number_box/number_box.base.js"() {
    init_renderer();
    init_dom_adapter();
    init_events_engine();
    init_common();
    init_type();
    init_math();
    init_extend();
    init_array();
    init_devices();
    init_browser();
    init_ui_text_editor();
    init_utils2();
    init_number_box_spins();
    init_message();
    init_deferred();
    math2 = Math;
    WIDGET_CLASS4 = "dx-numberbox";
    FIREFOX_CONTROL_KEYS = ["tab", "del", "backspace", "leftArrow", "rightArrow", "home", "end", "enter"];
    FORCE_VALUECHANGE_EVENT_NAMESPACE = "NumberBoxForceValueChange";
    NumberBoxBase = ui_text_editor_default.inherit({
      _supportedKeys: function() {
        return extend2(this.callBase(), {
          upArrow: function(e) {
            if (!isCommandKeyPressed(e)) {
              e.preventDefault();
              e.stopPropagation();
              this._spinUpChangeHandler(e);
            }
          },
          downArrow: function(e) {
            if (!isCommandKeyPressed(e)) {
              e.preventDefault();
              e.stopPropagation();
              this._spinDownChangeHandler(e);
            }
          },
          enter: function() {
          }
        });
      },
      _getDefaultOptions: function() {
        return extend2(this.callBase(), {
          value: 0,
          min: void 0,
          max: void 0,
          step: 1,
          showSpinButtons: false,
          useLargeSpinButtons: true,
          mode: "text",
          invalidValueMessage: message_default.format("dxNumberBox-invalidValueMessage"),
          buttons: void 0
        });
      },
      _useTemplates: function() {
        return false;
      },
      _getDefaultButtons: function() {
        return this.callBase().concat([{
          name: "spins",
          Ctor: SpinButtons
        }]);
      },
      _isSupportInputMode: function() {
        var version2 = parseFloat(browser_default.version);
        return browser_default.chrome && version2 >= 66 || browser_default.safari && version2 >= 12 || browser_default.msie && version2 >= 75;
      },
      _defaultOptionsRules: function() {
        return this.callBase().concat([{
          device: function() {
            return devices_default.real().generic && !devices_default.isSimulator();
          },
          options: {
            useLargeSpinButtons: false
          }
        }, {
          device: (function() {
            return "desktop" !== devices_default.real().deviceType && !this._isSupportInputMode();
          }).bind(this),
          options: {
            mode: "number"
          }
        }]);
      },
      _initMarkup: function() {
        this._renderSubmitElement();
        this.$element().addClass(WIDGET_CLASS4);
        this.callBase();
      },
      _getDefaultAttributes: function() {
        var attributes = this.callBase();
        attributes.inputmode = "decimal";
        return attributes;
      },
      _renderContentImpl: function() {
        this.option("isValid") && this._validateValue(this.option("value"));
        this.setAria("role", "spinbutton");
      },
      _renderSubmitElement: function() {
        this._$submitElement = renderer_default("<input>").attr("type", "hidden").appendTo(this.$element());
        this._setSubmitValue(this.option("value"));
      },
      _setSubmitValue: function(value2) {
        this._getSubmitElement().val(applyServerDecimalSeparator(value2));
      },
      _getSubmitElement: function() {
        return this._$submitElement;
      },
      _keyPressHandler: function(e) {
        this.callBase(e);
        var char = getChar(e);
        var isInputCharValid = /[\d.,eE\-+]|Subtract/.test(char);
        if (!isInputCharValid) {
          var keyName = normalizeKeyName(e);
          if (isCommandKeyPressed(e) || keyName && inArray(keyName, FIREFOX_CONTROL_KEYS) >= 0) {
            return;
          }
          e.preventDefault();
          return false;
        }
        this._keyPressed = true;
      },
      _onMouseWheel: function(dxEvent) {
        dxEvent.delta > 0 ? this._spinValueChange(1, dxEvent) : this._spinValueChange(-1, dxEvent);
      },
      _renderValue: function() {
        var inputValue = this._input().val();
        var value2 = this.option("value");
        if (!inputValue.length || Number(inputValue) !== value2) {
          this._forceValueRender();
          this._toggleEmptinessEventHandler();
        }
        var valueText = isDefined(value2) ? null : message_default.format("dxNumberBox-noDataText");
        this.setAria({
          valuenow: ensureDefined(value2, ""),
          valuetext: valueText
        });
        this.option("text", this._input().val());
        this._updateButtons();
        return new Deferred().resolve();
      },
      _forceValueRender: function() {
        var value2 = this.option("value");
        var number2 = Number(value2);
        var formattedValue = isNaN(number2) ? "" : this._applyDisplayValueFormatter(value2);
        this._renderDisplayText(formattedValue);
      },
      _applyDisplayValueFormatter: function(value2) {
        return this.option("displayValueFormatter")(value2);
      },
      _renderProps: function() {
        this._input().prop({
          min: this.option("min"),
          max: this.option("max"),
          step: this.option("step")
        });
        this.setAria({
          valuemin: ensureDefined(this.option("min"), ""),
          valuemax: ensureDefined(this.option("max"), "")
        });
      },
      _spinButtonsPointerDownHandler: function() {
        var $input = this._input();
        if (!this.option("useLargeSpinButtons") && dom_adapter_default.getActiveElement() !== $input[0]) {
          events_engine_default.trigger($input, "focus");
        }
      },
      _spinUpChangeHandler: function(e) {
        if (!this.option("readOnly")) {
          this._spinValueChange(1, e.event || e);
        }
      },
      _spinDownChangeHandler: function(e) {
        if (!this.option("readOnly")) {
          this._spinValueChange(-1, e.event || e);
        }
      },
      _spinValueChange: function(sign2, dxEvent) {
        var step = parseFloat(this.option("step"));
        if (0 === step) {
          return;
        }
        var value2 = parseFloat(this._normalizeInputValue()) || 0;
        value2 = this._correctRounding(value2, step * sign2);
        var min = this.option("min");
        var max = this.option("max");
        if (isDefined(min)) {
          value2 = Math.max(min, value2);
        }
        if (isDefined(max)) {
          value2 = Math.min(max, value2);
        }
        this._saveValueChangeEvent(dxEvent);
        this.option("value", value2);
      },
      _correctRounding: function(value2, step) {
        var regex = /[,.](.*)/;
        var isFloatValue = regex.test(value2);
        var isFloatStep = regex.test(step);
        if (isFloatValue || isFloatStep) {
          var valueAccuracy = isFloatValue ? regex.exec(value2)[0].length : 0;
          var stepAccuracy = isFloatStep ? regex.exec(step)[0].length : 0;
          var accuracy = math2.max(valueAccuracy, stepAccuracy);
          value2 = this._round(value2 + step, accuracy);
          return value2;
        }
        return value2 + step;
      },
      _round: function(value2, precision) {
        precision = precision || 0;
        var multiplier = Math.pow(10, precision);
        value2 *= multiplier;
        value2 = Math.round(value2) / multiplier;
        return value2;
      },
      _renderValueChangeEvent: function() {
        this.callBase();
        var forceValueChangeEvent = addNamespace2("focusout", FORCE_VALUECHANGE_EVENT_NAMESPACE);
        events_engine_default.off(this.element(), forceValueChangeEvent);
        events_engine_default.on(this.element(), forceValueChangeEvent, this._forceRefreshInputValue.bind(this));
      },
      _forceRefreshInputValue: function() {
        if ("number" === this.option("mode")) {
          return;
        }
        var $input = this._input();
        var formattedValue = this._applyDisplayValueFormatter(this.option("value"));
        $input.val(null);
        $input.val(formattedValue);
      },
      _valueChangeEventHandler: function(e) {
        var $input = this._input();
        var inputValue = this._normalizeText();
        var value2 = this._parseValue(inputValue);
        var valueHasDigits = "." !== inputValue && "-" !== inputValue;
        if (this._isValueValid() && !this._validateValue(value2)) {
          $input.val(this._applyDisplayValueFormatter(value2));
          return;
        }
        if (valueHasDigits) {
          this.callBase(e, isNaN(value2) ? null : value2);
        }
        this._applyValueBoundaries(inputValue, value2);
        this.validationRequest.fire({
          value: value2,
          editor: this
        });
      },
      _applyValueBoundaries: function(inputValue, parsedValue) {
        var isValueIncomplete = this._isValueIncomplete(inputValue);
        var isValueCorrect = this._isValueInRange(inputValue);
        if (!isValueIncomplete && !isValueCorrect && null !== parsedValue) {
          if (Number(inputValue) !== parsedValue) {
            this._input().val(this._applyDisplayValueFormatter(parsedValue));
          }
        }
      },
      _replaceCommaWithPoint: function(value2) {
        return value2.replace(",", ".");
      },
      _inputIsInvalid: function() {
        var isNumberMode = "number" === this.option("mode");
        var validityState = this._input().get(0).validity;
        return isNumberMode && validityState && validityState.badInput;
      },
      _renderDisplayText: function(text) {
        if (this._inputIsInvalid()) {
          return;
        }
        this.callBase(text);
      },
      _isValueIncomplete: function(value2) {
        return /(^-$)|(^-?\d*\.$)|(\d+e-?$)/i.test(value2);
      },
      _isValueInRange: function(value2) {
        return inRange(value2, this.option("min"), this.option("max"));
      },
      _isNumber: function(value2) {
        return null !== this._parseValue(value2);
      },
      _validateValue: function(value2) {
        var inputValue = this._normalizeText();
        var isValueValid = this._isValueValid();
        var isValid = true;
        var isNumber2 = this._isNumber(inputValue);
        if (isNaN(Number(value2))) {
          isValid = false;
        }
        if (!value2 && isValueValid) {
          isValid = true;
        } else if (!isNumber2 && !isValueValid) {
          isValid = false;
        }
        this.option({
          isValid,
          validationError: isValid ? null : {
            editorSpecific: true,
            message: this.option("invalidValueMessage")
          }
        });
        return isValid;
      },
      _normalizeInputValue: function() {
        return this._parseValue(this._normalizeText());
      },
      _normalizeText: function() {
        var value2 = this._input().val().trim();
        return this._replaceCommaWithPoint(value2);
      },
      _parseValue: function(value2) {
        var number2 = parseFloat(value2);
        if (isNaN(number2)) {
          return null;
        }
        return fitIntoRange(number2, this.option("min"), this.option("max"));
      },
      _clearValue: function() {
        if (this._inputIsInvalid()) {
          this._input().val("");
          this._validateValue();
        }
        this.callBase();
      },
      reset: function() {
        if (null === this.option("value")) {
          this.option("text", "");
          this._renderValue();
        } else {
          this.option("value", null);
        }
      },
      _optionChanged: function(args) {
        switch (args.name) {
          case "value":
            this._validateValue(args.value);
            this._setSubmitValue(args.value);
            this.callBase(args);
            this._resumeValueChangeAction();
            break;
          case "step":
            this._renderProps();
            break;
          case "min":
          case "max":
            this._renderProps();
            this.option("value", this._parseValue(this.option("value")));
            break;
          case "showSpinButtons":
          case "useLargeSpinButtons":
            this._updateButtons(["spins"]);
            break;
          case "invalidValueMessage":
            break;
          default:
            this.callBase(args);
        }
      }
    });
    number_box_base_default = NumberBoxBase;
  }
});

// node_modules/devextreme/esm/ui/number_box/number_box.mask.js
var NUMBER_FORMATTER_NAMESPACE, MOVE_FORWARD, MOVE_BACKWARD, MINUS, MINUS_KEY, NUMPUD_MINUS_KEY_IE, INPUT_EVENT, CARET_TIMEOUT_DURATION, NumberBoxMask, number_box_mask_default;
var init_number_box_mask = __esm({
  "node_modules/devextreme/esm/ui/number_box/number_box.mask.js"() {
    init_events_engine();
    init_extend();
    init_type();
    init_browser();
    init_devices();
    init_math();
    init_number3();
    init_number_box_caret();
    init_number();
    init_number_box_base();
    init_utils2();
    init_common();
    init_utils6();
    NUMBER_FORMATTER_NAMESPACE = "dxNumberFormatter";
    MOVE_FORWARD = 1;
    MOVE_BACKWARD = -1;
    MINUS = "-";
    MINUS_KEY = "minus";
    NUMPUD_MINUS_KEY_IE = "Subtract";
    INPUT_EVENT = "input";
    CARET_TIMEOUT_DURATION = browser_default.msie ? 300 : 0;
    NumberBoxMask = number_box_base_default.inherit({
      _getDefaultOptions: function() {
        return extend2(this.callBase(), {
          useMaskBehavior: true,
          format: null
        });
      },
      _isDeleteKey: function(key) {
        return "del" === key;
      },
      _supportedKeys: function() {
        if (!this._useMaskBehavior()) {
          return this.callBase();
        }
        return extend2(this.callBase(), {
          minus: this._revertSign.bind(this),
          del: this._removeHandler.bind(this),
          backspace: this._removeHandler.bind(this),
          leftArrow: this._arrowHandler.bind(this, MOVE_BACKWARD),
          rightArrow: this._arrowHandler.bind(this, MOVE_FORWARD),
          home: this._moveCaretToBoundaryEventHandler.bind(this, MOVE_FORWARD),
          enter: this._updateFormattedValue.bind(this),
          end: this._moveCaretToBoundaryEventHandler.bind(this, MOVE_BACKWARD)
        });
      },
      _getTextSeparatorIndex: function(text) {
        var decimalSeparator = number_default2.getDecimalSeparator();
        var realSeparatorOccurrenceIndex = getRealSeparatorIndex(this.option("format")).occurrence;
        return getNthOccurrence(text, decimalSeparator, realSeparatorOccurrenceIndex);
      },
      _focusInHandler: function(e) {
        if (!this._preventNestedFocusEvent(e)) {
          this.clearCaretTimeout();
          this._caretTimeout = setTimeout((function() {
            this._caretTimeout = void 0;
            var caret3 = this._caret();
            if (caret3.start === caret3.end && this._useMaskBehavior()) {
              var text = this._getInputVal();
              var decimalSeparatorIndex = this._getTextSeparatorIndex(text);
              if (decimalSeparatorIndex >= 0) {
                this._caret({
                  start: decimalSeparatorIndex,
                  end: decimalSeparatorIndex
                });
              } else {
                this._moveCaretToBoundaryEventHandler(MOVE_BACKWARD, e);
              }
            }
          }).bind(this), CARET_TIMEOUT_DURATION);
        }
        this.callBase(e);
      },
      _focusOutHandler: function(e) {
        var shouldHandleEvent = !this._preventNestedFocusEvent(e);
        if (shouldHandleEvent) {
          this._focusOutOccurs = true;
          if (this._useMaskBehavior()) {
            this._updateFormattedValue();
          }
        }
        this.callBase(e);
        if (shouldHandleEvent) {
          this._focusOutOccurs = false;
        }
      },
      _hasValueBeenChanged(inputValue) {
        var format2 = this._getFormatPattern();
        var value2 = this.option("value");
        var formatted = this._format(value2, format2) || "";
        return formatted !== inputValue;
      },
      _updateFormattedValue: function() {
        var inputValue = this._getInputVal();
        if (this._hasValueBeenChanged(inputValue)) {
          this._updateParsedValue();
          this._adjustParsedValue();
          this._setTextByParsedValue();
          if (this._parsedValue !== this.option("value")) {
            events_engine_default.trigger(this._input(), "change");
          }
        }
      },
      _arrowHandler: function(step, e) {
        if (!this._useMaskBehavior()) {
          return;
        }
        var text = this._getInputVal();
        var format2 = this._getFormatPattern();
        var nextCaret = getCaretWithOffset(this._caret(), step);
        if (!isCaretInBoundaries(nextCaret, text, format2)) {
          nextCaret = step === MOVE_FORWARD ? nextCaret.end : nextCaret.start;
          e.preventDefault();
          this._caret(getCaretInBoundaries(nextCaret, text, format2));
        }
      },
      _moveCaretToBoundary: function(direction) {
        var boundaries = getCaretBoundaries(this._getInputVal(), this._getFormatPattern());
        var newCaret = getCaretWithOffset(direction === MOVE_FORWARD ? boundaries.start : boundaries.end, 0);
        this._caret(newCaret);
      },
      _moveCaretToBoundaryEventHandler: function(direction, e) {
        if (!this._useMaskBehavior() || e && e.shiftKey) {
          return;
        }
        this._moveCaretToBoundary(direction);
        e && e.preventDefault();
      },
      _shouldMoveCaret: function(text, caret3) {
        var decimalSeparator = number_default2.getDecimalSeparator();
        var isDecimalSeparatorNext = text.charAt(caret3.end) === decimalSeparator;
        var moveToFloat = (this._lastKey === decimalSeparator || "." === this._lastKey) && isDecimalSeparatorNext;
        return moveToFloat;
      },
      _getInputVal: function() {
        return number_default2.convertDigits(this._input().val(), true);
      },
      _keyboardHandler: function(e) {
        this.clearCaretTimeout();
        this._lastKey = number_default2.convertDigits(getChar(e), true);
        this._lastKeyName = normalizeKeyName(e);
        if (!this._shouldHandleKey(e.originalEvent)) {
          return this.callBase(e);
        }
        var normalizedText = this._getInputVal();
        var caret3 = this._caret();
        var enteredChar = this._lastKeyName === MINUS_KEY ? "" : this._lastKey;
        var newValue = this._tryParse(normalizedText, caret3, enteredChar);
        if (this._shouldMoveCaret(normalizedText, caret3)) {
          this._moveCaret(1);
          e.originalEvent.preventDefault();
        }
        if (void 0 === newValue) {
          if (this._lastKeyName !== MINUS_KEY) {
            e.originalEvent.preventDefault();
          }
        } else {
          this._parsedValue = newValue;
        }
        return this.callBase(e);
      },
      _keyPressHandler: function(e) {
        if (!this._useMaskBehavior()) {
          this.callBase(e);
        }
      },
      _removeHandler: function(e) {
        var caret3 = this._caret();
        var text = this._getInputVal();
        var start = caret3.start;
        var end = caret3.end;
        this._lastKey = getChar(e);
        this._lastKeyName = normalizeKeyName(e);
        var isDeleteKey = this._isDeleteKey(this._lastKeyName);
        var isBackspaceKey = !isDeleteKey;
        if (start === end) {
          var caretPosition = start;
          var canDelete = isBackspaceKey && caretPosition > 0 || isDeleteKey && caretPosition < text.length;
          if (canDelete) {
            isDeleteKey && end++;
            isBackspaceKey && start--;
          } else {
            e.preventDefault();
            return;
          }
        }
        var char = text.slice(start, end);
        if (this._isStub(char)) {
          this._moveCaret(isDeleteKey ? 1 : -1);
          if (this._parsedValue < 0 || 1 / this._parsedValue === -1 / 0) {
            this._revertSign(e);
            this._setTextByParsedValue();
          }
          e.preventDefault();
          return;
        }
        var decimalSeparator = number_default2.getDecimalSeparator();
        if (char === decimalSeparator) {
          var decimalSeparatorIndex = text.indexOf(decimalSeparator);
          if (this._isNonStubAfter(decimalSeparatorIndex + 1)) {
            this._moveCaret(isDeleteKey ? 1 : -1);
            e.preventDefault();
          }
          return;
        }
        if (end - start < text.length) {
          var editedText = this._replaceSelectedText(text, {
            start,
            end
          }, "");
          var noDigits = editedText.search(/[0-9]/) < 0;
          if (noDigits && this._isValueInRange(0)) {
            this._parsedValue = this._parsedValue < 0 || 1 / this._parsedValue === -1 / 0 ? -0 : 0;
            return;
          }
        }
        var valueAfterRemoving = this._tryParse(text, {
          start,
          end
        }, "");
        if (void 0 === valueAfterRemoving) {
          e.preventDefault();
        } else {
          this._parsedValue = valueAfterRemoving;
        }
      },
      _isPercentFormat: function() {
        var format2 = this._getFormatPattern();
        var noEscapedFormat = format2.replace(/'[^']+'/g, "");
        return -1 !== noEscapedFormat.indexOf("%");
      },
      _parse: function(text, format2) {
        var formatOption = this.option("format");
        var isCustomParser = isFunction(formatOption.parser);
        var parser = isCustomParser ? formatOption.parser : number_default2.parse;
        var integerPartStartIndex = 0;
        if (!isCustomParser) {
          var formatPointIndex = getRealSeparatorIndex(format2).index;
          var textPointIndex = this._getTextSeparatorIndex(text);
          var formatIntegerPartLength = -1 !== formatPointIndex ? formatPointIndex : format2.length;
          var textIntegerPartLength = -1 !== textPointIndex ? textPointIndex : text.length;
          if (textIntegerPartLength > formatIntegerPartLength && -1 === format2.indexOf("#")) {
            integerPartStartIndex = textIntegerPartLength - formatIntegerPartLength;
          }
        }
        text = text.substr(integerPartStartIndex);
        return parser(text, format2);
      },
      _format: function(value2, format2) {
        var formatOption = this.option("format");
        var customFormatter = (null === formatOption || void 0 === formatOption ? void 0 : formatOption.formatter) || formatOption;
        var formatter = isFunction(customFormatter) ? customFormatter : number_default2.format;
        var formattedValue = null === value2 ? "" : formatter(value2, format2);
        return formattedValue;
      },
      _getFormatPattern: function() {
        if (!this._currentFormat) {
          this._updateFormat();
        }
        return this._currentFormat;
      },
      _updateFormat: function() {
        var format2 = this.option("format");
        var isCustomParser = isFunction(null === format2 || void 0 === format2 ? void 0 : format2.parser);
        var isLDMLPattern = isString2(format2) && (format2.indexOf("0") >= 0 || format2.indexOf("#") >= 0);
        this._currentFormat = isCustomParser || isLDMLPattern ? format2 : getFormat((value2) => {
          var text = this._format(value2, format2);
          return number_default2.convertDigits(text, true);
        });
      },
      _getFormatForSign: function(text) {
        var format2 = this._getFormatPattern();
        if (isString2(format2)) {
          var signParts = format2.split(";");
          var sign2 = number_default2.getSign(text, format2);
          signParts[1] = signParts[1] || "-" + signParts[0];
          return sign2 < 0 ? signParts[1] : signParts[0];
        } else {
          var _sign = number_default2.getSign(text);
          return _sign < 0 ? "-" : "";
        }
      },
      _removeStubs: function(text, excludeComma) {
        var format2 = this._getFormatForSign(text);
        var thousandsSeparator = number_default2.getThousandsSeparator();
        var stubs = this._getStubs(format2);
        var result2 = text;
        if (stubs.length) {
          var prefixStubs = stubs[0];
          var postfixRegex = new RegExp("(" + escapeRegExp(stubs[1] || "") + ")$", "g");
          var decoratorsRegex = new RegExp("[-" + escapeRegExp(excludeComma ? "" : thousandsSeparator) + "]", "g");
          result2 = result2.replace(prefixStubs, "").replace(postfixRegex, "").replace(decoratorsRegex, "");
        }
        return result2;
      },
      _getStubs: function(format2) {
        var regExpResult = /[^']([#0.,]+)/g.exec(format2);
        var pattern = regExpResult && regExpResult[0].trim();
        return format2.split(pattern).map(function(stub) {
          return stub.replace(/'/g, "");
        });
      },
      _truncateToPrecision: function(value2, maxPrecision) {
        if (isDefined(value2)) {
          var strValue = value2.toString();
          var decimalSeparatorIndex = strValue.indexOf(".");
          if (strValue && decimalSeparatorIndex > -1) {
            var parsedValue = parseFloat(strValue.substr(0, decimalSeparatorIndex + maxPrecision + 1));
            return isNaN(parsedValue) ? value2 : parsedValue;
          }
        }
        return value2;
      },
      _tryParse: function(text, selection, char) {
        var editedText = this._replaceSelectedText(text, selection, char);
        var format2 = this._getFormatPattern();
        var isTextSelected = selection.start !== selection.end;
        var parsedValue = this._getParsedValue(editedText, format2);
        var maxPrecision = !format2.parser && this._getPrecisionLimits(editedText).max;
        var isValueChanged = parsedValue !== this._parsedValue;
        var decimalSeparator = number_default2.getDecimalSeparator();
        var isDecimalPointRestricted = char === decimalSeparator && 0 === maxPrecision;
        var isUselessCharRestricted = !isTextSelected && !isValueChanged && char !== MINUS && !this._isValueIncomplete(editedText) && this._isStub(char);
        if (isDecimalPointRestricted || isUselessCharRestricted) {
          return;
        }
        if ("" === this._removeStubs(editedText)) {
          parsedValue = Math.abs(0 * this._parsedValue);
        }
        if (isNaN(parsedValue)) {
          return;
        }
        var value2 = null === parsedValue ? this._parsedValue : parsedValue;
        parsedValue = maxPrecision ? this._truncateToPrecision(value2, maxPrecision) : parsedValue;
        return !format2.parser && this._isPercentFormat() ? adjustPercentValue(parsedValue, maxPrecision) : parsedValue;
      },
      _getParsedValue: function(text, format2) {
        var sign2 = number_default2.getSign(text, (null === format2 || void 0 === format2 ? void 0 : format2.formatter) || format2);
        var textWithoutStubs = this._removeStubs(text, true);
        var parsedValue = this._parse(textWithoutStubs, format2);
        var parsedValueSign = parsedValue < 0 ? -1 : 1;
        var parsedValueWithSign = isNumeric(parsedValue) && sign2 !== parsedValueSign ? sign2 * parsedValue : parsedValue;
        return parsedValueWithSign;
      },
      _isValueIncomplete: function(text) {
        if (!this._useMaskBehavior()) {
          return this.callBase(text);
        }
        var caret3 = this._caret();
        var point = number_default2.getDecimalSeparator();
        var pointIndex = this._getTextSeparatorIndex(text);
        var isCaretOnFloat = pointIndex >= 0 && pointIndex < caret3.start;
        var textParts = this._removeStubs(text, true).split(point);
        if (!isCaretOnFloat || 2 !== textParts.length) {
          return false;
        }
        var floatLength = textParts[1].length;
        var format2 = this._getFormatPattern();
        var isCustomParser = !!format2.parser;
        var precision = !isCustomParser && this._getPrecisionLimits(this._getFormatPattern(), text);
        var isPrecisionInRange = isCustomParser ? true : inRange(floatLength, precision.min, precision.max);
        var endsWithZero = "0" === textParts[1].charAt(floatLength - 1);
        return isPrecisionInRange && (endsWithZero || !floatLength);
      },
      _isValueInRange: function(value2) {
        var min = ensureDefined(this.option("min"), -1 / 0);
        var max = ensureDefined(this.option("max"), 1 / 0);
        return inRange(value2, min, max);
      },
      _setInputText: function(text) {
        var normalizedText = number_default2.convertDigits(text, true);
        var newCaret = getCaretAfterFormat(this._getInputVal(), normalizedText, this._caret(), this._getFormatPattern());
        this._input().val(text);
        this._toggleEmptinessEventHandler();
        this._formattedValue = text;
        if (!this._focusOutOccurs) {
          this._caret(newCaret);
        }
      },
      _useMaskBehavior: function() {
        return !!this.option("format") && this.option("useMaskBehavior");
      },
      _renderInputType: function() {
        var isNumberType = "number" === this.option("mode");
        var isDesktop = "desktop" === devices_default.real().deviceType;
        if (this._useMaskBehavior() && isNumberType) {
          this._setInputType(isDesktop || this._isSupportInputMode() ? "text" : "tel");
        } else {
          this.callBase();
        }
      },
      _isChar: function(str) {
        return isString2(str) && 1 === str.length;
      },
      _moveCaret: function(offset2) {
        if (!offset2) {
          return;
        }
        var newCaret = getCaretWithOffset(this._caret(), offset2);
        var adjustedCaret = getCaretInBoundaries(newCaret, this._getInputVal(), this._getFormatPattern());
        this._caret(adjustedCaret);
      },
      _shouldHandleKey: function(e) {
        var keyName = normalizeKeyName(e);
        var isSpecialChar = isCommandKeyPressed(e) || e.altKey || e.shiftKey || !this._isChar(keyName);
        var isMinusKey = keyName === MINUS_KEY;
        var useMaskBehavior = this._useMaskBehavior();
        return useMaskBehavior && !isSpecialChar && !isMinusKey;
      },
      _renderInput: function() {
        this.callBase();
        this._renderFormatter();
      },
      _renderFormatter: function() {
        this._clearCache();
        this._detachFormatterEvents();
        if (this._useMaskBehavior()) {
          this._attachFormatterEvents();
        }
      },
      _detachFormatterEvents: function() {
        events_engine_default.off(this._input(), "." + NUMBER_FORMATTER_NAMESPACE);
      },
      _isInputFromPaste: function(e) {
        var inputType2 = e.originalEvent && e.originalEvent.inputType;
        if (isDefined(inputType2)) {
          return "insertFromPaste" === inputType2;
        } else {
          return this._isValuePasted;
        }
      },
      _attachFormatterEvents: function() {
        var $input = this._input();
        events_engine_default.on($input, addNamespace2(INPUT_EVENT, NUMBER_FORMATTER_NAMESPACE), (function(e) {
          this._formatValue(e);
          this._isValuePasted = false;
        }).bind(this));
        if (browser_default.msie && browser_default.version < 12) {
          events_engine_default.on($input, addNamespace2("paste", NUMBER_FORMATTER_NAMESPACE), (function() {
            this._isValuePasted = true;
          }).bind(this));
        }
        events_engine_default.on($input, addNamespace2("dxclick", NUMBER_FORMATTER_NAMESPACE), (function() {
          if (!this._caretTimeout) {
            this._caretTimeout = setTimeout((function() {
              this._caretTimeout = void 0;
              this._caret(getCaretInBoundaries(this._caret(), this._getInputVal(), this._getFormatPattern()));
            }).bind(this), CARET_TIMEOUT_DURATION);
          }
        }).bind(this));
        events_engine_default.on($input, "dxdblclick", (function() {
          this.clearCaretTimeout();
        }).bind(this));
      },
      clearCaretTimeout: function() {
        clearTimeout(this._caretTimeout);
        this._caretTimeout = void 0;
      },
      _forceRefreshInputValue: function() {
        if (!this._useMaskBehavior()) {
          return this.callBase();
        }
      },
      _isNonStubAfter: function(index2) {
        var text = this._getInputVal().slice(index2);
        return text && !this._isStub(text, true);
      },
      _isStub: function(str, isString5) {
        var escapedDecimalSeparator = escapeRegExp(number_default2.getDecimalSeparator());
        var regExpString = "^[^0-9" + escapedDecimalSeparator + "]+$";
        var stubRegExp = new RegExp(regExpString, "g");
        return stubRegExp.test(str) && (isString5 || this._isChar(str));
      },
      _parseValue: function(text) {
        if (!this._useMaskBehavior()) {
          return this.callBase(text);
        }
        return this._parsedValue;
      },
      _getPrecisionLimits: function(text) {
        var currentFormat = this._getFormatForSign(text);
        var realSeparatorIndex = getRealSeparatorIndex(currentFormat).index;
        var floatPart = (splitByIndex(currentFormat, realSeparatorIndex)[1] || "").replace(/[^#0]/g, "");
        var minPrecision = floatPart.replace(/^(0*)#*/, "$1").length;
        var maxPrecision = floatPart.length;
        return {
          min: minPrecision,
          max: maxPrecision
        };
      },
      _revertSign: function(e) {
        if (!this._useMaskBehavior()) {
          return;
        }
        var caret3 = this._caret();
        if (caret3.start !== caret3.end) {
          if (normalizeKeyName(e) === MINUS_KEY) {
            this._applyRevertedSign(e, caret3, true);
            return;
          } else {
            this._caret(getCaretInBoundaries(0, this._getInputVal(), this._getFormatPattern()));
          }
        }
        this._applyRevertedSign(e, caret3);
      },
      _applyRevertedSign: function(e, caret3, preserveSelectedText) {
        var newValue = -1 * ensureDefined(this._parsedValue, null);
        if (this._isValueInRange(newValue)) {
          this._parsedValue = newValue;
          if (preserveSelectedText) {
            var format2 = this._getFormatPattern();
            var previousText = this._getInputVal();
            this._setTextByParsedValue();
            e.preventDefault();
            var currentText = this._getInputVal();
            var offset2 = getCaretOffset(previousText, currentText, format2);
            caret3 = getCaretWithOffset(caret3, offset2);
            var caretInBoundaries = getCaretInBoundaries(caret3, currentText, format2);
            if (browser_default.msie) {
              clearTimeout(this._caretTimeout);
              this._caretTimeout = setTimeout(this._caret.bind(this, caretInBoundaries));
            } else {
              this._caret(caretInBoundaries);
            }
          }
          if (e.key === NUMPUD_MINUS_KEY_IE) {
            events_engine_default.trigger(this._input(), INPUT_EVENT);
          }
        }
      },
      _removeMinusFromText: function(text, caret3) {
        var isMinusPressed = this._lastKeyName === MINUS_KEY && text.charAt(caret3.start - 1) === MINUS;
        return isMinusPressed ? this._replaceSelectedText(text, {
          start: caret3.start - 1,
          end: caret3.start
        }, "") : text;
      },
      _setTextByParsedValue: function() {
        var format2 = this._getFormatPattern();
        var parsed = this._parseValue();
        var formatted = this._format(parsed, format2) || "";
        this._setInputText(formatted);
      },
      _formatValue: function(e) {
        var normalizedText = this._getInputVal();
        var caret3 = this._caret();
        var textWithoutMinus = this._removeMinusFromText(normalizedText, caret3);
        var wasMinusRemoved = textWithoutMinus !== normalizedText;
        normalizedText = textWithoutMinus;
        if (!this._isInputFromPaste(e) && this._isValueIncomplete(textWithoutMinus)) {
          this._formattedValue = normalizedText;
          if (wasMinusRemoved) {
            this._setTextByParsedValue();
          }
          return;
        }
        var textWasChanged = number_default2.convertDigits(this._formattedValue, true) !== normalizedText;
        if (textWasChanged) {
          var value2 = this._tryParse(normalizedText, caret3, "");
          if (isDefined(value2)) {
            this._parsedValue = value2;
          }
        }
        this._setTextByParsedValue();
      },
      _renderDisplayText: function() {
        if (this._useMaskBehavior()) {
          this._toggleEmptinessEventHandler();
        } else {
          this.callBase.apply(this, arguments);
        }
      },
      _renderValue: function() {
        if (this._useMaskBehavior()) {
          this._parsedValue = this.option("value");
          this._setTextByParsedValue();
        }
        return this.callBase();
      },
      _updateParsedValue: function() {
        var inputValue = this._getInputVal();
        this._parsedValue = this._tryParse(inputValue, this._caret());
      },
      _adjustParsedValue: function() {
        if (!this._useMaskBehavior()) {
          return;
        }
        var clearedText = this._removeStubs(this._getInputVal());
        var parsedValue = clearedText ? this._parseValue() : null;
        if (!isNumeric(parsedValue)) {
          this._parsedValue = parsedValue;
          return;
        }
        this._parsedValue = fitIntoRange(parsedValue, this.option("min"), this.option("max"));
      },
      _valueChangeEventHandler: function(e) {
        if (!this._useMaskBehavior()) {
          return this.callBase(e);
        }
        var caret3 = this._caret();
        this._saveValueChangeEvent(e);
        this._lastKey = null;
        this._lastKeyName = null;
        this._updateParsedValue();
        this._adjustParsedValue();
        this.option("value", this._parsedValue);
        if (caret3) {
          this._caret(caret3);
        }
      },
      _optionChanged: function(args) {
        switch (args.name) {
          case "format":
          case "useMaskBehavior":
            this._renderInputType();
            this._updateFormat();
            this._renderFormatter();
            this._renderValue();
            this._refreshValueChangeEvent();
            this._refreshEvents();
            break;
          case "min":
          case "max":
            this._adjustParsedValue();
            this.callBase(args);
            break;
          default:
            this.callBase(args);
        }
      },
      _clearCache: function() {
        delete this._formattedValue;
        delete this._lastKey;
        delete this._lastKeyName;
        delete this._parsedValue;
        delete this._focusOutOccurs;
        clearTimeout(this._caretTimeout);
        delete this._caretTimeout;
      },
      _clean: function() {
        this._clearCache();
        this.callBase();
      }
    });
    number_box_mask_default = NumberBoxMask;
  }
});

// node_modules/devextreme/esm/ui/number_box/number_box.js
var number_box_default;
var init_number_box = __esm({
  "node_modules/devextreme/esm/ui/number_box/number_box.js"() {
    init_component_registrator();
    init_number_box_mask();
    component_registrator_default("dxNumberBox", number_box_mask_default);
    number_box_default = number_box_mask_default;
  }
});

// node_modules/devextreme/esm/ui/number_box.js
var number_box_default2;
var init_number_box2 = __esm({
  "node_modules/devextreme/esm/ui/number_box.js"() {
    init_number_box();
    number_box_default2 = number_box_default;
  }
});

// node_modules/devextreme/esm/ui/date_box/ui.date_box.mask.parts.js
var monthGetter, monthSetter, PATTERN_GETTERS, PATTERN_SETTERS2, getPatternGetter, renderDateParts, getLimits, getDatePartIndexByPosition;
var init_ui_date_box_mask_parts = __esm({
  "node_modules/devextreme/esm/ui/date_box/ui.date_box.mask.parts.js"() {
    init_date_parser();
    init_extend();
    init_math();
    init_common();
    monthGetter = (date) => date.getMonth() + 1;
    monthSetter = (date, value2) => {
      var day = date.getDate();
      var monthLimits = getLimits("M", date);
      var newValue = fitIntoRange(parseInt(value2), monthLimits.min, monthLimits.max);
      date.setMonth(newValue - 1, 1);
      var {
        min,
        max
      } = getLimits("dM", date);
      var newDay = fitIntoRange(day, min, max);
      date.setDate(newDay);
    };
    PATTERN_GETTERS = {
      a: (date) => date.getHours() < 12 ? 0 : 1,
      E: "getDay",
      y: "getFullYear",
      M: monthGetter,
      L: monthGetter,
      d: "getDate",
      H: "getHours",
      h: "getHours",
      m: "getMinutes",
      s: "getSeconds",
      S: "getMilliseconds"
    };
    PATTERN_SETTERS2 = extend2({}, getPatternSetters(), {
      a: (date, value2) => {
        var hours = date.getHours();
        var current2 = hours >= 12;
        if (current2 === !!parseInt(value2)) {
          return;
        }
        date.setHours((hours + 12) % 24);
      },
      d: (date, value2) => {
        var lastDayInMonth = getLimits("dM", date).max;
        if (value2 > lastDayInMonth) {
          date.setMonth(date.getMonth() + 1);
        }
        date.setDate(value2);
      },
      h: (date, value2) => {
        var isPM = date.getHours() >= 12;
        date.setHours(+value2 % 12 + (isPM ? 12 : 0));
      },
      M: monthSetter,
      L: monthSetter,
      E: (date, value2) => {
        if (value2 < 0) {
          return;
        }
        date.setDate(date.getDate() - date.getDay() + parseInt(value2));
      },
      y: (date, value2) => {
        var currentYear = date.getFullYear();
        var valueLength = String(value2).length;
        var maxLimitLength = String(getLimits("y", date).max).length;
        var newValue = parseInt(String(currentYear).substr(0, maxLimitLength - valueLength) + value2);
        date.setFullYear(newValue);
      }
    });
    getPatternGetter = (patternChar) => PATTERN_GETTERS[patternChar] || (() => patternChar);
    renderDateParts = (text, regExpInfo) => {
      var result2 = regExpInfo.regexp.exec(text);
      var start = 0;
      var end = 0;
      var sections = [];
      var _loop = function() {
        start = end;
        end = start + result2[i].length;
        var pattern = regExpInfo.patterns[i - 1].replace(/^'|'$/g, "");
        var getter = getPatternGetter(pattern[0]);
        sections.push({
          index: i - 1,
          isStub: pattern === result2[i],
          caret: {
            start,
            end
          },
          pattern,
          text: result2[i],
          limits: function() {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            return getLimits(pattern[0], ...args);
          },
          setter: PATTERN_SETTERS2[pattern[0]] || noop2,
          getter
        });
      };
      for (var i = 1; i < result2.length; i++) {
        _loop();
      }
      return sections;
    };
    getLimits = (pattern, date, forcedPattern) => {
      var limits = {
        y: {
          min: 0,
          max: 9999
        },
        M: {
          min: 1,
          max: 12
        },
        L: {
          min: 1,
          max: 12
        },
        d: {
          min: 1,
          max: 31
        },
        dM: {
          min: 1,
          max: new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate()
        },
        E: {
          min: 0,
          max: 6
        },
        H: {
          min: 0,
          max: 23
        },
        h: {
          min: 0,
          max: 23
        },
        m: {
          min: 0,
          max: 59
        },
        s: {
          min: 0,
          max: 59
        },
        S: {
          min: 0,
          max: 999
        },
        a: {
          min: 0,
          max: 1
        }
      };
      return limits[forcedPattern || pattern] || limits.getAmPm;
    };
    getDatePartIndexByPosition = (dateParts, position3) => {
      for (var i = 0; i < dateParts.length; i++) {
        var caretInGroup = dateParts[i].caret.end >= position3;
        if (!dateParts[i].isStub && caretInGroup) {
          return i;
        }
      }
      return null;
    };
  }
});

// node_modules/devextreme/esm/core/utils/date_serialization.js
function getTimePart(part) {
  return +part || 0;
}
function parseDate(text) {
  var isDefaultSerializationFormat = getDateSerializationFormat(text) === DATE_SERIALIZATION_FORMAT;
  var parsedValue = !isDate(text) && Date.parse(text);
  if ((!parsedValue || isIE113) && isDefaultSerializationFormat) {
    var parts = text.match(DATE_SERIALIZATION_PATTERN);
    if (parts) {
      var newDate = new Date(getTimePart(parts[1]), getTimePart(parts[2]), getTimePart(parts[3]));
      newDate.setFullYear(getTimePart(parts[1]));
      newDate.setMonth(getTimePart(parts[2]) - 1);
      newDate.setDate(getTimePart(parts[3]));
      return newDate;
    }
  }
  return isNumeric(parsedValue) ? new Date(parsedValue) : text;
}
function parseISO8601String(text) {
  var parts = text.match(ISO8601_PATTERN);
  if (!parts) {
    parts = text.match(ISO8601_TIME_PATTERN);
    if (parts) {
      return new Date(0, 0, 0, getTimePart(parts[1]), getTimePart(parts[2]), getTimePart(parts[4]));
    }
    return;
  }
  var year = getTimePart(parts[1]);
  var month = --parts[3];
  var day = parts[5];
  var timeZoneHour = 0;
  var timeZoneMinute = 0;
  var correctYear = (d) => {
    year < 100 && d.setFullYear(year);
    return d;
  };
  timeZoneHour = getTimePart(parts[14]);
  timeZoneMinute = getTimePart(parts[16]);
  if ("-" === parts[13]) {
    timeZoneHour = -timeZoneHour;
    timeZoneMinute = -timeZoneMinute;
  }
  var hour = getTimePart(parts[6]) - timeZoneHour;
  var minute = getTimePart(parts[8]) - timeZoneMinute;
  var second = getTimePart(parts[10]);
  var millisecond = function(part) {
    part = part || "";
    return getTimePart(part) * Math.pow(10, MILLISECOND_LENGHT - part.length);
  }(parts[11]);
  if (parts[12]) {
    return correctYear(new Date(Date.UTC(year, month, day, hour, minute, second, millisecond)));
  }
  return correctYear(new Date(year, month, day, hour, minute, second, millisecond));
}
var NUMBER_SERIALIZATION_FORMAT, DATE_SERIALIZATION_FORMAT, DATETIME_SERIALIZATION_FORMAT, ISO8601_PATTERN, ISO8601_TIME_PATTERN, ISO8601_PATTERN_PARTS, DATE_SERIALIZATION_PATTERN, MILLISECOND_LENGHT, isIE113, dateParser, getIso8601Format, deserializeDate, serializeDate, getDateSerializationFormat, date_serialization_default;
var init_date_serialization = __esm({
  "node_modules/devextreme/esm/core/utils/date_serialization.js"() {
    init_config();
    init_date_formatter();
    init_default_date_names();
    init_type();
    init_browser();
    NUMBER_SERIALIZATION_FORMAT = "number";
    DATE_SERIALIZATION_FORMAT = "yyyy/MM/dd";
    DATETIME_SERIALIZATION_FORMAT = "yyyy/MM/dd HH:mm:ss";
    ISO8601_PATTERN = /^(\d{4,})(-)?(\d{2})(-)?(\d{2})(?:T(\d{2})(:)?(\d{2})?(:)?(\d{2}(?:\.(\d{1,3})\d*)?)?)?(Z|([+-])(\d{2})(:)?(\d{2})?)?$/;
    ISO8601_TIME_PATTERN = /^(\d{2}):(\d{2})(:(\d{2}))?$/;
    ISO8601_PATTERN_PARTS = ["", "yyyy", "", "MM", "", "dd", "THH", "", "mm", "", "ss", ".SSS"];
    DATE_SERIALIZATION_PATTERN = /^(\d{4})\/(\d{2})\/(\d{2})$/;
    MILLISECOND_LENGHT = 3;
    isIE113 = browser_default.msie && parseInt(browser_default.version) <= 11;
    dateParser = function(text, skipISO8601Parsing) {
      var result2;
      if (isString2(text) && !skipISO8601Parsing) {
        result2 = parseISO8601String(text);
      }
      return result2 || parseDate(text);
    };
    getIso8601Format = function(text, useUtc) {
      var parts = text.match(ISO8601_PATTERN);
      var result2 = "";
      if (!parts) {
        parts = text.match(ISO8601_TIME_PATTERN);
        if (parts) {
          return parts[3] ? "HH:mm:ss" : "HH:mm";
        }
        return;
      }
      for (var i = 1; i < ISO8601_PATTERN_PARTS.length; i++) {
        if (parts[i]) {
          result2 += ISO8601_PATTERN_PARTS[i] || parts[i];
        }
      }
      if ("Z" === parts[12]) {
        result2 += "'Z'";
      }
      if (parts[14]) {
        if (parts[15]) {
          result2 += "xxx";
        } else if (parts[16]) {
          result2 += "xx";
        } else {
          result2 += "x";
        }
      }
      return result2;
    };
    deserializeDate = function(value2) {
      if ("number" === typeof value2) {
        return new Date(value2);
      }
      return dateParser(value2, !config_default().forceIsoDateParsing);
    };
    serializeDate = function(value2, serializationFormat) {
      if (!serializationFormat) {
        return value2;
      }
      if (!isDate(value2)) {
        return null;
      }
      if (serializationFormat === NUMBER_SERIALIZATION_FORMAT) {
        return value2 && value2.valueOf ? value2.valueOf() : null;
      }
      return getFormatter3(serializationFormat, default_date_names_default)(value2);
    };
    getDateSerializationFormat = function(value2) {
      if ("number" === typeof value2) {
        return NUMBER_SERIALIZATION_FORMAT;
      } else if (isString2(value2)) {
        var format2;
        if (config_default().forceIsoDateParsing) {
          format2 = getIso8601Format(value2);
        }
        if (format2) {
          return format2;
        } else if (value2.indexOf(":") >= 0) {
          return DATETIME_SERIALIZATION_FORMAT;
        } else {
          return DATE_SERIALIZATION_FORMAT;
        }
      } else if (value2) {
        return null;
      }
    };
    date_serialization_default = {
      dateParser,
      deserializeDate,
      serializeDate,
      getDateSerializationFormat
    };
  }
});

// node_modules/devextreme/esm/ui/date_box/ui.date_utils.js
var DATE_COMPONENTS, TIME_COMPONENTS, ONE_MINUTE, ONE_DAY, ONE_YEAR, getStringFormat, dateUtils2, ui_date_utils_default;
var init_ui_date_utils = __esm({
  "node_modules/devextreme/esm/ui/date_box/ui.date_utils.js"() {
    init_renderer();
    init_date_serialization();
    init_type();
    init_iterator();
    init_date3();
    DATE_COMPONENTS = ["year", "day", "month", "day"];
    TIME_COMPONENTS = ["hours", "minutes", "seconds", "milliseconds"];
    ONE_MINUTE = 6e4;
    ONE_DAY = 60 * ONE_MINUTE * 24;
    ONE_YEAR = 365 * ONE_DAY;
    getStringFormat = function(format2) {
      var formatType = typeof format2;
      if ("string" === formatType) {
        return "format";
      }
      if ("object" === formatType && void 0 !== format2.type) {
        return format2.type;
      }
      return null;
    };
    dateUtils2 = {
      SUPPORTED_FORMATS: ["date", "time", "datetime"],
      ONE_MINUTE,
      ONE_DAY,
      ONE_YEAR,
      MIN_DATEVIEW_DEFAULT_DATE: new Date(1900, 0, 1),
      MAX_DATEVIEW_DEFAULT_DATE: function() {
        var newDate = /* @__PURE__ */ new Date();
        return new Date(newDate.getFullYear() + 50, newDate.getMonth(), newDate.getDate(), 23, 59, 59);
      }(),
      FORMATS_INFO: {
        date: {
          getStandardPattern: function() {
            return "yyyy-MM-dd";
          },
          components: DATE_COMPONENTS
        },
        time: {
          getStandardPattern: function() {
            return "HH:mm";
          },
          components: TIME_COMPONENTS
        },
        datetime: {
          getStandardPattern: function() {
            var standardPattern;
            !function() {
              var $input = renderer_default("<input>").attr("type", "datetime");
              $input.val("2000-01-01T01:01Z");
              if ($input.val()) {
                standardPattern = "yyyy-MM-ddTHH:mmZ";
              }
            }();
            if (!standardPattern) {
              standardPattern = "yyyy-MM-ddTHH:mm:ssZ";
            }
            dateUtils2.FORMATS_INFO.datetime.getStandardPattern = function() {
              return standardPattern;
            };
            return standardPattern;
          },
          components: [...DATE_COMPONENTS, ...TIME_COMPONENTS]
        },
        "datetime-local": {
          getStandardPattern: function() {
            return "yyyy-MM-ddTHH:mm:ss";
          },
          components: [...DATE_COMPONENTS, "hours", "minutes", "seconds"]
        }
      },
      FORMATS_MAP: {
        date: "shortdate",
        time: "shorttime",
        datetime: "shortdateshorttime"
      },
      SUBMIT_FORMATS_MAP: {
        date: "date",
        time: "time",
        datetime: "datetime-local"
      },
      toStandardDateFormat: function(date, type2) {
        var pattern = dateUtils2.FORMATS_INFO[type2].getStandardPattern();
        return date_serialization_default.serializeDate(date, pattern);
      },
      fromStandardDateFormat: function(text) {
        var date = date_serialization_default.dateParser(text);
        return isDate(date) ? date : void 0;
      },
      getMaxMonthDay: function(year, month) {
        return new Date(year, month + 1, 0).getDate();
      },
      mergeDates: function(oldValue, newValue, format2) {
        if (!newValue) {
          return newValue || null;
        }
        if (!oldValue || isNaN(oldValue.getTime())) {
          var now = /* @__PURE__ */ new Date(null);
          oldValue = new Date(now.getFullYear(), now.getMonth(), now.getDate());
        }
        var result2 = new Date(oldValue.valueOf());
        var formatInfo = dateUtils2.FORMATS_INFO[format2];
        each(formatInfo.components, function() {
          var componentInfo = dateUtils2.DATE_COMPONENTS_INFO[this];
          result2[componentInfo.setter](newValue[componentInfo.getter]());
        });
        return result2;
      },
      getLongestCaptionIndex: function(captionArray) {
        var longestIndex = 0;
        var longestCaptionLength = 0;
        var i;
        for (i = 0; i < captionArray.length; ++i) {
          if (captionArray[i].length > longestCaptionLength) {
            longestIndex = i;
            longestCaptionLength = captionArray[i].length;
          }
        }
        return longestIndex;
      },
      formatUsesMonthName: function(format2) {
        return date_default3.formatUsesMonthName(format2);
      },
      formatUsesDayName: function(format2) {
        return date_default3.formatUsesDayName(format2);
      },
      getLongestDate: function(format2, monthNames, dayNames) {
        var stringFormat = getStringFormat(format2);
        var month = 9;
        if (!stringFormat || dateUtils2.formatUsesMonthName(stringFormat)) {
          month = dateUtils2.getLongestCaptionIndex(monthNames);
        }
        var longestDate = new Date(1888, month, 21, 23, 59, 59, 999);
        if (!stringFormat || dateUtils2.formatUsesDayName(stringFormat)) {
          var date = longestDate.getDate() - longestDate.getDay() + dateUtils2.getLongestCaptionIndex(dayNames);
          longestDate.setDate(date);
        }
        return longestDate;
      },
      normalizeTime: function(date) {
        date.setSeconds(0);
        date.setMilliseconds(0);
      }
    };
    dateUtils2.DATE_COMPONENTS_INFO = {
      year: {
        getter: "getFullYear",
        setter: "setFullYear",
        formatter: function(value2, date) {
          var formatDate = new Date(date.getTime());
          formatDate.setFullYear(value2);
          return date_default3.format(formatDate, "yyyy");
        },
        startValue: void 0,
        endValue: void 0
      },
      day: {
        getter: "getDate",
        setter: "setDate",
        formatter: function(value2, date) {
          var formatDate = new Date(date.getTime());
          formatDate.setDate(value2);
          return date_default3.format(formatDate, "d");
        },
        startValue: 1,
        endValue: void 0
      },
      month: {
        getter: "getMonth",
        setter: "setMonth",
        formatter: function(value2) {
          return date_default3.getMonthNames()[value2];
        },
        startValue: 0,
        endValue: 11
      },
      hours: {
        getter: "getHours",
        setter: "setHours",
        formatter: function(value2) {
          return date_default3.format(new Date(0, 0, 0, value2), "hour");
        },
        startValue: 0,
        endValue: 23
      },
      minutes: {
        getter: "getMinutes",
        setter: "setMinutes",
        formatter: function(value2) {
          return date_default3.format(new Date(0, 0, 0, 0, value2), "minute");
        },
        startValue: 0,
        endValue: 59
      },
      seconds: {
        getter: "getSeconds",
        setter: "setSeconds",
        formatter: function(value2) {
          return date_default3.format(new Date(0, 0, 0, 0, 0, value2), "second");
        },
        startValue: 0,
        endValue: 59
      },
      milliseconds: {
        getter: "getMilliseconds",
        setter: "setMilliseconds",
        formatter: function(value2) {
          return date_default3.format(new Date(0, 0, 0, 0, 0, 0, value2), "millisecond");
        },
        startValue: 0,
        endValue: 999
      }
    };
    ui_date_utils_default = dateUtils2;
  }
});

// node_modules/devextreme/esm/ui/drop_down_editor/ui.drop_down_button.js
var DROP_DOWN_EDITOR_BUTTON_CLASS, DROP_DOWN_EDITOR_BUTTON_VISIBLE, BUTTON_MESSAGE, DropDownButton;
var init_ui_drop_down_button = __esm({
  "node_modules/devextreme/esm/ui/drop_down_editor/ui.drop_down_button.js"() {
    init_renderer();
    init_extend();
    init_events_engine();
    init_message();
    init_button2();
    init_button();
    DROP_DOWN_EDITOR_BUTTON_CLASS = "dx-dropdowneditor-button";
    DROP_DOWN_EDITOR_BUTTON_VISIBLE = "dx-dropdowneditor-button-visible";
    BUTTON_MESSAGE = "dxDropDownEditor-selectLabel";
    DropDownButton = class extends TextEditorButton {
      constructor(name2, editor, options2) {
        super(name2, editor, options2);
        this.currentTemplate = null;
      }
      _attachEvents(instance) {
        var {
          editor
        } = this;
        instance.option("onClick", (e) => {
          !editor.option("openOnFieldClick") && editor._openHandler(e);
        });
        events_engine_default.on(instance.$element(), "mousedown", (e) => {
          if (editor.$element().is(".dx-state-focused")) {
            e.preventDefault();
          }
        });
      }
      _create() {
        var {
          editor
        } = this;
        var $element = renderer_default("<div>");
        var options2 = this._getOptions();
        this._addToContainer($element);
        var instance = editor._createComponent($element, button_default, extend2({}, options2, {
          elementAttr: {
            "aria-label": message_default.format(BUTTON_MESSAGE)
          }
        }));
        this._legacyRender(editor.$element(), $element, options2.visible);
        return {
          $element,
          instance
        };
      }
      _getOptions() {
        var {
          editor
        } = this;
        var visible2 = this._isVisible();
        var isReadOnly = editor.option("readOnly");
        var options2 = {
          focusStateEnabled: false,
          hoverStateEnabled: false,
          activeStateEnabled: false,
          useInkRipple: false,
          disabled: isReadOnly,
          visible: visible2
        };
        this._addTemplate(options2);
        return options2;
      }
      _isVisible() {
        var {
          editor
        } = this;
        return super._isVisible() && editor.option("showDropDownButton");
      }
      _legacyRender($editor, $element, isVisible2) {
        $editor.toggleClass(DROP_DOWN_EDITOR_BUTTON_VISIBLE, isVisible2);
        if ($element) {
          $element.removeClass("dx-button").addClass(DROP_DOWN_EDITOR_BUTTON_CLASS);
        }
      }
      _isSameTemplate() {
        return this.editor.option("dropDownButtonTemplate") === this.currentTemplate;
      }
      _addTemplate(options2) {
        if (!this._isSameTemplate()) {
          options2.template = this.editor._getTemplateByOption("dropDownButtonTemplate");
          this.currentTemplate = this.editor.option("dropDownButtonTemplate");
        }
      }
      update() {
        var shouldUpdate = super.update();
        if (shouldUpdate) {
          var {
            editor,
            instance
          } = this;
          var $editor = editor.$element();
          var options2 = this._getOptions();
          null === instance || void 0 === instance ? void 0 : instance.option(options2);
          this._legacyRender($editor, null === instance || void 0 === instance ? void 0 : instance.$element(), options2.visible);
        }
      }
    };
  }
});

// node_modules/devextreme/esm/ui/drop_down_editor/utils.js
var getElementWidth, getSizeValue;
var init_utils7 = __esm({
  "node_modules/devextreme/esm/ui/drop_down_editor/utils.js"() {
    init_window();
    getElementWidth = function($element) {
      if (hasWindow()) {
        return $element.outerWidth();
      }
    };
    getSizeValue = function(size) {
      if (null === size) {
        size = void 0;
      }
      if ("function" === typeof size) {
        size = size();
      }
      return size;
    };
  }
});

// node_modules/devextreme/esm/ui/drop_down_editor/ui.drop_down_editor.js
var DROP_DOWN_EDITOR_CLASS, DROP_DOWN_EDITOR_INPUT_WRAPPER, DROP_DOWN_EDITOR_BUTTON_ICON, DROP_DOWN_EDITOR_OVERLAY, DROP_DOWN_EDITOR_OVERLAY_FLIPPED, DROP_DOWN_EDITOR_ACTIVE, DROP_DOWN_EDITOR_FIELD_CLICKABLE, DROP_DOWN_EDITOR_FIELD_TEMPLATE_WRAPPER, isIOs, DropDownEditor, ui_drop_down_editor_default;
var init_ui_drop_down_editor = __esm({
  "node_modules/devextreme/esm/ui/drop_down_editor/ui.drop_down_editor.js"() {
    init_renderer();
    init_events_engine();
    init_guid();
    init_component_registrator();
    init_common();
    init_selectors();
    init_iterator();
    init_type();
    init_extend();
    init_element();
    init_ui_errors();
    init_position2();
    init_position();
    init_ui_drop_down_button();
    init_ui_widget();
    init_message();
    init_utils2();
    init_text_box2();
    init_click();
    init_devices();
    init_function_template();
    init_popup();
    init_window();
    init_utils7();
    DROP_DOWN_EDITOR_CLASS = "dx-dropdowneditor";
    DROP_DOWN_EDITOR_INPUT_WRAPPER = "dx-dropdowneditor-input-wrapper";
    DROP_DOWN_EDITOR_BUTTON_ICON = "dx-dropdowneditor-icon";
    DROP_DOWN_EDITOR_OVERLAY = "dx-dropdowneditor-overlay";
    DROP_DOWN_EDITOR_OVERLAY_FLIPPED = "dx-dropdowneditor-overlay-flipped";
    DROP_DOWN_EDITOR_ACTIVE = "dx-dropdowneditor-active";
    DROP_DOWN_EDITOR_FIELD_CLICKABLE = "dx-dropdowneditor-field-clickable";
    DROP_DOWN_EDITOR_FIELD_TEMPLATE_WRAPPER = "dx-dropdowneditor-field-template-wrapper";
    isIOs = "ios" === devices_default.current().platform;
    DropDownEditor = text_box_default2.inherit({
      _supportedKeys: function() {
        return extend2({}, this.callBase(), {
          tab: function(e) {
            if (!this.option("opened")) {
              return;
            }
            if ("instantly" === this.option("applyValueMode")) {
              this.close();
              return;
            }
            var $focusableElement = e.shiftKey ? this._getLastPopupElement() : this._getFirstPopupElement();
            $focusableElement && events_engine_default.trigger($focusableElement, "focus");
            e.preventDefault();
          },
          escape: function(e) {
            if (this.option("opened")) {
              e.preventDefault();
            }
            this.close();
            return true;
          },
          upArrow: function(e) {
            if (!isCommandKeyPressed(e)) {
              e.preventDefault();
              e.stopPropagation();
              if (e.altKey) {
                this.close();
                return false;
              }
            }
            return true;
          },
          downArrow: function(e) {
            if (!isCommandKeyPressed(e)) {
              e.preventDefault();
              e.stopPropagation();
              if (e.altKey) {
                this._validatedOpening();
                return false;
              }
            }
            return true;
          },
          enter: function(e) {
            if (this.option("opened")) {
              e.preventDefault();
              this._valueChangeEventHandler(e);
            }
            return true;
          }
        });
      },
      _getDefaultButtons: function() {
        return this.callBase().concat([{
          name: "dropDown",
          Ctor: DropDownButton
        }]);
      },
      _getDefaultOptions: function() {
        return extend2(this.callBase(), {
          value: null,
          onOpened: null,
          onClosed: null,
          opened: false,
          acceptCustomValue: true,
          applyValueMode: "instantly",
          deferRendering: true,
          activeStateEnabled: true,
          dropDownButtonTemplate: "dropDownButton",
          fieldTemplate: null,
          openOnFieldClick: false,
          showDropDownButton: true,
          buttons: void 0,
          dropDownOptions: {
            showTitle: false
          },
          popupPosition: this._getDefaultPopupPosition(),
          onPopupInitialized: null,
          applyButtonText: message_default.format("OK"),
          cancelButtonText: message_default.format("Cancel"),
          buttonsLocation: "default",
          useHiddenSubmitElement: false
        });
      },
      _useTemplates: function() {
        return true;
      },
      _getDefaultPopupPosition: function(isRtlEnabled) {
        var position3 = getDefaultAlignment(isRtlEnabled);
        return {
          offset: {
            h: 0,
            v: -1
          },
          my: position3 + " top",
          at: position3 + " bottom",
          collision: "flip flip"
        };
      },
      _defaultOptionsRules: function() {
        return this.callBase().concat([{
          device: function(_device) {
            var isGeneric2 = "generic" === _device.platform;
            return isGeneric2;
          },
          options: {
            popupPosition: {
              offset: {
                v: 0
              }
            }
          }
        }]);
      },
      _inputWrapper: function() {
        return this.$element().find("." + DROP_DOWN_EDITOR_INPUT_WRAPPER).first();
      },
      _init: function() {
        this.callBase();
        this._initVisibilityActions();
        this._initPopupInitializedAction();
        this._updatePopupPosition(this.option("rtlEnabled"));
        this._options.cache("dropDownOptions", this.option("dropDownOptions"));
      },
      _updatePopupPosition: function(isRtlEnabled) {
        var {
          my,
          at
        } = this._getDefaultPopupPosition(isRtlEnabled);
        var currentPosition = this.option("popupPosition");
        this.option("popupPosition", extend2({}, currentPosition, {
          my,
          at
        }));
      },
      _initVisibilityActions: function() {
        this._openAction = this._createActionByOption("onOpened", {
          excludeValidators: ["disabled", "readOnly"]
        });
        this._closeAction = this._createActionByOption("onClosed", {
          excludeValidators: ["disabled", "readOnly"]
        });
      },
      _initPopupInitializedAction: function() {
        this._popupInitializedAction = this._createActionByOption("onPopupInitialized", {
          excludeValidators: ["disabled", "readOnly"]
        });
      },
      _initMarkup: function() {
        this._renderSubmitElement();
        this.callBase();
        this.$element().addClass(DROP_DOWN_EDITOR_CLASS);
        this.setAria("role", "combobox");
      },
      _render: function() {
        this.callBase();
        this._renderOpenHandler();
        this._attachFocusOutHandler();
        this._renderOpenedState();
      },
      _renderContentImpl: function() {
        if (!this.option("deferRendering")) {
          this._createPopup();
        }
      },
      _renderInput: function() {
        this.callBase();
        this._wrapInput();
        this._setDefaultAria();
      },
      _wrapInput: function() {
        this._$container = this.$element().wrapInner(renderer_default("<div>").addClass(DROP_DOWN_EDITOR_INPUT_WRAPPER)).children().eq(0);
      },
      _setDefaultAria: function() {
        this.setAria({
          haspopup: "true",
          autocomplete: "list"
        });
      },
      _readOnlyPropValue: function() {
        return !this._isEditable() || this.callBase();
      },
      _cleanFocusState: function() {
        this.callBase();
        if (this.option("fieldTemplate")) {
          this._detachFocusEvents();
        }
      },
      _getFieldTemplate: function() {
        return this.option("fieldTemplate") && this._getTemplateByOption("fieldTemplate");
      },
      _renderMask: function() {
        if (this.option("fieldTemplate")) {
          return;
        }
        this.callBase();
      },
      _renderField: function() {
        var fieldTemplate = this._getFieldTemplate();
        fieldTemplate && this._renderTemplatedField(fieldTemplate, this._fieldRenderData());
      },
      _renderPlaceholder: function() {
        var hasFieldTemplate = !!this._getFieldTemplate();
        if (!hasFieldTemplate) {
          this.callBase();
        }
      },
      _renderValue: function() {
        if (this.option("useHiddenSubmitElement")) {
          this._setSubmitValue();
        }
        var promise2 = this.callBase();
        promise2.always(this._renderField.bind(this));
      },
      _renderTemplatedField: function(fieldTemplate, data2) {
        var _this$_fieldRenderQue;
        this._fieldRenderQueueLength = (null !== (_this$_fieldRenderQue = this._fieldRenderQueueLength) && void 0 !== _this$_fieldRenderQue ? _this$_fieldRenderQue : 0) + 1;
        var isFocused = focused(this._input());
        var $container = this._$container;
        this._detachKeyboardEvents();
        this._refreshButtonsContainer();
        this._detachWrapperContent();
        this._detachFocusEvents();
        $container.empty();
        var $templateWrapper = renderer_default("<div>").addClass(DROP_DOWN_EDITOR_FIELD_TEMPLATE_WRAPPER).appendTo($container);
        fieldTemplate.render({
          model: data2,
          container: getPublicElement($templateWrapper),
          onRendered: () => {
            this._fieldRenderQueueLength--;
            if (0 !== this._fieldRenderQueueLength) {
              return;
            }
            var $input = this._input();
            if (!$input.length) {
              throw ui_errors_default.Error("E1010");
            }
            this._integrateInput();
            isFocused && events_engine_default.trigger($input, "focus");
          }
        });
        this._attachWrapperContent($container);
      },
      _detachWrapperContent() {
        var _this$_$submitElement, _this$_$beforeButtons, _this$_$afterButtonsC;
        var useHiddenSubmitElement = this.option("useHiddenSubmitElement");
        useHiddenSubmitElement && (null === (_this$_$submitElement = this._$submitElement) || void 0 === _this$_$submitElement ? void 0 : _this$_$submitElement.detach());
        var beforeButtonsContainerParent = null === (_this$_$beforeButtons = this._$beforeButtonsContainer) || void 0 === _this$_$beforeButtons ? void 0 : _this$_$beforeButtons[0].parentNode;
        var afterButtonsContainerParent = null === (_this$_$afterButtonsC = this._$afterButtonsContainer) || void 0 === _this$_$afterButtonsC ? void 0 : _this$_$afterButtonsC[0].parentNode;
        null === beforeButtonsContainerParent || void 0 === beforeButtonsContainerParent ? void 0 : beforeButtonsContainerParent.removeChild(this._$beforeButtonsContainer[0]);
        null === afterButtonsContainerParent || void 0 === afterButtonsContainerParent ? void 0 : afterButtonsContainerParent.removeChild(this._$afterButtonsContainer[0]);
      },
      _attachWrapperContent($container) {
        var _this$_$submitElement2;
        var useHiddenSubmitElement = this.option("useHiddenSubmitElement");
        $container.prepend(this._$beforeButtonsContainer);
        useHiddenSubmitElement && (null === (_this$_$submitElement2 = this._$submitElement) || void 0 === _this$_$submitElement2 ? void 0 : _this$_$submitElement2.appendTo($container));
        $container.append(this._$afterButtonsContainer);
      },
      _refreshButtonsContainer() {
        this._$buttonsContainer = this.$element().children().eq(0);
      },
      _integrateInput: function() {
        this._renderFocusState();
        this._refreshValueChangeEvent();
        this._refreshEvents();
        this._refreshEmptinessEvent();
      },
      _refreshEmptinessEvent: function() {
        events_engine_default.off(this._input(), "input blur", this._toggleEmptinessEventHandler);
        this._renderEmptinessEvent();
      },
      _fieldRenderData: function() {
        return this.option("value");
      },
      _initTemplates: function() {
        this._templateManager.addDefaultTemplates({
          dropDownButton: new FunctionTemplate(function(options2) {
            var $icon = renderer_default("<div>").addClass(DROP_DOWN_EDITOR_BUTTON_ICON);
            renderer_default(options2.container).append($icon);
          })
        });
        this.callBase();
      },
      _renderOpenHandler: function() {
        var $inputWrapper = this._inputWrapper();
        var eventName = addNamespace2(CLICK_EVENT_NAME, this.NAME);
        var openOnFieldClick = this.option("openOnFieldClick");
        events_engine_default.off($inputWrapper, eventName);
        events_engine_default.on($inputWrapper, eventName, this._getInputClickHandler(openOnFieldClick));
        this.$element().toggleClass(DROP_DOWN_EDITOR_FIELD_CLICKABLE, openOnFieldClick);
        if (openOnFieldClick) {
          this._openOnFieldClickAction = this._createAction(this._openHandler.bind(this));
        }
      },
      _attachFocusOutHandler: function() {
        if (isIOs) {
          this._detachFocusOutEvents();
          events_engine_default.on(this._inputWrapper(), addNamespace2("focusout", this.NAME), (event) => {
            var newTarget = event.relatedTarget;
            var popupWrapper = this.content ? renderer_default(this.content()).closest("." + DROP_DOWN_EDITOR_OVERLAY) : this._$popup;
            if (newTarget && this.option("opened")) {
              var isNewTargetOutside = 0 === renderer_default(newTarget).closest("." + DROP_DOWN_EDITOR_OVERLAY, popupWrapper).length;
              if (isNewTargetOutside) {
                this.close();
              }
            }
          });
        }
      },
      _detachFocusOutEvents: function() {
        isIOs && events_engine_default.off(this._inputWrapper(), addNamespace2("focusout", this.NAME));
      },
      _getInputClickHandler: function(openOnFieldClick) {
        return openOnFieldClick ? (e) => {
          this._executeOpenAction(e);
        } : (e) => {
          this._focusInput();
        };
      },
      _openHandler: function() {
        this._toggleOpenState();
      },
      _executeOpenAction: function(e) {
        this._openOnFieldClickAction({
          event: e
        });
      },
      _keyboardEventBindingTarget: function() {
        return this._input();
      },
      _focusInput: function() {
        if (this.option("disabled")) {
          return false;
        }
        if (this.option("focusStateEnabled") && !focused(this._input())) {
          this._resetCaretPosition();
          events_engine_default.trigger(this._input(), "focus");
        }
        return true;
      },
      _resetCaretPosition: function() {
        var ignoreEditable = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : false;
        var inputElement = this._input().get(0);
        if (inputElement) {
          var {
            value: value2
          } = inputElement;
          var caretPosition = isDefined(value2) && (ignoreEditable || this._isEditable()) ? value2.length : 0;
          this._caret({
            start: caretPosition,
            end: caretPosition
          }, true);
        }
      },
      _isEditable: function() {
        return this.option("acceptCustomValue");
      },
      _toggleOpenState: function(isVisible2) {
        if (!this._focusInput()) {
          return;
        }
        if (!this.option("readOnly")) {
          isVisible2 = arguments.length ? isVisible2 : !this.option("opened");
          this.option("opened", isVisible2);
        }
      },
      _renderOpenedState: function() {
        var opened = this.option("opened");
        if (opened) {
          this._createPopup();
        }
        this.$element().toggleClass(DROP_DOWN_EDITOR_ACTIVE, opened);
        this._setPopupOption("visible", opened);
        this.setAria({
          expanded: opened
        });
        this.setAria("owns", opened ? this._popupContentId : void 0, this.$element());
      },
      _createPopup: function() {
        if (this._$popup) {
          return;
        }
        this._$popup = renderer_default("<div>").addClass(DROP_DOWN_EDITOR_OVERLAY).appendTo(this.$element());
        this._renderPopup();
        this._renderPopupContent();
      },
      _renderPopupContent: noop2,
      _renderPopup: function() {
        var popupConfig = extend2(this._popupConfig(), this._options.cache("dropDownOptions"));
        this._popup = this._createComponent(this._$popup, popup_default, popupConfig);
        this._popup.on({
          showing: this._popupShowingHandler.bind(this),
          shown: this._popupShownHandler.bind(this),
          hiding: this._popupHidingHandler.bind(this),
          hidden: this._popupHiddenHandler.bind(this),
          contentReady: this._contentReadyHandler.bind(this)
        });
        this._contentReadyHandler();
        this._setPopupContentId(this._popup.$content());
        this._bindInnerWidgetOptions(this._popup, "dropDownOptions");
      },
      _setPopupContentId($popupContent) {
        this._popupContentId = "dx-" + new guid_default();
        this.setAria("id", this._popupContentId, $popupContent);
      },
      _contentReadyHandler: noop2,
      _popupConfig: function() {
        return {
          onInitialized: this._popupInitializedHandler(),
          position: extend2(this.option("popupPosition"), {
            of: this.$element()
          }),
          showTitle: this.option("dropDownOptions.showTitle"),
          width: () => getElementWidth(this.$element()),
          height: "auto",
          shading: false,
          closeOnTargetScroll: true,
          closeOnOutsideClick: this._closeOutsideDropDownHandler.bind(this),
          animation: {
            show: {
              type: "fade",
              duration: 0,
              from: 0,
              to: 1
            },
            hide: {
              type: "fade",
              duration: 400,
              from: 1,
              to: 0
            }
          },
          deferRendering: false,
          focusStateEnabled: false,
          showCloseButton: false,
          dragEnabled: false,
          toolbarItems: this._getPopupToolbarItems(),
          onPositioned: this._popupPositionedHandler.bind(this),
          fullScreen: false,
          contentTemplate: null
        };
      },
      _popupInitializedHandler: function() {
        if (!this.option("onPopupInitialized")) {
          return null;
        }
        return (e) => {
          this._popupInitializedAction({
            popup: e.component
          });
        };
      },
      _dimensionChanged: function() {
        var popupWidth = getSizeValue(this.option("dropDownOptions.width"));
        if (void 0 === popupWidth) {
          this._setPopupOption("width", () => getElementWidth(this.$element()));
        }
      },
      _popupPositionedHandler: function(e) {
        e.position && this._popup.$overlayContent().toggleClass(DROP_DOWN_EDITOR_OVERLAY_FLIPPED, e.position.v.flip);
      },
      _popupShowingHandler: noop2,
      _popupHidingHandler: function() {
        this.option("opened", false);
      },
      _popupShownHandler: function() {
        var _this$_validationMess;
        this._openAction();
        null === (_this$_validationMess = this._validationMessage) || void 0 === _this$_validationMess ? void 0 : _this$_validationMess.option("positionRequest", this._getValidationMessagePositionRequest());
      },
      _popupHiddenHandler: function() {
        var _this$_validationMess2;
        this._closeAction();
        null === (_this$_validationMess2 = this._validationMessage) || void 0 === _this$_validationMess2 ? void 0 : _this$_validationMess2.option("positionRequest", this._getValidationMessagePositionRequest());
      },
      _getValidationMessagePositionRequest: function() {
        var positionRequest = "below";
        if (this._popup && this._popup.option("visible")) {
          var {
            top: myTop
          } = position_default.setup(this.$element());
          var {
            top: popupTop
          } = position_default.setup(this._popup.$content());
          positionRequest = myTop + this.option("popupPosition").offset.v > popupTop ? "below" : "above";
        }
        return positionRequest;
      },
      _closeOutsideDropDownHandler: function(_ref) {
        var {
          target
        } = _ref;
        var $target = renderer_default(target);
        var dropDownButton = this.getButton("dropDown");
        var $dropDownButton = dropDownButton && dropDownButton.$element();
        var isInputClicked = !!$target.closest(this.$element()).length;
        var isDropDownButtonClicked = !!$target.closest($dropDownButton).length;
        var isOutsideClick = !isInputClicked && !isDropDownButtonClicked;
        return isOutsideClick;
      },
      _clean: function() {
        delete this._openOnFieldClickAction;
        if (this._$popup) {
          this._$popup.remove();
          delete this._$popup;
          delete this._popup;
        }
        this.callBase();
      },
      _setPopupOption: function(optionName, value2) {
        this._setWidgetOption("_popup", arguments);
      },
      _validatedOpening: function() {
        if (!this.option("readOnly")) {
          this._toggleOpenState(true);
        }
      },
      _getPopupToolbarItems: function() {
        return "useButtons" === this.option("applyValueMode") ? this._popupToolbarItemsConfig() : [];
      },
      _getFirstPopupElement: function() {
        return this._popup.$wrapper().find(".dx-popup-done.dx-button");
      },
      _getLastPopupElement: function() {
        return this._popup.$wrapper().find(".dx-popup-cancel.dx-button");
      },
      _popupElementTabHandler: function(e) {
        var $element = renderer_default(e.currentTarget);
        if (e.shiftKey && $element.is(this._getFirstPopupElement()) || !e.shiftKey && $element.is(this._getLastPopupElement())) {
          events_engine_default.trigger(this._input(), "focus");
          e.preventDefault();
        }
      },
      _popupElementEscHandler: function() {
        events_engine_default.trigger(this._input(), "focus");
        this.close();
      },
      _popupButtonInitializedHandler: function(e) {
        e.component.registerKeyHandler("tab", this._popupElementTabHandler.bind(this));
        e.component.registerKeyHandler("escape", this._popupElementEscHandler.bind(this));
      },
      _popupToolbarItemsConfig: function() {
        var buttonsConfig = [{
          shortcut: "done",
          options: {
            onClick: this._applyButtonHandler.bind(this),
            text: this.option("applyButtonText"),
            onInitialized: this._popupButtonInitializedHandler.bind(this)
          }
        }, {
          shortcut: "cancel",
          options: {
            onClick: this._cancelButtonHandler.bind(this),
            text: this.option("cancelButtonText"),
            onInitialized: this._popupButtonInitializedHandler.bind(this)
          }
        }];
        return this._applyButtonsLocation(buttonsConfig);
      },
      _applyButtonsLocation: function(buttonsConfig) {
        var buttonsLocation = this.option("buttonsLocation");
        var resultConfig = buttonsConfig;
        if ("default" !== buttonsLocation) {
          var position3 = splitPair(buttonsLocation);
          each(resultConfig, function(_2, element) {
            extend2(element, {
              toolbar: position3[0],
              location: position3[1]
            });
          });
        }
        return resultConfig;
      },
      _applyButtonHandler: function() {
        this.close();
        this.option("focusStateEnabled") && this.focus();
      },
      _cancelButtonHandler: function() {
        this.close();
        this.option("focusStateEnabled") && this.focus();
      },
      _popupOptionChanged: function(args) {
        var options2 = ui_widget_default.getOptionsFromContainer(args);
        this._setPopupOption(options2);
        var optionsKeys = Object.keys(options2);
        if (-1 !== optionsKeys.indexOf("width") || -1 !== optionsKeys.indexOf("height")) {
          this._dimensionChanged();
        }
      },
      _renderSubmitElement: function() {
        if (this.option("useHiddenSubmitElement")) {
          this._$submitElement = renderer_default("<input>").attr("type", "hidden").appendTo(this.$element());
        }
      },
      _setSubmitValue: function() {
        this._getSubmitElement().val(this.option("value"));
      },
      _getSubmitElement: function() {
        if (this.option("useHiddenSubmitElement")) {
          return this._$submitElement;
        } else {
          return this.callBase();
        }
      },
      _dispose: function() {
        this._detachFocusOutEvents();
        this.callBase();
      },
      _setDeprecatedOptions: function() {
        this.callBase();
        extend2(this._deprecatedOptions, {
          showPopupTitle: {
            since: "20.1",
            alias: "dropDownOptions.showTitle"
          }
        });
      },
      _optionChanged: function(args) {
        var _this$_popup;
        switch (args.name) {
          case "width":
          case "height":
            this.callBase(args);
            null === (_this$_popup = this._popup) || void 0 === _this$_popup ? void 0 : _this$_popup.repaint();
            break;
          case "opened":
            this._renderOpenedState();
            break;
          case "onOpened":
          case "onClosed":
            this._initVisibilityActions();
            break;
          case "onPopupInitialized":
            this._initPopupInitializedAction();
            break;
          case "fieldTemplate":
            if (isDefined(args.value)) {
              this._renderField();
            } else {
              this._invalidate();
            }
            break;
          case "acceptCustomValue":
          case "openOnFieldClick":
            this._invalidate();
            break;
          case "dropDownButtonTemplate":
          case "showDropDownButton":
            this._updateButtons(["dropDown"]);
            break;
          case "dropDownOptions":
            this._popupOptionChanged(args);
            this._options.cache("dropDownOptions", this.option("dropDownOptions"));
            break;
          case "popupPosition":
            break;
          case "deferRendering":
            if (hasWindow()) {
              this._createPopup();
            }
            break;
          case "applyValueMode":
          case "applyButtonText":
          case "cancelButtonText":
          case "buttonsLocation":
            this._setPopupOption("toolbarItems", this._getPopupToolbarItems());
            break;
          case "showPopupTitle":
            this._setPopupOption("showTitle", args.value);
            break;
          case "useHiddenSubmitElement":
            if (this._$submitElement) {
              this._$submitElement.remove();
              this._$submitElement = void 0;
            }
            this._renderSubmitElement();
            break;
          case "rtlEnabled":
            this._updatePopupPosition(args.value);
            this.callBase(args);
            break;
          default:
            this.callBase(args);
        }
      },
      open: function() {
        this.option("opened", true);
      },
      close: function() {
        this.option("opened", false);
      },
      field: function() {
        return getPublicElement(this._input());
      },
      content: function() {
        return this._popup ? this._popup.content() : null;
      }
    });
    component_registrator_default("dxDropDownEditor", DropDownEditor);
    ui_drop_down_editor_default = DropDownEditor;
  }
});

// node_modules/devextreme/esm/ui/calendar/ui.calendar.navigator.js
var CALENDAR_NAVIGATOR_CLASS, CALENDAR_NAVIGATOR_PREVIOUS_MONTH_CLASS, CALENDAR_NAVIGATOR_NEXT_MONTH_CLASS, CALENDAR_NAVIGATOR_PREVIOUS_VIEW_CLASS, CALENDAR_NAVIGATOR_NEXT_VIEW_CLASS, CALENDAR_NAVIGATOR_DISABLED_LINK_CLASS, CALENDAR_NAVIGATOR_CAPTION_BUTTON_CLASS, Navigator, ui_calendar_navigator_default;
var init_ui_calendar_navigator = __esm({
  "node_modules/devextreme/esm/ui/calendar/ui.calendar.navigator.js"() {
    init_renderer();
    init_extend();
    init_ui_widget();
    init_button();
    CALENDAR_NAVIGATOR_CLASS = "dx-calendar-navigator";
    CALENDAR_NAVIGATOR_PREVIOUS_MONTH_CLASS = "dx-calendar-navigator-previous-month";
    CALENDAR_NAVIGATOR_NEXT_MONTH_CLASS = "dx-calendar-navigator-next-month";
    CALENDAR_NAVIGATOR_PREVIOUS_VIEW_CLASS = "dx-calendar-navigator-previous-view";
    CALENDAR_NAVIGATOR_NEXT_VIEW_CLASS = "dx-calendar-navigator-next-view";
    CALENDAR_NAVIGATOR_DISABLED_LINK_CLASS = "dx-calendar-disabled-navigator-link";
    CALENDAR_NAVIGATOR_CAPTION_BUTTON_CLASS = "dx-calendar-caption-button";
    Navigator = ui_widget_default.inherit({
      _getDefaultOptions: function() {
        return extend2(this.callBase(), {
          onClick: null,
          onCaptionClick: null,
          text: ""
        });
      },
      _init: function() {
        this.callBase();
        this._initActions();
      },
      _initActions: function() {
        this._clickAction = this._createActionByOption("onClick");
        this._captionClickAction = this._createActionByOption("onCaptionClick");
      },
      _initMarkup: function() {
        this.callBase();
        this.$element().addClass(CALENDAR_NAVIGATOR_CLASS);
        this._renderButtons();
        this._renderCaption();
      },
      _renderButtons: function() {
        var that = this;
        var direction = this.option("rtlEnabled") ? -1 : 1;
        this._prevButton = this._createComponent(renderer_default("<a>"), button_default, {
          focusStateEnabled: false,
          icon: "chevronleft",
          onClick: function(e) {
            that._clickAction({
              direction: -direction,
              event: e
            });
          },
          integrationOptions: {}
        });
        var $prevButton = this._prevButton.$element().addClass(CALENDAR_NAVIGATOR_PREVIOUS_VIEW_CLASS).addClass(CALENDAR_NAVIGATOR_PREVIOUS_MONTH_CLASS);
        this._nextButton = this._createComponent(renderer_default("<a>"), button_default, {
          focusStateEnabled: false,
          icon: "chevronright",
          onClick: function(e) {
            that._clickAction({
              direction,
              event: e
            });
          },
          integrationOptions: {}
        });
        var $nextButton = this._nextButton.$element().addClass(CALENDAR_NAVIGATOR_NEXT_VIEW_CLASS).addClass(CALENDAR_NAVIGATOR_NEXT_MONTH_CLASS);
        this._caption = this._createComponent(renderer_default("<a>").addClass(CALENDAR_NAVIGATOR_CAPTION_BUTTON_CLASS), button_default, {
          focusStateEnabled: false,
          onClick: function(e) {
            that._captionClickAction({
              event: e
            });
          },
          integrationOptions: {}
        });
        var $caption = this._caption.$element();
        this.$element().append($prevButton, $caption, $nextButton);
      },
      _renderCaption: function() {
        this._caption.option("text", this.option("text"));
      },
      toggleButton: function(buttonPrefix, value2) {
        var buttonName = "_" + buttonPrefix + "Button";
        var button = this[buttonName];
        if (button) {
          button.option("disabled", value2);
          button.$element().toggleClass(CALENDAR_NAVIGATOR_DISABLED_LINK_CLASS, value2);
        }
      },
      _optionChanged: function(args) {
        switch (args.name) {
          case "text":
            this._renderCaption();
            break;
          default:
            this.callBase(args);
        }
      }
    });
    ui_calendar_navigator_default = Navigator;
  }
});

// node_modules/devextreme/esm/ui/calendar/ui.calendar.base_view.js
var abstract8, CALENDAR_OTHER_VIEW_CLASS, CALENDAR_CELL_CLASS, CALENDAR_EMPTY_CELL_CLASS, CALENDAR_TODAY_CLASS, CALENDAR_SELECTED_DATE_CLASS, CALENDAR_CONTOURED_DATE_CLASS, CALENDAR_DXCLICK_EVENT_NAME, CALENDAR_DATE_VALUE_KEY, BaseView, ui_calendar_base_view_default;
var init_ui_calendar_base_view = __esm({
  "node_modules/devextreme/esm/ui/calendar/ui.calendar.base_view.js"() {
    init_renderer();
    init_dom_adapter();
    init_events_engine();
    init_element_data();
    init_element();
    init_ui_widget();
    init_date();
    init_extend();
    init_common();
    init_date_serialization();
    init_message();
    init_utils2();
    init_click();
    ({
      abstract: abstract8
    } = ui_widget_default);
    CALENDAR_OTHER_VIEW_CLASS = "dx-calendar-other-view";
    CALENDAR_CELL_CLASS = "dx-calendar-cell";
    CALENDAR_EMPTY_CELL_CLASS = "dx-calendar-empty-cell";
    CALENDAR_TODAY_CLASS = "dx-calendar-today";
    CALENDAR_SELECTED_DATE_CLASS = "dx-calendar-selected-date";
    CALENDAR_CONTOURED_DATE_CLASS = "dx-calendar-contoured-date";
    CALENDAR_DXCLICK_EVENT_NAME = addNamespace2(CLICK_EVENT_NAME, "dxCalendar");
    CALENDAR_DATE_VALUE_KEY = "dxDateValueKey";
    BaseView = ui_widget_default.inherit({
      _getViewName: function() {
        return "base";
      },
      _getDefaultOptions: function() {
        return extend2(this.callBase(), {
          date: /* @__PURE__ */ new Date(),
          focusStateEnabled: false,
          cellTemplate: null,
          disabledDates: null,
          onCellClick: null,
          rowCount: 3,
          colCount: 4,
          allowValueSelection: true,
          _todayDate: () => /* @__PURE__ */ new Date()
        });
      },
      _initMarkup: function() {
        this.callBase();
        this._renderImpl();
      },
      _renderImpl: function() {
        this.$element().append(this._createTable());
        this._createDisabledDatesHandler();
        this._renderBody();
        this._renderContouredDate();
        this._renderValue();
        this._renderEvents();
      },
      _createTable: function() {
        this._$table = renderer_default("<table>");
        this.setAria({
          label: message_default.format("dxCalendar-ariaWidgetName"),
          role: "grid"
        }, this._$table);
        return this._$table;
      },
      _renderBody: function() {
        this.$body = renderer_default("<tbody>").appendTo(this._$table);
        var rowData = {
          cellDate: this._getFirstCellData(),
          prevCellDate: null
        };
        for (var rowIndex = 0, rowCount = this.option("rowCount"); rowIndex < rowCount; rowIndex++) {
          rowData.row = this._createRow();
          for (var colIndex = 0, colCount = this.option("colCount"); colIndex < colCount; colIndex++) {
            this._renderCell(rowData, colIndex);
          }
        }
      },
      _createRow: function() {
        var row = dom_adapter_default.createElement("tr");
        this.setAria("role", "row", renderer_default(row));
        this.$body.get(0).appendChild(row);
        return row;
      },
      _appendCell: function(row, cell) {
        if (!this._appendMethodName) {
          this._cacheAppendMethodName();
        }
        renderer_default(row)[this._appendMethodName](cell);
      },
      _cacheAppendMethodName: function(rtlEnabled) {
        this._appendMethodName = (null !== rtlEnabled && void 0 !== rtlEnabled ? rtlEnabled : this.option("rtlEnabled")) ? "prepend" : "append";
      },
      _createCell: function(cellDate) {
        var cell = dom_adapter_default.createElement("td");
        var $cell = renderer_default(cell);
        cell.className = this._getClassNameByDate(cellDate);
        cell.setAttribute("data-value", date_serialization_default.serializeDate(cellDate, date_default.getShortDateFormat()));
        data(cell, CALENDAR_DATE_VALUE_KEY, cellDate);
        this.setAria({
          role: "gridcell",
          label: this.getCellAriaLabel(cellDate)
        }, $cell);
        return {
          cell,
          $cell
        };
      },
      _renderCell: function(params, cellIndex) {
        var {
          cellDate,
          prevCellDate,
          row
        } = params;
        if (prevCellDate) {
          date_default.fixTimezoneGap(prevCellDate, cellDate);
        }
        params.prevCellDate = cellDate;
        var {
          cell,
          $cell
        } = this._createCell(cellDate);
        var cellTemplate = this.option("cellTemplate");
        this._appendCell(row, cell);
        if (cellTemplate) {
          cellTemplate.render(this._prepareCellTemplateData(cellDate, cellIndex, $cell));
        } else {
          cell.innerHTML = this._getCellText(cellDate);
        }
        params.cellDate = this._getNextCellData(cellDate);
      },
      _getClassNameByDate: function(cellDate) {
        var className = CALENDAR_CELL_CLASS;
        if (this._isTodayCell(cellDate)) {
          className += " ".concat(CALENDAR_TODAY_CLASS);
        }
        if (this._isDateOutOfRange(cellDate) || this.isDateDisabled(cellDate)) {
          className += " ".concat(CALENDAR_EMPTY_CELL_CLASS);
        }
        if (this._isOtherView(cellDate)) {
          className += " ".concat(CALENDAR_OTHER_VIEW_CLASS);
        }
        return className;
      },
      _prepareCellTemplateData: function(cellDate, cellIndex, $cell) {
        return {
          model: {
            text: this._getCellText(cellDate),
            date: cellDate,
            view: this._getViewName()
          },
          container: getPublicElement($cell),
          index: cellIndex
        };
      },
      _renderEvents: function() {
        this._createCellClickAction();
        events_engine_default.off(this._$table, CALENDAR_DXCLICK_EVENT_NAME);
        events_engine_default.on(this._$table, CALENDAR_DXCLICK_EVENT_NAME, "td", (e) => {
          if (!renderer_default(e.currentTarget).hasClass(CALENDAR_EMPTY_CELL_CLASS)) {
            this._cellClickAction({
              event: e,
              value: renderer_default(e.currentTarget).data(CALENDAR_DATE_VALUE_KEY)
            });
          }
        });
      },
      _createCellClickAction: function() {
        this._cellClickAction = this._createActionByOption("onCellClick");
      },
      _createDisabledDatesHandler: function() {
        var disabledDates = this.option("disabledDates");
        this._disabledDatesHandler = Array.isArray(disabledDates) ? this._getDefaultDisabledDatesHandler(disabledDates) : disabledDates || noop2;
      },
      _getDefaultDisabledDatesHandler: function(disabledDates) {
        return noop2;
      },
      _isTodayCell: abstract8,
      _isDateOutOfRange: abstract8,
      isDateDisabled: function(cellDate) {
        var dateParts = {
          date: cellDate,
          view: this._getViewName()
        };
        return this._disabledDatesHandler(dateParts);
      },
      _isOtherView: abstract8,
      _getCellText: abstract8,
      _getFirstCellData: abstract8,
      _getNextCellData: abstract8,
      _renderContouredDate: function(contouredDate) {
        if (!this.option("focusStateEnabled")) {
          return;
        }
        contouredDate = contouredDate || this.option("contouredDate");
        var $oldContouredCell = this._getContouredCell();
        var $newContouredCell = this._getCellByDate(contouredDate);
        $oldContouredCell.removeClass(CALENDAR_CONTOURED_DATE_CLASS);
        $newContouredCell.addClass(CALENDAR_CONTOURED_DATE_CLASS);
      },
      _getContouredCell: function() {
        return this._$table.find(".".concat(CALENDAR_CONTOURED_DATE_CLASS));
      },
      _changeValue: function(cellDate) {
        if (cellDate) {
          var value2 = this.option("value");
          var newValue = value2 ? new Date(value2) : /* @__PURE__ */ new Date();
          newValue.setDate(cellDate.getDate());
          newValue.setMonth(cellDate.getMonth());
          newValue.setFullYear(cellDate.getFullYear());
          newValue.setDate(cellDate.getDate());
          this.option("value", newValue);
        } else {
          this.option("value", null);
        }
      },
      _renderValue: function() {
        if (!this.option("allowValueSelection")) {
          return;
        }
        var value2 = this.option("value");
        var selectedCell = this._getCellByDate(value2);
        if (this._selectedCell) {
          this._selectedCell.removeClass(CALENDAR_SELECTED_DATE_CLASS);
        }
        selectedCell.addClass(CALENDAR_SELECTED_DATE_CLASS);
        this._selectedCell = selectedCell;
      },
      getCellAriaLabel: function(date) {
        return this._getCellText(date);
      },
      _getFirstAvailableDate: function() {
        var date = this.option("date");
        var min = this.option("min");
        date = date_default.getFirstDateView(this._getViewName(), date);
        return new Date(min && date < min ? min : date);
      },
      _getCellByDate: abstract8,
      isBoundary: abstract8,
      _optionChanged: function(args) {
        var {
          name: name2,
          value: value2
        } = args;
        switch (name2) {
          case "value":
            this._renderValue();
            break;
          case "contouredDate":
            this._renderContouredDate(value2);
            break;
          case "onCellClick":
            this._createCellClickAction();
            break;
          case "disabledDates":
          case "cellTemplate":
            this._invalidate();
            break;
          case "rtlEnabled":
            this._cacheAppendMethodName(value2);
            this.callBase(args);
            break;
          case "_todayDate":
            this._renderBody();
            break;
          default:
            this.callBase(args);
        }
      }
    });
    ui_calendar_base_view_default = BaseView;
  }
});

// node_modules/devextreme/esm/ui/calendar/ui.calendar.views.js
var CALENDAR_OTHER_MONTH_CLASS, CALENDAR_OTHER_VIEW_CLASS2, Views, ui_calendar_views_default;
var init_ui_calendar_views = __esm({
  "node_modules/devextreme/esm/ui/calendar/ui.calendar.views.js"() {
    init_renderer();
    init_ui_calendar_base_view();
    init_common();
    init_date();
    init_extend();
    init_date3();
    init_date_serialization();
    init_type();
    CALENDAR_OTHER_MONTH_CLASS = "dx-calendar-other-month";
    CALENDAR_OTHER_VIEW_CLASS2 = "dx-calendar-other-view";
    Views = {
      month: ui_calendar_base_view_default.inherit({
        _getViewName: function() {
          return "month";
        },
        _getDefaultOptions: function() {
          return extend2(this.callBase(), {
            firstDayOfWeek: void 0,
            rowCount: 6,
            colCount: 7
          });
        },
        _renderImpl: function() {
          this.callBase();
          this._renderHeader();
        },
        _renderBody: function() {
          this.callBase();
          this._$table.find(".".concat(CALENDAR_OTHER_VIEW_CLASS2)).addClass(CALENDAR_OTHER_MONTH_CLASS);
        },
        _renderFocusTarget: noop2,
        getCellAriaLabel: function(date) {
          return date_default3.format(date, "longdate");
        },
        _renderHeader: function() {
          var $headerRow = renderer_default("<tr>");
          var $header = renderer_default("<thead>").append($headerRow);
          this._$table.prepend($header);
          for (var colIndex = 0, colCount = this.option("colCount"); colIndex < colCount; colIndex++) {
            this._renderHeaderCell(colIndex, $headerRow);
          }
        },
        _renderHeaderCell: function(cellIndex, $headerRow) {
          var {
            full: fullCaption,
            abbreviated: abbrCaption
          } = this._getDayCaption(this._getFirstDayOfWeek() + cellIndex);
          var $cell = renderer_default("<th>").attr({
            scope: "col",
            abbr: fullCaption
          }).text(abbrCaption);
          this._appendCell($headerRow, $cell);
        },
        getNavigatorCaption: function() {
          return date_default3.format(this.option("date"), "monthandyear");
        },
        _isTodayCell: function(cellDate) {
          var today = this.option("_todayDate")();
          return date_default.sameDate(cellDate, today);
        },
        _isDateOutOfRange: function(cellDate) {
          var minDate = this.option("min");
          var maxDate = this.option("max");
          return !date_default.dateInRange(cellDate, minDate, maxDate, "date");
        },
        _isOtherView: function(cellDate) {
          return cellDate.getMonth() !== this.option("date").getMonth();
        },
        _getCellText: function(cellDate) {
          return date_default3.format(cellDate, "d");
        },
        _getDayCaption: function(day) {
          var daysInWeek = this.option("colCount");
          var dayIndex = day % daysInWeek;
          return {
            full: date_default3.getDayNames()[dayIndex],
            abbreviated: date_default3.getDayNames("abbreviated")[dayIndex]
          };
        },
        _getFirstCellData: function() {
          var firstDay = date_default.getFirstMonthDate(this.option("date"));
          var firstMonthDayOffset = this._getFirstDayOfWeek() - firstDay.getDay();
          var daysInWeek = this.option("colCount");
          if (firstMonthDayOffset >= 0) {
            firstMonthDayOffset -= daysInWeek;
          }
          firstDay.setDate(firstDay.getDate() + firstMonthDayOffset);
          return firstDay;
        },
        _getNextCellData: function(date) {
          date = date_default.createDate(date);
          date.setDate(date.getDate() + 1);
          return date;
        },
        _getFirstDayOfWeek: function() {
          return isDefined(this.option("firstDayOfWeek")) ? this.option("firstDayOfWeek") : date_default3.firstDayOfWeekIndex();
        },
        _getCellByDate: function(date) {
          return this._$table.find("td[data-value='".concat(date_serialization_default.serializeDate(date, date_default.getShortDateFormat()), "']"));
        },
        isBoundary: function(date) {
          return date_default.sameMonthAndYear(date, this.option("min")) || date_default.sameMonthAndYear(date, this.option("max"));
        },
        _getDefaultDisabledDatesHandler: function(disabledDates) {
          return function(args) {
            var isDisabledDate = disabledDates.some(function(item) {
              return date_default.sameDate(item, args.date);
            });
            if (isDisabledDate) {
              return true;
            }
          };
        }
      }),
      year: ui_calendar_base_view_default.inherit({
        _getViewName: function() {
          return "year";
        },
        _isTodayCell: function(cellDate) {
          var today = this.option("_todayDate")();
          return date_default.sameMonthAndYear(cellDate, today);
        },
        _isDateOutOfRange: function(cellDate) {
          return !date_default.dateInRange(cellDate, date_default.getFirstMonthDate(this.option("min")), date_default.getLastMonthDate(this.option("max")));
        },
        _isOtherView: function() {
          return false;
        },
        _getCellText: function(cellDate) {
          return date_default3.getMonthNames("abbreviated")[cellDate.getMonth()];
        },
        _getFirstCellData: function() {
          var currentDate = this.option("date");
          var data2 = date_default.createDate(currentDate);
          data2.setDate(1);
          data2.setMonth(0);
          return data2;
        },
        _getNextCellData: function(date) {
          date = date_default.createDate(date);
          date.setMonth(date.getMonth() + 1);
          return date;
        },
        _getCellByDate: function(date) {
          var foundDate = date_default.createDate(date);
          foundDate.setDate(1);
          return this._$table.find("td[data-value='".concat(date_serialization_default.serializeDate(foundDate, date_default.getShortDateFormat()), "']"));
        },
        getCellAriaLabel: function(date) {
          return date_default3.format(date, "monthandyear");
        },
        getNavigatorCaption: function() {
          return date_default3.format(this.option("date"), "yyyy");
        },
        isBoundary: function(date) {
          return date_default.sameYear(date, this.option("min")) || date_default.sameYear(date, this.option("max"));
        }
      }),
      decade: ui_calendar_base_view_default.inherit({
        _getViewName: function() {
          return "decade";
        },
        _isTodayCell: function(cellDate) {
          var today = this.option("_todayDate")();
          return date_default.sameYear(cellDate, today);
        },
        _isDateOutOfRange: function(cellDate) {
          var min = this.option("min");
          var max = this.option("max");
          return !date_default.dateInRange(cellDate.getFullYear(), min && min.getFullYear(), max && max.getFullYear());
        },
        _isOtherView: function(cellDate) {
          var date = date_default.createDate(cellDate);
          date.setMonth(1);
          return !date_default.sameDecade(date, this.option("date"));
        },
        _getCellText: function(cellDate) {
          return date_default3.format(cellDate, "yyyy");
        },
        _getFirstCellData: function() {
          var year = date_default.getFirstYearInDecade(this.option("date")) - 1;
          return date_default.createDateWithFullYear(year, 0, 1);
        },
        _getNextCellData: function(date) {
          date = date_default.createDate(date);
          date.setFullYear(date.getFullYear() + 1);
          return date;
        },
        getNavigatorCaption: function() {
          var currentDate = this.option("date");
          var firstYearInDecade = date_default.getFirstYearInDecade(currentDate);
          var startDate = date_default.createDate(currentDate);
          var endDate = date_default.createDate(currentDate);
          startDate.setFullYear(firstYearInDecade);
          endDate.setFullYear(firstYearInDecade + 9);
          return date_default3.format(startDate, "yyyy") + "-" + date_default3.format(endDate, "yyyy");
        },
        _isValueOnCurrentView: function(currentDate, value2) {
          return date_default.sameDecade(currentDate, value2);
        },
        _getCellByDate: function(date) {
          var foundDate = date_default.createDate(date);
          foundDate.setDate(1);
          foundDate.setMonth(0);
          return this._$table.find("td[data-value='".concat(date_serialization_default.serializeDate(foundDate, date_default.getShortDateFormat()), "']"));
        },
        isBoundary: function(date) {
          return date_default.sameDecade(date, this.option("min")) || date_default.sameDecade(date, this.option("max"));
        }
      }),
      century: ui_calendar_base_view_default.inherit({
        _getViewName: function() {
          return "century";
        },
        _isTodayCell: function(cellDate) {
          var today = this.option("_todayDate")();
          return date_default.sameDecade(cellDate, today);
        },
        _isDateOutOfRange: function(cellDate) {
          var decade = date_default.getFirstYearInDecade(cellDate);
          var minDecade = date_default.getFirstYearInDecade(this.option("min"));
          var maxDecade = date_default.getFirstYearInDecade(this.option("max"));
          return !date_default.dateInRange(decade, minDecade, maxDecade);
        },
        _isOtherView: function(cellDate) {
          var date = date_default.createDate(cellDate);
          date.setMonth(1);
          return !date_default.sameCentury(date, this.option("date"));
        },
        _getCellText: function(cellDate) {
          var startDate = date_default3.format(cellDate, "yyyy");
          var endDate = date_default.createDate(cellDate);
          endDate.setFullYear(endDate.getFullYear() + 9);
          return startDate + " - " + date_default3.format(endDate, "yyyy");
        },
        _getFirstCellData: function() {
          var decade = date_default.getFirstDecadeInCentury(this.option("date")) - 10;
          return date_default.createDateWithFullYear(decade, 0, 1);
        },
        _getNextCellData: function(date) {
          date = date_default.createDate(date);
          date.setFullYear(date.getFullYear() + 10);
          return date;
        },
        _getCellByDate: function(date) {
          var foundDate = date_default.createDate(date);
          foundDate.setDate(1);
          foundDate.setMonth(0);
          foundDate.setFullYear(date_default.getFirstYearInDecade(foundDate));
          return this._$table.find("td[data-value='".concat(date_serialization_default.serializeDate(foundDate, date_default.getShortDateFormat()), "']"));
        },
        getNavigatorCaption: function() {
          var currentDate = this.option("date");
          var firstDecadeInCentury = date_default.getFirstDecadeInCentury(currentDate);
          var startDate = date_default.createDate(currentDate);
          var endDate = date_default.createDate(currentDate);
          startDate.setFullYear(firstDecadeInCentury);
          endDate.setFullYear(firstDecadeInCentury + 99);
          return date_default3.format(startDate, "yyyy") + "-" + date_default3.format(endDate, "yyyy");
        },
        isBoundary: function(date) {
          return date_default.sameCentury(date, this.option("min")) || date_default.sameCentury(date, this.option("max"));
        }
      })
    };
    ui_calendar_views_default = Views;
  }
});

// node_modules/devextreme/esm/ui/calendar/ui.calendar.js
var CALENDAR_CLASS, CALENDAR_BODY_CLASS, CALENDAR_CELL_CLASS2, CALENDAR_FOOTER_CLASS, CALENDAR_TODAY_BUTTON_CLASS, CALENDAR_HAS_FOOTER_CLASS, CALENDAR_VIEWS_WRAPPER_CLASS, CALENDAR_VIEW_CLASS, FOCUSED_STATE_CLASS2, ANIMATION_DURATION_SHOW_VIEW, POP_ANIMATION_FROM, POP_ANIMATION_TO, CALENDAR_INPUT_STANDARD_PATTERN, CALENDAR_DATE_VALUE_KEY2, LEVEL_COMPARE_MAP, ZOOM_LEVEL, isIE114, Calendar, ui_calendar_default;
var init_ui_calendar = __esm({
  "node_modules/devextreme/esm/ui/calendar/ui.calendar.js"() {
    init_renderer();
    init_guid();
    init_component_registrator();
    init_common();
    init_type();
    init_math();
    init_extend();
    init_button();
    init_editor();
    init_swipeable();
    init_ui_calendar_navigator();
    init_ui_calendar_views();
    init_translator();
    init_browser();
    init_date();
    init_date_serialization();
    init_devices();
    init_fx();
    init_window();
    init_message();
    init_function_template();
    init_utils2();
    CALENDAR_CLASS = "dx-calendar";
    CALENDAR_BODY_CLASS = "dx-calendar-body";
    CALENDAR_CELL_CLASS2 = "dx-calendar-cell";
    CALENDAR_FOOTER_CLASS = "dx-calendar-footer";
    CALENDAR_TODAY_BUTTON_CLASS = "dx-calendar-today-button";
    CALENDAR_HAS_FOOTER_CLASS = "dx-calendar-with-footer";
    CALENDAR_VIEWS_WRAPPER_CLASS = "dx-calendar-views-wrapper";
    CALENDAR_VIEW_CLASS = "dx-calendar-view";
    FOCUSED_STATE_CLASS2 = "dx-state-focused";
    ANIMATION_DURATION_SHOW_VIEW = 250;
    POP_ANIMATION_FROM = 0.6;
    POP_ANIMATION_TO = 1;
    CALENDAR_INPUT_STANDARD_PATTERN = "yyyy-MM-dd";
    CALENDAR_DATE_VALUE_KEY2 = "dxDateValueKey";
    LEVEL_COMPARE_MAP = {
      month: 3,
      year: 2,
      decade: 1,
      century: 0
    };
    ZOOM_LEVEL = {
      MONTH: "month",
      YEAR: "year",
      DECADE: "decade",
      CENTURY: "century"
    };
    isIE114 = browser_default.msie && parseInt(browser_default.version) <= 11;
    Calendar = editor_default.inherit({
      _activeStateUnit: "." + CALENDAR_CELL_CLASS2,
      _getDefaultOptions: function() {
        return extend2(this.callBase(), {
          hoverStateEnabled: true,
          activeStateEnabled: true,
          currentDate: /* @__PURE__ */ new Date(),
          value: null,
          dateSerializationFormat: void 0,
          min: new Date(1e3, 0),
          max: new Date(3e3, 0),
          firstDayOfWeek: void 0,
          zoomLevel: ZOOM_LEVEL.MONTH,
          maxZoomLevel: ZOOM_LEVEL.MONTH,
          minZoomLevel: ZOOM_LEVEL.CENTURY,
          showTodayButton: false,
          cellTemplate: "cell",
          disabledDates: null,
          onCellClick: null,
          onContouredChanged: null,
          hasFocus: function(element) {
            return element.hasClass(FOCUSED_STATE_CLASS2);
          },
          _todayDate: () => /* @__PURE__ */ new Date()
        });
      },
      _defaultOptionsRules: function() {
        return this.callBase().concat([{
          device: function() {
            return "desktop" === devices_default.real().deviceType && !devices_default.isSimulator();
          },
          options: {
            focusStateEnabled: true
          }
        }]);
      },
      _supportedKeys: function() {
        return extend2(this.callBase(), {
          rightArrow: function(e) {
            e.preventDefault();
            if (isCommandKeyPressed(e)) {
              this._waitRenderView(1);
            } else {
              this._moveCurrentDateByOffset(1 * this._getRtlCorrection());
            }
          },
          leftArrow: function(e) {
            e.preventDefault();
            if (isCommandKeyPressed(e)) {
              this._waitRenderView(-1);
            } else {
              this._moveCurrentDateByOffset(-1 * this._getRtlCorrection());
            }
          },
          upArrow: function(e) {
            e.preventDefault();
            if (isCommandKeyPressed(e)) {
              this._navigateUp();
            } else {
              if (fx_default.isAnimating(this._view.$element())) {
                return;
              }
              this._moveCurrentDateByOffset(-1 * this._view.option("colCount"));
            }
          },
          downArrow: function(e) {
            e.preventDefault();
            if (isCommandKeyPressed(e)) {
              this._navigateDown();
            } else {
              if (fx_default.isAnimating(this._view.$element())) {
                return;
              }
              this._moveCurrentDateByOffset(1 * this._view.option("colCount"));
            }
          },
          home: function(e) {
            e.preventDefault();
            var zoomLevel = this.option("zoomLevel");
            var currentDate = this.option("currentDate");
            var min = this._dateOption("min");
            if (this._view.isDateDisabled(currentDate)) {
              return;
            }
            var date = date_default.sameView(zoomLevel, currentDate, min) ? min : date_default.getViewFirstCellDate(zoomLevel, currentDate);
            this._moveToClosestAvailableDate(date);
          },
          end: function(e) {
            e.preventDefault();
            var zoomLevel = this.option("zoomLevel");
            var currentDate = this.option("currentDate");
            var max = this._dateOption("max");
            if (this._view.isDateDisabled(currentDate)) {
              return;
            }
            var date = date_default.sameView(zoomLevel, currentDate, max) ? max : date_default.getViewLastCellDate(zoomLevel, currentDate);
            this._moveToClosestAvailableDate(date);
          },
          pageUp: function(e) {
            e.preventDefault();
            this._waitRenderView(-1 * this._getRtlCorrection());
          },
          pageDown: function(e) {
            e.preventDefault();
            this._waitRenderView(1 * this._getRtlCorrection());
          },
          tab: noop2,
          enter: function(e) {
            if (!this._isMaxZoomLevel()) {
              this._navigateDown();
            } else if (!this._view.isDateDisabled(this.option("currentDate"))) {
              var value2 = this._updateTimeComponent(this.option("currentDate"));
              this._dateValue(value2, e);
            }
          }
        });
      },
      _getSerializationFormat: function(optionName) {
        var value2 = this.option(optionName || "value");
        if (this.option("dateSerializationFormat")) {
          return this.option("dateSerializationFormat");
        }
        if (isNumeric(value2)) {
          return "number";
        }
        if (!isString2(value2)) {
          return;
        }
        return date_serialization_default.getDateSerializationFormat(value2);
      },
      _convertToDate: function(value2, optionName) {
        return date_serialization_default.deserializeDate(value2);
      },
      _dateValue: function(value2, event) {
        if (event) {
          if ("keydown" === event.type) {
            var cellElement = this._view._getContouredCell().get(0);
            event.target = cellElement;
          }
          this._saveValueChangeEvent(event);
        }
        this._dateOption("value", value2);
      },
      _dateOption: function(optionName, optionValue) {
        if (1 === arguments.length) {
          return this._convertToDate(this.option(optionName), optionName);
        }
        var serializationFormat = this._getSerializationFormat(optionName);
        this.option(optionName, date_serialization_default.serializeDate(optionValue, serializationFormat));
      },
      _shiftDate: function(zoomLevel, date, offset2, reverse) {
        switch (zoomLevel) {
          case ZOOM_LEVEL.MONTH:
            date.setDate(date.getDate() + offset2 * reverse);
            break;
          case ZOOM_LEVEL.YEAR:
            date.setMonth(date.getMonth() + offset2 * reverse);
            break;
          case ZOOM_LEVEL.DECADE:
            date.setFullYear(date.getFullYear() + offset2 * reverse);
            break;
          case ZOOM_LEVEL.CENTURY:
            date.setFullYear(date.getFullYear() + 10 * offset2 * reverse);
        }
      },
      _moveCurrentDateByOffset: function(offset2) {
        var baseDate = this.option("currentDate");
        var currentDate = new Date(baseDate);
        var zoomLevel = this.option("zoomLevel");
        this._shiftDate(zoomLevel, currentDate, offset2, 1);
        var maxDate = this._getMaxDate();
        var minDate = this._getMinDate();
        var isDateForwardInNeighborView = this._areDatesInNeighborView(zoomLevel, currentDate, baseDate);
        var isDateForwardInRange = inRange(currentDate, minDate, maxDate) && isDateForwardInNeighborView;
        var dateForward = new Date(currentDate);
        while (isDateForwardInRange) {
          if (!this._view.isDateDisabled(dateForward)) {
            currentDate = dateForward;
            break;
          }
          this._shiftDate(zoomLevel, dateForward, offset2, 1);
          isDateForwardInNeighborView = this._areDatesInNeighborView(zoomLevel, dateForward, baseDate);
          isDateForwardInRange = inRange(dateForward, minDate, maxDate) && isDateForwardInNeighborView;
        }
        if (this._view.isDateDisabled(baseDate) || this._view.isDateDisabled(currentDate)) {
          this._waitRenderView(offset2 > 0 ? 1 : -1);
        } else {
          this.option("currentDate", currentDate);
        }
      },
      _areDatesInSameView(zoomLevel, date1, date2) {
        switch (zoomLevel) {
          case ZOOM_LEVEL.MONTH:
            return date1.getMonth() === date2.getMonth();
          case ZOOM_LEVEL.YEAR:
            return date1.getYear() === date2.getYear();
          case ZOOM_LEVEL.DECADE:
            return parseInt(date1.getYear() / 10) === parseInt(date2.getYear() / 10);
          case ZOOM_LEVEL.CENTURY:
            return parseInt(date1.getYear() / 100) === parseInt(date2.getYear() / 100);
        }
      },
      _areDatesInNeighborView(zoomLevel, date1, date2) {
        switch (zoomLevel) {
          case ZOOM_LEVEL.MONTH:
            return (a = date1.getMonth(), b = date2.getMonth(), abs4 = Math.abs(a - b), Math.min(abs4, 12 - abs4)) <= 1;
          case ZOOM_LEVEL.YEAR:
            return Math.abs(date1.getYear() - date2.getYear()) <= 1;
          case ZOOM_LEVEL.DECADE:
            return Math.abs(date1.getYear() - date2.getYear()) <= 10;
          case ZOOM_LEVEL.CENTURY:
            return Math.abs(date1.getYear() - date2.getYear()) <= 100;
        }
        var a, b, abs4;
      },
      _moveToClosestAvailableDate: function() {
        var baseDate = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.option("currentDate");
        var currentDate = date_default.createDate(baseDate);
        var zoomLevel = this.option("zoomLevel");
        var isCurrentDateAvailable = !this._isDateNotAvailable(currentDate);
        var isDateForwardAvailable = isCurrentDateAvailable;
        var isDateBackwardAvailable = isCurrentDateAvailable;
        var isDateForwardInStartView;
        var isDateBackwardInStartView;
        var dateForward = date_default.createDate(currentDate);
        var dateBackward = date_default.createDate(currentDate);
        do {
          if (isDateForwardAvailable) {
            currentDate = dateForward;
            break;
          }
          if (isDateBackwardAvailable) {
            currentDate = dateBackward;
            break;
          }
          this._shiftDate(zoomLevel, dateForward, 1, 1);
          this._shiftDate(zoomLevel, dateBackward, 1, -1);
          isDateForwardInStartView = this._areDatesInSameView(zoomLevel, dateForward, baseDate);
          isDateBackwardInStartView = this._areDatesInSameView(zoomLevel, dateBackward, baseDate);
          isDateForwardAvailable = isDateForwardInStartView && !this._isDateNotAvailable(dateForward);
          isDateBackwardAvailable = isDateBackwardInStartView && !this._isDateNotAvailable(dateBackward);
        } while (isDateForwardInStartView || isDateBackwardInStartView);
        this.option("currentDate", currentDate);
      },
      _isDateNotAvailable: function(date) {
        var maxDate = this._getMaxDate();
        var minDate = this._getMinDate();
        return !inRange(date, minDate, maxDate) || this._view.isDateDisabled(date);
      },
      _init: function() {
        this.callBase();
        this._correctZoomLevel();
        this._initCurrentDate();
        this._initActions();
      },
      _correctZoomLevel: function() {
        var minZoomLevel = this.option("minZoomLevel");
        var maxZoomLevel = this.option("maxZoomLevel");
        var zoomLevel = this.option("zoomLevel");
        if (LEVEL_COMPARE_MAP[maxZoomLevel] < LEVEL_COMPARE_MAP[minZoomLevel]) {
          return;
        }
        if (LEVEL_COMPARE_MAP[zoomLevel] > LEVEL_COMPARE_MAP[maxZoomLevel]) {
          this.option("zoomLevel", maxZoomLevel);
        } else if (LEVEL_COMPARE_MAP[zoomLevel] < LEVEL_COMPARE_MAP[minZoomLevel]) {
          this.option("zoomLevel", minZoomLevel);
        }
      },
      _initCurrentDate: function() {
        var currentDate = this._getNormalizedDate(this._dateOption("value")) || this._getNormalizedDate(this.option("currentDate"));
        this.option("currentDate", currentDate);
      },
      _getNormalizedDate: function(date) {
        date = date_default.normalizeDate(date, this._getMinDate(), this._getMaxDate());
        return isDefined(date) ? this._getDate(date) : date;
      },
      _initActions: function() {
        this._cellClickAction = this._createActionByOption("onCellClick");
        this._onContouredChanged = this._createActionByOption("onContouredChanged");
      },
      _initTemplates: function() {
        this._templateManager.addDefaultTemplates({
          cell: new FunctionTemplate(function(options2) {
            var data2 = options2.model;
            renderer_default(options2.container).append(renderer_default("<span>").text(data2 && data2.text || String(data2)));
          })
        });
        this.callBase();
      },
      _updateCurrentDate: function(date) {
        if (fx_default.isAnimating(this._$viewsWrapper)) {
          fx_default.stop(this._$viewsWrapper, true);
        }
        var min = this._getMinDate();
        var max = this._getMaxDate();
        if (min > max) {
          this.option("currentDate", /* @__PURE__ */ new Date());
          return;
        }
        var normalizedDate = this._getNormalizedDate(date);
        if (date.getTime() !== normalizedDate.getTime()) {
          this.option("currentDate", date_default.createDate(normalizedDate));
          return;
        }
        var offset2 = this._getViewsOffset(this._view.option("date"), normalizedDate);
        if (0 !== offset2 && !this._isMaxZoomLevel() && this._isOtherViewCellClicked) {
          offset2 = 0;
        }
        if (this._view && 0 !== offset2 && !this._suppressNavigation) {
          this._navigate(offset2, normalizedDate);
        } else {
          this._renderNavigator();
          this._setViewContoured(normalizedDate);
          this._updateAriaId(normalizedDate);
        }
      },
      _setViewContoured: function(date) {
        if (this.option("hasFocus")(this._focusTarget())) {
          this._view.option("contouredDate", date);
        }
      },
      _getMinDate: function() {
        if (this.min) {
          return this.min;
        }
        this.min = this._dateOption("min") || new Date(1e3, 0);
        return this.min;
      },
      _getMaxDate: function() {
        if (this.max) {
          return this.max;
        }
        this.max = this._dateOption("max") || new Date(3e3, 0);
        return this.max;
      },
      _getViewsOffset: function(startDate, endDate) {
        var zoomLevel = this.option("zoomLevel");
        if (zoomLevel === ZOOM_LEVEL.MONTH) {
          return this._getMonthsOffset(startDate, endDate);
        }
        var zoomCorrection;
        switch (zoomLevel) {
          case ZOOM_LEVEL.CENTURY:
            zoomCorrection = 100;
            break;
          case ZOOM_LEVEL.DECADE:
            zoomCorrection = 10;
            break;
          default:
            zoomCorrection = 1;
        }
        return parseInt(endDate.getFullYear() / zoomCorrection) - parseInt(startDate.getFullYear() / zoomCorrection);
      },
      _getMonthsOffset: function(startDate, endDate) {
        var yearOffset = endDate.getFullYear() - startDate.getFullYear();
        var monthOffset = endDate.getMonth() - startDate.getMonth();
        return 12 * yearOffset + monthOffset;
      },
      _waitRenderView: function(offset2) {
        if (this._alreadyViewRender) {
          return;
        }
        this._alreadyViewRender = true;
        var date = this._getDateByOffset(offset2 * this._getRtlCorrection());
        this._moveToClosestAvailableDate(date);
        this._waitRenderViewTimeout = setTimeout(() => {
          this._alreadyViewRender = false;
        });
      },
      _getRtlCorrection: function() {
        return this.option("rtlEnabled") ? -1 : 1;
      },
      _getDateByOffset: function(offset2, date) {
        var _date;
        date = this._getDate(null !== (_date = date) && void 0 !== _date ? _date : this.option("currentDate"));
        var currentDay = date.getDate();
        var difference = date_default.getDifferenceInMonth(this.option("zoomLevel")) * offset2;
        date.setDate(1);
        date.setMonth(date.getMonth() + difference);
        var lastDay = date_default.getLastMonthDate(date).getDate();
        date.setDate(currentDay > lastDay ? lastDay : currentDay);
        return date;
      },
      _focusTarget: function() {
        return this.$element();
      },
      _initMarkup: function() {
        this._renderSubmitElement();
        this.callBase();
        var $element = this.$element();
        $element.addClass(CALENDAR_CLASS);
        this._renderBody();
        $element.append(this.$body);
        this._renderViews();
        this._renderNavigator();
        $element.append(this._navigator.$element());
        this._renderSwipeable();
        this._renderFooter();
        this._updateAriaSelected();
        this._updateAriaId();
        this._moveToClosestAvailableDate();
      },
      _render: function() {
        this.callBase();
        this._setViewContoured(this.option("currentDate"));
      },
      _renderBody: function() {
        if (!this._$viewsWrapper) {
          this.$body = renderer_default("<div>").addClass(CALENDAR_BODY_CLASS);
          this._$viewsWrapper = renderer_default("<div>").addClass(CALENDAR_VIEWS_WRAPPER_CLASS);
          this.$body.append(this._$viewsWrapper);
        }
      },
      _getKeyboardListeners() {
        return this.callBase().concat([this._view]);
      },
      _renderViews: function() {
        this.$element().addClass(CALENDAR_VIEW_CLASS + "-" + this.option("zoomLevel"));
        var currentDate = this.option("currentDate");
        this._view = this._renderSpecificView(currentDate);
        if (hasWindow()) {
          var beforeDate = this._getDateByOffset(-1, currentDate);
          this._beforeView = this._isViewAvailable(beforeDate) ? this._renderSpecificView(beforeDate) : null;
          var afterDate = this._getDateByOffset(1, currentDate);
          afterDate.setDate(1);
          this._afterView = this._isViewAvailable(afterDate) ? this._renderSpecificView(afterDate) : null;
        }
        this._translateViews();
      },
      _renderSpecificView: function(date) {
        var specificView = ui_calendar_views_default[this.option("zoomLevel")];
        var $view = renderer_default("<div>").appendTo(this._$viewsWrapper);
        var config2 = this._viewConfig(date);
        return this._createComponent($view, specificView, config2);
      },
      _viewConfig: function(date) {
        var disabledDates = this.option("disabledDates");
        disabledDates = isFunction(disabledDates) ? this._injectComponent(disabledDates.bind(this)) : disabledDates;
        return {
          date,
          min: this._getMinDate(),
          max: this._getMaxDate(),
          firstDayOfWeek: this.option("firstDayOfWeek"),
          value: this._dateOption("value"),
          tabIndex: void 0,
          focusStateEnabled: this.option("focusStateEnabled"),
          hoverStateEnabled: this.option("hoverStateEnabled"),
          disabledDates,
          onCellClick: this._cellClickHandler.bind(this),
          cellTemplate: this._getTemplateByOption("cellTemplate"),
          allowValueSelection: this._isMaxZoomLevel(),
          _todayDate: this.option("_todayDate")
        };
      },
      _injectComponent: function(func) {
        var that = this;
        return function(params) {
          extend2(params, {
            component: that
          });
          return func(params);
        };
      },
      _isViewAvailable: function(date) {
        var zoomLevel = this.option("zoomLevel");
        var min = date_default.getViewMinBoundaryDate(zoomLevel, this._getMinDate());
        var max = date_default.getViewMaxBoundaryDate(zoomLevel, this._getMaxDate());
        return date_default.dateInRange(date, min, max);
      },
      _translateViews: function() {
        move(this._view.$element(), {
          left: 0,
          top: 0
        });
        this._beforeView && move(this._beforeView.$element(), {
          left: this._getViewPosition(-1),
          top: 0
        });
        this._afterView && move(this._afterView.$element(), {
          left: this._getViewPosition(1),
          top: 0
        });
      },
      _getViewPosition: function(coefficient) {
        var rtlCorrection = this.option("rtlEnabled") && !browser_default.msie ? -1 : 1;
        return 100 * coefficient * rtlCorrection + "%";
      },
      _cellClickHandler: function(e) {
        var zoomLevel = this.option("zoomLevel");
        var nextView = date_default.getViewDown(zoomLevel);
        var isMaxZoomLevel = this._isMaxZoomLevel();
        if (nextView && !isMaxZoomLevel) {
          this._navigateDown(e.event.currentTarget);
        } else {
          var newValue = this._updateTimeComponent(e.value);
          this._dateValue(newValue, e.event);
          this._cellClickAction(e);
        }
      },
      _updateTimeComponent: function(date) {
        var result2 = date_default.createDate(date);
        var currentValue = this._dateOption("value");
        if (currentValue) {
          result2.setHours(currentValue.getHours());
          result2.setMinutes(currentValue.getMinutes());
          result2.setSeconds(currentValue.getSeconds());
          result2.setMilliseconds(currentValue.getMilliseconds());
        }
        return result2;
      },
      _isMaxZoomLevel: function() {
        return this.option("zoomLevel") === this.option("maxZoomLevel");
      },
      _navigateDown: function(cell) {
        var zoomLevel = this.option("zoomLevel");
        if (this._isMaxZoomLevel()) {
          return;
        }
        var nextView = date_default.getViewDown(zoomLevel);
        if (!nextView) {
          return;
        }
        var newCurrentDate = this._view.option("contouredDate") || this._view.option("date");
        if (cell) {
          newCurrentDate = renderer_default(cell).data(CALENDAR_DATE_VALUE_KEY2);
        }
        this._isOtherViewCellClicked = true;
        this.option("currentDate", newCurrentDate);
        this.option("zoomLevel", nextView);
        this._isOtherViewCellClicked = false;
        this._renderNavigator();
        this._animateShowView();
        this._moveToClosestAvailableDate();
        this._setViewContoured(this._getNormalizedDate(this.option("currentDate")));
      },
      _renderNavigator: function() {
        if (!this._navigator) {
          this._navigator = new ui_calendar_navigator_default(renderer_default("<div>"), this._navigatorConfig());
        }
        this._navigator.option("text", this._view.getNavigatorCaption());
        this._updateButtonsVisibility();
      },
      _navigatorConfig: function() {
        return {
          text: this._view.getNavigatorCaption(),
          onClick: this._navigatorClickHandler.bind(this),
          onCaptionClick: this._navigateUp.bind(this),
          rtlEnabled: this.option("rtlEnabled")
        };
      },
      _navigatorClickHandler: function(e) {
        var currentDate = this._getDateByOffset(e.direction, this.option("currentDate"));
        this._moveToClosestAvailableDate(currentDate);
      },
      _navigateUp: function() {
        var zoomLevel = this.option("zoomLevel");
        var nextView = date_default.getViewUp(zoomLevel);
        if (!nextView || this._isMinZoomLevel(zoomLevel)) {
          return;
        }
        this.option("zoomLevel", nextView);
        this._renderNavigator();
        this._animateShowView();
        this._moveToClosestAvailableDate();
        this._setViewContoured(this._getNormalizedDate(this.option("currentDate")));
      },
      _isMinZoomLevel: function(zoomLevel) {
        var min = this._getMinDate();
        var max = this._getMaxDate();
        return date_default.sameView(zoomLevel, min, max) || this.option("minZoomLevel") === zoomLevel;
      },
      _updateButtonsVisibility: function() {
        this._navigator.toggleButton("next", !isDefined(this._getRequiredView("next")));
        this._navigator.toggleButton("prev", !isDefined(this._getRequiredView("prev")));
      },
      _renderSwipeable: function() {
        if (!this._swipeable) {
          this._swipeable = this._createComponent(this.$element(), swipeable_default, {
            onStart: this._swipeStartHandler.bind(this),
            onUpdated: this._swipeUpdateHandler.bind(this),
            onEnd: this._swipeEndHandler.bind(this),
            itemSizeFunc: this._viewWidth.bind(this)
          });
        }
      },
      _swipeStartHandler: function(e) {
        fx_default.stop(this._$viewsWrapper, true);
        e.event.maxLeftOffset = this._getRequiredView("next") ? 1 : 0;
        e.event.maxRightOffset = this._getRequiredView("prev") ? 1 : 0;
      },
      _getRequiredView: function(name2) {
        var view;
        var isRtl = this.option("rtlEnabled");
        if ("next" === name2) {
          view = isRtl ? this._beforeView : this._afterView;
        } else if ("prev" === name2) {
          view = isRtl ? this._afterView : this._beforeView;
        }
        return view;
      },
      _swipeUpdateHandler: function(e) {
        var offset2 = e.event.offset;
        move(this._$viewsWrapper, {
          left: offset2 * this._viewWidth(),
          top: 0
        });
        this._updateNavigatorCaption(offset2);
      },
      _swipeEndHandler: function(e) {
        var targetOffset = e.event.targetOffset;
        var moveOffset = !targetOffset ? 0 : targetOffset / Math.abs(targetOffset);
        if (0 === moveOffset) {
          this._animateWrapper(0, ANIMATION_DURATION_SHOW_VIEW);
          return;
        }
        var date = this._getDateByOffset(-moveOffset * this._getRtlCorrection());
        if (this._isDateInInvalidRange(date)) {
          if (moveOffset >= 0) {
            date = new Date(this._getMinDate());
          } else {
            date = new Date(this._getMaxDate());
          }
        }
        this.option("currentDate", date);
      },
      _viewWidth: function() {
        if (!this._viewWidthValue) {
          this._viewWidthValue = this.$element().width();
        }
        return this._viewWidthValue;
      },
      _updateNavigatorCaption: function(offset2) {
        offset2 *= this._getRtlCorrection();
        var view = this._view;
        if (offset2 > 0.5 && this._beforeView) {
          view = this._beforeView;
        } else if (offset2 < -0.5 && this._afterView) {
          view = this._afterView;
        }
        this._navigator.option("text", view.getNavigatorCaption());
      },
      _isDateInInvalidRange: function(date) {
        if (this._view.isBoundary(date)) {
          return;
        }
        var min = this._getMinDate();
        var max = this._getMaxDate();
        var normalizedDate = date_default.normalizeDate(date, min, max);
        return normalizedDate === min || normalizedDate === max;
      },
      _renderFooter: function() {
        var showTodayButton = this.option("showTodayButton");
        if (showTodayButton) {
          var $todayButton = this._createComponent(renderer_default("<a>"), button_default, {
            focusStateEnabled: false,
            text: message_default.format("dxCalendar-todayButtonText"),
            onClick: (function(args) {
              this._toTodayView(args);
            }).bind(this),
            integrationOptions: {}
          }).$element().addClass(CALENDAR_TODAY_BUTTON_CLASS);
          this._$footer = renderer_default("<div>").addClass(CALENDAR_FOOTER_CLASS).append($todayButton);
          this.$element().append(this._$footer);
        }
        this.$element().toggleClass(CALENDAR_HAS_FOOTER_CLASS, showTodayButton);
      },
      _renderSubmitElement: function() {
        this._$submitElement = renderer_default("<input>").attr("type", "hidden").appendTo(this.$element());
        this._setSubmitValue(this.option("value"));
      },
      _setSubmitValue: function(value2) {
        var dateValue = this._convertToDate(value2);
        this._getSubmitElement().val(date_serialization_default.serializeDate(dateValue, CALENDAR_INPUT_STANDARD_PATTERN));
      },
      _getSubmitElement: function() {
        return this._$submitElement;
      },
      _animateShowView: function() {
        fx_default.stop(this._view.$element(), true);
        return this._popAnimationView(this._view, POP_ANIMATION_FROM, POP_ANIMATION_TO, ANIMATION_DURATION_SHOW_VIEW).promise();
      },
      _popAnimationView: function(view, from, to, duration) {
        return fx_default.animate(view.$element(), {
          type: "pop",
          from: {
            scale: from,
            opacity: from
          },
          to: {
            scale: to,
            opacity: to
          },
          duration
        });
      },
      _navigate: function(offset2, value2) {
        if (0 !== offset2 && 1 !== Math.abs(offset2) && this._isViewAvailable(value2)) {
          var newView = this._renderSpecificView(value2);
          if (offset2 > 0) {
            this._afterView && this._afterView.$element().remove();
            this._afterView = newView;
          } else {
            this._beforeView && this._beforeView.$element().remove();
            this._beforeView = newView;
          }
          this._translateViews();
        }
        var rtlCorrection = this._getRtlCorrection();
        var offsetSign = offset2 > 0 ? 1 : offset2 < 0 ? -1 : 0;
        var endPosition = -rtlCorrection * offsetSign * this._viewWidth();
        var viewsWrapperPosition = this._$viewsWrapper.position().left;
        if (viewsWrapperPosition !== endPosition) {
          if (this._preventViewChangeAnimation) {
            this._wrapperAnimationEndHandler(offset2, value2);
          } else {
            this._animateWrapper(endPosition, ANIMATION_DURATION_SHOW_VIEW).done(this._wrapperAnimationEndHandler.bind(this, offset2, value2));
          }
        }
      },
      _animateWrapper: function(to, duration) {
        return fx_default.animate(this._$viewsWrapper, {
          type: "slide",
          from: {
            left: this._$viewsWrapper.position().left
          },
          to: {
            left: to
          },
          duration
        });
      },
      _getDate(value2) {
        var result2 = date_default.createDate(value2);
        if (isIE114 && isDate(value2)) {
          result2.setMilliseconds(0);
        }
        return result2;
      },
      _toTodayView: function(args) {
        this._saveValueChangeEvent(args.event);
        var today = /* @__PURE__ */ new Date();
        if (this._isMaxZoomLevel()) {
          this._dateOption("value", today);
          return;
        }
        this._preventViewChangeAnimation = true;
        this.option("zoomLevel", this.option("maxZoomLevel"));
        this._dateOption("value", today);
        this._animateShowView();
        this._preventViewChangeAnimation = false;
      },
      _wrapperAnimationEndHandler: function(offset2, newDate) {
        this._rearrangeViews(offset2);
        this._translateViews();
        this._resetLocation();
        this._renderNavigator();
        this._setViewContoured(newDate);
        this._updateAriaId(newDate);
      },
      _rearrangeViews: function(offset2) {
        if (0 === offset2) {
          return;
        }
        var viewOffset;
        var viewToCreateKey;
        var viewToRemoveKey;
        if (offset2 < 0) {
          viewOffset = 1;
          viewToCreateKey = "_beforeView";
          viewToRemoveKey = "_afterView";
        } else {
          viewOffset = -1;
          viewToCreateKey = "_afterView";
          viewToRemoveKey = "_beforeView";
        }
        if (!this[viewToCreateKey]) {
          return;
        }
        var destinationDate = this[viewToCreateKey].option("date");
        if (this[viewToRemoveKey]) {
          this[viewToRemoveKey].$element().remove();
        }
        if (offset2 === viewOffset) {
          this[viewToRemoveKey] = this._view;
        } else {
          this[viewToRemoveKey] = this._renderSpecificView(this._getDateByOffset(viewOffset, destinationDate));
          this._view.$element().remove();
        }
        this._view = this[viewToCreateKey];
        var dateByOffset = this._getDateByOffset(-viewOffset, destinationDate);
        this[viewToCreateKey] = this._isViewAvailable(dateByOffset) ? this._renderSpecificView(dateByOffset) : null;
      },
      _resetLocation: function() {
        move(this._$viewsWrapper, {
          left: 0,
          top: 0
        });
      },
      _clean: function() {
        this.callBase();
        this._clearViewWidthCache();
        delete this._$viewsWrapper;
        delete this._navigator;
        delete this._$footer;
      },
      _clearViewWidthCache: function() {
        delete this._viewWidthValue;
      },
      _disposeViews: function() {
        this._view.$element().remove();
        this._beforeView && this._beforeView.$element().remove();
        this._afterView && this._afterView.$element().remove();
        delete this._view;
        delete this._beforeView;
        delete this._afterView;
      },
      _dispose: function() {
        clearTimeout(this._waitRenderViewTimeout);
        this.callBase();
      },
      _refreshViews: function() {
        this._disposeViews();
        this._renderViews();
      },
      _visibilityChanged: function() {
        this._translateViews();
      },
      _focusInHandler: function() {
        this.callBase.apply(this, arguments);
        this._view.option("contouredDate", this.option("currentDate"));
      },
      _focusOutHandler: function() {
        this.callBase.apply(this, arguments);
        this._view.option("contouredDate", null);
      },
      _updateViewsValue: function(value2) {
        var newValue = value2 ? new Date(value2) : null;
        this._view.option("value", newValue);
        this._beforeView && this._beforeView.option("value", newValue);
        this._afterView && this._afterView.option("value", newValue);
      },
      _updateAriaSelected: function(value2, previousValue) {
        var _value;
        value2 = null !== (_value = value2) && void 0 !== _value ? _value : this._dateOption("value");
        var $prevSelectedCell = this._view._getCellByDate(previousValue);
        var $selectedCell = this._view._getCellByDate(value2);
        this.setAria("selected", void 0, $prevSelectedCell);
        this.setAria("selected", true, $selectedCell);
        if (value2 && this.option("currentDate").getTime() === value2.getTime()) {
          this._updateAriaId(value2);
        }
      },
      _updateAriaId: function(value2) {
        var _value2;
        value2 = null !== (_value2 = value2) && void 0 !== _value2 ? _value2 : this.option("currentDate");
        var ariaId = "dx-" + new guid_default();
        var $newCell = this._view._getCellByDate(value2);
        this.setAria("id", ariaId, $newCell);
        this.setAria("activedescendant", ariaId);
        this._onContouredChanged(ariaId);
      },
      _suppressingNavigation: function(callback, args) {
        this._suppressNavigation = true;
        callback.apply(this, args);
        delete this._suppressNavigation;
      },
      _optionChanged: function(args) {
        var value2 = args.value;
        var previousValue = args.previousValue;
        switch (args.name) {
          case "width":
            this.callBase(args);
            this._clearViewWidthCache();
            break;
          case "min":
          case "max":
            this.min = void 0;
            this.max = void 0;
            this._suppressingNavigation(this._updateCurrentDate, [this.option("currentDate")]);
            this._refreshViews();
            this._renderNavigator();
            break;
          case "firstDayOfWeek":
            this._refreshViews();
            this._updateButtonsVisibility();
            break;
          case "currentDate":
            this.setAria("id", void 0, this._view._getCellByDate(previousValue));
            this._updateCurrentDate(value2);
            break;
          case "zoomLevel":
            this.$element().removeClass(CALENDAR_VIEW_CLASS + "-" + previousValue);
            this._correctZoomLevel();
            this._refreshViews();
            this._renderNavigator();
            this._updateAriaId();
            break;
          case "minZoomLevel":
          case "maxZoomLevel":
            this._correctZoomLevel();
            this._updateButtonsVisibility();
            break;
          case "value":
            value2 = this._convertToDate(value2);
            previousValue = this._convertToDate(previousValue);
            this._updateAriaSelected(value2, previousValue);
            this.option("currentDate", isDefined(value2) ? date_default.createDate(value2) : /* @__PURE__ */ new Date());
            this._updateViewsValue(value2);
            this._setSubmitValue(value2);
            this.callBase(args);
            break;
          case "onCellClick":
            this._view.option("onCellClick", value2);
            break;
          case "onContouredChanged":
            this._onContouredChanged = this._createActionByOption("onContouredChanged");
            break;
          case "disabledDates":
          case "dateSerializationFormat":
          case "cellTemplate":
          case "showTodayButton":
            this._invalidate();
            break;
          case "hasFocus":
            break;
          case "_todayDate":
            this._refreshViews();
            break;
          default:
            this.callBase(args);
        }
      },
      getContouredDate: function() {
        return this._view.option("contouredDate");
      }
    });
    component_registrator_default("dxCalendar", Calendar);
    ui_calendar_default = Calendar;
  }
});

// node_modules/devextreme/esm/ui/calendar.js
var calendar_default;
var init_calendar = __esm({
  "node_modules/devextreme/esm/ui/calendar.js"() {
    init_ui_calendar();
    calendar_default = ui_calendar_default;
  }
});

// node_modules/devextreme/esm/ui/date_box/ui.date_box.strategy.js
var abstract9, DateBoxStrategy, ui_date_box_strategy_default;
var init_ui_date_box_strategy = __esm({
  "node_modules/devextreme/esm/ui/date_box/ui.date_box.strategy.js"() {
    init_renderer();
    init_events_engine();
    init_common();
    init_class();
    init_date3();
    abstract9 = class_default.abstract;
    DateBoxStrategy = class_default.inherit({
      ctor: function(dateBox) {
        this.dateBox = dateBox;
      },
      widgetOption: function() {
        return this._widget && this._widget.option.apply(this._widget, arguments);
      },
      _renderWidget: function(element) {
        element = element || renderer_default("<div>");
        this._widget = this._createWidget(element);
        this._widget.$element().appendTo(this._getWidgetContainer());
      },
      _createWidget: function(element) {
        var widgetName = this._getWidgetName();
        var widgetOptions = this._getWidgetOptions();
        return this.dateBox._createComponent(element, widgetName, widgetOptions);
      },
      _getWidgetOptions: abstract9,
      _getWidgetName: abstract9,
      getDefaultOptions: function() {
        return {
          mode: "text"
        };
      },
      getDisplayFormat: abstract9,
      supportedKeys: noop2,
      getKeyboardListener: noop2,
      customizeButtons: noop2,
      getParsedText: function(text, format2) {
        var value2 = date_default3.parse(text, format2);
        return value2 ? value2 : date_default3.parse(text);
      },
      renderInputMinMax: noop2,
      renderOpenedState: function() {
        this._updateValue();
      },
      popupConfig: abstract9,
      _dimensionChanged: function() {
        var _this$_getPopup;
        null === (_this$_getPopup = this._getPopup()) || void 0 === _this$_getPopup ? void 0 : _this$_getPopup.repaint();
      },
      renderPopupContent: function() {
        var popup = this._getPopup();
        this._renderWidget();
        var $popupContent = popup.$content().parent();
        events_engine_default.off($popupContent, "mousedown");
        events_engine_default.on($popupContent, "mousedown", this._preventFocusOnPopup.bind(this));
      },
      getFirstPopupElement: noop2,
      getLastPopupElement: noop2,
      _preventFocusOnPopup: function(e) {
        e.preventDefault();
      },
      _getWidgetContainer: function() {
        return this._getPopup().$content();
      },
      _getPopup: function() {
        return this.dateBox._popup;
      },
      popupShowingHandler: noop2,
      popupHiddenHandler: noop2,
      _updateValue: function() {
        this._widget && this._widget.option("value", this.dateBoxValue());
      },
      useCurrentDateByDefault: noop2,
      getDefaultDate: function() {
        return /* @__PURE__ */ new Date();
      },
      textChangedHandler: noop2,
      renderValue: function() {
        if (this.dateBox.option("opened")) {
          this._updateValue();
        }
      },
      getValue: function() {
        return this._widget.option("value");
      },
      isAdaptivityChanged: function() {
        return false;
      },
      dispose: function() {
        var popup = this._getPopup();
        if (popup) {
          popup.$content().empty();
        }
      },
      dateBoxValue: function() {
        if (arguments.length) {
          return this.dateBox.dateValue.apply(this.dateBox, arguments);
        } else {
          return this.dateBox.dateOption.apply(this.dateBox, ["value"]);
        }
      }
    });
    ui_date_box_strategy_default = DateBoxStrategy;
  }
});

// node_modules/devextreme/esm/ui/date_box/ui.date_box.strategy.calendar.js
var CalendarStrategy, ui_date_box_strategy_calendar_default;
var init_ui_date_box_strategy_calendar = __esm({
  "node_modules/devextreme/esm/ui/date_box/ui.date_box.strategy.calendar.js"() {
    init_calendar();
    init_ui_date_box_strategy();
    init_date();
    init_common();
    init_type();
    init_extend();
    init_message();
    CalendarStrategy = ui_date_box_strategy_default.inherit({
      NAME: "Calendar",
      supportedKeys: function() {
        var homeEndHandler = function(e) {
          if (this.option("opened")) {
            e.preventDefault();
            return true;
          }
          return false;
        };
        return {
          rightArrow: function() {
            if (this.option("opened")) {
              return true;
            }
          },
          leftArrow: function() {
            if (this.option("opened")) {
              return true;
            }
          },
          enter: (function(e) {
            if (this.dateBox.option("opened")) {
              e.preventDefault();
              if (this._widget.option("zoomLevel") === this._widget.option("maxZoomLevel")) {
                var viewValue = this._getContouredValue();
                var lastActionElement = this._lastActionElement;
                var shouldCloseDropDown = this._closeDropDownByEnter();
                if (shouldCloseDropDown && viewValue && "calendar" === lastActionElement) {
                  this.dateBoxValue(viewValue, e);
                }
                shouldCloseDropDown && this.dateBox.close();
                this.dateBox._valueChangeEventHandler(e);
                return !shouldCloseDropDown;
              } else {
                return true;
              }
            } else {
              this.dateBox._valueChangeEventHandler(e);
            }
          }).bind(this),
          home: homeEndHandler,
          end: homeEndHandler
        };
      },
      getDisplayFormat: function(displayFormat) {
        return displayFormat || "shortdate";
      },
      _closeDropDownByEnter: () => true,
      _getWidgetName: function() {
        return calendar_default;
      },
      _getContouredValue: function() {
        return this._widget._view.option("contouredDate");
      },
      getKeyboardListener() {
        return this._widget;
      },
      _getWidgetOptions: function() {
        var disabledDates = this.dateBox.option("disabledDates");
        return extend2(this.dateBox.option("calendarOptions"), {
          value: this.dateBoxValue() || null,
          dateSerializationFormat: null,
          min: this.dateBox.dateOption("min"),
          max: this.dateBox.dateOption("max"),
          onValueChanged: this._valueChangedHandler.bind(this),
          onCellClick: this._cellClickHandler.bind(this),
          tabIndex: null,
          disabledDates: isFunction(disabledDates) ? this._injectComponent(disabledDates.bind(this.dateBox)) : disabledDates,
          onContouredChanged: this._refreshActiveDescendant.bind(this),
          hasFocus: function() {
            return true;
          }
        });
      },
      _injectComponent: function(func) {
        var that = this;
        return function(params) {
          extend2(params, {
            component: that.dateBox
          });
          return func(params);
        };
      },
      _refreshActiveDescendant: function(e) {
        this._lastActionElement = "calendar";
        this.dateBox.setAria("activedescendant", e.actionValue);
      },
      popupConfig: function(_popupConfig) {
        var toolbarItems = _popupConfig.toolbarItems;
        var buttonsLocation = this.dateBox.option("buttonsLocation");
        var position3 = [];
        if ("default" !== buttonsLocation) {
          position3 = splitPair(buttonsLocation);
        } else {
          position3 = ["bottom", "center"];
        }
        if ("useButtons" === this.dateBox.option("applyValueMode") && this._isCalendarVisible()) {
          toolbarItems.unshift({
            widget: "dxButton",
            toolbar: position3[0],
            location: "after" === position3[1] ? "before" : position3[1],
            options: {
              onInitialized: (function(e) {
                e.component.registerKeyHandler("escape", this._escapeHandler.bind(this));
              }).bind(this),
              onClick: (args) => {
                this._widget._toTodayView(args);
              },
              text: message_default.format("dxCalendar-todayButtonText"),
              type: "today"
            }
          });
        }
        return extend2(true, _popupConfig, {
          toolbarItems,
          position: {
            collision: "flipfit flip"
          },
          width: "auto"
        });
      },
      _isCalendarVisible: function() {
        return isEmptyObject(this.dateBox.option("calendarOptions")) || false !== this.dateBox.option("calendarOptions.visible");
      },
      _escapeHandler: function() {
        this.dateBox.close();
        this.dateBox.focus();
      },
      _valueChangedHandler: function(e) {
        var value2 = e.value;
        var prevValue = e.previousValue;
        if (date_default.sameDate(value2, prevValue) && date_default.sameHoursAndMinutes(value2, prevValue)) {
          return;
        }
        if ("instantly" === this.dateBox.option("applyValueMode")) {
          this.dateBoxValue(this.getValue(), e.event);
        }
      },
      _updateValue: function() {
        if (!this._widget) {
          return;
        }
        this._widget.option("value", this.dateBoxValue());
      },
      textChangedHandler: function() {
        this._lastActionElement = "input";
        if (this.dateBox.option("opened") && this._widget) {
          this._updateValue(true);
        }
      },
      _cellClickHandler: function(e) {
        var dateBox = this.dateBox;
        if ("instantly" === dateBox.option("applyValueMode")) {
          dateBox.option("opened", false);
          this.dateBoxValue(this.getValue(), e.event);
        }
      }
    });
    ui_date_box_strategy_calendar_default = CalendarStrategy;
  }
});

// node_modules/devextreme/esm/ui/date_box/ui.date_view_roller.js
var DATEVIEW_ROLLER_CLASS, DATEVIEW_ROLLER_ACTIVE_CLASS, DATEVIEW_ROLLER_CURRENT_CLASS, DATEVIEW_ROLLER_ITEM_CLASS, DATEVIEW_ROLLER_ITEM_SELECTED_CLASS, DATEVIEW_ROLLER_ITEM_SELECTED_FRAME_CLASS, DATEVIEW_ROLLER_ITEM_SELECTED_BORDER_CLASS, DateViewRoller, ui_date_view_roller_default;
var init_ui_date_view_roller = __esm({
  "node_modules/devextreme/esm/ui/date_box/ui.date_view_roller.js"() {
    init_renderer();
    init_events_engine();
    init_component_registrator();
    init_extend();
    init_iterator();
    init_utils2();
    init_click();
    init_ui_scrollable();
    init_devices();
    init_fx();
    init_translator();
    DATEVIEW_ROLLER_CLASS = "dx-dateviewroller";
    DATEVIEW_ROLLER_ACTIVE_CLASS = "dx-state-active";
    DATEVIEW_ROLLER_CURRENT_CLASS = "dx-dateviewroller-current";
    DATEVIEW_ROLLER_ITEM_CLASS = "dx-dateview-item";
    DATEVIEW_ROLLER_ITEM_SELECTED_CLASS = "dx-dateview-item-selected";
    DATEVIEW_ROLLER_ITEM_SELECTED_FRAME_CLASS = "dx-dateview-item-selected-frame";
    DATEVIEW_ROLLER_ITEM_SELECTED_BORDER_CLASS = "dx-dateview-item-selected-border";
    DateViewRoller = ui_scrollable_default.inherit({
      _getDefaultOptions: function() {
        return extend2(this.callBase(), {
          showScrollbar: "never",
          useNative: false,
          selectedIndex: 0,
          bounceEnabled: false,
          items: [],
          showOnClick: false,
          onClick: null,
          onSelectedIndexChanged: null
        });
      },
      _defaultOptionsRules: function() {
        return this.callBase().concat([{
          device: {
            platform: "generic"
          },
          options: {
            scrollByContent: true
          }
        }]);
      },
      _init: function() {
        this.callBase();
        this._renderSelectedItemFrame();
      },
      _render: function() {
        this.callBase();
        this.$element().addClass(DATEVIEW_ROLLER_CLASS);
        this._renderContainerClick();
        this._renderItems();
        this._renderSelectedValue();
        this._renderItemsClick();
        this._renderWheelEvent();
        this._wrapAction("_endAction", this._endActionHandler.bind(this));
        this._renderSelectedIndexChanged();
      },
      _renderSelectedIndexChanged: function() {
        this._selectedIndexChanged = this._createActionByOption("onSelectedIndexChanged");
      },
      _renderWheelEvent: function() {
        events_engine_default.on(this._$container, "dxmousewheel", (e) => {
          this._isWheelScrolled = true;
        });
      },
      _renderContainerClick: function() {
        if (!this.option("showOnClick")) {
          return;
        }
        var eventName = addNamespace2(CLICK_EVENT_NAME, this.NAME);
        var clickAction = this._createActionByOption("onClick");
        events_engine_default.off(this._$container, eventName);
        events_engine_default.on(this._$container, eventName, function(e) {
          clickAction({
            event: e
          });
        });
      },
      _wrapAction: function(actionName, callback) {
        var strategy3 = this._strategy;
        var originalAction = strategy3[actionName];
        strategy3[actionName] = function() {
          callback.apply(this, arguments);
          return originalAction.apply(this, arguments);
        };
      },
      _renderItems: function() {
        var items = this.option("items") || [];
        var $items = renderer_default();
        this._$content.empty();
        items.forEach(function(item) {
          $items = $items.add(renderer_default("<div>").addClass(DATEVIEW_ROLLER_ITEM_CLASS).append(item));
        });
        this._$content.append($items);
        this._$items = $items;
        this.update();
      },
      _renderSelectedItemFrame: function() {
        renderer_default("<div>").addClass(DATEVIEW_ROLLER_ITEM_SELECTED_FRAME_CLASS).append(renderer_default("<div>").addClass(DATEVIEW_ROLLER_ITEM_SELECTED_BORDER_CLASS)).appendTo(this._$container);
      },
      _renderSelectedValue: function(selectedIndex) {
        var index2 = this._fitIndex(null !== selectedIndex && void 0 !== selectedIndex ? selectedIndex : this.option("selectedIndex"));
        this._moveTo({
          top: this._getItemPosition(index2)
        });
        this._renderActiveStateItem();
      },
      _fitIndex: function(index2) {
        var items = this.option("items") || [];
        var itemCount = items.length;
        if (index2 >= itemCount) {
          return itemCount - 1;
        }
        if (index2 < 0) {
          return 0;
        }
        return index2;
      },
      _getItemPosition: function(index2) {
        return Math.round(this._itemHeight() * index2);
      },
      _renderItemsClick: function() {
        var itemSelector = this._getItemSelector();
        var eventName = addNamespace2(CLICK_EVENT_NAME, this.NAME);
        events_engine_default.off(this.$element(), eventName, itemSelector);
        events_engine_default.on(this.$element(), eventName, itemSelector, this._itemClickHandler.bind(this));
      },
      _getItemSelector: function() {
        return "." + DATEVIEW_ROLLER_ITEM_CLASS;
      },
      _itemClickHandler: function(e) {
        this.option("selectedIndex", this._itemElementIndex(e.currentTarget));
      },
      _itemElementIndex: function(itemElement) {
        return this._itemElements().index(itemElement);
      },
      _itemElements: function() {
        return this.$element().find(this._getItemSelector());
      },
      _renderActiveStateItem: function() {
        var selectedIndex = this.option("selectedIndex");
        each(this._$items, function(index2) {
          renderer_default(this).toggleClass(DATEVIEW_ROLLER_ITEM_SELECTED_CLASS, selectedIndex === index2);
        });
      },
      _shouldScrollToNeighborItem: function() {
        return "desktop" === devices_default.real().deviceType && this._isWheelScrolled;
      },
      _moveTo: function(targetLocation) {
        targetLocation = this._normalizeLocation(targetLocation);
        var location = this._location();
        var delta = {
          x: -(location.left - targetLocation.left),
          y: -(location.top - targetLocation.top)
        };
        if (this._isVisible() && (delta.x || delta.y)) {
          this._strategy._prepareDirections(true);
          if (this._animation && !this._shouldScrollToNeighborItem()) {
            var that = this;
            fx_default.stop(this._$content);
            fx_default.animate(this._$content, {
              duration: 200,
              type: "slide",
              to: {
                top: Math.floor(delta.y)
              },
              complete: function() {
                resetPosition(that._$content);
                that._strategy.handleMove({
                  delta
                });
              }
            });
            delete this._animation;
          } else {
            this._strategy.handleMove({
              delta
            });
          }
        }
      },
      _validate: function(e) {
        return this._strategy.validate(e);
      },
      _fitSelectedIndexInRange: function(index2) {
        var itemsCount = this.option("items").length;
        return Math.max(Math.min(index2, itemsCount - 1), 0);
      },
      _isInNullNeighborhood: function(x) {
        return -0.1 <= x && x <= 0.1;
      },
      _getSelectedIndexAfterScroll: function(currentSelectedIndex) {
        var locationTop = -this._location().top;
        var currentSelectedIndexPosition = currentSelectedIndex * this._itemHeight();
        var dy = locationTop - currentSelectedIndexPosition;
        if (this._isInNullNeighborhood(dy)) {
          return currentSelectedIndex;
        }
        var direction = dy > 0 ? 1 : -1;
        var newSelectedIndex = this._fitSelectedIndexInRange(currentSelectedIndex + direction);
        return newSelectedIndex;
      },
      _getNewSelectedIndex: function(currentSelectedIndex) {
        if (this._shouldScrollToNeighborItem()) {
          return this._getSelectedIndexAfterScroll(currentSelectedIndex);
        }
        this._animation = true;
        var ratio = -this._location().top / this._itemHeight();
        return Math.round(ratio);
      },
      _endActionHandler: function() {
        var currentSelectedIndex = this.option("selectedIndex");
        var newSelectedIndex = this._getNewSelectedIndex(currentSelectedIndex);
        if (newSelectedIndex === currentSelectedIndex) {
          this._renderSelectedValue(newSelectedIndex);
        } else {
          this.option("selectedIndex", newSelectedIndex);
        }
        this._isWheelScrolled = false;
      },
      _itemHeight: function() {
        var $item = this._$items.first();
        return $item.height();
      },
      _toggleActive: function(state) {
        this.$element().toggleClass(DATEVIEW_ROLLER_ACTIVE_CLASS, state);
      },
      _isVisible: function() {
        return this._$container.is(":visible");
      },
      _fireSelectedIndexChanged: function(value2, previousValue) {
        this._selectedIndexChanged({
          value: value2,
          previousValue,
          event: void 0
        });
      },
      _visibilityChanged: function(visible2) {
        this.callBase(visible2);
        if (visible2) {
          this._renderSelectedValue(this.option("selectedIndex"));
        }
        this.toggleActiveState(false);
      },
      toggleActiveState: function(state) {
        this.$element().toggleClass(DATEVIEW_ROLLER_CURRENT_CLASS, state);
      },
      _refreshSelectedIndex: function() {
        var selectedIndex = this.option("selectedIndex");
        var fitIndex = this._fitIndex(selectedIndex);
        if (fitIndex === selectedIndex) {
          this._renderActiveStateItem();
        } else {
          this.option("selectedIndex", fitIndex);
        }
      },
      _optionChanged: function(args) {
        switch (args.name) {
          case "selectedIndex":
            this._fireSelectedIndexChanged(args.value, args.previousValue);
            this._renderSelectedValue(args.value);
            break;
          case "items":
            this._renderItems();
            this._refreshSelectedIndex();
            break;
          case "onClick":
          case "showOnClick":
            this._renderContainerClick();
            break;
          case "onSelectedIndexChanged":
            this._renderSelectedIndexChanged();
            break;
          default:
            this.callBase(args);
        }
      }
    });
    component_registrator_default("dxDateViewRoller", DateViewRoller);
    ui_date_view_roller_default = DateViewRoller;
  }
});

// node_modules/devextreme/esm/ui/date_box/ui.date_view.js
var DATEVIEW_CLASS, DATEVIEW_COMPACT_CLASS, DATEVIEW_WRAPPER_CLASS, DATEVIEW_ROLLER_CONTAINER_CLASS, DATEVIEW_ROLLER_CLASS2, TYPE, ROLLER_TYPE, DateView, ui_date_view_default;
var init_ui_date_view = __esm({
  "node_modules/devextreme/esm/ui/date_box/ui.date_view.js"() {
    init_renderer();
    init_editor();
    init_ui_date_view_roller();
    init_date();
    init_iterator();
    init_extend();
    init_ui_date_utils();
    init_component_registrator();
    init_date3();
    DATEVIEW_CLASS = "dx-dateview";
    DATEVIEW_COMPACT_CLASS = "dx-dateview-compact";
    DATEVIEW_WRAPPER_CLASS = "dx-dateview-wrapper";
    DATEVIEW_ROLLER_CONTAINER_CLASS = "dx-dateview-rollers";
    DATEVIEW_ROLLER_CLASS2 = "dx-dateviewroller";
    TYPE = {
      date: "date",
      datetime: "datetime",
      time: "time"
    };
    ROLLER_TYPE = {
      year: "year",
      month: "month",
      day: "day",
      hours: "hours"
    };
    DateView = editor_default.inherit({
      _valueOption: function() {
        var value2 = this.option("value");
        var date = new Date(value2);
        return !value2 || isNaN(date) ? this._getDefaultDate() : date;
      },
      _getDefaultDate: function() {
        var date = /* @__PURE__ */ new Date();
        if (this.option("type") === TYPE.date) {
          return new Date(date.getFullYear(), date.getMonth(), date.getDate());
        }
        return date;
      },
      _getDefaultOptions: function() {
        return extend2(this.callBase(), {
          minDate: ui_date_utils_default.MIN_DATEVIEW_DEFAULT_DATE,
          maxDate: ui_date_utils_default.MAX_DATEVIEW_DEFAULT_DATE,
          type: TYPE.date,
          value: /* @__PURE__ */ new Date(),
          applyCompactClass: false
        });
      },
      _defaultOptionsRules: function() {
        return this.callBase().concat([{
          device: function(_device) {
            return "desktop" !== _device.deviceType;
          },
          options: {
            applyCompactClass: true
          }
        }]);
      },
      _render: function() {
        this.callBase();
        this.$element().addClass(DATEVIEW_CLASS);
        this._toggleFormatClasses(this.option("type"));
        this._toggleCompactClass();
      },
      _toggleFormatClasses: function(currentFormat, previousFormat) {
        this.$element().addClass(DATEVIEW_CLASS + "-" + currentFormat);
        previousFormat && this.$element().removeClass(DATEVIEW_CLASS + "-" + previousFormat);
      },
      _toggleCompactClass: function() {
        this.$element().toggleClass(DATEVIEW_COMPACT_CLASS, this.option("applyCompactClass"));
      },
      _wrapper: function() {
        return this._$wrapper;
      },
      _renderContentImpl: function() {
        this._$wrapper = renderer_default("<div>").addClass(DATEVIEW_WRAPPER_CLASS);
        this._renderRollers();
        this._$wrapper.appendTo(this.$element());
      },
      _renderRollers: function() {
        if (!this._$rollersContainer) {
          this._$rollersContainer = renderer_default("<div>").addClass(DATEVIEW_ROLLER_CONTAINER_CLASS);
        }
        this._$rollersContainer.empty();
        this._createRollerConfigs();
        this._rollers = {};
        var that = this;
        each(that._rollerConfigs, function(name2) {
          var $roller = renderer_default("<div>").appendTo(that._$rollersContainer).addClass(DATEVIEW_ROLLER_CLASS2 + "-" + that._rollerConfigs[name2].type);
          that._rollers[that._rollerConfigs[name2].type] = that._createComponent($roller, ui_date_view_roller_default, {
            items: that._rollerConfigs[name2].displayItems,
            selectedIndex: that._rollerConfigs[name2].selectedIndex,
            showScrollbar: "never",
            onStart: function(e) {
              var roller = e.component;
              roller._toggleActive(true);
              that._setActiveRoller(that._rollerConfigs[name2], roller.option("selectedIndex"));
            },
            onEnd: function(e) {
              var roller = e.component;
              roller._toggleActive(false);
            },
            onClick: function(e) {
              var roller = e.component;
              roller._toggleActive(true);
              that._setActiveRoller(that._rollerConfigs[name2], roller.option("selectedIndex"));
              that._setRollerState(that._rollerConfigs[name2], roller.option("selectedIndex"));
              roller._toggleActive(false);
            },
            onSelectedIndexChanged: function(e) {
              var roller = e.component;
              that._setRollerState(that._rollerConfigs[name2], roller.option("selectedIndex"));
            }
          });
        });
        that._$rollersContainer.appendTo(that._wrapper());
      },
      _createRollerConfigs: function(type2) {
        var that = this;
        type2 = type2 || that.option("type");
        that._rollerConfigs = {};
        date_default3.getFormatParts(ui_date_utils_default.FORMATS_MAP[type2]).forEach(function(partName) {
          that._createRollerConfig(partName);
        });
      },
      _createRollerConfig: function(componentName) {
        var componentInfo = ui_date_utils_default.DATE_COMPONENTS_INFO[componentName];
        var valueRange = this._calculateRollerConfigValueRange(componentName);
        var startValue = valueRange.startValue;
        var endValue = valueRange.endValue;
        var formatter = componentInfo.formatter;
        var curDate = this._getCurrentDate();
        var config2 = {
          type: componentName,
          setValue: componentInfo.setter,
          valueItems: [],
          displayItems: [],
          getIndex: function(value2) {
            return value2[componentInfo.getter]() - startValue;
          }
        };
        for (var i = startValue; i <= endValue; i++) {
          config2.valueItems.push(i);
          config2.displayItems.push(formatter(i, curDate));
        }
        config2.selectedIndex = config2.getIndex(curDate);
        this._rollerConfigs[componentName] = config2;
      },
      _setActiveRoller: function(currentRoller) {
        var activeRoller = currentRoller && this._rollers[currentRoller.type];
        each(this._rollers, function() {
          this.toggleActiveState(this === activeRoller);
        });
      },
      _updateRollersPosition: function() {
        var that = this;
        each(this._rollers, function(type2) {
          var correctIndex = that._rollerConfigs[type2].getIndex(that._getCurrentDate());
          this.option("selectedIndex", correctIndex);
        });
      },
      _setRollerState: function(roller, selectedIndex) {
        if (selectedIndex !== roller.selectedIndex) {
          var rollerValue = roller.valueItems[selectedIndex];
          var setValue = roller.setValue;
          var currentValue = new Date(this._getCurrentDate());
          var currentDate = currentValue.getDate();
          var minDate = this.option("minDate");
          var maxDate = this.option("maxDate");
          if (roller.type === ROLLER_TYPE.month) {
            currentDate = Math.min(currentDate, ui_date_utils_default.getMaxMonthDay(currentValue.getFullYear(), rollerValue));
          } else if (roller.type === ROLLER_TYPE.year) {
            currentDate = Math.min(currentDate, ui_date_utils_default.getMaxMonthDay(rollerValue, currentValue.getMonth()));
          }
          currentValue.setDate(currentDate);
          currentValue[setValue](rollerValue);
          var normalizedDate = date_default.normalizeDate(currentValue, minDate, maxDate);
          currentValue = ui_date_utils_default.mergeDates(normalizedDate, currentValue, "time");
          currentValue = date_default.normalizeDate(currentValue, minDate, maxDate);
          this.option("value", currentValue);
          roller.selectedIndex = selectedIndex;
        }
        if (roller.type === ROLLER_TYPE.year) {
          this._refreshRollers();
        }
        if (roller.type === ROLLER_TYPE.month) {
          this._refreshRoller(ROLLER_TYPE.day);
          this._refreshRoller(ROLLER_TYPE.hours);
        }
      },
      _refreshRoller: function(rollerType) {
        var roller = this._rollers[rollerType];
        if (roller) {
          this._createRollerConfig(rollerType);
          var rollerConfig = this._rollerConfigs[rollerType];
          if (rollerType === ROLLER_TYPE.day || rollerConfig.displayItems.toString() !== roller.option("items").toString()) {
            roller.option({
              items: rollerConfig.displayItems,
              selectedIndex: rollerConfig.selectedIndex
            });
          }
        }
      },
      _getCurrentDate: function() {
        var curDate = this._valueOption();
        var minDate = this.option("minDate");
        var maxDate = this.option("maxDate");
        return date_default.normalizeDate(curDate, minDate, maxDate);
      },
      _calculateRollerConfigValueRange: function(componentName) {
        var curDate = this._getCurrentDate();
        var minDate = this.option("minDate");
        var maxDate = this.option("maxDate");
        var minYear = date_default.sameYear(curDate, minDate);
        var minMonth = minYear && curDate.getMonth() === minDate.getMonth();
        var maxYear = date_default.sameYear(curDate, maxDate);
        var maxMonth = maxYear && curDate.getMonth() === maxDate.getMonth();
        var minHour = minMonth && curDate.getDate() === minDate.getDate();
        var maxHour = maxMonth && curDate.getDate() === maxDate.getDate();
        var componentInfo = ui_date_utils_default.DATE_COMPONENTS_INFO[componentName];
        var startValue = componentInfo.startValue;
        var endValue = componentInfo.endValue;
        if (componentName === ROLLER_TYPE.year) {
          startValue = minDate.getFullYear();
          endValue = maxDate.getFullYear();
        }
        if (componentName === ROLLER_TYPE.month) {
          if (minYear) {
            startValue = minDate.getMonth();
          }
          if (maxYear) {
            endValue = maxDate.getMonth();
          }
        }
        if (componentName === ROLLER_TYPE.day) {
          endValue = ui_date_utils_default.getMaxMonthDay(curDate.getFullYear(), curDate.getMonth());
          if (minYear && minMonth) {
            startValue = minDate.getDate();
          }
          if (maxYear && maxMonth) {
            endValue = maxDate.getDate();
          }
        }
        if (componentName === ROLLER_TYPE.hours) {
          startValue = minHour ? minDate.getHours() : startValue;
          endValue = maxHour ? maxDate.getHours() : endValue;
        }
        return {
          startValue,
          endValue
        };
      },
      _refreshRollers: function() {
        this._refreshRoller(ROLLER_TYPE.month);
        this._refreshRoller(ROLLER_TYPE.day);
        this._refreshRoller(ROLLER_TYPE.hours);
      },
      _optionChanged: function(args) {
        switch (args.name) {
          case "minDate":
          case "maxDate":
          case "type":
            this._renderRollers();
            this._toggleFormatClasses(args.value, args.previousValue);
            break;
          case "visible":
            this.callBase(args);
            if (args.value) {
              this._renderRollers();
            }
            break;
          case "value":
            this.option("value", this._valueOption());
            this._refreshRollers();
            this._updateRollersPosition();
            break;
          default:
            this.callBase(args);
        }
      },
      _clean: function() {
        this.callBase();
        delete this._$rollersContainer;
      }
    });
    component_registrator_default("dxDateView", DateView);
    ui_date_view_default = DateView;
  }
});

// node_modules/devextreme/esm/ui/date_box/ui.date_box.strategy.date_view.js
var window23, DateViewStrategy, ui_date_box_strategy_date_view_default;
var init_ui_date_box_strategy_date_view = __esm({
  "node_modules/devextreme/esm/ui/date_box/ui.date_box.strategy.date_view.js"() {
    init_renderer();
    init_window();
    init_ui_date_view();
    init_ui_date_box_strategy();
    init_support();
    init_extend();
    init_ui_date_utils();
    init_message();
    window23 = getWindow();
    DateViewStrategy = ui_date_box_strategy_default.inherit({
      NAME: "DateView",
      getDefaultOptions: function() {
        return extend2(this.callBase(), {
          openOnFieldClick: true,
          applyButtonText: message_default.format("OK"),
          "dropDownOptions.showTitle": true
        });
      },
      getDisplayFormat: function(displayFormat) {
        return displayFormat || ui_date_utils_default.FORMATS_MAP[this.dateBox.option("type")];
      },
      popupConfig: function(config2) {
        return {
          toolbarItems: this.dateBox._popupToolbarItemsConfig(),
          onInitialized: config2.onInitialized,
          defaultOptionsRules: [{
            device: {
              platform: "android"
            },
            options: {
              width: 333,
              height: 331
            }
          }, {
            device: function(_device) {
              var platform = _device.platform;
              return "generic" === platform || "ios" === platform;
            },
            options: {
              width: "auto",
              height: "auto"
            }
          }, {
            device: function(_device2) {
              var platform = _device2.platform;
              var phone = _device2.phone;
              return "generic" === platform && phone;
            },
            options: {
              width: 333,
              maxWidth: "100%",
              maxHeight: "100%",
              height: "auto",
              position: {
                collision: "flipfit flip"
              }
            }
          }, {
            device: {
              platform: "ios",
              phone: true
            },
            options: {
              width: "100%",
              position: {
                my: "bottom",
                at: "bottom",
                of: window23
              }
            }
          }]
        };
      },
      _renderWidget: function() {
        if (inputType(this.dateBox.option("mode")) && this.dateBox._isNativeType() || this.dateBox.option("readOnly")) {
          if (this._widget) {
            this._widget.$element().remove();
            this._widget = null;
          }
          return;
        }
        var popup = this._getPopup();
        if (this._widget) {
          this._widget.option(this._getWidgetOptions());
        } else {
          var element = renderer_default("<div>").appendTo(popup.$content());
          this._widget = this._createWidget(element);
        }
        this._widget.$element().appendTo(this._getWidgetContainer());
      },
      _getWidgetName: function() {
        return ui_date_view_default;
      },
      renderOpenedState: function() {
        this.callBase();
        if (this._widget) {
          this._widget.option("value", this._widget._getCurrentDate());
        }
      },
      _getWidgetOptions: function() {
        return {
          value: this.dateBoxValue() || /* @__PURE__ */ new Date(),
          type: this.dateBox.option("type"),
          minDate: this.dateBox.dateOption("min") || new Date(1900, 0, 1),
          maxDate: this.dateBox.dateOption("max") || new Date(Date.now() + 50 * ui_date_utils_default.ONE_YEAR),
          onDisposing: (function() {
            this._widget = null;
          }).bind(this)
        };
      }
    });
    ui_date_box_strategy_date_view_default = DateViewStrategy;
  }
});

// node_modules/devextreme/esm/ui/date_box/ui.date_box.strategy.native.js
var NativeStrategy2, ui_date_box_strategy_native_default;
var init_ui_date_box_strategy_native = __esm({
  "node_modules/devextreme/esm/ui/date_box/ui.date_box.strategy.native.js"() {
    init_common();
    init_ui_date_box_strategy();
    init_support();
    init_array();
    init_ui_date_utils();
    init_date_serialization();
    init_extend();
    init_devices();
    NativeStrategy2 = ui_date_box_strategy_default.inherit({
      NAME: "Native",
      popupConfig: function(_popupConfig) {
        return extend2({}, _popupConfig, {
          width: "auto"
        });
      },
      getParsedText: function(text, format2) {
        if (!text) {
          return null;
        }
        if ("datetime" === this.dateBox.option("type")) {
          return new Date(text.replace(/-/g, "/").replace("T", " ").split(".")[0]);
        }
        if (this._isTextInput()) {
          return this.callBase(text, format2);
        } else {
          return ui_date_utils_default.fromStandardDateFormat(text);
        }
      },
      _isTextInput: function() {
        return "text" === this.dateBox._input().prop("type");
      },
      renderPopupContent: noop2,
      _getWidgetName: noop2,
      _getWidgetOptions: noop2,
      _getDateBoxType: function() {
        var type2 = this.dateBox.option("type");
        if (-1 === inArray(type2, ui_date_utils_default.SUPPORTED_FORMATS)) {
          type2 = "date";
        } else if ("datetime" === type2 && !inputType(type2)) {
          type2 = "datetime-local";
        }
        return type2;
      },
      customizeButtons: function() {
        var dropDownButton = this.dateBox.getButton("dropDown");
        if (devices_default.real().android && dropDownButton) {
          dropDownButton.on("click", (function() {
            this.dateBox._input().get(0).click();
          }).bind(this));
        }
      },
      getDefaultOptions: function() {
        return {
          mode: this._getDateBoxType()
        };
      },
      getDisplayFormat: function(displayFormat) {
        var type2 = this._getDateBoxType();
        return displayFormat || ui_date_utils_default.FORMATS_MAP[type2];
      },
      renderInputMinMax: function($input) {
        $input.attr({
          min: date_serialization_default.serializeDate(this.dateBox.dateOption("min"), "yyyy-MM-dd"),
          max: date_serialization_default.serializeDate(this.dateBox.dateOption("max"), "yyyy-MM-dd")
        });
      }
    });
    ui_date_box_strategy_native_default = NativeStrategy2;
  }
});

// node_modules/devextreme/esm/ui/editor/ui.data_expression.js
var DataExpressionMixin, ui_data_expression_default;
var init_ui_data_expression = __esm({
  "node_modules/devextreme/esm/ui/editor/ui.data_expression.js"() {
    init_variable_wrapper();
    init_data();
    init_common();
    init_type();
    init_extend();
    init_data_helper();
    init_data_source();
    init_array_store();
    init_deferred();
    DataExpressionMixin = extend2({}, data_helper_default, {
      _dataExpressionDefaultOptions: function() {
        return {
          items: [],
          dataSource: null,
          itemTemplate: "item",
          value: null,
          valueExpr: "this",
          displayExpr: void 0
        };
      },
      _initDataExpressions: function() {
        this._compileValueGetter();
        this._compileDisplayGetter();
        this._initDynamicTemplates();
        this._initDataSource();
        this._itemsToDataSource();
      },
      _itemsToDataSource: function() {
        if (!this.option("dataSource")) {
          this._dataSource = new DataSource({
            store: new array_store_default(this.option("items")),
            pageSize: 0
          });
        }
      },
      _compileDisplayGetter: function() {
        this._displayGetter = compileGetter(this._displayGetterExpr());
      },
      _displayGetterExpr: function() {
        return this.option("displayExpr");
      },
      _compileValueGetter: function() {
        this._valueGetter = compileGetter(this._valueGetterExpr());
      },
      _valueGetterExpr: function() {
        return this.option("valueExpr") || "this";
      },
      _loadValue: function(value2) {
        var deferred = new Deferred();
        value2 = this._unwrappedValue(value2);
        if (!isDefined(value2)) {
          return deferred.reject().promise();
        }
        this._loadSingle(this._valueGetterExpr(), value2).done((function(item) {
          this._isValueEquals(this._valueGetter(item), value2) ? deferred.resolve(item) : deferred.reject();
        }).bind(this)).fail(function() {
          deferred.reject();
        });
        this._loadValueDeferred = deferred;
        return deferred.promise();
      },
      _rejectValueLoading: function() {
        var _this$_loadValueDefer;
        null === (_this$_loadValueDefer = this._loadValueDeferred) || void 0 === _this$_loadValueDefer ? void 0 : _this$_loadValueDefer.reject({
          shouldSkipCallback: true
        });
      },
      _getCurrentValue: function() {
        return this.option("value");
      },
      _unwrappedValue: function(value2) {
        var _value;
        value2 = null !== (_value = value2) && void 0 !== _value ? _value : this._getCurrentValue();
        if (value2 && this._dataSource && "this" === this._valueGetterExpr()) {
          value2 = this._getItemKey(value2);
        }
        return variable_wrapper_default.unwrap(value2);
      },
      _getItemKey: function(value2) {
        var key = this._dataSource.key();
        if (Array.isArray(key)) {
          var result2 = {};
          for (var i = 0, n = key.length; i < n; i++) {
            result2[key[i]] = value2[key[i]];
          }
          return result2;
        }
        if (key && "object" === typeof value2) {
          value2 = value2[key];
        }
        return value2;
      },
      _isValueEquals: function(value1, value2) {
        var dataSourceKey = this._dataSource && this._dataSource.key();
        var result2 = this._compareValues(value1, value2);
        if (!result2 && dataSourceKey && isDefined(value1) && isDefined(value2)) {
          if (Array.isArray(dataSourceKey)) {
            result2 = this._compareByCompositeKey(value1, value2, dataSourceKey);
          } else {
            result2 = this._compareByKey(value1, value2, dataSourceKey);
          }
        }
        return result2;
      },
      _compareByCompositeKey: function(value1, value2, key) {
        var isObject3 = isObject2;
        if (!isObject3(value1) || !isObject3(value2)) {
          return false;
        }
        for (var i = 0, n = key.length; i < n; i++) {
          if (value1[key[i]] !== value2[key[i]]) {
            return false;
          }
        }
        return true;
      },
      _compareByKey: function(value1, value2, key) {
        var unwrapObservable = variable_wrapper_default.unwrap;
        var valueKey1 = ensureDefined(unwrapObservable(value1[key]), value1);
        var valueKey2 = ensureDefined(unwrapObservable(value2[key]), value2);
        return this._compareValues(valueKey1, valueKey2);
      },
      _compareValues: function(value1, value2) {
        return toComparable(value1, true) === toComparable(value2, true);
      },
      _initDynamicTemplates: noop2,
      _setCollectionWidgetItemTemplate: function() {
        this._initDynamicTemplates();
        this._setCollectionWidgetOption("itemTemplate", this.option("itemTemplate"));
      },
      _getCollectionKeyExpr: function() {
        var valueExpr = this.option("valueExpr");
        var isValueExprField = isString2(valueExpr) && "this" !== valueExpr || isFunction(valueExpr);
        return isValueExprField ? valueExpr : null;
      },
      _dataExpressionOptionChanged: function(args) {
        switch (args.name) {
          case "items":
            this._itemsToDataSource();
            this._setCollectionWidgetOption("items");
            break;
          case "dataSource":
            this._initDataSource();
            break;
          case "itemTemplate":
            this._setCollectionWidgetItemTemplate();
            break;
          case "valueExpr":
            this._compileValueGetter();
            break;
          case "displayExpr":
            this._compileDisplayGetter();
            this._initDynamicTemplates();
            this._setCollectionWidgetOption("displayExpr");
        }
      }
    });
    ui_data_expression_default = DataExpressionMixin;
  }
});

// node_modules/devextreme/esm/ui/drop_down_editor/ui.drop_down_list.js
var window24, LIST_ITEM_SELECTOR2, LIST_ITEM_DATA_KEY2, DROPDOWNLIST_POPUP_WRAPPER_CLASS, SEARCH_EVENT, SEARCH_MODES, useCompositionEvents, DropDownList, ui_drop_down_list_default;
var init_ui_drop_down_list = __esm({
  "node_modules/devextreme/esm/ui/drop_down_editor/ui.drop_down_list.js"() {
    init_renderer();
    init_window();
    init_events_engine();
    init_guid();
    init_component_registrator();
    init_common();
    init_type();
    init_extend();
    init_array();
    init_ui_drop_down_editor();
    init_list();
    init_ui_errors();
    init_utils2();
    init_devices();
    init_query();
    init_iterator();
    init_ui_data_expression();
    init_message();
    init_child_default_template();
    init_deferred();
    init_grouped_data_converter_mixin();
    window24 = getWindow();
    LIST_ITEM_SELECTOR2 = ".dx-list-item";
    LIST_ITEM_DATA_KEY2 = "dxListItemData";
    DROPDOWNLIST_POPUP_WRAPPER_CLASS = "dx-dropdownlist-popup-wrapper";
    SEARCH_EVENT = "input";
    SEARCH_MODES = ["startswith", "contains", "endwith", "notcontains"];
    useCompositionEvents = "android" !== devices_default.real().platform;
    DropDownList = ui_drop_down_editor_default.inherit({
      _supportedKeys: function() {
        var parent = this.callBase();
        return extend2({}, parent, {
          tab: function(e) {
            if (this._allowSelectItemByTab()) {
              this._saveValueChangeEvent(e);
              var $focusedItem = renderer_default(this._list.option("focusedElement"));
              $focusedItem.length && this._setSelectedElement($focusedItem);
            }
            parent.tab.apply(this, arguments);
          },
          space: noop2,
          home: noop2,
          end: noop2
        });
      },
      _allowSelectItemByTab: function() {
        return this.option("opened") && "instantly" === this.option("applyValueMode");
      },
      _setSelectedElement: function($element) {
        var value2 = this._valueGetter(this._list._getItemData($element));
        this._setValue(value2);
      },
      _setValue: function(value2) {
        this.option("value", value2);
      },
      _getDefaultOptions: function() {
        return extend2(this.callBase(), extend2(ui_data_expression_default._dataExpressionDefaultOptions(), {
          displayValue: void 0,
          searchEnabled: false,
          searchMode: "contains",
          searchTimeout: 500,
          minSearchLength: 0,
          searchExpr: null,
          valueChangeEvent: "input change keyup",
          selectedItem: null,
          noDataText: message_default.format("dxCollectionWidget-noDataText"),
          onSelectionChanged: null,
          onItemClick: noop2,
          showDataBeforeSearch: false,
          grouped: false,
          groupTemplate: "group",
          popupPosition: {
            my: "left top",
            at: "left bottom",
            offset: {
              h: 0,
              v: 0
            },
            collision: "flip"
          },
          wrapItemText: false,
          useItemTextAsTitle: false
        }));
      },
      _defaultOptionsRules: function() {
        return this.callBase().concat([{
          device: {
            platform: "ios"
          },
          options: {
            popupPosition: {
              offset: {
                v: -1
              }
            }
          }
        }, {
          device: {
            platform: "generic"
          },
          options: {
            buttonsLocation: "bottom center"
          }
        }]);
      },
      _setOptionsByReference: function() {
        this.callBase();
        extend2(this._optionsByReference, {
          value: true,
          selectedItem: true,
          displayValue: true
        });
      },
      _init: function() {
        this.callBase();
        this._initDataExpressions();
        this._initActions();
        this._setListDataSource();
        this._validateSearchMode();
        this._clearSelectedItem();
        this._initItems();
      },
      _setListFocusedElementOptionChange: function() {
        this._list._updateParentActiveDescendant = this._updateActiveDescendant.bind(this);
      },
      _initItems: function() {
        var items = this.option().items;
        if (items && !items.length && this._dataSource) {
          this.option().items = this._dataSource.items();
        }
      },
      _initActions: function() {
        this._initContentReadyAction();
        this._initSelectionChangedAction();
        this._initItemClickAction();
      },
      _initContentReadyAction: function() {
        this._contentReadyAction = this._createActionByOption("onContentReady", {
          excludeValidators: ["disabled", "readOnly"]
        });
      },
      _initSelectionChangedAction: function() {
        this._selectionChangedAction = this._createActionByOption("onSelectionChanged", {
          excludeValidators: ["disabled", "readOnly"]
        });
      },
      _initItemClickAction: function() {
        this._itemClickAction = this._createActionByOption("onItemClick");
      },
      _initTemplates: function() {
        this.callBase();
        this._templateManager.addDefaultTemplates({
          item: new ChildDefaultTemplate("item")
        });
      },
      _isEditable: function() {
        return this.callBase() || this.option("searchEnabled");
      },
      _saveFocusOnWidget: function(e) {
        if (this._list && this._list.initialOption("focusStateEnabled")) {
          this._focusInput();
        }
      },
      _fitIntoRange: function(value2, start, end) {
        if (value2 > end) {
          return start;
        }
        if (value2 < start) {
          return end;
        }
        return value2;
      },
      _items: function() {
        var items = this._getPlainItems(!this._list && this._dataSource.items());
        var availableItems = new query_default(items).filter("disabled", "<>", true).toArray();
        return availableItems;
      },
      _calcNextItem: function(step) {
        var items = this._items();
        var nextIndex = this._fitIntoRange(this._getSelectedIndex() + step, 0, items.length - 1);
        return items[nextIndex];
      },
      _getSelectedIndex: function() {
        var items = this._items();
        var selectedItem = this.option("selectedItem");
        var result2 = -1;
        each(items, (function(index2, item) {
          if (this._isValueEquals(item, selectedItem)) {
            result2 = index2;
            return false;
          }
        }).bind(this));
        return result2;
      },
      _createPopup: function() {
        this.callBase();
        this._updateCustomBoundaryContainer();
        this._popup.$wrapper().addClass(this._popupWrapperClass());
        var $popupContent = this._popup.$content();
        events_engine_default.off($popupContent, "mouseup");
        events_engine_default.on($popupContent, "mouseup", this._saveFocusOnWidget.bind(this));
      },
      _updateCustomBoundaryContainer: function() {
        var customContainer = this.option("dropDownOptions.container");
        var $container = customContainer && renderer_default(customContainer);
        if ($container && $container.length && !isWindow($container.get(0))) {
          var $containerWithParents = [].slice.call($container.parents());
          $containerWithParents.unshift($container.get(0));
          each($containerWithParents, (function(i, parent) {
            if (parent === renderer_default("body").get(0)) {
              return false;
            } else if ("hidden" === window24.getComputedStyle(parent).overflowY) {
              this._$customBoundaryContainer = renderer_default(parent);
              return false;
            }
          }).bind(this));
        }
      },
      _popupWrapperClass: function() {
        return DROPDOWNLIST_POPUP_WRAPPER_CLASS;
      },
      _renderInputValue: function() {
        var value2 = this._getCurrentValue();
        this._rejectValueLoading();
        return this._loadInputValue(value2, this._setSelectedItem.bind(this)).always(this.callBase.bind(this, value2));
      },
      _loadInputValue: function(value2, callback) {
        return this._loadItem(value2).always(callback);
      },
      _getItemFromPlain: function(value2, cache) {
        var plainItems;
        var selectedItem;
        if (cache && "object" !== typeof value2) {
          if (!cache.itemByValue) {
            cache.itemByValue = {};
            plainItems = this._getPlainItems();
            plainItems.forEach(function(item) {
              cache.itemByValue[this._valueGetter(item)] = item;
            }, this);
          }
          selectedItem = cache.itemByValue[value2];
        }
        if (!selectedItem) {
          plainItems = this._getPlainItems();
          selectedItem = grep(plainItems, (function(item) {
            return this._isValueEquals(this._valueGetter(item), value2);
          }).bind(this))[0];
        }
        return selectedItem;
      },
      _loadItem: function(value2, cache) {
        var selectedItem = this._getItemFromPlain(value2, cache);
        return void 0 !== selectedItem ? new Deferred().resolve(selectedItem).promise() : this._loadValue(value2);
      },
      _getPlainItems: function(items) {
        var plainItems = [];
        items = items || this.option("items") || this._dataSource.items() || [];
        for (var i = 0; i < items.length; i++) {
          if (items[i] && items[i].items) {
            plainItems = plainItems.concat(items[i].items);
          } else {
            plainItems.push(items[i]);
          }
        }
        return plainItems;
      },
      _updateActiveDescendant() {
        var _this$_list;
        var opened = this.option("opened");
        var listFocusedItemId = null === (_this$_list = this._list) || void 0 === _this$_list ? void 0 : _this$_list.getFocusedItemId();
        var isElementOnDom = renderer_default("#".concat(listFocusedItemId)).length > 0;
        var activedescendant = opened && isElementOnDom && listFocusedItemId;
        this.setAria({
          activedescendant: activedescendant || null
        });
      },
      _setSelectedItem: function(item) {
        var displayValue = this._displayValue(item);
        this.option("selectedItem", ensureDefined(item, null));
        this.option("displayValue", displayValue);
      },
      _displayValue: function(item) {
        return this._displayGetter(item);
      },
      _refreshSelected: function() {
        var cache = {};
        this._listItemElements().each((function(_2, itemElement) {
          var $itemElement = renderer_default(itemElement);
          var itemValue = this._valueGetter($itemElement.data(LIST_ITEM_DATA_KEY2));
          var isItemSelected = this._isSelectedValue(itemValue, cache);
          if (isItemSelected) {
            this._list.selectItem($itemElement);
          } else {
            this._list.unselectItem($itemElement);
          }
        }).bind(this));
      },
      _popupShownHandler: function() {
        this.callBase();
        this._setFocusPolicy();
      },
      _setFocusPolicy: function() {
        if (!this.option("focusStateEnabled") || !this._list) {
          return;
        }
        this._list.option("focusedElement", null);
      },
      _isSelectedValue: function(value2) {
        return this._isValueEquals(value2, this.option("value"));
      },
      _validateSearchMode: function() {
        var searchMode = this.option("searchMode");
        var normalizedSearchMode = searchMode.toLowerCase();
        if (inArray(normalizedSearchMode, SEARCH_MODES) < 0) {
          throw ui_errors_default.Error("E1019", searchMode);
        }
      },
      _clearSelectedItem: function() {
        this.option("selectedItem", null);
      },
      _processDataSourceChanging: function() {
        this._setListDataSource();
        this._renderInputValue().fail((function() {
          if (this._isCustomValueAllowed()) {
            return;
          }
          this._clearSelectedItem();
        }).bind(this));
      },
      _isCustomValueAllowed: function() {
        return this.option("displayCustomValue");
      },
      reset: function() {
        this.callBase();
        this._clearFilter();
        this._clearSelectedItem();
      },
      _listItemElements: function() {
        return this._$list ? this._$list.find(LIST_ITEM_SELECTOR2) : renderer_default();
      },
      _popupConfig: function() {
        return extend2(this.callBase(), {
          templatesRenderAsynchronously: false,
          autoResizeEnabled: false,
          maxHeight: this._getMaxHeight.bind(this)
        });
      },
      _renderPopupContent: function() {
        this.callBase();
        this._renderList();
      },
      _getKeyboardListeners() {
        var canListHaveFocus = this._canListHaveFocus();
        return this.callBase().concat([!canListHaveFocus && this._list]);
      },
      _setAriaTargetForList: function() {
        this._list._getAriaTarget = this._getAriaTarget.bind(this);
      },
      _renderList: function() {
        this._listId = "dx-" + new guid_default()._value;
        var $list = this._$list = renderer_default("<div>").attr("id", this._listId).appendTo(this._popup.$content());
        this._list = this._createComponent($list, list_default, this._listConfig());
        this._refreshList();
        this._setAriaTargetForList();
        this._list.option("_listAttributes", {
          role: "combobox"
        });
        this._renderPreventBlurOnListClick();
        this._setListFocusedElementOptionChange();
      },
      _renderPreventBlurOnListClick: function() {
        var eventName = addNamespace2("mousedown", "dxDropDownList");
        events_engine_default.off(this._$list, eventName);
        events_engine_default.on(this._$list, eventName, (e) => e.preventDefault());
      },
      _renderOpenedState: function() {
        this.callBase();
        this._list && this._updateActiveDescendant();
        this.setAria({
          controls: this._list && this._listId,
          owns: this._popup && this._popupContentId
        });
      },
      _setDefaultAria: function() {
        this.setAria({
          haspopup: "listbox",
          autocomplete: "list"
        });
      },
      _refreshList: function() {
        if (this._list && this._shouldRefreshDataSource()) {
          this._setListDataSource();
        }
      },
      _shouldRefreshDataSource: function() {
        var dataSourceProvided = !!this._list.option("dataSource");
        return dataSourceProvided !== this._needPassDataSourceToList();
      },
      _isDesktopDevice: function() {
        return "desktop" === devices_default.real().deviceType;
      },
      _listConfig: function() {
        var options2 = {
          selectionMode: "single",
          _templates: this.option("_templates"),
          templateProvider: this.option("templateProvider"),
          noDataText: this.option("noDataText"),
          grouped: this.option("grouped"),
          wrapItemText: this.option("wrapItemText"),
          useItemTextAsTitle: this.option("useItemTextAsTitle"),
          onContentReady: this._listContentReadyHandler.bind(this),
          itemTemplate: this.option("itemTemplate"),
          indicateLoading: false,
          keyExpr: this._getCollectionKeyExpr(),
          displayExpr: this._displayGetterExpr(),
          groupTemplate: this.option("groupTemplate"),
          onItemClick: this._listItemClickAction.bind(this),
          dataSource: this._getDataSource(),
          _revertPageOnEmptyLoad: true,
          hoverStateEnabled: this._isDesktopDevice() ? this.option("hoverStateEnabled") : false,
          focusStateEnabled: this._isDesktopDevice() ? this.option("focusStateEnabled") : false
        };
        if (!this._canListHaveFocus()) {
          options2.tabIndex = null;
        }
        return options2;
      },
      _canListHaveFocus: () => false,
      _getDataSource: function() {
        return this._needPassDataSourceToList() ? this._dataSource : null;
      },
      _dataSourceOptions: function() {
        return {
          paginate: false
        };
      },
      _getGroupedOption: function() {
        return this.option("grouped");
      },
      _dataSourceFromUrlLoadMode: function() {
        return "raw";
      },
      _listContentReadyHandler: function() {
        this._list = this._list || this._$list.dxList("instance");
        if (!this.option("deferRendering")) {
          this._refreshSelected();
        }
        this._dimensionChanged();
        this._contentReadyAction();
      },
      _setListOption: function(optionName, value2) {
        this._setWidgetOption("_list", arguments);
      },
      _listItemClickAction: function(e) {
        this._listItemClickHandler(e);
        this._itemClickAction(e);
      },
      _listItemClickHandler: noop2,
      _setListDataSource: function() {
        if (!this._list) {
          return;
        }
        this._setListOption("dataSource", this._getDataSource());
        if (!this._needPassDataSourceToList()) {
          this._setListOption("items", []);
        }
      },
      _needPassDataSourceToList: function() {
        return this.option("showDataBeforeSearch") || this._isMinSearchLengthExceeded();
      },
      _isMinSearchLengthExceeded: function() {
        return this._searchValue().toString().length >= this.option("minSearchLength");
      },
      _needClearFilter: function() {
        return this._canKeepDataSource() ? false : this._needPassDataSourceToList();
      },
      _canKeepDataSource: function() {
        var _this$_dataSource;
        var isMinSearchLengthExceeded = this._isMinSearchLengthExceeded();
        return (null === (_this$_dataSource = this._dataSource) || void 0 === _this$_dataSource ? void 0 : _this$_dataSource.isLoaded()) && this.option("showDataBeforeSearch") && this.option("minSearchLength") && !isMinSearchLengthExceeded && !this._isLastMinSearchLengthExceeded;
      },
      _searchValue: function() {
        return this._input().val() || "";
      },
      _getSearchEvent: function() {
        return addNamespace2(SEARCH_EVENT, this.NAME + "Search");
      },
      _getCompositionStartEvent: function() {
        return addNamespace2("compositionstart", this.NAME + "CompositionStart");
      },
      _getCompositionEndEvent: function() {
        return addNamespace2("compositionend", this.NAME + "CompositionEnd");
      },
      _getSetFocusPolicyEvent: function() {
        return addNamespace2("input", this.NAME + "FocusPolicy");
      },
      _renderEvents: function() {
        this.callBase();
        events_engine_default.on(this._input(), this._getSetFocusPolicyEvent(), () => {
          this._setFocusPolicy();
        });
        if (this._shouldRenderSearchEvent()) {
          events_engine_default.on(this._input(), this._getSearchEvent(), (e) => {
            this._searchHandler(e);
          });
          if (useCompositionEvents) {
            events_engine_default.on(this._input(), this._getCompositionStartEvent(), () => {
              this._isTextCompositionInProgress(true);
            });
            events_engine_default.on(this._input(), this._getCompositionEndEvent(), (e) => {
              this._isTextCompositionInProgress(void 0);
              this._searchHandler(e, this._searchValue());
            });
          }
        }
      },
      _shouldRenderSearchEvent: function() {
        return this.option("searchEnabled");
      },
      _refreshEvents: function() {
        events_engine_default.off(this._input(), this._getSearchEvent());
        events_engine_default.off(this._input(), this._getSetFocusPolicyEvent());
        if (useCompositionEvents) {
          events_engine_default.off(this._input(), this._getCompositionStartEvent());
          events_engine_default.off(this._input(), this._getCompositionEndEvent());
        }
        this.callBase();
      },
      _isTextCompositionInProgress: function(value2) {
        if (arguments.length) {
          this._isTextComposition = value2;
        } else {
          return this._isTextComposition;
        }
      },
      _searchHandler: function(e, searchValue) {
        if (this._isTextCompositionInProgress()) {
          return;
        }
        if (!this._isMinSearchLengthExceeded()) {
          this._searchCanceled();
          return;
        }
        var searchTimeout = this.option("searchTimeout");
        if (searchTimeout) {
          this._clearSearchTimer();
          this._searchTimer = setTimeout(() => {
            this._searchDataSource(searchValue);
          }, searchTimeout);
        } else {
          this._searchDataSource(searchValue);
        }
      },
      _searchCanceled: function() {
        this._clearSearchTimer();
        if (this._needClearFilter()) {
          this._filterDataSource(null);
        }
        this._refreshList();
      },
      _searchDataSource: function() {
        var searchValue = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this._searchValue();
        this._filterDataSource(searchValue);
      },
      _filterDataSource: function(searchValue) {
        this._clearSearchTimer();
        var dataSource = this._dataSource;
        if (dataSource) {
          dataSource.searchExpr(this.option("searchExpr") || this._displayGetterExpr());
          dataSource.searchOperation(this.option("searchMode"));
          dataSource.searchValue(searchValue);
          dataSource.load().done(this._dataSourceFiltered.bind(this, searchValue));
        }
      },
      _clearFilter: function() {
        var dataSource = this._dataSource;
        dataSource && dataSource.searchValue() && dataSource.searchValue(null);
      },
      _dataSourceFiltered: function() {
        this._isLastMinSearchLengthExceeded = this._isMinSearchLengthExceeded();
        this._refreshList();
        this._refreshPopupVisibility();
      },
      _shouldOpenPopup: function() {
        return this._hasItemsToShow();
      },
      _refreshPopupVisibility: function() {
        if (this.option("readOnly") || !this._searchValue()) {
          return;
        }
        var shouldOpenPopup = this._shouldOpenPopup();
        if (shouldOpenPopup && !this._isFocused()) {
          return;
        }
        this.option("opened", shouldOpenPopup);
        if (shouldOpenPopup) {
          this._dimensionChanged();
        }
      },
      _dataSourceChangedHandler: function(newItems) {
        if (0 === this._dataSource.pageIndex()) {
          this.option().items = newItems;
        } else {
          this.option().items = this.option().items.concat(newItems);
        }
      },
      _hasItemsToShow: function() {
        var resultItems = this._dataSource && this._dataSource.items() || [];
        var resultAmount = resultItems.length;
        var isMinSearchLengthExceeded = this._needPassDataSourceToList();
        return !!(isMinSearchLengthExceeded && resultAmount);
      },
      _clearSearchTimer: function() {
        clearTimeout(this._searchTimer);
        delete this._searchTimer;
      },
      _popupShowingHandler: function() {
        this._dimensionChanged();
      },
      _dimensionChanged: function() {
        this.callBase(arguments);
        this._popup && this._updatePopupDimensions();
      },
      _needPopupRepaint: function() {
        if (!this._dataSource) {
          return false;
        }
        var currentPageIndex = this._dataSource.pageIndex();
        var needRepaint = isDefined(this._pageIndex) && currentPageIndex <= this._pageIndex;
        this._pageIndex = currentPageIndex;
        return needRepaint;
      },
      _updatePopupDimensions: function() {
        if (this._needPopupRepaint()) {
          this._popup.repaint();
        }
        this._list && this._list.updateDimensions();
      },
      _getMaxHeight: function() {
        var $element = this.$element();
        var $customBoundaryContainer = this._$customBoundaryContainer;
        var offsetTop = $element.offset().top - ($customBoundaryContainer ? $customBoundaryContainer.offset().top : 0);
        var windowHeight = renderer_default(window24).outerHeight();
        var containerHeight = $customBoundaryContainer ? Math.min($customBoundaryContainer.outerHeight(), windowHeight) : windowHeight;
        var maxHeight = Math.max(offsetTop, containerHeight - offsetTop - $element.outerHeight());
        return Math.min(0.5 * containerHeight, maxHeight);
      },
      _clean: function() {
        if (this._list) {
          delete this._list;
        }
        delete this._isLastMinSearchLengthExceeded;
        this.callBase();
      },
      _dispose: function() {
        this._clearSearchTimer();
        this.callBase();
      },
      _setCollectionWidgetOption: function() {
        this._setListOption.apply(this, arguments);
      },
      _setSubmitValue: function() {
        var value2 = this.option("value");
        var submitValue = this._shouldUseDisplayValue(value2) ? this._displayGetter(value2) : value2;
        this._getSubmitElement().val(submitValue);
      },
      _shouldUseDisplayValue: function(value2) {
        return "this" === this.option("valueExpr") && isObject2(value2);
      },
      _optionChanged: function(args) {
        this._dataExpressionOptionChanged(args);
        switch (args.name) {
          case "hoverStateEnabled":
          case "focusStateEnabled":
            this._isDesktopDevice() && this._setListOption(args.name, args.value);
            this.callBase(args);
            break;
          case "items":
            if (!this.option("dataSource")) {
              this._processDataSourceChanging();
            }
            break;
          case "dataSource":
            this._processDataSourceChanging();
            break;
          case "valueExpr":
            this._renderValue();
            this._setListOption("keyExpr", this._getCollectionKeyExpr());
            break;
          case "displayExpr":
            this._renderValue();
            this._setListOption("displayExpr", this._displayGetterExpr());
            break;
          case "searchMode":
            this._validateSearchMode();
            break;
          case "minSearchLength":
            this._refreshList();
            break;
          case "searchEnabled":
          case "showDataBeforeSearch":
          case "searchExpr":
            this._invalidate();
            break;
          case "onContentReady":
            this._initContentReadyAction();
            break;
          case "onSelectionChanged":
            this._initSelectionChangedAction();
            break;
          case "onItemClick":
            this._initItemClickAction();
            break;
          case "grouped":
          case "groupTemplate":
          case "wrapItemText":
          case "noDataText":
          case "useItemTextAsTitle":
            this._setListOption(args.name);
            break;
          case "displayValue":
            this.option("text", args.value);
            break;
          case "itemTemplate":
          case "searchTimeout":
            break;
          case "selectedItem":
            if (args.previousValue !== args.value) {
              this._selectionChangedAction({
                selectedItem: args.value
              });
            }
            break;
          default:
            this.callBase(args);
        }
      }
    }).include(ui_data_expression_default, grouped_data_converter_mixin_default);
    component_registrator_default("dxDropDownList", DropDownList);
    ui_drop_down_list_default = DropDownList;
  }
});

// node_modules/devextreme/esm/ui/select_box.js
var DISABLED_STATE_SELECTOR, SELECTBOX_CLASS, SELECTBOX_POPUP_CLASS, SELECTBOX_CONTAINER_CLASS, SELECTBOX_POPUP_WRAPPER_CLASS, SelectBox, select_box_default;
var init_select_box = __esm({
  "node_modules/devextreme/esm/ui/select_box.js"() {
    init_renderer();
    init_common();
    init_type();
    init_extend();
    init_array();
    init_iterator();
    init_deferred();
    init_element();
    init_errors();
    init_dom_adapter();
    init_utils_ink_ripple();
    init_message();
    init_component_registrator();
    init_ui_drop_down_list();
    init_utils2();
    DISABLED_STATE_SELECTOR = ".dx-state-disabled";
    SELECTBOX_CLASS = "dx-selectbox";
    SELECTBOX_POPUP_CLASS = "dx-selectbox-popup";
    SELECTBOX_CONTAINER_CLASS = "dx-selectbox-container";
    SELECTBOX_POPUP_WRAPPER_CLASS = "dx-selectbox-popup-wrapper";
    SelectBox = ui_drop_down_list_default.inherit({
      _supportedKeys: function() {
        var that = this;
        var parent = this.callBase();
        var clearSelectBox = function(e) {
          var isEditable = this._isEditable();
          if (!isEditable) {
            if (this.option("showClearButton")) {
              e.preventDefault();
              this.reset();
            }
          } else if (this._valueSubstituted()) {
            this._preventFiltering = true;
          }
          this._savedTextRemoveEvent = e;
          this._preventSubstitution = true;
        };
        var searchIfNeeded = function() {
          if (that.option("searchEnabled") && that._valueSubstituted()) {
            that._searchHandler();
          }
        };
        return extend2({}, parent, {
          tab: function() {
            if (this.option("opened") && "instantly" === this.option("applyValueMode")) {
              this._resetCaretPosition(true);
            }
            parent.tab && parent.tab.apply(this, arguments);
            this._cancelSearchIfNeed();
          },
          upArrow: function(e) {
            if (parent.upArrow && parent.upArrow.apply(this, arguments)) {
              if (!this.option("opened")) {
                this._setNextValue(e);
              }
              return true;
            }
          },
          downArrow: function(e) {
            if (parent.downArrow && parent.downArrow.apply(this, arguments)) {
              if (!this.option("opened")) {
                this._setNextValue(e);
              }
              return true;
            }
          },
          leftArrow: function() {
            searchIfNeeded();
            parent.leftArrow && parent.leftArrow.apply(this, arguments);
          },
          rightArrow: function() {
            searchIfNeeded();
            parent.rightArrow && parent.rightArrow.apply(this, arguments);
          },
          home: function() {
            searchIfNeeded();
            parent.home && parent.home.apply(this, arguments);
          },
          end: function() {
            searchIfNeeded();
            parent.end && parent.end.apply(this, arguments);
          },
          escape: function() {
            var result2 = parent.escape && parent.escape.apply(this, arguments);
            this._cancelEditing();
            return null !== result2 && void 0 !== result2 ? result2 : true;
          },
          enter: function(e) {
            var isOpened = this.option("opened");
            var inputText = this._input().val().trim();
            var isCustomText = inputText && this._list && !this._list.option("focusedElement");
            if (!inputText && isDefined(this.option("value")) && this.option("allowClearing")) {
              this._saveValueChangeEvent(e);
              this.option({
                selectedItem: null,
                value: null
              });
              this.close();
            } else {
              if (this.option("acceptCustomValue")) {
                e.preventDefault();
                if (isCustomText) {
                  if (isOpened) {
                    this._toggleOpenState();
                  }
                  this._valueChangeEventHandler(e);
                }
                return isOpened;
              }
              if (parent.enter && parent.enter.apply(this, arguments)) {
                return isOpened;
              }
            }
          },
          space: function(e) {
            var isOpened = this.option("opened");
            var isSearchEnabled2 = this.option("searchEnabled");
            var acceptCustomValue = this.option("acceptCustomValue");
            if (!isOpened || isSearchEnabled2 || acceptCustomValue) {
              return;
            }
            e.preventDefault();
            this._valueChangeEventHandler(e);
            return true;
          },
          backspace: clearSelectBox,
          del: clearSelectBox
        });
      },
      _getDefaultOptions: function() {
        return extend2(this.callBase(), {
          placeholder: message_default.format("Select"),
          fieldTemplate: null,
          valueChangeEvent: "change",
          acceptCustomValue: false,
          onCustomItemCreating: function(e) {
            if (!isDefined(e.customItem)) {
              e.customItem = e.text;
            }
          },
          showSelectionControls: false,
          allowClearing: true,
          tooltipEnabled: false,
          openOnFieldClick: true,
          showDropDownButton: true,
          displayCustomValue: false,
          useInkRipple: false,
          useHiddenSubmitElement: true
        });
      },
      _init: function() {
        this.callBase();
        this._initCustomItemCreatingAction();
      },
      _initMarkup: function() {
        this.$element().addClass(SELECTBOX_CLASS);
        this._renderTooltip();
        this.option("useInkRipple") && this._renderInkRipple();
        this.callBase();
        this._$container.addClass(SELECTBOX_CONTAINER_CLASS);
      },
      _renderInkRipple: function() {
        this._inkRipple = render();
      },
      _toggleActiveState: function($element, value2, e) {
        this.callBase.apply(this, arguments);
        if (!this._inkRipple || this._isEditable()) {
          return;
        }
        var config2 = {
          element: this._inputWrapper(),
          event: e
        };
        if (value2) {
          this._inkRipple.showWave(config2);
        } else {
          this._inkRipple.hideWave(config2);
        }
      },
      _createPopup: function() {
        this.callBase();
        this._popup.$element().addClass(SELECTBOX_POPUP_CLASS);
        this._popup.$overlayContent().attr("tabindex", -1);
      },
      _popupWrapperClass: function() {
        return this.callBase() + " " + SELECTBOX_POPUP_WRAPPER_CLASS;
      },
      _cancelEditing: function() {
        if (!this.option("searchEnabled") && this._list) {
          this._focusListElement(null);
          this._updateField(this.option("selectedItem"));
        }
      },
      _renderOpenedState: function() {
        this.callBase();
        if (this.option("opened")) {
          this._scrollToSelectedItem();
          this._focusSelectedElement();
        }
      },
      _focusSelectedElement: function() {
        var searchValue = this._searchValue();
        if (!searchValue) {
          this._focusListElement(null);
          return;
        }
        var $listItems = this._list._itemElements();
        var index2 = inArray(this.option("selectedItem"), this.option("items"));
        var focusedElement = index2 >= 0 && !this._isCustomItemSelected() ? $listItems.eq(index2) : null;
        this._focusListElement(focusedElement);
      },
      _renderFocusedElement: function() {
        if (!this._list) {
          return;
        }
        var searchValue = this._searchValue();
        if (!searchValue || this.option("acceptCustomValue")) {
          this._focusListElement(null);
          return;
        }
        var $listItems = this._list._itemElements();
        var focusedElement = $listItems.not(DISABLED_STATE_SELECTOR).eq(0);
        this._focusListElement(focusedElement);
      },
      _focusListElement: function(element) {
        this._preventInputValueRender = true;
        this._list.option("focusedElement", getPublicElement(element));
        delete this._preventInputValueRender;
      },
      _scrollToSelectedItem: function() {
        this._list && this._list.scrollToItem(this._list.option("selectedItem"));
      },
      _listContentReadyHandler: function() {
        this.callBase();
        var isPaginate = this._dataSource && this._dataSource.paginate();
        if (isPaginate && this._needPopupRepaint()) {
          return;
        }
        this._scrollToSelectedItem();
      },
      _renderValue: function() {
        this._renderInputValue();
        this._setSubmitValue();
        return new Deferred().resolve();
      },
      _renderInputValue: function() {
        return this.callBase().always((function() {
          this._renderInputValueAsync();
        }).bind(this));
      },
      _renderInputValueAsync: function() {
        this._renderTooltip();
        this._renderInputValueImpl().always((function() {
          this._refreshSelected();
        }).bind(this));
      },
      _renderInputValueImpl: function() {
        this._renderField();
        return new Deferred().resolve();
      },
      _setNextItem: function(step) {
        var item = this._calcNextItem(step);
        var value2 = this._valueGetter(item);
        this._setValue(value2);
      },
      _setNextValue: function(e) {
        var dataSourceIsLoaded = this._dataSource.isLoaded() ? new Deferred().resolve() : this._dataSource.load();
        dataSourceIsLoaded.done((function() {
          var selectedIndex = this._getSelectedIndex();
          var hasPages = this._dataSource.pageSize();
          var isLastPage = this._dataSource.isLastPage();
          var isLastItem = selectedIndex === this._items().length - 1;
          this._saveValueChangeEvent(e);
          var step = "downArrow" === normalizeKeyName(e) ? 1 : -1;
          if (hasPages && !isLastPage && isLastItem && step > 0) {
            if (!this._popup) {
              this._createPopup();
            }
            if (!this._dataSource.isLoading()) {
              this._list._loadNextPage().done(this._setNextItem.bind(this, step));
            }
          } else {
            this._setNextItem(step);
          }
        }).bind(this));
      },
      _setSelectedItem: function(item) {
        var isUnknownItem = !this._isCustomValueAllowed() && void 0 === item;
        this.callBase(isUnknownItem ? null : item);
        if (!isUnknownItem && (!this._isEditable() || this._isCustomItemSelected())) {
          this._setListOption("selectedItem", this.option("selectedItem"));
        }
      },
      _isCustomValueAllowed: function() {
        return this.option("acceptCustomValue") || this.callBase();
      },
      _displayValue: function(item) {
        item = !isDefined(item) && this._isCustomValueAllowed() ? this.option("value") : item;
        return this.callBase(item);
      },
      _listConfig: function() {
        var result2 = extend2(this.callBase(), {
          pageLoadMode: "scrollBottom",
          onSelectionChanged: this._getSelectionChangeHandler(),
          selectedItem: this.option("selectedItem"),
          onFocusedItemChanged: this._listFocusedItemChangeHandler.bind(this)
        });
        if (this.option("showSelectionControls")) {
          extend2(result2, {
            showSelectionControls: true,
            selectionByClick: true
          });
        }
        return result2;
      },
      _listFocusedItemChangeHandler: function(e) {
        if (this._preventInputValueRender) {
          return;
        }
        var list = e.component;
        var focusedElement = renderer_default(list.option("focusedElement"));
        var focusedItem = list._getItemData(focusedElement);
        this._updateField(focusedItem);
      },
      _updateField: function(item) {
        var fieldTemplate = this._getTemplateByOption("fieldTemplate");
        if (!(fieldTemplate && this.option("fieldTemplate"))) {
          var text = this._displayGetter(item);
          this.option("text", text);
          this._renderDisplayText(text);
          return;
        }
        this._renderField();
      },
      _getSelectionChangeHandler: function() {
        return this.option("showSelectionControls") ? this._selectionChangeHandler.bind(this) : noop2;
      },
      _selectionChangeHandler: function(e) {
        each(e.addedItems || [], (function(_2, addedItem) {
          this._setValue(this._valueGetter(addedItem));
        }).bind(this));
      },
      _getActualSearchValue: function() {
        return this._dataSource.searchValue();
      },
      _toggleOpenState: function(isVisible2) {
        if (this.option("disabled")) {
          return;
        }
        isVisible2 = arguments.length ? isVisible2 : !this.option("opened");
        if (!isVisible2 && !this._shouldClearFilter()) {
          this._restoreInputText(true);
        }
        if (this._wasSearch() && isVisible2) {
          this._wasSearch(false);
          var showDataImmediately = this.option("showDataBeforeSearch") || this._isMinSearchLengthExceeded();
          if (showDataImmediately && this._dataSource) {
            if (this._searchTimer) {
              return;
            }
            var searchValue = this._getActualSearchValue();
            searchValue && this._wasSearch(true);
            this._filterDataSource(searchValue || null);
          } else {
            this._setListOption("items", []);
          }
        }
        if (isVisible2) {
          this._scrollToSelectedItem();
        }
        this.callBase(isVisible2);
      },
      _renderTooltip: function() {
        if (this.option("tooltipEnabled")) {
          this.$element().attr("title", this.option("displayValue"));
        }
      },
      _renderDimensions: function() {
        this.callBase();
        this._dimensionChanged();
      },
      _isValueEqualInputText: function() {
        var initialSelectedItem = this.option("selectedItem");
        if (null === initialSelectedItem) {
          return false;
        }
        var value2 = this._displayGetter(initialSelectedItem);
        var displayValue = value2 ? String(value2) : "";
        var inputText = this._searchValue();
        return displayValue === inputText;
      },
      _popupHidingHandler: function() {
        if (this._isValueEqualInputText()) {
          this._cancelEditing();
        }
        this.callBase();
      },
      _popupHiddenHandler: function() {
        this.callBase();
        if (this._shouldCancelSearch()) {
          this._wasSearch(false);
          this._searchCanceled();
          this._shouldCancelSearch(false);
        }
      },
      _restoreInputText: function(saveEditingValue) {
        if (this.option("readOnly")) {
          return;
        }
        this._loadItemDeferred && this._loadItemDeferred.always((function() {
          var {
            selectedItem: initialSelectedItem,
            text
          } = this.option();
          if (this.option("acceptCustomValue")) {
            if (!saveEditingValue) {
              this._updateField(null !== initialSelectedItem && void 0 !== initialSelectedItem ? initialSelectedItem : this._createCustomItem(text));
              this._clearFilter();
            }
            return;
          }
          if (this.option("searchEnabled")) {
            if (!this._searchValue() && this.option("allowClearing")) {
              this._clearTextValue();
              return;
            }
          }
          if (this._isValueEqualInputText()) {
            return;
          }
          this._renderInputValue().always((function(selectedItem) {
            var newSelectedItem = ensureDefined(selectedItem, initialSelectedItem);
            this._setSelectedItem(newSelectedItem);
            this._updateField(newSelectedItem);
            this._clearFilter();
          }).bind(this));
        }).bind(this));
      },
      _focusOutHandler: function(e) {
        if (!this._preventNestedFocusEvent(e)) {
          var isOverlayTarget = this._isOverlayNestedTarget(e.relatedTarget);
          if (!isOverlayTarget) {
            this._restoreInputText();
            this._clearSearchTimer();
          }
          this._cancelSearchIfNeed(e);
        }
        e.target = this._input().get(0);
        this.callBase(e);
      },
      _cancelSearchIfNeed: function(e) {
        var {
          searchEnabled
        } = this.option();
        var isOverlayTarget = this._isOverlayNestedTarget(null === e || void 0 === e ? void 0 : e.relatedTarget);
        var shouldCancelSearch = this._wasSearch() && searchEnabled && !isOverlayTarget;
        if (shouldCancelSearch) {
          var _this$_popup;
          var isPopupVisible = null === (_this$_popup = this._popup) || void 0 === _this$_popup ? void 0 : _this$_popup._hideAnimationProcessing;
          this._clearSearchTimer();
          if (isPopupVisible) {
            this._shouldCancelSearch(true);
          } else {
            this._wasSearch(false);
            this._searchCanceled();
          }
        }
      },
      _shouldCancelSearch: function(value2) {
        if (!arguments.length) {
          return this._shouldCancelSearchValue;
        }
        this._shouldCancelSearchValue = value2;
      },
      _isOverlayNestedTarget: function(target) {
        return !!renderer_default(target).closest(".".concat(SELECTBOX_POPUP_WRAPPER_CLASS)).length;
      },
      _clearTextValue: function() {
        if (this.option("selectedItem")) {
          if (this._savedTextRemoveEvent) {
            this._saveValueChangeEvent(this._savedTextRemoveEvent);
          }
          this.option("value", null);
        }
        delete this._savedTextRemoveEvent;
      },
      _shouldOpenPopup: function() {
        return this._needPassDataSourceToList() && this._wasSearch();
      },
      _isFocused: function() {
        var activeElement = dom_adapter_default.getActiveElement();
        return this.callBase() && renderer_default(activeElement).closest(this._input()).length > 0;
      },
      _renderValueChangeEvent: function() {
        if (this._isEditable()) {
          this.callBase();
        }
      },
      _fieldRenderData: function() {
        var $listFocused = this._list && this.option("opened") && renderer_default(this._list.option("focusedElement"));
        if ($listFocused && $listFocused.length) {
          return this._list._getItemData($listFocused);
        }
        return this.option("selectedItem");
      },
      _isSelectedValue: function(value2) {
        return this._isValueEquals(value2, this.option("value"));
      },
      _shouldCloseOnItemClick: function() {
        return !(this.option("showSelectionControls") && "single" !== this.option("selectionMode"));
      },
      _listItemClickHandler: function(e) {
        var previousValue = this._getCurrentValue();
        this._focusListElement(renderer_default(e.itemElement));
        this._saveValueChangeEvent(e.event);
        this._completeSelection(this._valueGetter(e.itemData));
        if (this._shouldCloseOnItemClick()) {
          this.option("opened", false);
        }
        if (this.option("searchEnabled") && previousValue === this._valueGetter(e.itemData)) {
          this._updateField(e.itemData);
        }
        if (this._shouldClearFilter()) {
          this._cancelSearchIfNeed();
        }
      },
      _shouldClearFilter: function() {
        return this._wasSearch();
      },
      _completeSelection: function(value2) {
        this._setValue(value2);
      },
      _loadItem: function(value2, cache) {
        var that = this;
        var deferred = new Deferred();
        this.callBase(value2, cache).done((function(item) {
          deferred.resolve(item);
        }).bind(this)).fail((function(args) {
          if (null !== args && void 0 !== args && args.shouldSkipCallback) {
            return;
          }
          var selectedItem = that.option("selectedItem");
          if (that.option("acceptCustomValue") && value2 === that._valueGetter(selectedItem)) {
            deferred.resolve(selectedItem);
          } else {
            deferred.reject();
          }
        }).bind(this));
        return deferred.promise();
      },
      _loadInputValue: function(value2, callback) {
        this._loadItemDeferred = this._loadItem(value2).always(callback);
        return this._loadItemDeferred;
      },
      _isCustomItemSelected: function() {
        var selectedItem = this.option("selectedItem");
        var searchValue = this._searchValue();
        var selectedItemText = this._displayGetter(selectedItem);
        return !selectedItemText || searchValue !== selectedItemText.toString();
      },
      _valueChangeEventHandler: function(e) {
        if (this.option("acceptCustomValue") && this._isCustomItemSelected() && !this._isValueChanging) {
          this._isValueChanging = true;
          this._customItemAddedHandler(e);
          this._isValueChanging = false;
        }
      },
      _initCustomItemCreatingAction: function() {
        this._customItemCreatingAction = this._createActionByOption("onCustomItemCreating");
      },
      _createCustomItem: function(text) {
        var params = {
          text
        };
        var actionResult = this._customItemCreatingAction(params);
        var item = ensureDefined(actionResult, params.customItem);
        if (isDefined(actionResult)) {
          errors_default.log("W0015", "onCustomItemCreating", "customItem");
        }
        return item;
      },
      _customItemAddedHandler: function(e) {
        var searchValue = this._searchValue();
        var item = this._createCustomItem(searchValue);
        this._saveValueChangeEvent(e);
        if (void 0 === item) {
          this._renderValue();
          throw errors_default.Error("E0121");
        }
        if (isPromise(item)) {
          fromPromise(item).done(this._setCustomItem.bind(this)).fail(this._setCustomItem.bind(this, null));
        } else {
          this._setCustomItem(item);
        }
      },
      _setCustomItem: function(item) {
        if (this._disposed) {
          return;
        }
        item = item || null;
        this.option("selectedItem", item);
        this._cancelSearchIfNeed();
        this._setValue(this._valueGetter(item));
        this._renderDisplayText(this._displayGetter(item));
      },
      _clearValueHandler: function(e) {
        this._preventFiltering = true;
        this.callBase(e);
        this._searchCanceled();
        return false;
      },
      _wasSearch: function(value2) {
        if (!arguments.length) {
          return !!this._wasSearchValue;
        }
        this._wasSearchValue = value2;
      },
      _searchHandler: function() {
        if (this._preventFiltering) {
          delete this._preventFiltering;
          return;
        }
        if (this._needPassDataSourceToList()) {
          this._wasSearch(true);
        }
        this.callBase(arguments);
      },
      _dataSourceFiltered: function(searchValue) {
        this.callBase();
        if (null !== searchValue) {
          this._renderInputSubstitution();
          this._renderFocusedElement();
        }
      },
      _valueSubstituted: function() {
        var input = this._input().get(0);
        var currentSearchLength = this._searchValue().length;
        var isAllSelected = 0 === input.selectionStart && input.selectionEnd === currentSearchLength;
        var inputHasSelection = input.selectionStart !== input.selectionEnd;
        var isLastSymbolSelected = currentSearchLength === input.selectionEnd;
        return this._wasSearch() && inputHasSelection && !isAllSelected && isLastSymbolSelected && this._shouldSubstitutionBeRendered();
      },
      _shouldSubstitutionBeRendered: function() {
        return !this._preventSubstitution && this.option("searchEnabled") && !this.option("acceptCustomValue") && "startswith" === this.option("searchMode");
      },
      _renderInputSubstitution: function() {
        if (!this._shouldSubstitutionBeRendered()) {
          delete this._preventSubstitution;
          return;
        }
        var item = this._list && this._getPlainItems(this._list.option("items"))[0];
        if (!item) {
          return;
        }
        var $input = this._input();
        var valueLength = $input.val().length;
        if (0 === valueLength) {
          return;
        }
        var inputElement = $input.get(0);
        var displayValue = this._displayGetter(item).toString();
        inputElement.value = displayValue;
        this._caret({
          start: valueLength,
          end: displayValue.length
        });
      },
      _dispose: function() {
        this._renderInputValueAsync = noop2;
        delete this._loadItemDeferred;
        this.callBase();
      },
      _optionChanged: function(args) {
        switch (args.name) {
          case "onCustomItemCreating":
            this._initCustomItemCreatingAction();
            break;
          case "tooltipEnabled":
            this._renderTooltip();
            break;
          case "displayCustomValue":
          case "acceptCustomValue":
          case "showSelectionControls":
          case "useInkRipple":
            this._invalidate();
            break;
          case "allowClearing":
            break;
          default:
            this.callBase(args);
        }
      },
      _clean: function() {
        delete this._inkRipple;
        this.callBase();
      }
    });
    component_registrator_default("dxSelectBox", SelectBox);
    select_box_default = SelectBox;
  }
});

// node_modules/devextreme/esm/ui/date_box/ui.time_view.js
var TIMEVIEW_CLASS, TIMEVIEW_CLOCK_CLASS, TIMEVIEW_FIELD_CLASS, TIMEVIEW_HOURARROW_CLASS, TIMEVIEW_TIME_SEPARATOR_CLASS, TIMEVIEW_FORMAT12_CLASS, TIMEVIEW_FORMAT12_AM, TIMEVIEW_FORMAT12_PM, TIMEVIEW_MINUTEARROW_CLASS, rotateArrow, cssRotate, TimeView, ui_time_view_default;
var init_ui_time_view = __esm({
  "node_modules/devextreme/esm/ui/date_box/ui.time_view.js"() {
    init_renderer();
    init_editor();
    init_number_box2();
    init_select_box();
    init_box();
    init_extend();
    init_component_registrator();
    init_date3();
    init_ui_date_utils();
    TIMEVIEW_CLASS = "dx-timeview";
    TIMEVIEW_CLOCK_CLASS = "dx-timeview-clock";
    TIMEVIEW_FIELD_CLASS = "dx-timeview-field";
    TIMEVIEW_HOURARROW_CLASS = "dx-timeview-hourarrow";
    TIMEVIEW_TIME_SEPARATOR_CLASS = "dx-timeview-time-separator";
    TIMEVIEW_FORMAT12_CLASS = "dx-timeview-format12";
    TIMEVIEW_FORMAT12_AM = -1;
    TIMEVIEW_FORMAT12_PM = 1;
    TIMEVIEW_MINUTEARROW_CLASS = "dx-timeview-minutearrow";
    rotateArrow = function($arrow, angle, offset2) {
      cssRotate($arrow, angle, offset2);
    };
    cssRotate = function($arrow, angle, offset2) {
      $arrow.css("transform", "rotate(" + angle + "deg) translate(0," + offset2 + "px)");
    };
    TimeView = editor_default.inherit({
      _getDefaultOptions: function() {
        return extend2(this.callBase(), {
          value: new Date(Date.now()),
          use24HourFormat: true,
          _showClock: true,
          _arrowOffset: 0,
          stylingMode: void 0
        });
      },
      _defaultOptionsRules: function() {
        return this.callBase().concat([{
          device: {
            platform: "android"
          },
          options: {
            _arrowOffset: 15
          }
        }, {
          device: {
            platform: "generic"
          },
          options: {
            _arrowOffset: 5
          }
        }]);
      },
      _getValue: function() {
        return this.option("value") || /* @__PURE__ */ new Date();
      },
      _init: function() {
        this.callBase();
        this.$element().addClass(TIMEVIEW_CLASS);
      },
      _render: function() {
        this.callBase();
        this._renderBox();
        this._updateTime();
      },
      _renderBox: function() {
        var $box = renderer_default("<div>").appendTo(this.$element());
        var items = [];
        if (this.option("_showClock")) {
          items.push({
            ratio: 1,
            shrink: 0,
            baseSize: "auto",
            template: this._renderClock.bind(this)
          });
        }
        items.push({
          ratio: 0,
          shrink: 0,
          baseSize: 50,
          template: this._renderField.bind(this)
        });
        this._createComponent($box, box_default, {
          height: "100%",
          width: "100%",
          direction: "col",
          items
        });
      },
      _renderClock: function(_2, __, container) {
        this._$hourArrow = renderer_default("<div>").addClass(TIMEVIEW_HOURARROW_CLASS);
        this._$minuteArrow = renderer_default("<div>").addClass(TIMEVIEW_MINUTEARROW_CLASS);
        var $container = renderer_default(container);
        $container.addClass(TIMEVIEW_CLOCK_CLASS).append(this._$hourArrow).append(this._$minuteArrow);
        this.setAria("role", "presentation", $container);
      },
      _updateClock: function() {
        var time = this._getValue();
        var hourArrowAngle = time.getHours() / 12 * 360 + time.getMinutes() / 60 * 30;
        var minuteArrowAngle = time.getMinutes() / 60 * 360;
        rotateArrow(this._$hourArrow, hourArrowAngle, this.option("_arrowOffset"));
        rotateArrow(this._$minuteArrow, minuteArrowAngle, this.option("_arrowOffset"));
      },
      _getBoxItems: function(is12HourFormat) {
        var items = [{
          ratio: 0,
          shrink: 0,
          baseSize: "auto",
          template: () => this._hourBox.$element()
        }, {
          ratio: 0,
          shrink: 0,
          baseSize: "auto",
          template: renderer_default("<div>").addClass(TIMEVIEW_TIME_SEPARATOR_CLASS).text(date_default3.getTimeSeparator())
        }, {
          ratio: 0,
          shrink: 0,
          baseSize: "auto",
          template: () => this._minuteBox.$element()
        }];
        if (is12HourFormat) {
          items.push({
            ratio: 0,
            shrink: 0,
            baseSize: "auto",
            template: () => this._format12.$element()
          });
        }
        return items;
      },
      _renderField: function() {
        var is12HourFormat = !this.option("use24HourFormat");
        this._createHourBox(is12HourFormat);
        this._createMinuteBox();
        if (is12HourFormat) {
          this._createFormat12Box();
        }
        return this._createComponent(renderer_default("<div>").addClass(TIMEVIEW_FIELD_CLASS), box_default, {
          direction: "row",
          align: "center",
          crossAlign: "center",
          items: this._getBoxItems(is12HourFormat)
        }).$element();
      },
      _createHourBox: function(is12HourFormat) {
        var editor = this._hourBox = this._createComponent(renderer_default("<div>"), number_box_default2, extend2({
          min: -1,
          max: is12HourFormat ? 13 : 24,
          value: this._getValue().getHours(),
          onValueChanged: this._onHourBoxValueChanged.bind(this),
          onKeyboardHandled: (opts) => this._keyboardHandler(opts)
        }, this._getNumberBoxConfig()));
        editor.setAria("label", "hours");
      },
      _isPM: function() {
        return !this.option("use24HourFormat") && 1 === this._format12.option("value");
      },
      _onHourBoxValueChanged: function(_ref) {
        var {
          value: value2,
          component
        } = _ref;
        var currentValue = this._getValue();
        var newValue = new Date(currentValue);
        var newHours = this._convertMaxHourToMin(value2);
        component.option("value", newHours);
        if (this._isPM()) {
          newHours += 12;
        }
        newValue.setHours(newHours);
        ui_date_utils_default.normalizeTime(newValue);
        this.option("value", newValue);
      },
      _convertMaxHourToMin: function(hours) {
        var maxHoursValue = this.option("use24HourFormat") ? 24 : 12;
        return (maxHoursValue + hours) % maxHoursValue;
      },
      _createMinuteBox: function() {
        var editor = this._minuteBox = this._createComponent(renderer_default("<div>"), number_box_default2, extend2({
          min: -1,
          max: 60,
          value: this._getValue().getMinutes(),
          onKeyboardHandled: (opts) => this._keyboardHandler(opts),
          onValueChanged: (_ref2) => {
            var {
              value: value2,
              component
            } = _ref2;
            var newMinutes = (60 + value2) % 60;
            component.option("value", newMinutes);
            var time = new Date(this._getValue());
            time.setMinutes(newMinutes);
            ui_date_utils_default.normalizeTime(time);
            this.option("value", time);
          }
        }, this._getNumberBoxConfig()));
        editor.setAria("label", "minutes");
      },
      _createFormat12Box: function() {
        var periodNames = date_default3.getPeriodNames();
        var editor = this._format12 = this._createComponent(renderer_default("<div>").addClass(TIMEVIEW_FORMAT12_CLASS), select_box_default, {
          items: [{
            value: TIMEVIEW_FORMAT12_AM,
            text: periodNames[0]
          }, {
            value: TIMEVIEW_FORMAT12_PM,
            text: periodNames[1]
          }],
          valueExpr: "value",
          displayExpr: "text",
          onKeyboardHandled: (opts) => this._keyboardHandler(opts),
          onValueChanged: (_ref3) => {
            var {
              value: value2
            } = _ref3;
            var hours = this._getValue().getHours();
            var time = new Date(this._getValue());
            var newHours = (hours + 12 * value2) % 24;
            time.setHours(newHours);
            this.option("value", time);
          },
          value: this._getValue().getHours() >= 12 ? TIMEVIEW_FORMAT12_PM : TIMEVIEW_FORMAT12_AM,
          stylingMode: this.option("stylingMode")
        });
        editor.setAria("label", "type");
      },
      _refreshFormat12: function() {
        if (this.option("use24HourFormat")) {
          return;
        }
        var value2 = this._getValue();
        var hours = value2.getHours();
        var isPM = hours >= 12;
        var newValue = isPM ? TIMEVIEW_FORMAT12_PM : TIMEVIEW_FORMAT12_AM;
        this._silentEditorValueUpdate(this._format12, newValue);
      },
      _silentEditorValueUpdate: function(editor, value2) {
        if (editor) {
          editor._suppressValueChangeAction();
          editor.option("value", value2);
          editor._resumeValueChangeAction();
        }
      },
      _getNumberBoxConfig: function() {
        return {
          showSpinButtons: true,
          displayValueFormatter: function(value2) {
            return (value2 < 10 ? "0" : "") + value2;
          },
          stylingMode: this.option("stylingMode")
        };
      },
      _normalizeHours: function(hours) {
        return this.option("use24HourFormat") ? hours : hours % 12 || 12;
      },
      _updateField: function() {
        var hours = this._normalizeHours(this._getValue().getHours());
        this._silentEditorValueUpdate(this._hourBox, hours);
        this._silentEditorValueUpdate(this._minuteBox, this._getValue().getMinutes());
        this._refreshFormat12();
      },
      _updateTime: function() {
        if (this.option("_showClock")) {
          this._updateClock();
        }
        this._updateField();
      },
      _visibilityChanged: function(visible2) {
        if (visible2) {
          this._updateTime();
        }
      },
      _optionChanged: function(args) {
        switch (args.name) {
          case "value":
            this._updateTime();
            this.callBase(args);
            break;
          case "_arrowOffset":
            break;
          case "use24HourFormat":
          case "_showClock":
          case "stylingMode":
            this._invalidate();
            break;
          default:
            this.callBase(args);
        }
      }
    });
    component_registrator_default("dxTimeView", TimeView);
    ui_time_view_default = TimeView;
  }
});

// node_modules/devextreme/esm/ui/date_box/ui.date_box.strategy.calendar_with_time.js
var window25, SHRINK_VIEW_SCREEN_WIDTH, DATEBOX_ADAPTIVITY_MODE_CLASS, CalendarWithTimeStrategy, ui_date_box_strategy_calendar_with_time_default;
var init_ui_date_box_strategy_calendar_with_time = __esm({
  "node_modules/devextreme/esm/ui/date_box/ui.date_box.strategy.calendar_with_time.js"() {
    init_renderer();
    init_window();
    init_ui_date_box_strategy_calendar();
    init_ui_time_view();
    init_date3();
    init_extend();
    init_date();
    init_box();
    init_ui_date_utils();
    window25 = getWindow();
    SHRINK_VIEW_SCREEN_WIDTH = 573;
    DATEBOX_ADAPTIVITY_MODE_CLASS = "dx-datebox-adaptivity-mode";
    CalendarWithTimeStrategy = ui_date_box_strategy_calendar_default.inherit({
      NAME: "CalendarWithTime",
      getDefaultOptions: function() {
        return extend2(this.callBase(), {
          applyValueMode: "useButtons",
          buttonsLocation: "bottom after",
          "dropDownOptions.showTitle": false
        });
      },
      _closeDropDownByEnter: function() {
        return date_default.sameDate(this._getContouredValue(), this.widgetOption("value"));
      },
      getDisplayFormat: function(displayFormat) {
        return displayFormat || "shortdateshorttime";
      },
      _is24HourFormat: function() {
        return date_default3.is24HourFormat(this.getDisplayFormat(this.dateBox.option("displayFormat")));
      },
      _getContouredValue: function() {
        var viewDate = this.callBase();
        return this._updateDateTime(viewDate);
      },
      _renderWidget: function() {
        this.callBase();
        this._timeView = this.dateBox._createComponent(renderer_default("<div>"), ui_time_view_default, {
          value: this.dateBoxValue(),
          _showClock: !this._isShrinkView(),
          use24HourFormat: this._is24HourFormat(),
          onValueChanged: this._valueChangedHandler.bind(this),
          stylingMode: this.dateBox.option("stylingMode")
        });
        this._timeView.registerKeyHandler("escape", this._escapeHandler.bind(this));
      },
      renderOpenedState: function() {
        this.callBase();
        var popup = this._getPopup();
        if (popup) {
          popup.$wrapper().toggleClass(DATEBOX_ADAPTIVITY_MODE_CLASS, this._isSmallScreen());
        }
        clearTimeout(this._repaintTimer);
        this._repaintTimer = setTimeout((function() {
          this._getPopup() && this._getPopup().repaint();
        }).bind(this), 0);
      },
      isAdaptivityChanged: function() {
        var isAdaptiveMode = this._isShrinkView();
        var currentAdaptiveMode = this._currentAdaptiveMode;
        if (isAdaptiveMode !== currentAdaptiveMode) {
          this._currentAdaptiveMode = isAdaptiveMode;
          return void 0 !== currentAdaptiveMode;
        }
        return this.callBase();
      },
      _updateValue: function(preventDefaultValue) {
        var date = this.dateBoxValue();
        if (!date && !preventDefaultValue) {
          date = /* @__PURE__ */ new Date();
          ui_date_utils_default.normalizeTime(date);
        }
        this.callBase();
        if (this._timeView) {
          date && this._timeView.option("value", date);
          this._timeView.option("use24HourFormat", this._is24HourFormat());
        }
      },
      _isSmallScreen: function() {
        return renderer_default(window25).width() <= SHRINK_VIEW_SCREEN_WIDTH;
      },
      _isShrinkView: function() {
        return !this.dateBox.option("showAnalogClock") || this.dateBox.option("adaptivityEnabled") && this._isSmallScreen();
      },
      _getBoxItems: function() {
        var items = [{
          ratio: 0,
          shrink: 0,
          baseSize: "auto",
          name: "calendar"
        }];
        if (!this._isShrinkView()) {
          items.push({
            ratio: 0,
            shrink: 0,
            baseSize: "auto",
            name: "time"
          });
        }
        return items;
      },
      renderPopupContent: function() {
        this.callBase();
        this._currentAdaptiveMode = this._isShrinkView();
        var $popupContent = this._getPopup().$content();
        this._box = this.dateBox._createComponent(renderer_default("<div>").appendTo($popupContent), box_default, {
          direction: "row",
          crossAlign: "start",
          items: this._getBoxItems(),
          itemTemplate: (function(data2) {
            var $container = renderer_default("<div>");
            switch (data2.name) {
              case "calendar":
                $container.append(this._widget.$element());
                if (this._isShrinkView()) {
                  $container.append(this._timeView.$element());
                }
                break;
              case "time":
                $container.append(this._timeView.$element());
            }
            return $container;
          }).bind(this)
        });
        this._attachTabHandler();
      },
      popupConfig: function(_popupConfig) {
        var calendarPopupConfig = this.callBase(_popupConfig);
        var result2 = extend2(calendarPopupConfig, {
          width: "auto",
          onShowing: (function() {
            if ("fallback" === this._box.option("_layoutStrategy")) {
              var clockMinWidth = this._getPopup().$content().find(".dx-timeview-clock").css("minWidth");
              this._timeView.$element().css("maxWidth", clockMinWidth);
            }
          }).bind(this)
        });
        return result2;
      },
      getFirstPopupElement: function() {
        return this._timeView._hourBox.$element().find("input");
      },
      _attachTabHandler: function() {
        var dateBox = this.dateBox;
        this._timeView._hourBox.registerKeyHandler("tab", function(e) {
          if (e.shiftKey) {
            e.preventDefault();
            dateBox.focus();
          }
        });
      },
      _preventFocusOnPopup: function(e) {
        if (!renderer_default(e.target).hasClass("dx-texteditor-input")) {
          this.callBase.apply(this, arguments);
          if (!this.dateBox._hasFocusClass()) {
            this.dateBox.focus();
          }
        }
      },
      _updateDateTime: function(date) {
        var time = this._timeView.option("value");
        date.setHours(time.getHours(), time.getMinutes(), time.getSeconds(), time.getMilliseconds());
        return date;
      },
      getValue: function() {
        var _this$_widget$option;
        var date = null !== (_this$_widget$option = this._widget.option("value")) && void 0 !== _this$_widget$option ? _this$_widget$option : this._widget.getContouredDate();
        date = date ? new Date(date) : /* @__PURE__ */ new Date();
        return this._updateDateTime(date);
      },
      dispose: function() {
        clearTimeout(this._removeMinWidthTimer);
        clearTimeout(this._repaintTimer);
        this.callBase();
      }
    });
    ui_date_box_strategy_calendar_with_time_default = CalendarWithTimeStrategy;
  }
});

// node_modules/devextreme/esm/ui/date_box/ui.date_box.strategy.list.js
var window26, DATE_FORMAT, BOUNDARY_VALUES, ListStrategy, ui_date_box_strategy_list_default;
var init_ui_date_box_strategy_list = __esm({
  "node_modules/devextreme/esm/ui/date_box/ui.date_box.strategy.list.js"() {
    init_renderer();
    init_window();
    init_list();
    init_ui_date_box_strategy();
    init_common();
    init_type();
    init_extend();
    init_ui_date_utils();
    init_date3();
    init_date_serialization();
    init_utils7();
    window26 = getWindow();
    DATE_FORMAT = "date";
    BOUNDARY_VALUES = {
      min: new Date(0, 0, 0, 0, 0),
      max: new Date(0, 0, 0, 23, 59)
    };
    ListStrategy = ui_date_box_strategy_default.inherit({
      NAME: "List",
      supportedKeys: function() {
        return {
          tab: function() {
            var {
              opened,
              applyValueMode
            } = this.option();
            if (opened && "instantly" === applyValueMode) {
              this.close();
            }
          },
          space: noop2,
          home: noop2,
          end: noop2
        };
      },
      getDefaultOptions: function() {
        return extend2(this.callBase(), {
          applyValueMode: "instantly"
        });
      },
      getDisplayFormat: function(displayFormat) {
        return displayFormat || "shorttime";
      },
      popupConfig: function(_popupConfig) {
        return _popupConfig;
      },
      getValue: function() {
        var selectedIndex = this._widget.option("selectedIndex");
        if (-1 === selectedIndex) {
          return this.dateBox.option("value");
        }
        var itemData = this._widgetItems[selectedIndex];
        return this._getDateByItemData(itemData);
      },
      useCurrentDateByDefault: function() {
        return true;
      },
      getDefaultDate: function() {
        return /* @__PURE__ */ new Date(null);
      },
      popupShowingHandler: function() {
        this.dateBox._dimensionChanged();
      },
      _renderWidget: function() {
        this.callBase();
        this._refreshItems();
      },
      _getWidgetName: function() {
        return list_default;
      },
      _getWidgetOptions: function() {
        return {
          itemTemplate: this._timeListItemTemplate.bind(this),
          onItemClick: this._listItemClickHandler.bind(this),
          tabIndex: -1,
          onFocusedItemChanged: this._refreshActiveDescendant.bind(this),
          selectionMode: "single"
        };
      },
      _refreshActiveDescendant: function(e) {
        this.dateBox.setAria("activedescendant", "");
        this.dateBox.setAria("activedescendant", e.actionValue);
      },
      _refreshItems: function() {
        this._widgetItems = this._getTimeListItems();
        this._widget.option("items", this._widgetItems);
      },
      renderOpenedState: function() {
        if (!this._widget) {
          return;
        }
        this._widget.option("focusedElement", null);
        this._setSelectedItemsByValue();
        if (this._widget.option("templatesRenderAsynchronously")) {
          this._asyncScrollTimeout = setTimeout(this._scrollToSelectedItem.bind(this));
        } else {
          this._scrollToSelectedItem();
        }
      },
      dispose: function() {
        this.callBase();
        clearTimeout(this._asyncScrollTimeout);
      },
      _updateValue: function() {
        if (!this._widget) {
          return;
        }
        this._refreshItems();
        this._setSelectedItemsByValue();
        this._scrollToSelectedItem();
      },
      _setSelectedItemsByValue: function() {
        var value2 = this.dateBoxValue();
        var dateIndex = this._getDateIndex(value2);
        if (-1 === dateIndex) {
          this._widget.option("selectedItems", []);
        } else {
          this._widget.option("selectedIndex", dateIndex);
        }
      },
      _scrollToSelectedItem: function() {
        this._widget.scrollToItem(this._widget.option("selectedIndex"));
      },
      _getDateIndex: function(date) {
        var result2 = -1;
        for (var i = 0, n = this._widgetItems.length; i < n; i++) {
          if (this._areDatesEqual(date, this._widgetItems[i])) {
            result2 = i;
            break;
          }
        }
        return result2;
      },
      _areDatesEqual: function(first, second) {
        return isDate(first) && isDate(second) && first.getHours() === second.getHours() && first.getMinutes() === second.getMinutes();
      },
      _getTimeListItems: function() {
        var min = this.dateBox.dateOption("min") || this._getBoundaryDate("min");
        var max = this.dateBox.dateOption("max") || this._getBoundaryDate("max");
        var value2 = this.dateBox.dateOption("value") || null;
        var delta = max - min;
        var minutes = min.getMinutes() % this.dateBox.option("interval");
        if (delta < 0) {
          return [];
        }
        if (delta > ui_date_utils_default.ONE_DAY) {
          delta = ui_date_utils_default.ONE_DAY;
        }
        if (value2 - min < ui_date_utils_default.ONE_DAY) {
          return this._getRangeItems(min, new Date(min), delta);
        }
        min = this._getBoundaryDate("min");
        min.setMinutes(minutes);
        if (value2 && Math.abs(value2 - max) < ui_date_utils_default.ONE_DAY) {
          delta = (60 * max.getHours() + Math.abs(max.getMinutes() - minutes)) * ui_date_utils_default.ONE_MINUTE;
        }
        return this._getRangeItems(min, new Date(min), delta);
      },
      _getRangeItems: function(startValue, currentValue, rangeDuration) {
        var rangeItems = [];
        var interval = this.dateBox.option("interval");
        while (currentValue - startValue <= rangeDuration) {
          rangeItems.push(new Date(currentValue));
          currentValue.setMinutes(currentValue.getMinutes() + interval);
        }
        return rangeItems;
      },
      _getBoundaryDate: function(boundary) {
        var boundaryValue = BOUNDARY_VALUES[boundary];
        var currentValue = new Date(ensureDefined(this.dateBox.dateOption("value"), 0));
        return new Date(currentValue.getFullYear(), currentValue.getMonth(), currentValue.getDate(), boundaryValue.getHours(), boundaryValue.getMinutes());
      },
      _timeListItemTemplate: function(itemData) {
        var displayFormat = this.dateBox.option("displayFormat");
        return date_default3.format(itemData, this.getDisplayFormat(displayFormat));
      },
      _listItemClickHandler: function(e) {
        if ("useButtons" === this.dateBox.option("applyValueMode")) {
          return;
        }
        var date = this._getDateByItemData(e.itemData);
        this.dateBox.option("opened", false);
        this.dateBoxValue(date, e.event);
      },
      _getDateByItemData: function(itemData) {
        var date = this.dateBox.option("value");
        var hours = itemData.getHours();
        var minutes = itemData.getMinutes();
        var seconds = itemData.getSeconds();
        var year = itemData.getFullYear();
        var month = itemData.getMonth();
        var day = itemData.getDate();
        if (date) {
          if (this.dateBox.option("dateSerializationFormat")) {
            date = date_serialization_default.deserializeDate(date);
          } else {
            date = new Date(date);
          }
          date.setHours(hours);
          date.setMinutes(minutes);
          date.setSeconds(seconds);
          date.setFullYear(year);
          date.setMonth(month);
          date.setDate(day);
        } else {
          date = new Date(year, month, day, hours, minutes, 0, 0);
        }
        return date;
      },
      getKeyboardListener: function() {
        return this._widget;
      },
      _updatePopupHeight: function() {
        var dropDownOptionsHeight = getSizeValue(this.dateBox.option("dropDownOptions.height"));
        if (void 0 === dropDownOptionsHeight || "auto" === dropDownOptionsHeight) {
          this.dateBox._setPopupOption("height", "auto");
          var popupHeight = this._widget.$element().outerHeight();
          var maxHeight = 0.45 * renderer_default(window26).height();
          this.dateBox._setPopupOption("height", Math.min(popupHeight, maxHeight));
        }
        this.dateBox._timeList && this.dateBox._timeList.updateDimensions();
      },
      getParsedText: function(text, format2) {
        var value2 = this.callBase(text, format2);
        if (value2) {
          value2 = ui_date_utils_default.mergeDates(value2, /* @__PURE__ */ new Date(null), DATE_FORMAT);
        }
        return value2;
      }
    });
    ui_date_box_strategy_list_default = ListStrategy;
  }
});

// node_modules/devextreme/esm/ui/date_box/ui.date_box.base.js
var window27, DATEBOX_CLASS, DX_AUTO_WIDTH_CLASS, DX_INVALID_BADGE_CLASS2, DX_CLEAR_BUTTON_CLASS, DATEBOX_WRAPPER_CLASS, PICKER_TYPE, TYPE2, STRATEGY_NAME, STRATEGY_CLASSES, DateBox, ui_date_box_base_default;
var init_ui_date_box_base = __esm({
  "node_modules/devextreme/esm/ui/date_box/ui.date_box.base.js"() {
    init_window();
    init_type();
    init_dom();
    init_iterator();
    init_version2();
    init_extend();
    init_support();
    init_devices();
    init_config();
    init_date();
    init_ui_date_utils();
    init_date_serialization();
    init_ui_drop_down_editor();
    init_date3();
    init_message();
    init_ui_date_box_strategy_calendar();
    init_ui_date_box_strategy_date_view();
    init_ui_date_box_strategy_native();
    init_ui_date_box_strategy_calendar_with_time();
    init_ui_date_box_strategy_list();
    window27 = getWindow();
    DATEBOX_CLASS = "dx-datebox";
    DX_AUTO_WIDTH_CLASS = "dx-auto-width";
    DX_INVALID_BADGE_CLASS2 = "dx-show-invalid-badge";
    DX_CLEAR_BUTTON_CLASS = "dx-clear-button-area";
    DATEBOX_WRAPPER_CLASS = "dx-datebox-wrapper";
    PICKER_TYPE = {
      calendar: "calendar",
      rollers: "rollers",
      list: "list",
      native: "native"
    };
    TYPE2 = {
      date: "date",
      datetime: "datetime",
      time: "time"
    };
    STRATEGY_NAME = {
      calendar: "Calendar",
      dateView: "DateView",
      native: "Native",
      calendarWithTime: "CalendarWithTime",
      list: "List"
    };
    STRATEGY_CLASSES = {
      Calendar: ui_date_box_strategy_calendar_default,
      DateView: ui_date_box_strategy_date_view_default,
      Native: ui_date_box_strategy_native_default,
      CalendarWithTime: ui_date_box_strategy_calendar_with_time_default,
      List: ui_date_box_strategy_list_default
    };
    DateBox = ui_drop_down_editor_default.inherit({
      _supportedKeys: function() {
        return extend2(this.callBase(), this._strategy.supportedKeys());
      },
      _renderButtonContainers: function() {
        this.callBase.apply(this, arguments);
        this._strategy.customizeButtons();
      },
      _getDefaultOptions: function() {
        return extend2(this.callBase(), {
          type: "date",
          showAnalogClock: true,
          value: null,
          dateSerializationFormat: void 0,
          min: void 0,
          max: void 0,
          displayFormat: null,
          interval: 30,
          disabledDates: null,
          pickerType: PICKER_TYPE.calendar,
          invalidDateMessage: message_default.format("dxDateBox-validation-datetime"),
          dateOutOfRangeMessage: message_default.format("validation-range"),
          applyButtonText: message_default.format("OK"),
          adaptivityEnabled: false,
          calendarOptions: {},
          useHiddenSubmitElement: true
        });
      },
      _defaultOptionsRules: function() {
        return this.callBase().concat([{
          device: {
            platform: "ios"
          },
          options: {
            "dropDownOptions.showTitle": true
          }
        }, {
          device: {
            platform: "android"
          },
          options: {
            buttonsLocation: "bottom after"
          }
        }, {
          device: function() {
            var realDevice4 = devices_default.real();
            var platform = realDevice4.platform;
            return "ios" === platform || "android" === platform;
          },
          options: {
            pickerType: PICKER_TYPE.native
          }
        }, {
          device: function(currentDevice) {
            var realDevice4 = devices_default.real();
            var platform = realDevice4.platform;
            var version2 = realDevice4.version;
            return "generic" === platform && "desktop" !== currentDevice.deviceType || "android" === platform && compare(version2, [4, 4]) < 0;
          },
          options: {
            pickerType: PICKER_TYPE.rollers
          }
        }, {
          device: {
            platform: "generic",
            deviceType: "desktop"
          },
          options: {
            buttonsLocation: "bottom after"
          }
        }]);
      },
      _initOptions: function(options2) {
        this._userOptions = extend2({}, options2);
        this.callBase(options2);
        this._updatePickerOptions();
      },
      _updatePickerOptions: function() {
        var pickerType = this.option("pickerType");
        var type2 = this.option("type");
        if (pickerType === PICKER_TYPE.list && (type2 === TYPE2.datetime || type2 === TYPE2.date)) {
          pickerType = PICKER_TYPE.calendar;
        }
        if (type2 === TYPE2.time && pickerType === PICKER_TYPE.calendar) {
          pickerType = PICKER_TYPE.list;
        }
        this.option("showDropDownButton", "generic" !== devices_default.real().platform || pickerType !== PICKER_TYPE.native);
        this._pickerType = pickerType;
      },
      _init: function() {
        this._initStrategy();
        this.option(extend2({}, this._strategy.getDefaultOptions(), this._userOptions));
        delete this._userOptions;
        this.callBase();
      },
      _toLowerCaseFirstLetter: function(string) {
        return string.charAt(0).toLowerCase() + string.substr(1);
      },
      _initStrategy: function() {
        var strategyName = this._getStrategyName(this._getFormatType());
        var strategy3 = STRATEGY_CLASSES[strategyName];
        if (!(this._strategy && this._strategy.NAME === strategyName)) {
          this._strategy = new strategy3(this);
        }
      },
      _getFormatType: function() {
        var currentType = this.option("type");
        var isTime = /h|m|s/g.test(currentType);
        var isDate2 = /d|M|Y/g.test(currentType);
        var type2 = "";
        if (isDate2) {
          type2 += TYPE2.date;
        }
        if (isTime) {
          type2 += TYPE2.time;
        }
        return type2;
      },
      _getStrategyName: function(type2) {
        var pickerType = this._pickerType;
        if (pickerType === PICKER_TYPE.rollers) {
          return STRATEGY_NAME.dateView;
        } else if (pickerType === PICKER_TYPE.native) {
          return STRATEGY_NAME.native;
        }
        if (type2 === TYPE2.date) {
          return STRATEGY_NAME.calendar;
        }
        if (type2 === TYPE2.datetime) {
          return STRATEGY_NAME.calendarWithTime;
        }
        return STRATEGY_NAME.list;
      },
      _initMarkup: function() {
        this.$element().addClass(DATEBOX_CLASS);
        this.callBase();
        this._refreshFormatClass();
        this._refreshPickerTypeClass();
        this._strategy.renderInputMinMax(this._input());
      },
      _render: function() {
        this.callBase();
        this._formatValidationIcon();
      },
      _renderDimensions: function() {
        this.callBase();
        this.$element().toggleClass(DX_AUTO_WIDTH_CLASS, !this.option("width"));
        this._dimensionChanged();
      },
      _dimensionChanged: function() {
        this.callBase(arguments);
        if (this._popup) {
          var _this$_strategy$_upda, _this$_strategy;
          null === (_this$_strategy$_upda = (_this$_strategy = this._strategy)._updatePopupHeight) || void 0 === _this$_strategy$_upda ? void 0 : _this$_strategy$_upda.call(_this$_strategy);
        }
      },
      _refreshFormatClass: function() {
        var $element = this.$element();
        each(TYPE2, function(_2, item) {
          $element.removeClass(DATEBOX_CLASS + "-" + item);
        });
        $element.addClass(DATEBOX_CLASS + "-" + this.option("type"));
      },
      _refreshPickerTypeClass: function() {
        var $element = this.$element();
        each(PICKER_TYPE, function(_2, item) {
          $element.removeClass(DATEBOX_CLASS + "-" + item);
        });
        $element.addClass(DATEBOX_CLASS + "-" + this._pickerType);
      },
      _formatValidationIcon: function() {
        if (!hasWindow()) {
          return;
        }
        var inputElement = this._input().get(0);
        var isRtlEnabled = this.option("rtlEnabled");
        var clearButtonWidth = this._getClearButtonWidth();
        var longestElementDimensions = this._getLongestElementDimensions();
        var curWidth = parseFloat(window27.getComputedStyle(inputElement).width) - clearButtonWidth;
        var shouldHideValidationIcon = longestElementDimensions.width > curWidth;
        var style = inputElement.style;
        this.$element().toggleClass(DX_INVALID_BADGE_CLASS2, !shouldHideValidationIcon);
        if (shouldHideValidationIcon) {
          if (void 0 === this._storedPadding) {
            this._storedPadding = isRtlEnabled ? longestElementDimensions.leftPadding : longestElementDimensions.rightPadding;
          }
          isRtlEnabled ? style.paddingLeft = 0 : style.paddingRight = 0;
        } else {
          isRtlEnabled ? style.paddingLeft = this._storedPadding + "px" : style.paddingRight = this._storedPadding + "px";
        }
      },
      _getClearButtonWidth: function() {
        var clearButtonWidth = 0;
        if (this._isClearButtonVisible() && "" === this._input().val()) {
          var clearButtonElement = this.$element().find("." + DX_CLEAR_BUTTON_CLASS).get(0);
          clearButtonWidth = parseFloat(window27.getComputedStyle(clearButtonElement).width);
        }
        return clearButtonWidth;
      },
      _getLongestElementDimensions: function() {
        var format2 = this._strategy.getDisplayFormat(this.option("displayFormat"));
        var longestValue = date_default3.format(ui_date_utils_default.getLongestDate(format2, date_default3.getMonthNames(), date_default3.getDayNames()), format2);
        var $input = this._input();
        var inputElement = $input.get(0);
        var $longestValueElement = createTextElementHiddenCopy($input, longestValue);
        var isPaddingStored = void 0 !== this._storedPadding;
        var storedPadding = !isPaddingStored ? 0 : this._storedPadding;
        $longestValueElement.appendTo(this.$element());
        var elementWidth = parseFloat(window27.getComputedStyle($longestValueElement.get(0)).width);
        var rightPadding = parseFloat(window27.getComputedStyle(inputElement).paddingRight);
        var leftPadding = parseFloat(window27.getComputedStyle(inputElement).paddingLeft);
        var necessaryWidth = elementWidth + leftPadding + rightPadding + storedPadding;
        $longestValueElement.remove();
        return {
          width: necessaryWidth,
          leftPadding,
          rightPadding
        };
      },
      _getKeyboardListeners() {
        return this.callBase().concat([this._strategy && this._strategy.getKeyboardListener()]);
      },
      _renderPopup: function() {
        this.callBase();
        this._popup.$wrapper().addClass(DATEBOX_WRAPPER_CLASS);
        this._renderPopupWrapper();
      },
      _popupConfig: function() {
        var popupConfig = this.callBase();
        return extend2(this._strategy.popupConfig(popupConfig), {
          title: this._getPopupTitle(),
          dragEnabled: false
        });
      },
      _renderPopupWrapper: function() {
        if (!this._popup) {
          return;
        }
        var $element = this.$element();
        var classPostfixes = extend2({}, TYPE2, PICKER_TYPE);
        each(classPostfixes, (function(_2, item) {
          $element.removeClass(DATEBOX_WRAPPER_CLASS + "-" + item);
        }).bind(this));
        this._popup.$wrapper().addClass(DATEBOX_WRAPPER_CLASS + "-" + this.option("type")).addClass(DATEBOX_WRAPPER_CLASS + "-" + this._pickerType);
      },
      _renderPopupContent: function() {
        this.callBase();
        this._strategy.renderPopupContent();
      },
      _getFirstPopupElement: function() {
        return this._strategy.getFirstPopupElement() || this.callBase();
      },
      _getLastPopupElement: function() {
        return this._strategy.getLastPopupElement() || this.callBase();
      },
      _popupShowingHandler: function() {
        this.callBase();
        this._strategy.popupShowingHandler();
      },
      _popupShownHandler: function() {
        this.callBase();
        this._strategy.renderOpenedState();
      },
      _popupHiddenHandler: function() {
        this.callBase();
        this._strategy.renderOpenedState();
        this._strategy.popupHiddenHandler();
      },
      _visibilityChanged: function(visible2) {
        if (visible2) {
          this._formatValidationIcon();
        }
      },
      _clearValueHandler: function(e) {
        this.option("text", "");
        this.callBase(e);
      },
      _readOnlyPropValue: function() {
        if (this._pickerType === PICKER_TYPE.rollers) {
          return true;
        }
        var platform = devices_default.real().platform;
        var isCustomValueDisabled = this._isNativeType() && ("ios" === platform || "android" === platform);
        if (isCustomValueDisabled) {
          return this.option("readOnly");
        }
        return this.callBase();
      },
      _isClearButtonVisible: function() {
        return this.callBase() && !this._isNativeType();
      },
      _renderValue: function() {
        var value2 = this.dateOption("value");
        this.option("text", this._getDisplayedText(value2));
        this._strategy.renderValue();
        return this.callBase();
      },
      _setSubmitValue: function() {
        var value2 = this.dateOption("value");
        var dateSerializationFormat = this.option("dateSerializationFormat");
        var submitFormat = ui_date_utils_default.SUBMIT_FORMATS_MAP[this.option("type")];
        var submitValue = dateSerializationFormat ? date_serialization_default.serializeDate(value2, dateSerializationFormat) : ui_date_utils_default.toStandardDateFormat(value2, submitFormat);
        this._getSubmitElement().val(submitValue);
      },
      _getDisplayedText: function(value2) {
        var mode = this.option("mode");
        var displayedText;
        if ("text" === mode) {
          var displayFormat = this._strategy.getDisplayFormat(this.option("displayFormat"));
          displayedText = date_default3.format(value2, displayFormat);
        } else {
          var format2 = this._getFormatByMode(mode);
          if (format2) {
            displayedText = date_default3.format(value2, format2);
          } else {
            displayedText = ui_date_utils_default.toStandardDateFormat(value2, mode);
          }
        }
        return displayedText;
      },
      _getFormatByMode: function(mode) {
        return inputType(mode) ? null : ui_date_utils_default.FORMATS_MAP[mode];
      },
      _valueChangeEventHandler: function(e) {
        var {
          text,
          type: type2,
          validationError
        } = this.option();
        var currentValue = this.dateOption("value");
        if (text === this._getDisplayedText(currentValue)) {
          if (!validationError || validationError.editorSpecific) {
            this._applyInternalValidation(currentValue);
            this._applyCustomValidation(currentValue);
          }
          return;
        }
        var parsedDate = this._getParsedDate(text);
        var value2 = null !== currentValue && void 0 !== currentValue ? currentValue : this._getDateByDefault();
        var newValue = ui_date_utils_default.mergeDates(value2, parsedDate, type2);
        var date = parsedDate && "time" === type2 ? newValue : parsedDate;
        if (this._applyInternalValidation(date).isValid) {
          var displayedText = this._getDisplayedText(newValue);
          if (value2 && newValue && value2.getTime() === newValue.getTime() && displayedText !== text) {
            this._renderValue();
          } else {
            this.dateValue(newValue, e);
          }
        }
      },
      _getDateByDefault: function() {
        return this._strategy.useCurrentDateByDefault() && this._strategy.getDefaultDate();
      },
      _getParsedDate: function(text) {
        var displayFormat = this._strategy.getDisplayFormat(this.option("displayFormat"));
        var parsedText = this._strategy.getParsedText(text, displayFormat);
        return null !== parsedText && void 0 !== parsedText ? parsedText : void 0;
      },
      _applyInternalValidation(value2) {
        var text = this.option("text");
        var hasText = !!text && null !== value2;
        var isDate2 = !!value2 && isDate(value2) && !isNaN(value2.getTime());
        var isDateInRange = isDate2 && date_default.dateInRange(value2, this.dateOption("min"), this.dateOption("max"), this.option("type"));
        var isValid = !hasText && !value2 || isDateInRange;
        var validationMessage = "";
        if (!isDate2) {
          validationMessage = this.option("invalidDateMessage");
        } else if (!isDateInRange) {
          validationMessage = this.option("dateOutOfRangeMessage");
        }
        this.option({
          isValid,
          validationError: isValid ? null : {
            editorSpecific: true,
            message: validationMessage
          }
        });
        return {
          isValid,
          isDate: isDate2
        };
      },
      _applyCustomValidation: function(value2) {
        this.validationRequest.fire({
          editor: this,
          value: this._serializeDate(value2)
        });
      },
      _isValueChanged: function(newValue) {
        var oldValue = this.dateOption("value");
        var oldTime = oldValue && oldValue.getTime();
        var newTime = newValue && newValue.getTime();
        return oldTime !== newTime;
      },
      _isTextChanged: function(newValue) {
        var oldText = this.option("text");
        var newText = newValue && this._getDisplayedText(newValue) || "";
        return oldText !== newText;
      },
      _renderProps: function() {
        this.callBase();
        this._input().attr("autocomplete", "off");
      },
      _renderOpenedState: function() {
        if (!this._isNativeType()) {
          this.callBase();
        }
        if (this._strategy.isAdaptivityChanged()) {
          this._refreshStrategy();
        }
      },
      _getPopupTitle: function() {
        var placeholder = this.option("placeholder");
        if (placeholder) {
          return placeholder;
        }
        var type2 = this.option("type");
        if (type2 === TYPE2.time) {
          return message_default.format("dxDateBox-simulatedDataPickerTitleTime");
        }
        if (type2 === TYPE2.date || type2 === TYPE2.datetime) {
          return message_default.format("dxDateBox-simulatedDataPickerTitleDate");
        }
        return "";
      },
      _refreshStrategy: function() {
        this._strategy.dispose();
        this._initStrategy();
        this.option(this._strategy.getDefaultOptions());
        this._refresh();
      },
      _applyButtonHandler: function(e) {
        var value2 = this._strategy.getValue();
        this.dateValue(value2, e.event);
        this.callBase();
      },
      _dispose: function() {
        var _this$_strategy2;
        this.callBase();
        null === (_this$_strategy2 = this._strategy) || void 0 === _this$_strategy2 ? void 0 : _this$_strategy2.dispose();
      },
      _isNativeType: function() {
        return this._pickerType === PICKER_TYPE.native;
      },
      _updatePopupTitle: function() {
        var _this$_popup;
        null === (_this$_popup = this._popup) || void 0 === _this$_popup ? void 0 : _this$_popup.option("title", this._getPopupTitle());
      },
      _optionChanged: function(args) {
        switch (args.name) {
          case "showClearButton":
          case "buttons":
            this.callBase.apply(this, arguments);
            this._formatValidationIcon();
            break;
          case "pickerType":
            this._updatePickerOptions({
              pickerType: args.value
            });
            this._refreshStrategy();
            this._refreshPickerTypeClass();
            this._invalidate();
            break;
          case "type":
            this._updatePickerOptions({
              format: args.value
            });
            this._refreshStrategy();
            this._refreshFormatClass();
            this._renderPopupWrapper();
            this._formatValidationIcon();
            this._updateValue();
            break;
          case "placeholder":
            this.callBase.apply(this, arguments);
            this._updatePopupTitle();
            break;
          case "min":
          case "max":
            var isValid = this.option("isValid");
            this._applyInternalValidation(this.dateOption("value"));
            if (!isValid) {
              this._applyCustomValidation(this.dateOption("value"));
            }
            this._invalidate();
            break;
          case "dateSerializationFormat":
          case "interval":
          case "disabledDates":
          case "calendarOptions":
            this._invalidate();
            break;
          case "displayFormat":
            this.option("text", this._getDisplayedText(this.dateOption("value")));
            this._renderInputValue();
            break;
          case "text":
            this._strategy.textChangedHandler(args.value);
            this.callBase.apply(this, arguments);
            break;
          case "isValid":
            this.callBase.apply(this, arguments);
            this._formatValidationIcon();
            break;
          case "showDropDownButton":
            this._formatValidationIcon();
            this.callBase.apply(this, arguments);
            break;
          case "readOnly":
            this.callBase.apply(this, arguments);
            this._formatValidationIcon();
            break;
          case "invalidDateMessage":
          case "dateOutOfRangeMessage":
          case "adaptivityEnabled":
          case "showAnalogClock":
            break;
          default:
            this.callBase.apply(this, arguments);
        }
      },
      _getSerializationFormat: function() {
        var value2 = this.option("value");
        if (this.option("dateSerializationFormat") && config_default().forceIsoDateParsing) {
          return this.option("dateSerializationFormat");
        }
        if (isNumeric(value2)) {
          return "number";
        }
        if (!isString2(value2)) {
          return;
        }
        return date_serialization_default.getDateSerializationFormat(value2);
      },
      _updateValue: function(value2) {
        this.callBase();
        this._applyInternalValidation(null !== value2 && void 0 !== value2 ? value2 : this.dateOption("value"));
      },
      dateValue: function(value2, dxEvent) {
        var isValueChanged = this._isValueChanged(value2);
        if (isValueChanged && dxEvent) {
          this._saveValueChangeEvent(dxEvent);
        }
        if (!isValueChanged) {
          if (this._isTextChanged(value2)) {
            this._updateValue(value2);
          } else if ("" === this.option("text")) {
            this._applyCustomValidation(value2);
          }
        }
        return this.dateOption("value", value2);
      },
      dateOption: function(optionName, value2) {
        if (1 === arguments.length) {
          return date_serialization_default.deserializeDate(this.option(optionName));
        }
        this.option(optionName, this._serializeDate(value2));
      },
      _serializeDate: function(date) {
        var serializationFormat = this._getSerializationFormat();
        return date_serialization_default.serializeDate(date, serializationFormat);
      },
      _clearValue: function() {
        var value2 = this.option("value");
        this.callBase();
        if (null === value2) {
          this._applyCustomValidation(null);
        }
      },
      reset: function() {
        var value2 = this.option("value");
        this.callBase();
        if (null === value2) {
          this._applyInternalValidation(null);
        }
      }
    });
    ui_date_box_base_default = DateBox;
  }
});

// node_modules/devextreme/esm/ui/date_box/ui.date_box.mask.js
var MASK_EVENT_NAMESPACE2, FORWARD, BACKWARD, DateBoxMask, ui_date_box_mask_default;
var init_ui_date_box_mask = __esm({
  "node_modules/devextreme/esm/ui/date_box/ui.date_box.mask.js"() {
    init_utils2();
    init_type();
    init_dom();
    init_extend();
    init_math();
    init_events_engine();
    init_ui_date_box_mask_parts();
    init_date3();
    init_date_parser();
    init_date_format();
    init_ui_date_box_base();
    init_number3();
    init_devices();
    init_browser();
    MASK_EVENT_NAMESPACE2 = "dateBoxMask";
    FORWARD = 1;
    BACKWARD = -1;
    DateBoxMask = ui_date_box_base_default.inherit({
      _supportedKeys(e) {
        var originalHandlers = this.callBase(e);
        var callOriginalHandler = (e2) => {
          var originalHandler = originalHandlers[normalizeKeyName(e2)];
          return originalHandler && originalHandler.apply(this, [e2]);
        };
        var applyHandler = (e2, maskHandler) => {
          if (this._shouldUseOriginalHandler(e2)) {
            return callOriginalHandler.apply(this, [e2]);
          } else {
            return maskHandler.apply(this, [e2]);
          }
        };
        return extend2({}, originalHandlers, {
          del: (e2) => applyHandler(e2, (event) => {
            this._revertPart(FORWARD);
            this._isAllSelected() || event.preventDefault();
          }),
          backspace: (e2) => applyHandler(e2, (event) => {
            this._revertPart(BACKWARD);
            this._isAllSelected() || event.preventDefault();
          }),
          home: (e2) => applyHandler(e2, (event) => {
            this._selectFirstPart();
            event.preventDefault();
          }),
          end: (e2) => applyHandler(e2, (event) => {
            this._selectLastPart();
            event.preventDefault();
          }),
          escape: (e2) => applyHandler(e2, (event) => {
            this._revertChanges(event);
          }),
          enter: (e2) => applyHandler(e2, (event) => {
            this._enterHandler(event);
          }),
          leftArrow: (e2) => applyHandler(e2, (event) => {
            this._selectNextPart(BACKWARD);
            event.preventDefault();
          }),
          rightArrow: (e2) => applyHandler(e2, (event) => {
            this._selectNextPart(FORWARD);
            event.preventDefault();
          }),
          upArrow: (e2) => applyHandler(e2, (event) => {
            this._upDownArrowHandler(FORWARD);
            event.preventDefault();
          }),
          downArrow: (e2) => applyHandler(e2, (event) => {
            this._upDownArrowHandler(BACKWARD);
            event.preventDefault();
          })
        });
      },
      _shouldUseOriginalHandler(e) {
        var isNotDeletingInCalendar = this.option("opened") && e && -1 === ["backspace", "del"].indexOf(normalizeKeyName(e));
        return !this._useMaskBehavior() || isNotDeletingInCalendar || e && e.altKey;
      },
      _upDownArrowHandler(step) {
        this._setNewDateIfEmpty();
        var originalValue = this._getActivePartValue(this._initialMaskValue);
        var currentValue = this._getActivePartValue();
        var delta = currentValue - originalValue;
        this._loadMaskValue(this._initialMaskValue);
        this._partIncrease(delta + step, true);
      },
      _getDefaultOptions() {
        return extend2(this.callBase(), {
          useMaskBehavior: false,
          emptyDateValue: new Date(2e3, 0, 1, 0, 0, 0)
        });
      },
      _isSingleCharKey(_ref) {
        var {
          originalEvent,
          alt
        } = _ref;
        var key = originalEvent.data || ("space" === normalizeKeyName(originalEvent) ? " " : originalEvent.key);
        return "string" === typeof key && 1 === key.length && !alt && !isCommandKeyPressed(originalEvent);
      },
      _isSingleDigitKey(e) {
        var _e$originalEvent;
        var data2 = null === (_e$originalEvent = e.originalEvent) || void 0 === _e$originalEvent ? void 0 : _e$originalEvent.data;
        return 1 === (null === data2 || void 0 === data2 ? void 0 : data2.length) && parseInt(data2, 10);
      },
      _useBeforeInputEvent: function() {
        var device = devices_default.real();
        return device.android && device.version[0] > 4;
      },
      _keyInputHandler(e, key) {
        var oldInputValue = this._input().val();
        this._processInputKey(key);
        e.preventDefault();
        var isValueChanged = oldInputValue !== this._input().val();
        isValueChanged && events_engine_default.trigger(this._input(), "input");
      },
      _keyboardHandler(e) {
        var key = e.originalEvent.key;
        var result2 = this.callBase(e);
        if (!this._useMaskBehavior() || this._useBeforeInputEvent()) {
          return result2;
        }
        if (browser_default.chrome && "Process" === e.key && 0 === e.code.indexOf("Digit")) {
          key = e.code.replace("Digit", "");
          this._processInputKey(key);
          this._maskInputHandler = () => {
            this._renderSelectedPart();
          };
        } else if (this._isSingleCharKey(e)) {
          this._keyInputHandler(e.originalEvent, key);
        }
        return result2;
      },
      _maskBeforeInputHandler(e) {
        this._maskInputHandler = null;
        var {
          inputType: inputType2
        } = e.originalEvent;
        if ("insertCompositionText" === inputType2) {
          this._maskInputHandler = () => {
            this._renderSelectedPart();
          };
        }
        var isBackwardDeletion = "deleteContentBackward" === inputType2;
        var isForwardDeletion = "deleteContentForward" === inputType2;
        if (isBackwardDeletion || isForwardDeletion) {
          var direction = isBackwardDeletion ? BACKWARD : FORWARD;
          this._maskInputHandler = () => {
            this._revertPart();
            this._selectNextPart(direction);
          };
        }
        if (!this._useMaskBehavior() || !this._isSingleCharKey(e)) {
          return;
        }
        var key = e.originalEvent.data;
        this._keyInputHandler(e, key);
        return true;
      },
      _keyPressHandler(e) {
        var {
          originalEvent: event
        } = e;
        if ("insertCompositionText" === (null === event || void 0 === event ? void 0 : event.inputType) && this._isSingleDigitKey(e)) {
          this._processInputKey(event.data);
          this._renderDisplayText(this._getDisplayedText(this._maskValue));
          this._selectNextPart();
        }
        this.callBase(e);
        if (this._maskInputHandler) {
          this._maskInputHandler();
          this._maskInputHandler = null;
        }
      },
      _processInputKey(key) {
        if (this._isAllSelected()) {
          this._activePartIndex = 0;
        }
        this._setNewDateIfEmpty();
        if (isNaN(parseInt(key))) {
          this._searchString(key);
        } else {
          this._searchNumber(key);
        }
      },
      _isAllSelected() {
        var caret3 = this._caret();
        return caret3.end - caret3.start === this.option("text").length;
      },
      _getFormatPattern() {
        if (this._formatPattern) {
          return this._formatPattern;
        }
        var format2 = this._strategy.getDisplayFormat(this.option("displayFormat"));
        var isLDMLPattern = isString2(format2) && !date_default3._getPatternByFormat(format2);
        if (isLDMLPattern) {
          this._formatPattern = format2;
        } else {
          this._formatPattern = getFormat2(function(value2) {
            return date_default3.format(value2, format2);
          });
        }
        return this._formatPattern;
      },
      _setNewDateIfEmpty() {
        if (!this._maskValue) {
          var value2 = "time" === this.option("type") ? /* @__PURE__ */ new Date(null) : /* @__PURE__ */ new Date();
          this._maskValue = value2;
          this._initialMaskValue = value2;
          this._renderDateParts();
        }
      },
      _partLimitsReached(max) {
        var maxLimitLength = String(max).length;
        var formatLength = this._getActivePartProp("pattern").length;
        var isShortFormat = 1 === formatLength;
        var maxSearchLength = isShortFormat ? maxLimitLength : Math.min(formatLength, maxLimitLength);
        var isLengthExceeded = this._searchValue.length === maxSearchLength;
        var isValueOverflowed = parseInt(this._searchValue + "0") > max;
        return isLengthExceeded || isValueOverflowed;
      },
      _searchNumber(char) {
        var {
          max
        } = this._getActivePartLimits();
        var maxLimitLength = String(max).length;
        this._searchValue = (this._searchValue + char).substr(-maxLimitLength);
        if (isNaN(this._searchValue)) {
          this._searchValue = char;
        }
        this._setActivePartValue(this._searchValue);
        if (this._partLimitsReached(max)) {
          this._selectNextPart(FORWARD);
        }
      },
      _searchString(char) {
        if (!isNaN(parseInt(this._getActivePartProp("text")))) {
          return;
        }
        var limits = this._getActivePartProp("limits")(this._maskValue);
        var startString = this._searchValue + char.toLowerCase();
        var endLimit = limits.max - limits.min;
        for (var i = 0; i <= endLimit; i++) {
          this._loadMaskValue(this._initialMaskValue);
          this._partIncrease(i + 1);
          if (0 === this._getActivePartProp("text").toLowerCase().indexOf(startString)) {
            this._searchValue = startString;
            return;
          }
        }
        this._setNewDateIfEmpty();
        if (this._searchValue) {
          this._clearSearchValue();
          this._searchString(char);
        }
      },
      _clearSearchValue() {
        this._searchValue = "";
      },
      _revertPart: function(direction) {
        if (!this._isAllSelected()) {
          var actual = this._getActivePartValue(this.option("emptyDateValue"));
          this._setActivePartValue(actual);
          this._selectNextPart(direction);
        }
        this._clearSearchValue();
      },
      _useMaskBehavior() {
        return this.option("useMaskBehavior") && "text" === this.option("mode");
      },
      _prepareRegExpInfo() {
        this._regExpInfo = getRegExpInfo(this._getFormatPattern(), date_default3);
        var regexp = this._regExpInfo.regexp;
        var source = regexp.source;
        var flags = regexp.flags;
        var quantifierRegexp = new RegExp(/(\{[0-9]+,?[0-9]*\})/);
        var convertedSource = source.split(quantifierRegexp).map((sourcePart) => quantifierRegexp.test(sourcePart) ? sourcePart : number_default2.convertDigits(sourcePart, false)).join("");
        this._regExpInfo.regexp = new RegExp(convertedSource, flags);
      },
      _initMaskState() {
        this._activePartIndex = 0;
        this._formatPattern = null;
        this._prepareRegExpInfo();
        this._loadMaskValue();
      },
      _renderMask() {
        this.callBase();
        this._detachMaskEvents();
        this._clearMaskState();
        if (this._useMaskBehavior()) {
          this._attachMaskEvents();
          this._initMaskState();
          this._renderDateParts();
        }
      },
      _renderDateParts() {
        if (!this._useMaskBehavior()) {
          return;
        }
        var text = this.option("text") || this._getDisplayedText(this._maskValue);
        if (text) {
          this._dateParts = renderDateParts(text, this._regExpInfo);
          if (!this._input().is(":hidden")) {
            this._selectNextPart();
          }
        }
      },
      _detachMaskEvents() {
        events_engine_default.off(this._input(), "." + MASK_EVENT_NAMESPACE2);
      },
      _attachMaskEvents() {
        events_engine_default.on(this._input(), addNamespace2("dxclick", MASK_EVENT_NAMESPACE2), this._maskClickHandler.bind(this));
        events_engine_default.on(this._input(), addNamespace2("paste", MASK_EVENT_NAMESPACE2), this._maskPasteHandler.bind(this));
        events_engine_default.on(this._input(), addNamespace2("drop", MASK_EVENT_NAMESPACE2), () => {
          this._renderSelectedPart();
        });
        events_engine_default.on(this._input(), addNamespace2("compositionend", MASK_EVENT_NAMESPACE2), this._maskCompositionEndHandler.bind(this));
        if (this._useBeforeInputEvent()) {
          events_engine_default.on(this._input(), addNamespace2("beforeinput", MASK_EVENT_NAMESPACE2), this._maskBeforeInputHandler.bind(this));
        }
      },
      _renderSelectedPart() {
        this._renderDisplayText(this._getDisplayedText(this._maskValue));
        this._selectNextPart();
      },
      _selectLastPart() {
        if (this.option("text")) {
          this._activePartIndex = this._dateParts.length;
          this._selectNextPart(BACKWARD);
        }
      },
      _selectFirstPart() {
        if (this.option("text")) {
          this._activePartIndex = -1;
          this._selectNextPart(FORWARD);
        }
      },
      _onMouseWheel(e) {
        if (this._useMaskBehavior()) {
          this._partIncrease(e.delta > 0 ? FORWARD : BACKWARD, e);
        }
      },
      _selectNextPart() {
        var step = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
        if (!this.option("text") || this._disposed) {
          return;
        }
        if (step) {
          this._initialMaskValue = new Date(this._maskValue);
        }
        var index2 = fitIntoRange(this._activePartIndex + step, 0, this._dateParts.length - 1);
        if (this._dateParts[index2].isStub) {
          var isBoundaryIndex = 0 === index2 && step < 0 || index2 === this._dateParts.length - 1 && step > 0;
          if (!isBoundaryIndex) {
            this._selectNextPart(step >= 0 ? step + 1 : step - 1);
            return;
          } else {
            index2 = this._activePartIndex;
          }
        }
        if (this._activePartIndex !== index2) {
          this._clearSearchValue();
        }
        this._activePartIndex = index2;
        this._caret(this._getActivePartProp("caret"));
      },
      _getRealLimitsPattern() {
        if ("d" === this._getActivePartProp("pattern")[0]) {
          return "dM";
        }
      },
      _getActivePartLimits(lockOtherParts) {
        var limitFunction = this._getActivePartProp("limits");
        return limitFunction(this._maskValue, lockOtherParts && this._getRealLimitsPattern());
      },
      _getActivePartValue(dateValue) {
        dateValue = dateValue || this._maskValue;
        var getter = this._getActivePartProp("getter");
        return isFunction(getter) ? getter(dateValue) : dateValue[getter]();
      },
      _addLeadingZeroes(value2) {
        var zeroes = this._searchValue.match(/^0+/);
        var limits = this._getActivePartLimits();
        var maxLimitLength = String(limits.max).length;
        return ((zeroes && zeroes[0] || "") + String(value2)).substr(-maxLimitLength);
      },
      _setActivePartValue(value2, dateValue) {
        dateValue = dateValue || this._maskValue;
        var setter = this._getActivePartProp("setter");
        var limits = this._getActivePartLimits();
        value2 = inRange(value2, limits.min, limits.max) ? value2 : value2 % 10;
        value2 = this._addLeadingZeroes(fitIntoRange(value2, limits.min, limits.max));
        isFunction(setter) ? setter(dateValue, value2) : dateValue[setter](value2);
        this._renderDisplayText(this._getDisplayedText(dateValue));
        this._renderDateParts();
      },
      _getActivePartProp(property) {
        if (!this._dateParts || !this._dateParts[this._activePartIndex]) {
          return;
        }
        return this._dateParts[this._activePartIndex][property];
      },
      _loadMaskValue() {
        var value2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.dateOption("value");
        this._maskValue = value2 && new Date(value2);
        this._initialMaskValue = value2 && new Date(value2);
      },
      _saveMaskValue() {
        var value2 = this._maskValue && new Date(this._maskValue);
        if (value2 && "date" === this.option("type")) {
          value2.setHours(0, 0, 0, 0);
        }
        this._initialMaskValue = new Date(value2);
        this.dateOption("value", value2);
      },
      _revertChanges() {
        this._loadMaskValue();
        this._renderDisplayText(this._getDisplayedText(this._maskValue));
        this._renderDateParts();
      },
      _renderDisplayText(text) {
        this.callBase(text);
        if (this._useMaskBehavior()) {
          this.option("text", text);
        }
      },
      _partIncrease(step, lockOtherParts) {
        this._setNewDateIfEmpty();
        var {
          max,
          min
        } = this._getActivePartLimits(lockOtherParts);
        var limitDelta = max - min;
        if (1 === limitDelta) {
          limitDelta++;
        }
        var newValue = step + this._getActivePartValue();
        if (newValue > max) {
          newValue = this._applyLimits(newValue, {
            limitBase: min,
            limitClosest: max,
            limitDelta
          });
        } else if (newValue < min) {
          newValue = this._applyLimits(newValue, {
            limitBase: max,
            limitClosest: min,
            limitDelta
          });
        }
        this._setActivePartValue(newValue);
      },
      _applyLimits(newValue, _ref2) {
        var {
          limitBase,
          limitClosest,
          limitDelta
        } = _ref2;
        var delta = (newValue - limitClosest) % limitDelta;
        return delta ? limitBase + delta - 1 * sign(delta) : limitClosest;
      },
      _maskClickHandler() {
        if (this.option("text")) {
          this._activePartIndex = getDatePartIndexByPosition(this._dateParts, this._caret().start);
          if (!this._isAllSelected()) {
            if (isDefined(this._activePartIndex)) {
              this._caret(this._getActivePartProp("caret"));
            } else {
              this._selectLastPart();
            }
          }
        }
      },
      _maskCompositionEndHandler(e) {
        if (browser_default.msie && this._isSingleDigitKey(e)) {
          var key = e.originalEvent.data;
          this._processInputKey(key);
        } else {
          this._input().val(this._getDisplayedText(this._maskValue));
          this._selectNextPart();
          this._maskInputHandler = () => {
            this._renderSelectedPart();
          };
        }
      },
      _maskPasteHandler(e) {
        var newText = this._replaceSelectedText(this.option("text"), this._caret(), clipboardText(e));
        var date = date_default3.parse(newText, this._getFormatPattern());
        if (date && this._isDateValid(date)) {
          this._maskValue = date;
          this._renderDisplayText(this._getDisplayedText(this._maskValue));
          this._renderDateParts();
          this._selectNextPart();
        }
        e.preventDefault();
      },
      _isDateValid: (date) => isDate(date) && !isNaN(date),
      _isValueDirty() {
        var value2 = this.dateOption("value");
        return (this._maskValue && this._maskValue.getTime()) !== (value2 && value2.getTime());
      },
      _fireChangeEvent() {
        this._clearSearchValue();
        if (this._isValueDirty()) {
          events_engine_default.trigger(this._input(), "change");
        }
      },
      _enterHandler(e) {
        this._fireChangeEvent();
        this._selectNextPart(FORWARD);
        e.preventDefault();
      },
      _focusOutHandler(e) {
        var shouldFireChangeEvent = this._useMaskBehavior() && !e.isDefaultPrevented();
        if (shouldFireChangeEvent) {
          this._fireChangeEvent();
          this.callBase(e);
          this._selectFirstPart(e);
        } else {
          this.callBase(e);
        }
      },
      _valueChangeEventHandler(e) {
        var text = this.option("text");
        if (this._useMaskBehavior()) {
          this._saveValueChangeEvent(e);
          if (!text) {
            this._maskValue = null;
          } else if (null === this._maskValue) {
            this._loadMaskValue(text);
          }
          this._saveMaskValue();
        } else {
          this.callBase(e);
        }
      },
      _optionChanged(args) {
        switch (args.name) {
          case "useMaskBehavior":
            this._renderMask();
            break;
          case "displayFormat":
          case "mode":
            this.callBase(args);
            this._renderMask();
            break;
          case "value":
            this._loadMaskValue();
            this.callBase(args);
            this._renderDateParts();
            break;
          case "emptyDateValue":
            break;
          default:
            this.callBase(args);
        }
      },
      _clearMaskState() {
        this._clearSearchValue();
        delete this._dateParts;
        delete this._activePartIndex;
        delete this._maskValue;
      },
      reset() {
        this._clearMaskState();
        this._activePartIndex = 0;
        this.callBase();
      },
      _clean() {
        this.callBase();
        this._detachMaskEvents();
        this._clearMaskState();
      }
    });
    ui_date_box_mask_default = DateBoxMask;
  }
});

// node_modules/devextreme/esm/ui/date_box/ui.date_box.js
var init_ui_date_box = __esm({
  "node_modules/devextreme/esm/ui/date_box/ui.date_box.js"() {
    init_component_registrator();
    init_ui_date_box_mask();
    component_registrator_default("dxDateBox", ui_date_box_mask_default);
  }
});

// node_modules/devextreme/esm/ui/date_box.js
var init_date_box = __esm({
  "node_modules/devextreme/esm/ui/date_box.js"() {
    init_ui_date_box();
  }
});

// node_modules/devextreme/esm/ui/validation/default_adapter.js
var DefaultAdapter, default_adapter_default;
var init_default_adapter = __esm({
  "node_modules/devextreme/esm/ui/validation/default_adapter.js"() {
    init_class();
    DefaultAdapter = class_default.inherit({
      ctor(editor, validator) {
        this.editor = editor;
        this.validator = validator;
        this.validationRequestsCallbacks = [];
        var handler = (args) => {
          this.validationRequestsCallbacks.forEach((item) => item(args));
        };
        editor.validationRequest.add(handler);
        editor.on("disposing", function() {
          editor.validationRequest.remove(handler);
        });
      },
      getValue() {
        return this.editor.option("value");
      },
      getCurrentValidationError() {
        return this.editor.option("validationError");
      },
      bypass() {
        return this.editor.option("disabled");
      },
      applyValidationResults(params) {
        this.editor.option({
          validationErrors: params.brokenRules,
          validationStatus: params.status
        });
      },
      reset() {
        this.editor.reset();
      },
      focus() {
        this.editor.focus();
      }
    });
    default_adapter_default = DefaultAdapter;
  }
});

// node_modules/devextreme/esm/ui/validator.js
var VALIDATOR_CLASS, VALIDATION_STATUS_VALID2, VALIDATION_STATUS_INVALID2, VALIDATION_STATUS_PENDING, Validator, validator_default;
var init_validator = __esm({
  "node_modules/devextreme/esm/ui/validator.js"() {
    init_element_data();
    init_callbacks();
    init_ui_errors();
    init_dom_component();
    init_extend();
    init_iterator();
    init_validation_engine();
    init_default_adapter();
    init_component_registrator();
    init_deferred();
    init_guid();
    VALIDATOR_CLASS = "dx-validator";
    VALIDATION_STATUS_VALID2 = "valid";
    VALIDATION_STATUS_INVALID2 = "invalid";
    VALIDATION_STATUS_PENDING = "pending";
    Validator = dom_component_default.inherit({
      _initOptions: function(options2) {
        this.callBase.apply(this, arguments);
        this.option(validation_engine_default.initValidationOptions(options2));
      },
      _getDefaultOptions() {
        return extend2(this.callBase(), {
          validationRules: []
        });
      },
      _init() {
        this.callBase();
        this._initGroupRegistration();
        this.focused = callbacks_default();
        this._initAdapter();
        this._validationInfo = {
          result: null,
          deferred: null,
          skipValidation: false
        };
      },
      _initGroupRegistration() {
        var group = this._findGroup();
        if (!this._groupWasInit) {
          this.on("disposing", function(args) {
            validation_engine_default.removeRegisteredValidator(args.component._validationGroup, args.component);
          });
        }
        if (!this._groupWasInit || this._validationGroup !== group) {
          validation_engine_default.removeRegisteredValidator(this._validationGroup, this);
          this._groupWasInit = true;
          this._validationGroup = group;
          validation_engine_default.registerValidatorInGroup(group, this);
        }
      },
      _setOptionsByReference() {
        this.callBase();
        extend2(this._optionsByReference, {
          validationGroup: true
        });
      },
      _getEditor() {
        var element = this.$element()[0];
        return data(element, "dx-validation-target");
      },
      _initAdapter() {
        var dxStandardEditor = this._getEditor();
        var adapter = this.option("adapter");
        if (!adapter) {
          if (dxStandardEditor) {
            adapter = new default_adapter_default(dxStandardEditor, this);
            adapter.validationRequestsCallbacks.push((args) => {
              if (this._validationInfo.skipValidation) {
                return;
              }
              this.validate(args);
            });
            this.option("adapter", adapter);
            return;
          }
          throw ui_errors_default.Error("E0120");
        }
        var callbacks2 = adapter.validationRequestsCallbacks;
        if (callbacks2) {
          callbacks2.push((args) => {
            this.validate(args);
          });
        }
      },
      _toggleRTLDirection(isRtl) {
        var _this$option$editor$o, _this$option, _this$option$editor;
        var rtlEnabled = null !== (_this$option$editor$o = null === (_this$option = this.option("adapter")) || void 0 === _this$option ? void 0 : null === (_this$option$editor = _this$option.editor) || void 0 === _this$option$editor ? void 0 : _this$option$editor.option("rtlEnabled")) && void 0 !== _this$option$editor$o ? _this$option$editor$o : isRtl;
        this.callBase(rtlEnabled);
      },
      _initMarkup() {
        this.$element().addClass(VALIDATOR_CLASS);
        this.callBase();
      },
      _render() {
        this.callBase();
        this._toggleAccessibilityAttributes();
      },
      _toggleAccessibilityAttributes() {
        var dxStandardEditor = this._getEditor();
        if (dxStandardEditor) {
          var rules = this.option("validationRules") || [];
          var isRequired = rules.some((_ref) => {
            var {
              type: type2
            } = _ref;
            return "required" === type2;
          }) || null;
          if (dxStandardEditor.isInitialized()) {
            dxStandardEditor.setAria("required", isRequired);
          }
          dxStandardEditor.option("_onMarkupRendered", () => {
            dxStandardEditor.setAria("required", isRequired);
          });
        }
      },
      _visibilityChanged(visible2) {
        if (visible2) {
          this._initGroupRegistration();
        }
      },
      _optionChanged(args) {
        switch (args.name) {
          case "validationGroup":
            this._initGroupRegistration();
            return;
          case "validationRules":
            this._resetValidationRules();
            this._toggleAccessibilityAttributes();
            void 0 !== this.option("isValid") && this.validate();
            return;
          case "adapter":
            this._initAdapter();
            break;
          case "isValid":
          case "validationStatus":
            this.option(validation_engine_default.synchronizeValidationOptions(args, this.option()));
            break;
          default:
            this.callBase(args);
        }
      },
      _getValidationRules() {
        if (!this._validationRules) {
          this._validationRules = map(this.option("validationRules"), (rule, index2) => extend2({}, rule, {
            validator: this,
            index: index2
          }));
        }
        return this._validationRules;
      },
      _findGroup() {
        var $element = this.$element();
        return this.option("validationGroup") || validation_engine_default.findGroup($element, this._modelByElement($element));
      },
      _resetValidationRules() {
        delete this._validationRules;
      },
      validate(args) {
        var adapter = this.option("adapter");
        var name2 = this.option("name");
        var bypass = adapter.bypass && adapter.bypass();
        var value2 = args && void 0 !== args.value ? args.value : adapter.getValue();
        var currentError = adapter.getCurrentValidationError && adapter.getCurrentValidationError();
        var rules = this._getValidationRules();
        var currentResult = this._validationInfo && this._validationInfo.result;
        if (currentResult && currentResult.status === VALIDATION_STATUS_PENDING && currentResult.value === value2) {
          return extend2({}, currentResult);
        }
        var result2;
        if (bypass) {
          result2 = {
            isValid: true,
            status: VALIDATION_STATUS_VALID2
          };
        } else if (currentError && currentError.editorSpecific) {
          currentError.validator = this;
          result2 = {
            isValid: false,
            status: VALIDATION_STATUS_INVALID2,
            brokenRule: currentError,
            brokenRules: [currentError]
          };
        } else {
          result2 = validation_engine_default.validate(value2, rules, name2);
        }
        result2.id = new guid_default().toString();
        this._applyValidationResult(result2, adapter);
        result2.complete && result2.complete.then((res) => {
          if (res.id === this._validationInfo.result.id) {
            this._applyValidationResult(res, adapter);
          }
        });
        return extend2({}, this._validationInfo.result);
      },
      reset() {
        var adapter = this.option("adapter");
        var result2 = {
          id: null,
          isValid: true,
          brokenRule: null,
          brokenRules: null,
          pendingRules: null,
          status: VALIDATION_STATUS_VALID2,
          complete: null
        };
        this._validationInfo.skipValidation = true;
        adapter.reset();
        this._validationInfo.skipValidation = false;
        this._resetValidationRules();
        this._applyValidationResult(result2, adapter);
      },
      _updateValidationResult(result2) {
        if (!this._validationInfo.result || this._validationInfo.result.id !== result2.id) {
          var complete = this._validationInfo.deferred && this._validationInfo.result.complete;
          this._validationInfo.result = extend2({}, result2, {
            complete
          });
        } else {
          for (var prop in result2) {
            if ("id" !== prop && "complete" !== prop) {
              this._validationInfo.result[prop] = result2[prop];
            }
          }
        }
      },
      _applyValidationResult(result2, adapter) {
        var validatedAction = this._createActionByOption("onValidated", {
          excludeValidators: ["readOnly"]
        });
        result2.validator = this;
        this._updateValidationResult(result2);
        adapter.applyValidationResults && adapter.applyValidationResults(this._validationInfo.result);
        this.option({
          validationStatus: this._validationInfo.result.status
        });
        if (this._validationInfo.result.status === VALIDATION_STATUS_PENDING) {
          if (!this._validationInfo.deferred) {
            this._validationInfo.deferred = new Deferred();
            this._validationInfo.result.complete = this._validationInfo.deferred.promise();
          }
          this._eventsStrategy.fireEvent("validating", [this._validationInfo.result]);
          return;
        }
        if (this._validationInfo.result.status !== VALIDATION_STATUS_PENDING) {
          validatedAction(result2);
          if (this._validationInfo.deferred) {
            this._validationInfo.deferred.resolve(result2);
            this._validationInfo.deferred = null;
          }
        }
      },
      focus() {
        var adapter = this.option("adapter");
        adapter && adapter.focus && adapter.focus();
      },
      _useTemplates: function() {
        return false;
      }
    });
    component_registrator_default("dxValidator", Validator);
    validator_default = Validator;
  }
});

// node_modules/devextreme/esm/ui/form/components/label.js
function renderLabel(_ref) {
  var {
    text,
    id,
    location,
    alignment,
    labelID = null,
    markOptions = {}
  } = _ref;
  if (!isDefined(text) || text.length <= 0) {
    return null;
  }
  return renderer_default("<label>").addClass(FIELD_ITEM_LABEL_CLASS + " " + FIELD_ITEM_LABEL_LOCATION_CLASS + location).attr("for", id).attr("id", labelID).css("textAlign", alignment).append(renderer_default("<span>").addClass(FIELD_ITEM_LABEL_CONTENT_CLASS).append(renderer_default("<span>").addClass(FIELD_ITEM_LABEL_TEXT_CLASS).text(text), _renderLabelMark(markOptions)));
}
function _renderLabelMark(_ref2) {
  var {
    showRequiredMark,
    requiredMark,
    showOptionalMark,
    optionalMark
  } = _ref2;
  if (!showRequiredMark && !showOptionalMark) {
    return null;
  }
  return renderer_default("<span>").addClass(showRequiredMark ? FIELD_ITEM_REQUIRED_MARK_CLASS : FIELD_ITEM_OPTIONAL_MARK_CLASS).text(String.fromCharCode(160) + (showRequiredMark ? requiredMark : optionalMark));
}
function setLabelWidthByMaxLabelWidth($targetContainer, labelsSelector, labelMarkOptions) {
  var FIELD_ITEM_LABEL_CONTENT_CLASS_Selector = "".concat(labelsSelector, " > .").concat(FIELD_ITEM_LABEL_CLASS, ":not(.").concat(FIELD_ITEM_LABEL_LOCATION_CLASS, "top) > .").concat(FIELD_ITEM_LABEL_CONTENT_CLASS);
  var $FIELD_ITEM_LABEL_CONTENT_CLASS_Items = $targetContainer.find(FIELD_ITEM_LABEL_CONTENT_CLASS_Selector);
  var FIELD_ITEM_LABEL_CONTENT_CLASS_Length = $FIELD_ITEM_LABEL_CONTENT_CLASS_Items.length;
  var labelWidth;
  var i;
  var maxWidth = 0;
  for (i = 0; i < FIELD_ITEM_LABEL_CONTENT_CLASS_Length; i++) {
    labelWidth = getLabelWidthByInnerHTML({
      $FIELD_ITEM_LABEL_CONTENT_CLASS: $FIELD_ITEM_LABEL_CONTENT_CLASS_Items[i],
      location: "left",
      markOptions: labelMarkOptions
    });
    if (labelWidth > maxWidth) {
      maxWidth = labelWidth;
    }
  }
  for (i = 0; i < FIELD_ITEM_LABEL_CONTENT_CLASS_Length; i++) {
    $FIELD_ITEM_LABEL_CONTENT_CLASS_Items[i].style.width = maxWidth + "px";
  }
}
function getLabelWidthByInnerHTML(options2) {
  var {
    $FIELD_ITEM_LABEL_CONTENT_CLASS
  } = options2, renderLabelOptions = _objectWithoutPropertiesLoose(options2, _excluded2);
  var $hiddenContainer = renderer_default("<div>").addClass(WIDGET_CLASS3).addClass(GET_LABEL_WIDTH_BY_TEXT_CLASS).appendTo("body");
  renderLabelOptions.text = " ";
  var $label = renderLabel(renderLabelOptions).appendTo($hiddenContainer);
  var labelTextElement = $label.find("." + FIELD_ITEM_LABEL_TEXT_CLASS)[0];
  labelTextElement.innerHTML = getLabelInnerHTML($FIELD_ITEM_LABEL_CONTENT_CLASS);
  var result2 = labelTextElement.offsetWidth;
  $hiddenContainer.remove();
  return result2;
}
function getLabelInnerHTML($FIELD_ITEM_LABEL_CONTENT_CLASS) {
  var length = $FIELD_ITEM_LABEL_CONTENT_CLASS.children.length;
  var child;
  var result2 = "";
  var i;
  for (i = 0; i < length; i++) {
    child = $FIELD_ITEM_LABEL_CONTENT_CLASS.children[i];
    result2 += !isEmpty(child.innerText) ? child.innerText : child.innerHTML;
  }
  return result2;
}
var _excluded2, GET_LABEL_WIDTH_BY_TEXT_CLASS, FIELD_ITEM_REQUIRED_MARK_CLASS, FIELD_ITEM_LABEL_LOCATION_CLASS, FIELD_ITEM_OPTIONAL_MARK_CLASS, FIELD_ITEM_LABEL_TEXT_CLASS;
var init_label = __esm({
  "node_modules/devextreme/esm/ui/form/components/label.js"() {
    init_objectWithoutPropertiesLoose();
    init_renderer();
    init_type();
    init_string();
    init_constants3();
    _excluded2 = ["$FIELD_ITEM_LABEL_CONTENT_CLASS"];
    GET_LABEL_WIDTH_BY_TEXT_CLASS = "dx-layout-manager-hidden-label";
    FIELD_ITEM_REQUIRED_MARK_CLASS = "dx-field-item-required-mark";
    FIELD_ITEM_LABEL_LOCATION_CLASS = "dx-field-item-label-location-";
    FIELD_ITEM_OPTIONAL_MARK_CLASS = "dx-field-item-optional-mark";
    FIELD_ITEM_LABEL_TEXT_CLASS = "dx-field-item-label-text";
  }
});

// node_modules/devextreme/esm/ui/form/components/field_item.js
function renderFieldItem(_ref) {
  var {
    $parent,
    rootElementCssClassList,
    parentComponent,
    createComponentCallback,
    useFlexLayout,
    labelOptions,
    labelNeedBaselineAlign,
    labelLocation,
    needRenderLabel,
    formLabelLocation,
    item,
    editorOptions,
    isSimpleItem,
    isRequired,
    template,
    helpID,
    labelID,
    name: name2,
    helpText,
    requiredMessageTemplate,
    validationGroup
  } = _ref;
  var $rootElement = renderer_default("<div>").addClass(rootElementCssClassList.join(" ")).appendTo($parent);
  $rootElement.addClass(isRequired ? FIELD_ITEM_REQUIRED_CLASS : FIELD_ITEM_OPTIONAL_CLASS);
  if (isSimpleItem && useFlexLayout) {
    $rootElement.addClass(FLEX_LAYOUT_CLASS);
  }
  if (isSimpleItem && labelNeedBaselineAlign) {
    $rootElement.addClass(FIELD_ITEM_LABEL_ALIGN_CLASS);
  }
  var $fieldEditorContainer = renderer_default("<div>");
  $fieldEditorContainer.data("dx-form-item", item);
  $fieldEditorContainer.addClass(FIELD_ITEM_CONTENT_CLASS).addClass(FIELD_ITEM_CONTENT_LOCATION_CLASS + {
    right: "left",
    left: "right",
    top: "bottom"
  }[formLabelLocation]);
  var $label = needRenderLabel ? renderLabel(labelOptions) : null;
  if ($label) {
    $rootElement.append($label);
    if ("top" === labelLocation || "left" === labelLocation) {
      $rootElement.append($fieldEditorContainer);
    }
    if ("right" === labelLocation) {
      $rootElement.prepend($fieldEditorContainer);
    }
    if ("top" === labelLocation) {
      $rootElement.addClass(LABEL_VERTICAL_ALIGNMENT_CLASS);
    } else {
      $rootElement.addClass(LABEL_HORIZONTAL_ALIGNMENT_CLASS);
    }
    if ("dxCheckBox" === item.editorType || "dxSwitch" === item.editorType) {
      events_engine_default.on($label, CLICK_EVENT_NAME, function() {
        events_engine_default.trigger($fieldEditorContainer.children(), CLICK_EVENT_NAME);
      });
    }
  } else {
    $rootElement.append($fieldEditorContainer);
  }
  var widgetInstance;
  if (template) {
    template.render({
      container: getPublicElement($fieldEditorContainer),
      model: {
        dataField: item.dataField,
        editorType: item.editorType,
        editorOptions,
        component: parentComponent,
        name: item.name
      }
    });
  } else {
    var $div = renderer_default("<div>").appendTo($fieldEditorContainer);
    try {
      widgetInstance = createComponentCallback($div, item.editorType, editorOptions);
      widgetInstance.setAria("describedby", helpID);
      widgetInstance.setAria("labelledby", labelID);
      widgetInstance.setAria("required", isRequired);
    } catch (e) {
      ui_errors_default.log("E1035", e.message);
    }
  }
  var editorElem = $fieldEditorContainer.children().first();
  var $validationTarget = editorElem.hasClass(TEMPLATE_WRAPPER_CLASS4) ? editorElem.children().first() : editorElem;
  var validationTargetInstance = $validationTarget && $validationTarget.data("dx-validation-target");
  if (validationTargetInstance) {
    var isItemHaveCustomLabel = item.label && item.label.text;
    var itemName = isItemHaveCustomLabel ? null : name2;
    var fieldName = isItemHaveCustomLabel ? item.label.text : itemName && captionize(itemName);
    var validationRules;
    if (isSimpleItem) {
      if (item.validationRules) {
        validationRules = item.validationRules;
      } else {
        var requiredMessage = format(requiredMessageTemplate, fieldName || "");
        validationRules = item.isRequired ? [{
          type: "required",
          message: requiredMessage
        }] : null;
      }
    }
    if (Array.isArray(validationRules) && validationRules.length) {
      createComponentCallback($validationTarget, validator_default, {
        validationRules,
        validationGroup,
        dataGetter: function() {
          return {
            formItem: item
          };
        }
      });
    }
    if (isMaterial()) {
      var wrapperClass = "." + FIELD_ITEM_CONTENT_WRAPPER_CLASS;
      var toggleInvalidClass = function(e) {
        renderer_default(e.element).parents(wrapperClass).toggleClass(INVALID_CLASS2, false === e.component.option("isValid") && (e.component._isFocused() || "always" === e.component.option("validationMessageMode")));
      };
      validationTargetInstance.on("optionChanged", (e) => {
        if ("isValid" !== e.name) {
          return;
        }
        toggleInvalidClass(e);
      });
      validationTargetInstance.on("focusIn", toggleInvalidClass).on("focusOut", toggleInvalidClass).on("enterKey", toggleInvalidClass);
    }
  }
  if (helpText && isSimpleItem) {
    var $editorParent = $fieldEditorContainer.parent();
    $editorParent.append(renderer_default("<div>").addClass(FIELD_ITEM_CONTENT_WRAPPER_CLASS).append($fieldEditorContainer).append(renderer_default("<div>").addClass(FIELD_ITEM_HELP_TEXT_CLASS).attr("id", helpID).text(helpText)));
  }
  return {
    $fieldEditorContainer,
    $rootElement,
    widgetInstance
  };
}
var FLEX_LAYOUT_CLASS, FIELD_ITEM_OPTIONAL_CLASS, FIELD_ITEM_REQUIRED_CLASS, FIELD_ITEM_CONTENT_WRAPPER_CLASS, FIELD_ITEM_CONTENT_LOCATION_CLASS, FIELD_ITEM_LABEL_ALIGN_CLASS, FIELD_ITEM_HELP_TEXT_CLASS, LABEL_VERTICAL_ALIGNMENT_CLASS, LABEL_HORIZONTAL_ALIGNMENT_CLASS, TEMPLATE_WRAPPER_CLASS4, INVALID_CLASS2;
var init_field_item = __esm({
  "node_modules/devextreme/esm/ui/form/components/field_item.js"() {
    init_renderer();
    init_events_engine();
    init_click();
    init_element();
    init_inflector();
    init_string();
    init_themes();
    init_ui_errors();
    init_validator();
    init_constants3();
    init_label();
    FLEX_LAYOUT_CLASS = "dx-flex-layout";
    FIELD_ITEM_OPTIONAL_CLASS = "dx-field-item-optional";
    FIELD_ITEM_REQUIRED_CLASS = "dx-field-item-required";
    FIELD_ITEM_CONTENT_WRAPPER_CLASS = "dx-field-item-content-wrapper";
    FIELD_ITEM_CONTENT_LOCATION_CLASS = "dx-field-item-content-location-";
    FIELD_ITEM_LABEL_ALIGN_CLASS = "dx-field-item-label-align";
    FIELD_ITEM_HELP_TEXT_CLASS = "dx-field-item-help-text";
    LABEL_VERTICAL_ALIGNMENT_CLASS = "dx-label-v-align";
    LABEL_HORIZONTAL_ALIGNMENT_CLASS = "dx-label-h-align";
    TEMPLATE_WRAPPER_CLASS4 = "dx-template-wrapper";
    INVALID_CLASS2 = "dx-invalid";
  }
});

// node_modules/devextreme/esm/ui/form/components/button_item.js
function renderButtonItem(_ref) {
  var {
    item,
    $parent,
    rootElementCssClassList,
    validationGroup,
    createComponentCallback
  } = _ref;
  var $rootElement = renderer_default("<div>").appendTo($parent).addClass(rootElementCssClassList.join(" ")).addClass(FIELD_BUTTON_ITEM_CLASS).css("textAlign", convertAlignmentToTextAlign(item.horizontalAlignment));
  $parent.css("justifyContent", convertAlignmentToJustifyContent(item.verticalAlignment));
  var $button = renderer_default("<div>").appendTo($rootElement);
  return {
    $rootElement,
    buttonInstance: createComponentCallback($button, "dxButton", extend2({
      validationGroup
    }, item.buttonOptions))
  };
}
function convertAlignmentToTextAlign(horizontalAlignment) {
  return isDefined(horizontalAlignment) ? horizontalAlignment : "right";
}
function convertAlignmentToJustifyContent(verticalAlignment) {
  switch (verticalAlignment) {
    case "center":
      return "center";
    case "bottom":
      return "flex-end";
    default:
      return "flex-start";
  }
}
var FIELD_BUTTON_ITEM_CLASS;
var init_button_item = __esm({
  "node_modules/devextreme/esm/ui/form/components/button_item.js"() {
    init_renderer();
    init_type();
    init_extend();
    FIELD_BUTTON_ITEM_CLASS = "dx-field-button-item";
  }
});

// node_modules/devextreme/esm/ui/form/components/empty_item.js
function renderEmptyItem(_ref) {
  var {
    $parent,
    rootElementCssClassList
  } = _ref;
  return renderer_default("<div>").addClass(FIELD_EMPTY_ITEM_CLASS).html("&nbsp;").addClass(rootElementCssClassList.join(" ")).appendTo($parent);
}
var FIELD_EMPTY_ITEM_CLASS;
var init_empty_item = __esm({
  "node_modules/devextreme/esm/ui/form/components/empty_item.js"() {
    init_renderer();
    FIELD_EMPTY_ITEM_CLASS = "dx-field-empty-item";
  }
});

// node_modules/devextreme/esm/ui/form/ui.form.layout_manager.utils.js
function convertToRenderFieldItemOptions(_ref) {
  var {
    $parent,
    rootElementCssClassList,
    parentComponent,
    createComponentCallback,
    useFlexLayout,
    item,
    template,
    name: name2,
    formLabelLocation,
    requiredMessageTemplate,
    validationGroup,
    editorValue,
    canAssignUndefinedValueToEditor,
    editorValidationBoundary,
    editorStylingMode,
    showColonAfterLabel,
    managerLabelLocation,
    itemId,
    managerMarkOptions
  } = _ref;
  var isRequired = isDefined(item.isRequired) ? item.isRequired : !!_hasRequiredRuleInSet(item.validationRules);
  var isSimpleItem = item.itemType === SIMPLE_ITEM_TYPE;
  var helpID = item.helpText ? "dx-" + new guid_default() : null;
  var helpText = item.helpText;
  var labelOptions = _convertToLabelOptions({
    item,
    id: itemId,
    isRequired,
    managerMarkOptions,
    showColonAfterLabel,
    labelLocation: managerLabelLocation
  });
  var needRenderLabel = labelOptions.visible && labelOptions.text;
  var {
    location: labelLocation,
    labelID
  } = labelOptions;
  var labelNeedBaselineAlign = "top" !== labelLocation && (!!item.helpText && !useFlexLayout || -1 !== inArray(item.editorType, ["dxTextArea", "dxRadioGroup", "dxCalendar", "dxHtmlEditor"]));
  return {
    $parent,
    rootElementCssClassList,
    parentComponent,
    createComponentCallback,
    useFlexLayout,
    labelOptions,
    labelNeedBaselineAlign,
    labelLocation,
    needRenderLabel,
    item,
    isSimpleItem,
    isRequired,
    template,
    helpID,
    labelID,
    name: name2,
    helpText,
    formLabelLocation,
    requiredMessageTemplate,
    validationGroup,
    editorOptions: _convertToEditorOptions({
      editorType: item.editorType,
      editorValue,
      defaultEditorName: item.dataField,
      canAssignUndefinedValueToEditor,
      externalEditorOptions: item.editorOptions,
      editorInputId: itemId,
      editorValidationBoundary,
      editorStylingMode
    })
  };
}
function convertToLabelMarkOptions(_ref2, isRequired) {
  var {
    showRequiredMark,
    requiredMark,
    showOptionalMark,
    optionalMark
  } = _ref2;
  return {
    showRequiredMark: showRequiredMark && isRequired,
    requiredMark,
    showOptionalMark: showOptionalMark && !isRequired,
    optionalMark
  };
}
function _convertToEditorOptions(_ref3) {
  var {
    editorType,
    defaultEditorName,
    editorValue,
    canAssignUndefinedValueToEditor,
    externalEditorOptions,
    editorInputId,
    editorValidationBoundary,
    editorStylingMode
  } = _ref3;
  var editorOptionsWithValue = {};
  if (void 0 !== editorValue || canAssignUndefinedValueToEditor) {
    editorOptionsWithValue.value = editorValue;
  }
  if (-1 !== EDITORS_WITH_ARRAY_VALUE.indexOf(editorType)) {
    editorOptionsWithValue.value = editorOptionsWithValue.value || [];
  }
  var result2 = extend2(true, editorOptionsWithValue, externalEditorOptions, {
    inputAttr: {
      id: editorInputId
    },
    validationBoundary: editorValidationBoundary,
    stylingMode: editorStylingMode
  });
  if (externalEditorOptions) {
    if (result2.dataSource) {
      result2.dataSource = externalEditorOptions.dataSource;
    }
    if (result2.items) {
      result2.items = externalEditorOptions.items;
    }
  }
  if (defaultEditorName && !result2.name) {
    result2.name = defaultEditorName;
  }
  return result2;
}
function _hasRequiredRuleInSet(rules) {
  var hasRequiredRule;
  if (rules && rules.length) {
    each(rules, function(index2, rule) {
      if ("required" === rule.type) {
        hasRequiredRule = true;
        return false;
      }
    });
  }
  return hasRequiredRule;
}
function _convertToLabelOptions(_ref4) {
  var {
    item,
    id,
    isRequired,
    managerMarkOptions,
    showColonAfterLabel,
    labelLocation
  } = _ref4;
  var labelOptions = extend2({
    showColon: showColonAfterLabel,
    location: labelLocation,
    id,
    visible: true,
    isRequired
  }, item ? item.label : {}, {
    markOptions: convertToLabelMarkOptions(managerMarkOptions, isRequired)
  });
  if (-1 !== inArray(item.editorType, ["dxRadioGroup", "dxCheckBox", "dxLookup", "dxSlider", "dxRangeSlider", "dxSwitch", "dxHtmlEditor"])) {
    labelOptions.labelID = "dx-label-".concat(new guid_default());
  }
  if (!labelOptions.text && item.dataField) {
    labelOptions.text = captionize(item.dataField);
  }
  if (labelOptions.text) {
    labelOptions.text += labelOptions.showColon ? ":" : "";
  }
  return labelOptions;
}
var EDITORS_WITH_ARRAY_VALUE;
var init_ui_form_layout_manager_utils = __esm({
  "node_modules/devextreme/esm/ui/form/ui.form.layout_manager.utils.js"() {
    init_extend();
    init_type();
    init_iterator();
    init_inflector();
    init_array();
    init_guid();
    init_constants3();
    EDITORS_WITH_ARRAY_VALUE = ["dxTagBox", "dxRangeSlider"];
  }
});

// node_modules/devextreme/esm/ui/form/ui.form.layout_manager.js
var FORM_EDITOR_BY_DEFAULT, LAYOUT_MANAGER_FIRST_ROW_CLASS, LAYOUT_MANAGER_LAST_ROW_CLASS, LAYOUT_MANAGER_FIRST_COL_CLASS, LAYOUT_MANAGER_LAST_COL_CLASS, LAYOUT_STRATEGY_FLEX, LAYOUT_STRATEGY_FALLBACK, LayoutManager;
var init_ui_form_layout_manager = __esm({
  "node_modules/devextreme/esm/ui/form/ui.form.layout_manager.js"() {
    init_renderer();
    init_events_engine();
    init_ui_form_items_runtime_info();
    init_component_registrator();
    init_type();
    init_variable_wrapper();
    init_window();
    init_iterator();
    init_extend();
    init_array();
    init_data();
    init_remove();
    init_message();
    init_style();
    init_ui_widget();
    init_responsive_box();
    init_constants3();
    init_text_box2();
    init_number_box2();
    init_check_box();
    init_date_box();
    init_button();
    init_field_item();
    init_button_item();
    init_empty_item();
    init_ui_form_layout_manager_utils();
    FORM_EDITOR_BY_DEFAULT = "dxTextBox";
    LAYOUT_MANAGER_FIRST_ROW_CLASS = "dx-first-row";
    LAYOUT_MANAGER_LAST_ROW_CLASS = "dx-last-row";
    LAYOUT_MANAGER_FIRST_COL_CLASS = "dx-first-col";
    LAYOUT_MANAGER_LAST_COL_CLASS = "dx-last-col";
    LAYOUT_STRATEGY_FLEX = "flex";
    LAYOUT_STRATEGY_FALLBACK = "fallback";
    LayoutManager = ui_widget_default.inherit({
      _getDefaultOptions: function() {
        return extend2(this.callBase(), {
          layoutData: {},
          readOnly: false,
          colCount: 1,
          colCountByScreen: void 0,
          labelLocation: "left",
          onFieldDataChanged: null,
          onEditorEnterKey: null,
          customizeItem: null,
          alignItemLabels: true,
          minColWidth: 200,
          showRequiredMark: true,
          screenByWidth: null,
          showOptionalMark: false,
          requiredMark: "*",
          optionalMark: message_default.format("dxForm-optionalMark"),
          requiredMessage: message_default.getFormatter("dxForm-requiredMessage")
        });
      },
      _setOptionsByReference: function() {
        this.callBase();
        extend2(this._optionsByReference, {
          layoutData: true,
          validationGroup: true
        });
      },
      _init: function() {
        var layoutData = this.option("layoutData");
        this.callBase();
        this._itemWatchers = [];
        this._itemsRunTimeInfo = new FormItemsRunTimeInfo();
        this._updateReferencedOptions(layoutData);
        this._initDataAndItems(layoutData);
      },
      _dispose: function() {
        this.callBase();
        this._cleanItemWatchers();
      },
      _initDataAndItems: function(initialData) {
        this._syncDataWithItems();
        this._updateItems(initialData);
      },
      _syncDataWithItems: function() {
        var layoutData = this.option("layoutData");
        var userItems = this.option("items");
        if (isDefined(userItems)) {
          userItems.forEach((item) => {
            if (item.dataField && void 0 === this._getDataByField(item.dataField)) {
              var value2;
              if (item.editorOptions) {
                value2 = item.editorOptions.value;
              }
              if (isDefined(value2) || item.dataField in layoutData) {
                this._updateFieldValue(item.dataField, value2);
              }
            }
          });
        }
      },
      _getDataByField: function(dataField) {
        return dataField ? this.option("layoutData." + dataField) : null;
      },
      _isCheckboxUndefinedStateEnabled: function(_ref) {
        var {
          allowIndeterminateState,
          editorType,
          dataField
        } = _ref;
        if (true === allowIndeterminateState && "dxCheckBox" === editorType) {
          var nameParts = ["layoutData", ...dataField.split(".")];
          var propertyName = nameParts.pop();
          var layoutData = this.option(nameParts.join("."));
          return layoutData && propertyName in layoutData;
        }
        return false;
      },
      _updateFieldValue: function(dataField, value2) {
        var layoutData = this.option("layoutData");
        var newValue = value2;
        if (!variable_wrapper_default.isWrapped(layoutData[dataField]) && isDefined(dataField)) {
          this.option("layoutData." + dataField, newValue);
        } else if (variable_wrapper_default.isWritableWrapped(layoutData[dataField])) {
          newValue = isFunction(newValue) ? newValue() : newValue;
          layoutData[dataField](newValue);
        }
        this._triggerOnFieldDataChanged({
          dataField,
          value: newValue
        });
      },
      _triggerOnFieldDataChanged: function(args) {
        this._createActionByOption("onFieldDataChanged")(args);
      },
      _updateItems: function(layoutData) {
        var that = this;
        var userItems = this.option("items");
        var isUserItemsExist = isDefined(userItems);
        var customizeItem = that.option("customizeItem");
        var items = isUserItemsExist ? userItems : this._generateItemsByData(layoutData);
        if (isDefined(items)) {
          var processedItems = [];
          each(items, function(index2, item) {
            if (that._isAcceptableItem(item)) {
              item = that._processItem(item);
              customizeItem && customizeItem(item);
              if (isObject2(item) && false !== variable_wrapper_default.unwrap(item.visible)) {
                processedItems.push(item);
              }
            }
          });
          if (!that._itemWatchers.length || !isUserItemsExist) {
            that._updateItemWatchers(items);
          }
          this._setItems(processedItems);
          this._sortItems();
        }
      },
      _cleanItemWatchers: function() {
        this._itemWatchers.forEach(function(dispose) {
          dispose();
        });
        this._itemWatchers = [];
      },
      _updateItemWatchers: function(items) {
        var that = this;
        var watch = that._getWatch();
        items.forEach(function(item) {
          if (isObject2(item) && isDefined(item.visible) && isFunction(watch)) {
            that._itemWatchers.push(watch(function() {
              return variable_wrapper_default.unwrap(item.visible);
            }, function() {
              that._updateItems(that.option("layoutData"));
              that.repaint();
            }, {
              skipImmediate: true
            }));
          }
        });
      },
      _generateItemsByData: function(layoutData) {
        var result2 = [];
        if (isDefined(layoutData)) {
          each(layoutData, function(dataField) {
            result2.push({
              dataField
            });
          });
        }
        return result2;
      },
      _isAcceptableItem: function(item) {
        var itemField = item.dataField || item;
        var itemData = this._getDataByField(itemField);
        return !(isFunction(itemData) && !variable_wrapper_default.isWrapped(itemData));
      },
      _processItem: function(item) {
        if ("string" === typeof item) {
          item = {
            dataField: item
          };
        }
        if ("object" === typeof item && !item.itemType) {
          item.itemType = SIMPLE_ITEM_TYPE;
        }
        if (!isDefined(item.editorType) && isDefined(item.dataField)) {
          var value2 = this._getDataByField(item.dataField);
          item.editorType = isDefined(value2) ? this._getEditorTypeByDataType(type(value2)) : FORM_EDITOR_BY_DEFAULT;
        }
        if ("dxCheckBox" === item.editorType) {
          var _item$allowIndetermin;
          item.allowIndeterminateState = null !== (_item$allowIndetermin = item.allowIndeterminateState) && void 0 !== _item$allowIndetermin ? _item$allowIndetermin : true;
        }
        return item;
      },
      _getEditorTypeByDataType: function(dataType) {
        switch (dataType) {
          case "number":
            return "dxNumberBox";
          case "date":
            return "dxDateBox";
          case "boolean":
            return "dxCheckBox";
          default:
            return "dxTextBox";
        }
      },
      _sortItems: function() {
        normalizeIndexes(this._items, "visibleIndex");
        this._sortIndexes();
      },
      _sortIndexes: function() {
        this._items.sort(function(itemA, itemB) {
          var indexA = itemA.visibleIndex;
          var indexB = itemB.visibleIndex;
          var result2;
          if (indexA > indexB) {
            result2 = 1;
          } else if (indexA < indexB) {
            result2 = -1;
          } else {
            result2 = 0;
          }
          return result2;
        });
      },
      _initMarkup: function() {
        this._itemsRunTimeInfo.clear();
        this.$element().addClass(FORM_LAYOUT_MANAGER_CLASS);
        this.callBase();
        this._renderResponsiveBox();
      },
      _hasBrowserFlex: function() {
        return styleProp(LAYOUT_STRATEGY_FLEX) === LAYOUT_STRATEGY_FLEX;
      },
      _renderResponsiveBox: function() {
        var templatesInfo = [];
        if (this._items && this._items.length) {
          var colCount = this._getColCount();
          var $container = renderer_default("<div>").appendTo(this.$element());
          this._prepareItemsWithMerging(colCount);
          var layoutItems = this._generateLayoutItems();
          this._responsiveBox = this._createComponent($container, responsive_box_default, this._getResponsiveBoxConfig(layoutItems, colCount, templatesInfo));
          if (!hasWindow()) {
            this._renderTemplates(templatesInfo);
          }
        }
      },
      _itemStateChangedHandler: function(e) {
        this._refresh();
      },
      _renderTemplates: function(templatesInfo) {
        var that = this;
        each(templatesInfo, function(_2, info) {
          switch (info.itemType) {
            case "empty":
              renderEmptyItem(info);
              break;
            case "button":
              that._renderButtonItem(info);
              break;
            default:
              that._renderFieldItem(info);
          }
        });
      },
      _getResponsiveBoxConfig: function(layoutItems, colCount, templatesInfo) {
        var that = this;
        var colCountByScreen = that.option("colCountByScreen");
        var xsColCount = colCountByScreen && colCountByScreen.xs;
        return {
          onItemStateChanged: this._itemStateChangedHandler.bind(this),
          _layoutStrategy: that._hasBrowserFlex() ? LAYOUT_STRATEGY_FLEX : LAYOUT_STRATEGY_FALLBACK,
          onLayoutChanged: function() {
            var onLayoutChanged = that.option("onLayoutChanged");
            var isSingleColumnMode = that.isSingleColumnMode();
            if (onLayoutChanged) {
              that.$element().toggleClass(LAYOUT_MANAGER_ONE_COLUMN, isSingleColumnMode);
              onLayoutChanged(isSingleColumnMode);
            }
          },
          onContentReady: function(e) {
            if (hasWindow()) {
              that._renderTemplates(templatesInfo);
            }
            if (that.option("onLayoutChanged")) {
              that.$element().toggleClass(LAYOUT_MANAGER_ONE_COLUMN, that.isSingleColumnMode(e.component));
            }
          },
          itemTemplate: function(e, itemData, itemElement) {
            if (!e.location) {
              return;
            }
            var $itemElement = renderer_default(itemElement);
            var itemRenderedCountInPreviousRows = e.location.row * colCount;
            var item = that._items[e.location.col + itemRenderedCountInPreviousRows];
            var itemCssClassList = [item.cssClass];
            $itemElement.toggleClass(SINGLE_COLUMN_ITEM_CONTENT, that.isSingleColumnMode(this));
            if (0 === e.location.row) {
              itemCssClassList.push(LAYOUT_MANAGER_FIRST_ROW_CLASS);
            }
            if (0 === e.location.col) {
              itemCssClassList.push(LAYOUT_MANAGER_FIRST_COL_CLASS);
            }
            if (item.itemType === SIMPLE_ITEM_TYPE && that.option("isRoot")) {
              $itemElement.addClass(ROOT_SIMPLE_ITEM_CLASS);
            }
            var isLastColumn = e.location.col === colCount - 1 || e.location.col + e.location.colspan === colCount;
            var rowsCount = that._getRowsCount();
            var isLastRow = e.location.row === rowsCount - 1;
            if (isLastColumn) {
              itemCssClassList.push(LAYOUT_MANAGER_LAST_COL_CLASS);
            }
            if (isLastRow) {
              itemCssClassList.push(LAYOUT_MANAGER_LAST_ROW_CLASS);
            }
            if ("empty" !== item.itemType) {
              itemCssClassList.push(FIELD_ITEM_CLASS);
              itemCssClassList.push(that.option("cssItemClass"));
              if (isDefined(item.col)) {
                itemCssClassList.push("dx-col-" + item.col);
              }
            }
            templatesInfo.push({
              itemType: item.itemType,
              item,
              $parent: $itemElement,
              rootElementCssClassList: itemCssClassList
            });
          },
          cols: that._generateRatio(colCount),
          rows: that._generateRatio(that._getRowsCount(), true),
          dataSource: layoutItems,
          screenByWidth: that.option("screenByWidth"),
          singleColumnScreen: xsColCount ? false : "xs"
        };
      },
      _getColCount: function() {
        var colCount = this.option("colCount");
        var colCountByScreen = this.option("colCountByScreen");
        if (colCountByScreen) {
          var screenFactor = this.option("form").getTargetScreenFactor();
          if (!screenFactor) {
            screenFactor = hasWindow() ? getCurrentScreenFactor(this.option("screenByWidth")) : "lg";
          }
          colCount = colCountByScreen[screenFactor] || colCount;
        }
        if ("auto" === colCount) {
          if (this._cashedColCount) {
            return this._cashedColCount;
          }
          this._cashedColCount = colCount = this._getMaxColCount();
        }
        return colCount < 1 ? 1 : colCount;
      },
      _getMaxColCount: function() {
        if (!hasWindow()) {
          return 1;
        }
        var minColWidth = this.option("minColWidth");
        var width = this.$element().width();
        var itemsCount = this._items.length;
        var maxColCount = Math.floor(width / minColWidth) || 1;
        return itemsCount < maxColCount ? itemsCount : maxColCount;
      },
      isCachedColCountObsolete: function() {
        return this._cashedColCount && this._getMaxColCount() !== this._cashedColCount;
      },
      _prepareItemsWithMerging: function(colCount) {
        var items = this._items.slice(0);
        var item;
        var itemsMergedByCol;
        var result2 = [];
        var j;
        var i;
        for (i = 0; i < items.length; i++) {
          item = items[i];
          result2.push(item);
          if (this.option("alignItemLabels") || item.alignItemLabels || item.colSpan) {
            item.col = this._getColByIndex(result2.length - 1, colCount);
          }
          if (item.colSpan > 1 && item.col + item.colSpan <= colCount) {
            itemsMergedByCol = [];
            for (j = 0; j < item.colSpan - 1; j++) {
              itemsMergedByCol.push({
                merged: true
              });
            }
            result2 = result2.concat(itemsMergedByCol);
          } else {
            delete item.colSpan;
          }
        }
        this._setItems(result2);
      },
      _getColByIndex: function(index2, colCount) {
        return index2 % colCount;
      },
      _setItems: function(items) {
        this._items = items;
        this._cashedColCount = null;
      },
      _generateLayoutItems: function() {
        var items = this._items;
        var colCount = this._getColCount();
        var result2 = [];
        var item;
        var i;
        for (i = 0; i < items.length; i++) {
          item = items[i];
          if (!item.merged) {
            var generatedItem = {
              location: {
                row: parseInt(i / colCount),
                col: this._getColByIndex(i, colCount)
              }
            };
            if (isDefined(item.disabled)) {
              generatedItem.disabled = item.disabled;
            }
            if (isDefined(item.visible)) {
              generatedItem.visible = item.visible;
            }
            if (isDefined(item.colSpan)) {
              generatedItem.location.colspan = item.colSpan;
            }
            if (isDefined(item.rowSpan)) {
              generatedItem.location.rowspan = item.rowSpan;
            }
            if (isDefined(item._forceItemFlexSizeCorrectionInIE)) {
              generatedItem._forceItemFlexSizeCorrectionInIE = item._forceItemFlexSizeCorrectionInIE;
            }
            result2.push(generatedItem);
          }
        }
        return result2;
      },
      _renderEmptyItem: function($container) {
        renderEmptyItem({
          $container
        });
      },
      _renderButtonItem: function(_ref2) {
        var {
          item,
          $parent,
          rootElementCssClassList
        } = _ref2;
        var {
          $rootElement,
          buttonInstance
        } = renderButtonItem({
          item,
          $parent,
          rootElementCssClassList,
          validationGroup: this.option("validationGroup"),
          createComponentCallback: this._createComponent.bind(this)
        });
        this._itemsRunTimeInfo.add({
          item,
          widgetInstance: buttonInstance,
          guid: item.guid,
          $itemContainer: $rootElement
        });
      },
      _renderFieldItem: function(_ref3) {
        var _this$option;
        var {
          item,
          $parent,
          rootElementCssClassList
        } = _ref3;
        var editorValue = this._getDataByField(item.dataField);
        var canAssignUndefinedValueToEditor = false;
        if (void 0 === editorValue) {
          var {
            allowIndeterminateState,
            editorType,
            dataField
          } = item;
          canAssignUndefinedValueToEditor = this._isCheckboxUndefinedStateEnabled({
            allowIndeterminateState,
            editorType,
            dataField
          });
        }
        var name2 = item.dataField || item.name;
        var {
          $fieldEditorContainer,
          widgetInstance,
          $rootElement
        } = renderFieldItem(convertToRenderFieldItemOptions({
          $parent,
          rootElementCssClassList,
          item,
          name: name2,
          editorValue,
          canAssignUndefinedValueToEditor,
          parentComponent: this._getComponentOwner(),
          createComponentCallback: this._createComponent.bind(this),
          useFlexLayout: this._hasBrowserFlex(),
          formLabelLocation: this.option("labelLocation"),
          requiredMessageTemplate: this.option("requiredMessage"),
          validationGroup: this.option("validationGroup"),
          editorValidationBoundary: this.option("validationBoundary"),
          editorStylingMode: this.option("form") && this.option("form").option("stylingMode"),
          showColonAfterLabel: this.option("showColonAfterLabel"),
          managerLabelLocation: this.option("labelLocation"),
          template: item.template ? this._getTemplate(item.template) : null,
          itemId: this.option("form") && this.option("form").getItemID(name2),
          managerMarkOptions: this._getMarkOptions()
        }));
        null === (_this$option = this.option("onFieldItemRendered")) || void 0 === _this$option ? void 0 : _this$option();
        if (widgetInstance && item.dataField) {
          this._bindDataField(widgetInstance, item.dataField, item.editorType, $fieldEditorContainer);
        }
        this._itemsRunTimeInfo.add({
          item,
          widgetInstance,
          guid: item.guid,
          $itemContainer: $rootElement
        });
      },
      _getMarkOptions: function() {
        return {
          showRequiredMark: this.option("showRequiredMark"),
          requiredMark: this.option("requiredMark"),
          showOptionalMark: this.option("showOptionalMark"),
          optionalMark: this.option("optionalMark")
        };
      },
      _getComponentOwner: function() {
        return this.option("form") || this;
      },
      _bindDataField: function(editorInstance, dataField, editorType, $container) {
        var componentOwner = this._getComponentOwner();
        editorInstance.on("enterKey", function(args) {
          componentOwner._createActionByOption("onEditorEnterKey")(extend2(args, {
            dataField
          }));
        });
        this._createWatcher(editorInstance, $container, dataField);
        this.linkEditorToDataField(editorInstance, dataField, editorType);
      },
      _createWatcher: function(editorInstance, $container, dataField) {
        var that = this;
        var watch = that._getWatch();
        if (!isFunction(watch)) {
          return;
        }
        var dispose = watch(function() {
          return that._getDataByField(dataField);
        }, function() {
          editorInstance.option("value", that._getDataByField(dataField));
        }, {
          deep: true,
          skipImmediate: true
        });
        events_engine_default.on($container, removeEvent, dispose);
      },
      _getWatch: function() {
        if (!isDefined(this._watch)) {
          var formInstance = this.option("form");
          this._watch = formInstance && formInstance.option("integrationOptions.watchMethod");
        }
        return this._watch;
      },
      _createComponent: function($editor, type2, editorOptions) {
        var readOnlyState = this.option("readOnly");
        var instance = this.callBase($editor, type2, editorOptions);
        readOnlyState && instance.option("readOnly", readOnlyState);
        this.on("optionChanged", function(args) {
          if ("readOnly" === args.name && !isDefined(editorOptions.readOnly)) {
            instance.option(args.name, args.value);
          }
        });
        return instance;
      },
      _generateRatio: function(count, isAutoSize) {
        var result2 = [];
        var ratio;
        var i;
        for (i = 0; i < count; i++) {
          ratio = {
            ratio: 1
          };
          if (isAutoSize) {
            ratio.baseSize = "auto";
          }
          result2.push(ratio);
        }
        return result2;
      },
      _getRowsCount: function() {
        return Math.ceil(this._items.length / this._getColCount());
      },
      _updateReferencedOptions: function(newLayoutData) {
        var layoutData = this.option("layoutData");
        if (isObject2(layoutData)) {
          Object.getOwnPropertyNames(layoutData).forEach((property) => delete this._optionsByReference["layoutData." + property]);
        }
        if (isObject2(newLayoutData)) {
          Object.getOwnPropertyNames(newLayoutData).forEach((property) => this._optionsByReference["layoutData." + property] = true);
        }
      },
      _resetWidget(instance) {
        this._disableEditorValueChangedHandler = true;
        instance.reset();
        this._disableEditorValueChangedHandler = false;
        instance.option("isValid", true);
      },
      _optionChanged(args) {
        if (0 === args.fullName.search("layoutData.")) {
          return;
        }
        switch (args.name) {
          case "showRequiredMark":
          case "showOptionalMark":
          case "requiredMark":
          case "optionalMark":
            this._cashedRequiredConfig = null;
            this._invalidate();
            break;
          case "layoutData":
            this._updateReferencedOptions(args.value);
            if (this.option("items")) {
              if (!isEmptyObject(args.value)) {
                this._itemsRunTimeInfo.each((_2, itemRunTimeInfo) => {
                  if (isDefined(itemRunTimeInfo.item)) {
                    var dataField = itemRunTimeInfo.item.dataField;
                    if (dataField && isDefined(itemRunTimeInfo.widgetInstance)) {
                      var valueGetter = compileGetter(dataField);
                      var dataValue = valueGetter(args.value);
                      var {
                        allowIndeterminateState,
                        editorType
                      } = itemRunTimeInfo.item;
                      if (void 0 !== dataValue || this._isCheckboxUndefinedStateEnabled({
                        allowIndeterminateState,
                        editorType,
                        dataField
                      })) {
                        itemRunTimeInfo.widgetInstance.option("value", dataValue);
                      } else {
                        this._resetWidget(itemRunTimeInfo.widgetInstance);
                      }
                    }
                  }
                });
              }
            } else {
              this._initDataAndItems(args.value);
              this._invalidate();
            }
            break;
          case "items":
            this._cleanItemWatchers();
            this._initDataAndItems(args.value);
            this._invalidate();
            break;
          case "alignItemLabels":
          case "labelLocation":
          case "requiredMessage":
            this._invalidate();
            break;
          case "customizeItem":
            this._updateItems(this.option("layoutData"));
            this._invalidate();
            break;
          case "colCount":
            this._resetColCount();
            break;
          case "minColWidth":
            if ("auto" === this.option("colCount")) {
              this._resetColCount();
            }
            break;
          case "readOnly":
            break;
          case "width":
            this.callBase(args);
            if ("auto" === this.option("colCount")) {
              this._resetColCount();
            }
            break;
          case "onFieldDataChanged":
            break;
          default:
            this.callBase(args);
        }
      },
      _resetColCount: function() {
        this._cashedColCount = null;
        this._invalidate();
      },
      linkEditorToDataField(editorInstance, dataField) {
        this.on("optionChanged", (args) => {
          if (args.fullName === "layoutData.".concat(dataField)) {
            editorInstance._setOptionWithoutOptionChange("value", args.value);
          }
        });
        editorInstance.on("valueChanged", (args) => {
          var isValueReferenceType = isObject2(args.value) || Array.isArray(args.value);
          if (!this._disableEditorValueChangedHandler && !(isValueReferenceType && args.value === args.previousValue)) {
            this._updateFieldValue(dataField, args.value);
          }
        });
      },
      _dimensionChanged: function() {
        if ("auto" === this.option("colCount") && this.isCachedColCountObsolete()) {
          this._eventsStrategy.fireEvent("autoColCountChanged");
        }
      },
      updateData: function(data2, value2) {
        var that = this;
        if (isObject2(data2)) {
          each(data2, function(dataField, fieldValue) {
            that._updateFieldValue(dataField, fieldValue);
          });
        } else if ("string" === typeof data2) {
          that._updateFieldValue(data2, value2);
        }
      },
      getEditor: function(field) {
        return this._itemsRunTimeInfo.findWidgetInstanceByDataField(field) || this._itemsRunTimeInfo.findWidgetInstanceByName(field);
      },
      isSingleColumnMode: function(component) {
        var responsiveBox = this._responsiveBox || component;
        if (responsiveBox) {
          return responsiveBox.option("currentScreenFactor") === responsiveBox.option("singleColumnScreen");
        }
      },
      getItemsRunTimeInfo: function() {
        return this._itemsRunTimeInfo;
      }
    });
    component_registrator_default("dxLayoutManager", LayoutManager);
  }
});

// node_modules/devextreme/esm/ui/validation_summary.js
var VALIDATION_SUMMARY_CLASS, ITEM_CLASS4, ITEM_DATA_KEY3, ValidationSummary, validation_summary_default;
var init_validation_summary = __esm({
  "node_modules/devextreme/esm/ui/validation_summary.js"() {
    init_component_registrator();
    init_events_engine();
    init_common();
    init_extend();
    init_iterator();
    init_validation_engine();
    init_ui_collection_widget_edit();
    VALIDATION_SUMMARY_CLASS = "dx-validationsummary";
    ITEM_CLASS4 = VALIDATION_SUMMARY_CLASS + "-item";
    ITEM_DATA_KEY3 = VALIDATION_SUMMARY_CLASS + "-item-data";
    ValidationSummary = ui_collection_widget_edit_default.inherit({
      _getDefaultOptions() {
        return extend2(this.callBase(), {
          focusStateEnabled: false,
          noDataText: null
        });
      },
      _setOptionsByReference() {
        this.callBase();
        extend2(this._optionsByReference, {
          validationGroup: true
        });
      },
      _init() {
        this.callBase();
        this._initGroupRegistration();
      },
      _initGroupRegistration() {
        var $element = this.$element();
        var group = this.option("validationGroup") || validation_engine_default.findGroup($element, this._modelByElement($element));
        var groupConfig = validation_engine_default.addGroup(group);
        this._unsubscribeGroup();
        this._groupWasInit = true;
        this._validationGroup = group;
        this.groupSubscription = this._groupValidationHandler.bind(this);
        groupConfig.on("validated", this.groupSubscription);
      },
      _unsubscribeGroup() {
        var groupConfig = validation_engine_default.getGroupConfig(this._validationGroup);
        groupConfig && groupConfig.off("validated", this.groupSubscription);
      },
      _getOrderedItems(validators, items) {
        var orderedItems = [];
        each(validators, function(_2, validator) {
          var foundItems = grep(items, function(item) {
            if (item.validator === validator) {
              return true;
            }
          });
          if (foundItems.length) {
            orderedItems = orderedItems.concat(foundItems);
          }
        });
        return orderedItems;
      },
      _groupValidationHandler(params) {
        var items = this._getOrderedItems(params.validators, map(params.brokenRules, function(rule) {
          return {
            text: rule.message,
            validator: rule.validator,
            index: rule.index
          };
        }));
        this.validators = params.validators;
        each(this.validators, (_2, validator) => {
          if (validator._validationSummary !== this) {
            var handler = this._itemValidationHandler.bind(this);
            validator.on("validated", handler);
            validator.on("disposing", function() {
              validator.off("validated", handler);
              validator._validationSummary = null;
              handler = null;
            });
            validator._validationSummary = this;
          }
        });
        this.option("items", items);
      },
      _itemValidationHandler(_ref) {
        var {
          isValid,
          validator,
          brokenRules
        } = _ref;
        var items = this.option("items");
        var itemsChanged = false;
        var itemIndex = 0;
        var _loop = function() {
          var item = items[itemIndex];
          if (item.validator === validator) {
            var foundRule = grep(brokenRules || [], function(rule) {
              return rule.index === item.index;
            })[0];
            if (isValid || !foundRule) {
              items.splice(itemIndex, 1);
              itemsChanged = true;
              return "continue";
            }
            if (foundRule.message !== item.text) {
              item.text = foundRule.message;
              itemsChanged = true;
            }
          }
          itemIndex++;
        };
        while (itemIndex < items.length) {
          var _ret = _loop();
          if ("continue" === _ret) {
            continue;
          }
        }
        each(brokenRules, function(_2, rule) {
          var foundItem = grep(items, function(item) {
            return item.validator === validator && item.index === rule.index;
          })[0];
          if (!foundItem) {
            items.push({
              text: rule.message,
              validator,
              index: rule.index
            });
            itemsChanged = true;
          }
        });
        if (itemsChanged) {
          items = this._getOrderedItems(this.validators, items);
          this.option("items", items);
        }
      },
      _initMarkup() {
        this.$element().addClass(VALIDATION_SUMMARY_CLASS);
        this.callBase();
      },
      _optionChanged(args) {
        switch (args.name) {
          case "validationGroup":
            this._initGroupRegistration();
            break;
          default:
            this.callBase(args);
        }
      },
      _itemClass: () => ITEM_CLASS4,
      _itemDataKey: () => ITEM_DATA_KEY3,
      _postprocessRenderItem(params) {
        events_engine_default.on(params.itemElement, "click", function() {
          params.itemData.validator && params.itemData.validator.focus && params.itemData.validator.focus();
        });
      },
      _dispose() {
        this.callBase();
        this._unsubscribeGroup();
      }
    });
    component_registrator_default("dxValidationSummary", ValidationSummary);
    validation_summary_default = ValidationSummary;
  }
});

// node_modules/devextreme/esm/ui/validation_group.js
var VALIDATION_ENGINE_CLASS, VALIDATOR_CLASS2, VALIDATION_SUMMARY_CLASS2, ValidationGroup;
var init_validation_group = __esm({
  "node_modules/devextreme/esm/ui/validation_group.js"() {
    init_renderer();
    init_component_registrator();
    init_dom_component();
    init_validation_summary();
    init_validation_engine();
    init_validator();
    VALIDATION_ENGINE_CLASS = "dx-validationgroup";
    VALIDATOR_CLASS2 = "dx-validator";
    VALIDATION_SUMMARY_CLASS2 = "dx-validationsummary";
    ValidationGroup = class extends dom_component_default {
      _getDefaultOptions() {
        return super._getDefaultOptions();
      }
      _init() {
        super._init();
        validation_engine_default.addGroup(this);
      }
      _initMarkup() {
        var $element = this.$element();
        $element.addClass(VALIDATION_ENGINE_CLASS);
        $element.find(".".concat(VALIDATOR_CLASS2)).each(function(_2, validatorContainer) {
          validator_default.getInstance(renderer_default(validatorContainer))._initGroupRegistration();
        });
        $element.find(".".concat(VALIDATION_SUMMARY_CLASS2)).each(function(_2, summaryContainer) {
          validation_summary_default.getInstance(renderer_default(summaryContainer))._initGroupRegistration();
        });
        super._initMarkup();
      }
      validate() {
        return validation_engine_default.validateGroup(this);
      }
      reset() {
        return validation_engine_default.resetGroup(this);
      }
      _dispose() {
        validation_engine_default.removeGroup(this);
        this.$element().removeClass(VALIDATION_ENGINE_CLASS);
        super._dispose();
      }
      _useTemplates() {
        return false;
      }
    };
    component_registrator_default("dxValidationGroup", ValidationGroup);
  }
});

// node_modules/devextreme/esm/ui/form/ui.form.js
var FOCUSED_STATE_CLASS3, ITEM_OPTIONS_FOR_VALIDATION_UPDATING, Form, ui_form_default;
var init_ui_form = __esm({
  "node_modules/devextreme/esm/ui/form/ui.form.js"() {
    init_renderer();
    init_events_engine();
    init_component_registrator();
    init_guid();
    init_common();
    init_type();
    init_iterator();
    init_array();
    init_extend();
    init_browser();
    init_visibility_change();
    init_element();
    init_message();
    init_ui_widget();
    init_editor();
    init_window();
    init_validation_engine();
    init_ui_form_items_runtime_info();
    init_tab_panel();
    init_ui_scrollable();
    init_deferred();
    init_themes();
    init_ui_form_item_options_actions();
    init_ui_form_layout_manager();
    init_ui_form_utils();
    init_ui_form_layout_manager_utils();
    init_label();
    init_validation_summary();
    init_validation_group();
    init_constants3();
    init_constants();
    FOCUSED_STATE_CLASS3 = "dx-state-focused";
    ITEM_OPTIONS_FOR_VALIDATION_UPDATING = ["items", "isRequired", "validationRules", "visible"];
    Form = ui_widget_default.inherit({
      _init: function() {
        this.callBase();
        this._cachedColCountOptions = [];
        this._itemsRunTimeInfo = new FormItemsRunTimeInfo();
        this._groupsColCount = [];
        this._attachSyncSubscriptions();
      },
      _getDefaultOptions: function() {
        return extend2(this.callBase(), {
          formID: "dx-" + new guid_default(),
          formData: {},
          colCount: 1,
          screenByWidth: defaultScreenFactorFunc,
          colCountByScreen: void 0,
          labelLocation: "left",
          readOnly: false,
          onFieldDataChanged: null,
          customizeItem: null,
          onEditorEnterKey: null,
          minColWidth: 200,
          alignItemLabels: true,
          alignItemLabelsInAllGroups: true,
          alignRootItemLabels: true,
          showColonAfterLabel: true,
          showRequiredMark: true,
          showOptionalMark: false,
          requiredMark: "*",
          optionalMark: message_default.format("dxForm-optionalMark"),
          requiredMessage: message_default.getFormatter("dxForm-requiredMessage"),
          showValidationSummary: false,
          items: void 0,
          scrollingEnabled: false,
          validationGroup: void 0,
          stylingMode: void 0
        });
      },
      _defaultOptionsRules: function() {
        return this.callBase().concat([{
          device: function() {
            return isMaterial();
          },
          options: {
            showColonAfterLabel: false,
            labelLocation: "top"
          }
        }]);
      },
      _setOptionsByReference: function() {
        this.callBase();
        extend2(this._optionsByReference, {
          formData: true,
          validationGroup: true
        });
      },
      _getGroupColCount: function($element) {
        return parseInt($element.attr(GROUP_COL_COUNT_ATTR));
      },
      _applyLabelsWidthByCol: function($container, index2) {
        var options2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
        var labelMarkOptions = arguments.length > 3 ? arguments[3] : void 0;
        var fieldItemClass = options2.inOneColumn ? FIELD_ITEM_CLASS : FORM_FIELD_ITEM_COL_CLASS + index2;
        var cssExcludeTabbedSelector = options2.excludeTabbed ? ":not(.".concat(FIELD_ITEM_TAB_CLASS, ")") : "";
        setLabelWidthByMaxLabelWidth($container, ".".concat(fieldItemClass).concat(cssExcludeTabbedSelector), labelMarkOptions);
        return;
      },
      _applyLabelsWidth: function($container, excludeTabbed, inOneColumn, colCount, labelMarkOptions) {
        colCount = inOneColumn ? 1 : colCount || this._getGroupColCount($container);
        var applyLabelsOptions = {
          excludeTabbed,
          inOneColumn
        };
        var i;
        for (i = 0; i < colCount; i++) {
          this._applyLabelsWidthByCol($container, i, applyLabelsOptions, labelMarkOptions);
        }
      },
      _getGroupElementsInColumn: function($container, columnIndex, colCount) {
        var cssColCountSelector = isDefined(colCount) ? "." + GROUP_COL_COUNT_CLASS + colCount : "";
        var groupSelector = "." + FORM_FIELD_ITEM_COL_CLASS + columnIndex + " > ." + FIELD_ITEM_CONTENT_CLASS + " > ." + FORM_GROUP_CLASS + cssColCountSelector;
        return $container.find(groupSelector);
      },
      _applyLabelsWidthWithGroups: function($container, colCount, excludeTabbed, labelMarkOptions) {
        if (true === this.option("alignRootItemLabels")) {
          var $rootSimpleItems = $container.find(".".concat(ROOT_SIMPLE_ITEM_CLASS));
          for (var colIndex = 0; colIndex < colCount; colIndex++) {
            this._applyLabelsWidthByCol($rootSimpleItems, colIndex, excludeTabbed, labelMarkOptions);
          }
        }
        var alignItemLabelsInAllGroups = this.option("alignItemLabelsInAllGroups");
        if (alignItemLabelsInAllGroups) {
          this._applyLabelsWidthWithNestedGroups($container, colCount, excludeTabbed, labelMarkOptions);
        } else {
          var $groups = this.$element().find("." + FORM_GROUP_CLASS);
          var i;
          for (i = 0; i < $groups.length; i++) {
            this._applyLabelsWidth($groups.eq(i), excludeTabbed, void 0, void 0, labelMarkOptions);
          }
        }
      },
      _applyLabelsWidthWithNestedGroups: function($container, colCount, excludeTabbed, labelMarkOptions) {
        var applyLabelsOptions = {
          excludeTabbed
        };
        var colIndex;
        var groupsColIndex;
        var groupColIndex;
        var $groupsByCol;
        for (colIndex = 0; colIndex < colCount; colIndex++) {
          $groupsByCol = this._getGroupElementsInColumn($container, colIndex);
          this._applyLabelsWidthByCol($groupsByCol, 0, applyLabelsOptions, labelMarkOptions);
          for (groupsColIndex = 0; groupsColIndex < this._groupsColCount.length; groupsColIndex++) {
            $groupsByCol = this._getGroupElementsInColumn($container, colIndex, this._groupsColCount[groupsColIndex]);
            var groupColCount = this._getGroupColCount($groupsByCol);
            for (groupColIndex = 1; groupColIndex < groupColCount; groupColIndex++) {
              this._applyLabelsWidthByCol($groupsByCol, groupColIndex, applyLabelsOptions, labelMarkOptions);
            }
          }
        }
      },
      _labelLocation: function() {
        return this.option("labelLocation");
      },
      _alignLabelsInColumn: function(_ref) {
        var {
          layoutManager,
          inOneColumn,
          $container,
          excludeTabbed,
          items
        } = _ref;
        if (!hasWindow() || "top" === this._labelLocation()) {
          return;
        }
        var labelMarkOptions = convertToLabelMarkOptions(layoutManager._getMarkOptions());
        if (inOneColumn) {
          this._applyLabelsWidth($container, excludeTabbed, true, void 0, labelMarkOptions);
        } else if (this._checkGrouping(items)) {
          this._applyLabelsWidthWithGroups($container, layoutManager._getColCount(), excludeTabbed, labelMarkOptions);
        } else {
          this._applyLabelsWidth($container, excludeTabbed, false, layoutManager._getColCount(), labelMarkOptions);
        }
      },
      _prepareFormData: function() {
        if (!isDefined(this.option("formData"))) {
          this.option("formData", {});
        }
      },
      _initMarkup: function() {
        validation_engine_default.addGroup(this._getValidationGroup());
        this._clearCachedInstances();
        this._prepareFormData();
        this.$element().addClass(FORM_CLASS);
        this.callBase();
        this.setAria("role", "form", this.$element());
        if (this.option("scrollingEnabled")) {
          this._renderScrollable();
        }
        this._renderLayout();
        this._renderValidationSummary();
        this._lastMarkupScreenFactor = this._targetScreenFactor || this._getCurrentScreenFactor();
      },
      _getCurrentScreenFactor: function() {
        return hasWindow() ? getCurrentScreenFactor(this.option("screenByWidth")) : "lg";
      },
      _clearCachedInstances: function() {
        this._itemsRunTimeInfo.clear();
        this._cachedLayoutManagers = [];
      },
      _alignLabels: function(layoutManager, inOneColumn) {
        this._alignLabelsInColumn({
          $container: this.$element(),
          layoutManager,
          excludeTabbed: true,
          items: this.option("items"),
          inOneColumn
        });
        triggerResizeEvent(this.$element().find(".".concat(TOOLBAR_CLASS)));
      },
      _clean: function() {
        this.callBase();
        this._groupsColCount = [];
        this._cachedColCountOptions = [];
        this._lastMarkupScreenFactor = void 0;
      },
      _renderScrollable: function() {
        var useNativeScrolling = this.option("useNativeScrolling");
        this._scrollable = new ui_scrollable_default(this.$element(), {
          useNative: !!useNativeScrolling,
          useSimulatedScrollbar: !useNativeScrolling,
          useKeyboard: false,
          direction: "both",
          bounceEnabled: false
        });
      },
      _getContent: function() {
        return this.option("scrollingEnabled") ? this._scrollable.$content() : this.$element();
      },
      _renderValidationSummary: function() {
        var $validationSummary = this.$element().find("." + FORM_VALIDATION_SUMMARY);
        if ($validationSummary.length > 0) {
          $validationSummary.remove();
        }
        if (this.option("showValidationSummary")) {
          var _$validationSummary = renderer_default("<div>").addClass(FORM_VALIDATION_SUMMARY).appendTo(this._getContent());
          this._validationSummary = _$validationSummary.dxValidationSummary({
            validationGroup: this._getValidationGroup()
          }).dxValidationSummary("instance");
        }
      },
      _prepareItems(items, parentIsTabbedItem, currentPath, isTabs) {
        if (items) {
          var result2 = [];
          for (var i = 0; i < items.length; i++) {
            var item = items[i];
            var path = concatPaths(currentPath, createItemPathByIndex(i, isTabs));
            var guid2 = this._itemsRunTimeInfo.add({
              item,
              itemIndex: i,
              path
            });
            if (isString2(item)) {
              item = {
                dataField: item
              };
            }
            if (isObject2(item)) {
              var itemCopy = extend2({}, item);
              itemCopy.guid = guid2;
              this._tryPrepareGroupItem(itemCopy);
              this._tryPrepareTabbedItem(itemCopy, path);
              this._tryPrepareItemTemplate(itemCopy);
              if (parentIsTabbedItem) {
                itemCopy.cssItemClass = FIELD_ITEM_TAB_CLASS;
              }
              if (itemCopy.items) {
                itemCopy.items = this._prepareItems(itemCopy.items, parentIsTabbedItem, path);
              }
              result2.push(itemCopy);
            } else {
              result2.push(item);
            }
          }
          return result2;
        }
      },
      _tryPrepareGroupItem: function(item) {
        if ("group" === item.itemType) {
          item.alignItemLabels = ensureDefined(item.alignItemLabels, true);
          if (item.template) {
            item.groupContentTemplate = this._getTemplate(item.template);
          }
          item.template = this._itemGroupTemplate.bind(this, item);
        }
      },
      _tryPrepareTabbedItem: function(item, path) {
        if ("tabbed" === item.itemType) {
          item.template = this._itemTabbedTemplate.bind(this, item);
          item.tabs = this._prepareItems(item.tabs, true, path, true);
        }
      },
      _tryPrepareItemTemplate: function(item) {
        if (item.template) {
          item.template = this._getTemplate(item.template);
        }
      },
      _checkGrouping: function(items) {
        if (items) {
          for (var i = 0; i < items.length; i++) {
            var item = items[i];
            if ("group" === item.itemType) {
              return true;
            }
          }
        }
      },
      _renderLayout: function() {
        var that = this;
        var items = that.option("items");
        var $content = that._getContent();
        items = that._prepareItems(items);
        that._rootLayoutManager = that._renderLayoutManager(items, $content, {
          isRoot: true,
          colCount: that.option("colCount"),
          alignItemLabels: that.option("alignItemLabels"),
          screenByWidth: this.option("screenByWidth"),
          colCountByScreen: this.option("colCountByScreen"),
          onLayoutChanged: function(inOneColumn) {
            that._alignLabels.bind(that)(that._rootLayoutManager, inOneColumn);
          },
          onContentReady: function(e) {
            that._alignLabels(e.component, e.component.isSingleColumnMode());
          }
        });
      },
      _tryGetItemsForTemplate: function(item) {
        return item.items || [];
      },
      _itemTabbedTemplate: function(item, e, $container) {
        var $tabPanel = renderer_default("<div>").appendTo($container);
        var tabPanelOptions = extend2({}, item.tabPanelOptions, {
          dataSource: item.tabs,
          onItemRendered: (args) => triggerShownEvent(args.itemElement),
          itemTemplate: (itemData, e2, container) => {
            var $container2 = renderer_default(container);
            var alignItemLabels = ensureDefined(itemData.alignItemLabels, true);
            var layoutManager = this._renderLayoutManager(this._tryGetItemsForTemplate(itemData), $container2, {
              colCount: itemData.colCount,
              alignItemLabels,
              screenByWidth: this.option("screenByWidth"),
              colCountByScreen: itemData.colCountByScreen,
              cssItemClass: itemData.cssItemClass,
              onLayoutChanged: (inOneColumn) => {
                this._alignLabelsInColumn({
                  $container: $container2,
                  layoutManager,
                  items: itemData.items,
                  inOneColumn
                });
              }
            });
            if (this._itemsRunTimeInfo) {
              this._itemsRunTimeInfo.extendRunTimeItemInfoByKey(itemData.guid, {
                layoutManager
              });
            }
            if (alignItemLabels) {
              this._alignLabelsInColumn({
                $container: $container2,
                layoutManager,
                items: itemData.items,
                inOneColumn: layoutManager.isSingleColumnMode()
              });
            }
          }
        });
        var tryUpdateTabPanelInstance = (items, instance) => {
          if (Array.isArray(items)) {
            items.forEach((item2) => this._itemsRunTimeInfo.extendRunTimeItemInfoByKey(item2.guid, {
              widgetInstance: instance
            }));
          }
        };
        var tabPanel = this._createComponent($tabPanel, tab_panel_default, tabPanelOptions);
        renderer_default($container).parent().addClass(FIELD_ITEM_CONTENT_HAS_TABS_CLASS);
        tabPanel.on("optionChanged", (e2) => {
          if ("dataSource" === e2.fullName) {
            tryUpdateTabPanelInstance(e2.value, e2.component);
          }
        });
        tryUpdateTabPanelInstance([{
          guid: item.guid
        }, ...item.tabs], tabPanel);
      },
      _itemGroupTemplate: function(item, e, $container) {
        var $group = renderer_default("<div>").toggleClass(FORM_GROUP_WITH_CAPTION_CLASS, isDefined(item.caption) && item.caption.length).addClass(FORM_GROUP_CLASS).appendTo($container);
        renderer_default($container).parent().addClass(FIELD_ITEM_CONTENT_HAS_GROUP_CLASS);
        var colCount;
        var layoutManager;
        if (item.caption) {
          renderer_default("<span>").addClass(FORM_GROUP_CAPTION_CLASS).text(item.caption).appendTo($group);
        }
        var $groupContent = renderer_default("<div>").addClass(FORM_GROUP_CONTENT_CLASS).appendTo($group);
        if (item.groupContentTemplate) {
          var data2 = {
            formData: this.option("formData"),
            component: this
          };
          item.groupContentTemplate.render({
            model: data2,
            container: getPublicElement($groupContent)
          });
        } else {
          layoutManager = this._renderLayoutManager(this._tryGetItemsForTemplate(item), $groupContent, {
            colCount: item.colCount,
            colCountByScreen: item.colCountByScreen,
            alignItemLabels: item.alignItemLabels,
            cssItemClass: item.cssItemClass
          });
          this._itemsRunTimeInfo && this._itemsRunTimeInfo.extendRunTimeItemInfoByKey(item.guid, {
            layoutManager
          });
          colCount = layoutManager._getColCount();
          if (-1 === inArray(colCount, this._groupsColCount)) {
            this._groupsColCount.push(colCount);
          }
          $group.addClass(GROUP_COL_COUNT_CLASS + colCount);
          $group.attr(GROUP_COL_COUNT_ATTR, colCount);
        }
      },
      _renderLayoutManager: function(items, $rootElement, options2) {
        var $element = renderer_default("<div>");
        var that = this;
        var config2 = that._getLayoutManagerConfig(items, options2);
        var baseColCountByScreen = {
          lg: options2.colCount,
          md: options2.colCount,
          sm: options2.colCount,
          xs: 1
        };
        that._cachedColCountOptions.push({
          colCountByScreen: extend2(baseColCountByScreen, options2.colCountByScreen)
        });
        $element.appendTo($rootElement);
        var instance = that._createComponent($element, "dxLayoutManager", config2);
        instance.on("autoColCountChanged", function() {
          that._refresh();
        });
        that._cachedLayoutManagers.push(instance);
        return instance;
      },
      _getValidationGroup: function() {
        return this.option("validationGroup") || this;
      },
      _getLayoutManagerConfig: function(items, options2) {
        var baseConfig = {
          form: this,
          isRoot: options2.isRoot,
          validationGroup: this._getValidationGroup(),
          showRequiredMark: this.option("showRequiredMark"),
          showOptionalMark: this.option("showOptionalMark"),
          requiredMark: this.option("requiredMark"),
          optionalMark: this.option("optionalMark"),
          requiredMessage: this.option("requiredMessage"),
          screenByWidth: this.option("screenByWidth"),
          layoutData: this.option("formData"),
          labelLocation: this.option("labelLocation"),
          customizeItem: this.option("customizeItem"),
          minColWidth: this.option("minColWidth"),
          showColonAfterLabel: this.option("showColonAfterLabel"),
          onEditorEnterKey: this.option("onEditorEnterKey"),
          onFieldDataChanged: (args) => {
            if (!this._isDataUpdating) {
              this._triggerOnFieldDataChanged(args);
            }
          },
          validationBoundary: this.option("scrollingEnabled") ? this.$element() : void 0
        };
        return extend2(baseConfig, {
          items,
          onContentReady: (args) => {
            this._itemsRunTimeInfo.addItemsOrExtendFrom(args.component._itemsRunTimeInfo);
            options2.onContentReady && options2.onContentReady(args);
          },
          onDisposing: (_ref2) => {
            var {
              component
            } = _ref2;
            var nestedItemsRunTimeInfo = component.getItemsRunTimeInfo();
            this._itemsRunTimeInfo.removeItemsByItems(nestedItemsRunTimeInfo);
          },
          onFieldItemRendered: () => {
            var _this$_validationSumm;
            null === (_this$_validationSumm = this._validationSummary) || void 0 === _this$_validationSumm ? void 0 : _this$_validationSumm._initGroupRegistration();
          },
          colCount: options2.colCount,
          alignItemLabels: options2.alignItemLabels,
          cssItemClass: options2.cssItemClass,
          colCountByScreen: options2.colCountByScreen,
          onLayoutChanged: options2.onLayoutChanged,
          width: options2.width
        });
      },
      _createComponent: function($element, type2, config2) {
        config2 = config2 || {};
        this._extendConfig(config2, {
          readOnly: this.option("readOnly")
        });
        return this.callBase($element, type2, config2);
      },
      _attachSyncSubscriptions: function() {
        var that = this;
        that.on("optionChanged", function(args) {
          var optionFullName = args.fullName;
          if ("formData" === optionFullName) {
            if (!isDefined(args.value)) {
              that._options.silent("formData", args.value = {});
            }
            that._triggerOnFieldDataChangedByDataSet(args.value);
          }
          if (that._cachedLayoutManagers.length) {
            each(that._cachedLayoutManagers, function(index2, layoutManager) {
              if ("formData" === optionFullName) {
                that._isDataUpdating = true;
                layoutManager.option("layoutData", args.value);
                that._isDataUpdating = false;
              }
              if ("readOnly" === args.name || "disabled" === args.name) {
                layoutManager.option(optionFullName, args.value);
              }
            });
          }
        });
      },
      _optionChanged: function(args) {
        var rootNameOfComplexOption = this._getRootLevelOfExpectedComplexOption(args.fullName, ["formData", "items"]);
        if (rootNameOfComplexOption) {
          this._customHandlerOfComplexOption(args, rootNameOfComplexOption);
          return;
        }
        switch (args.name) {
          case "formData":
            if (!this.option("items")) {
              this._invalidate();
            } else if (isEmptyObject(args.value)) {
              this._resetValues();
            }
            break;
          case "onFieldDataChanged":
            break;
          case "items":
          case "colCount":
          case "onEditorEnterKey":
          case "labelLocation":
          case "alignItemLabels":
          case "showColonAfterLabel":
          case "customizeItem":
          case "alignItemLabelsInAllGroups":
          case "showRequiredMark":
          case "showOptionalMark":
          case "requiredMark":
          case "optionalMark":
          case "requiredMessage":
          case "scrollingEnabled":
          case "formID":
          case "colCountByScreen":
          case "screenByWidth":
          case "stylingMode":
            this._invalidate();
            break;
          case "showValidationSummary":
            this._renderValidationSummary();
            break;
          case "minColWidth":
            if ("auto" === this.option("colCount")) {
              this._invalidate();
            }
            break;
          case "alignRootItemLabels":
          case "readOnly":
            break;
          case "width":
            this.callBase(args);
            this._rootLayoutManager.option(args.name, args.value);
            this._alignLabels(this._rootLayoutManager, this._rootLayoutManager.isSingleColumnMode());
            break;
          case "visible":
            this.callBase(args);
            if (args.value) {
              triggerShownEvent(this.$element());
            }
            break;
          case "validationGroup":
            validation_engine_default.removeGroup(args.previousValue || this);
            this._invalidate();
            break;
          default:
            this.callBase(args);
        }
      },
      _getRootLevelOfExpectedComplexOption: function(fullOptionName, expectedRootNames) {
        var splitFullName = fullOptionName.split(".");
        var result2;
        if (splitFullName.length > 1) {
          var i;
          var rootOptionName = splitFullName[0];
          for (i = 0; i < expectedRootNames.length; i++) {
            if (-1 !== rootOptionName.search(expectedRootNames[i])) {
              result2 = expectedRootNames[i];
            }
          }
        }
        return result2;
      },
      _tryCreateItemOptionAction: function(optionName, item, value2, previousValue, itemPath) {
        if ("tabs" === optionName) {
          this._itemsRunTimeInfo.removeItemsByPathStartWith("".concat(itemPath, ".tabs"));
          value2 = this._prepareItems(value2, true, itemPath, true);
        }
        return ui_form_item_options_actions_default(optionName, {
          item,
          value: value2,
          previousValue,
          itemsRunTimeInfo: this._itemsRunTimeInfo
        });
      },
      _tryExecuteItemOptionAction: function(action) {
        return action && action.tryExecute();
      },
      _updateValidationGroupAndSummaryIfNeeded: function(fullName) {
        var optionName = getOptionNameFromFullName(fullName);
        if (ITEM_OPTIONS_FOR_VALIDATION_UPDATING.indexOf(optionName) > -1) {
          validation_engine_default.addGroup(this._getValidationGroup());
          if (this.option("showValidationSummary")) {
            var _this$_validationSumm2;
            null === (_this$_validationSumm2 = this._validationSummary) || void 0 === _this$_validationSumm2 ? void 0 : _this$_validationSumm2._initGroupRegistration();
          }
        }
      },
      _setLayoutManagerItemOption(layoutManager, optionName, value2, path) {
        if (this._updateLockCount > 0) {
          !layoutManager._updateLockCount && layoutManager.beginUpdate();
          var key = this._itemsRunTimeInfo.getKeyByPath(path);
          this.postponedOperations.add(key, () => {
            !layoutManager._disposed && layoutManager.endUpdate();
            return new Deferred().resolve();
          });
        }
        var contentReadyHandler = (e) => {
          e.component.off("contentReady", contentReadyHandler);
          if (isFullPathContainsTabs(path)) {
            var tabPath = tryGetTabPath(path);
            var tabLayoutManager = this._itemsRunTimeInfo.getGroupOrTabLayoutManagerByPath(tabPath);
            this._alignLabelsInColumn({
              items: tabLayoutManager.option("items"),
              layoutManager: tabLayoutManager,
              $container: tabLayoutManager.$element(),
              inOneColumn: tabLayoutManager.isSingleColumnMode()
            });
          } else {
            this._alignLabels(this._rootLayoutManager, this._rootLayoutManager.isSingleColumnMode());
          }
        };
        layoutManager.on("contentReady", contentReadyHandler);
        layoutManager.option(optionName, value2);
        this._updateValidationGroupAndSummaryIfNeeded(optionName);
      },
      _tryChangeLayoutManagerItemOption(fullName, value2) {
        var nameParts = fullName.split(".");
        var optionName = getOptionNameFromFullName(fullName);
        if ("items" === optionName && nameParts.length > 1) {
          var itemPath = this._getItemPath(nameParts);
          var layoutManager = this._itemsRunTimeInfo.getGroupOrTabLayoutManagerByPath(itemPath);
          if (layoutManager) {
            this._itemsRunTimeInfo.removeItemsByItems(layoutManager.getItemsRunTimeInfo());
            var items = this._prepareItems(value2, false, itemPath);
            this._setLayoutManagerItemOption(layoutManager, optionName, items, itemPath);
            return true;
          }
        } else if (nameParts.length > 2) {
          var endPartIndex = nameParts.length - 2;
          var _itemPath = this._getItemPath(nameParts.slice(0, endPartIndex));
          var _layoutManager = this._itemsRunTimeInfo.getGroupOrTabLayoutManagerByPath(_itemPath);
          if (_layoutManager) {
            var fullOptionName = getFullOptionName(nameParts[endPartIndex], optionName);
            if ("editorType" === optionName) {
              if (_layoutManager.option(fullOptionName) !== value2) {
                return false;
              }
            }
            if ("visible" === optionName) {
              var formItems = this.option(getFullOptionName(_itemPath, "items"));
              if (formItems && formItems.length) {
                var layoutManagerItems = _layoutManager.option("items");
                formItems.forEach((item, index2) => {
                  var layoutItem = layoutManagerItems[index2];
                  layoutItem.visibleIndex = item.visibleIndex;
                });
              }
            }
            this._setLayoutManagerItemOption(_layoutManager, fullOptionName, value2, _itemPath);
            return true;
          }
        }
        return false;
      },
      _tryChangeLayoutManagerItemOptions(itemPath, options2) {
        var result2;
        this.beginUpdate();
        each(options2, (optionName, optionValue) => {
          result2 = this._tryChangeLayoutManagerItemOption(getFullOptionName(itemPath, optionName), optionValue);
          if (!result2) {
            return false;
          }
        });
        this.endUpdate();
        return result2;
      },
      _customHandlerOfComplexOption: function(args, rootOptionName) {
        var nameParts = args.fullName.split(".");
        var value2 = args.value;
        if ("items" === rootOptionName) {
          var itemPath = this._getItemPath(nameParts);
          var item = this.option(itemPath);
          var optionNameWithoutPath = args.fullName.replace(itemPath + ".", "");
          var simpleOptionName = optionNameWithoutPath.split(".")[0].replace(/\[\d+]/, "");
          var itemAction = this._tryCreateItemOptionAction(simpleOptionName, item, item[simpleOptionName], args.previousValue, itemPath);
          if (!this._tryExecuteItemOptionAction(itemAction) && !this._tryChangeLayoutManagerItemOption(args.fullName, value2)) {
            if (item) {
              this._changeItemOption(item, optionNameWithoutPath, value2);
              var items = this._generateItemsFromData(this.option("items"));
              this.option("items", items);
            }
          }
        }
        if ("formData" === rootOptionName) {
          var dataField = nameParts.slice(1).join(".");
          var editor = this.getEditor(dataField);
          if (editor) {
            editor.option("value", value2);
          } else {
            this._triggerOnFieldDataChanged({
              dataField,
              value: value2
            });
          }
        }
      },
      _getItemPath: function(nameParts) {
        var itemPath = nameParts[0];
        var i;
        for (i = 1; i < nameParts.length; i++) {
          if (-1 !== nameParts[i].search(/items\[\d+]|tabs\[\d+]/)) {
            itemPath += "." + nameParts[i];
          } else {
            break;
          }
        }
        return itemPath;
      },
      _triggerOnFieldDataChanged: function(args) {
        this._createActionByOption("onFieldDataChanged")(args);
      },
      _triggerOnFieldDataChangedByDataSet: function(data2) {
        var that = this;
        if (data2 && isObject2(data2)) {
          each(data2, function(dataField, value2) {
            that._triggerOnFieldDataChanged({
              dataField,
              value: value2
            });
          });
        }
      },
      _updateFieldValue: function(dataField, value2) {
        if (isDefined(this.option("formData"))) {
          var editor = this.getEditor(dataField);
          this.option("formData." + dataField, value2);
          if (editor) {
            var editorValue = editor.option("value");
            if (editorValue !== value2) {
              editor.option("value", value2);
            }
          }
        }
      },
      _generateItemsFromData: function(items) {
        var formData = this.option("formData");
        var result2 = [];
        if (!items && isDefined(formData)) {
          each(formData, function(dataField) {
            result2.push({
              dataField
            });
          });
        }
        if (items) {
          each(items, function(index2, item) {
            if (isObject2(item)) {
              result2.push(item);
            } else {
              result2.push({
                dataField: item
              });
            }
          });
        }
        return result2;
      },
      _getItemByField: function(field, items) {
        var that = this;
        var fieldParts = isObject2(field) ? field : that._getFieldParts(field);
        var fieldName = fieldParts.fieldName;
        var fieldPath = fieldParts.fieldPath;
        var resultItem;
        if (items.length) {
          each(items, function(index2, item) {
            var itemType = item.itemType;
            if (fieldPath.length) {
              var path = fieldPath.slice();
              item = that._getItemByFieldPath(path, fieldName, item);
            } else if ("group" === itemType && !(item.caption || item.name) || "tabbed" === itemType && !item.name) {
              var subItemsField = that._getSubItemField(itemType);
              item.items = that._generateItemsFromData(item.items);
              item = that._getItemByField({
                fieldName,
                fieldPath
              }, item[subItemsField]);
            }
            if (isExpectedItem(item, fieldName)) {
              resultItem = item;
              return false;
            }
          });
        }
        return resultItem;
      },
      _getFieldParts: function(field) {
        var fieldName = field;
        var separatorIndex = fieldName.indexOf(".");
        var resultPath = [];
        while (-1 !== separatorIndex) {
          resultPath.push(fieldName.substr(0, separatorIndex));
          fieldName = fieldName.substr(separatorIndex + 1);
          separatorIndex = fieldName.indexOf(".");
        }
        return {
          fieldName,
          fieldPath: resultPath.reverse()
        };
      },
      _getItemByFieldPath: function(path, fieldName, item) {
        var itemType = item.itemType;
        var subItemsField = this._getSubItemField(itemType);
        var isItemWithSubItems = "group" === itemType || "tabbed" === itemType || item.title;
        var result2;
        do {
          if (isItemWithSubItems) {
            var name2 = item.name || item.caption || item.title;
            var isGroupWithName = isDefined(name2);
            var nameWithoutSpaces = getTextWithoutSpaces(name2);
            var pathNode = void 0;
            item[subItemsField] = this._generateItemsFromData(item[subItemsField]);
            if (isGroupWithName) {
              pathNode = path.pop();
            }
            if (!path.length) {
              result2 = this._getItemByField(fieldName, item[subItemsField]);
              if (result2) {
                break;
              }
            }
            if (!isGroupWithName || isGroupWithName && nameWithoutSpaces === pathNode) {
              if (path.length) {
                result2 = this._searchItemInEverySubItem(path, fieldName, item[subItemsField]);
              }
            }
          } else {
            break;
          }
        } while (path.length && !isDefined(result2));
        return result2;
      },
      _getSubItemField: function(itemType) {
        return "tabbed" === itemType ? "tabs" : "items";
      },
      _searchItemInEverySubItem: function(path, fieldName, items) {
        var that = this;
        var result2;
        each(items, function(index2, groupItem) {
          result2 = that._getItemByFieldPath(path.slice(), fieldName, groupItem);
          if (result2) {
            return false;
          }
        });
        if (!result2) {
          result2 = false;
        }
        return result2;
      },
      _changeItemOption: function(item, option, value2) {
        if (isObject2(item)) {
          item[option] = value2;
        }
      },
      _dimensionChanged: function() {
        var currentScreenFactor = this._getCurrentScreenFactor();
        if (this._lastMarkupScreenFactor !== currentScreenFactor) {
          if (this._isColCountChanged(this._lastMarkupScreenFactor, currentScreenFactor)) {
            this._targetScreenFactor = currentScreenFactor;
            this._refresh();
            this._targetScreenFactor = void 0;
          }
          this._lastMarkupScreenFactor = currentScreenFactor;
        }
      },
      _isColCountChanged: function(oldScreenSize, newScreenSize) {
        var isChanged = false;
        each(this._cachedColCountOptions, function(index2, item) {
          if (item.colCountByScreen[oldScreenSize] !== item.colCountByScreen[newScreenSize]) {
            isChanged = true;
            return false;
          }
        });
        return isChanged;
      },
      _refresh: function() {
        var editorSelector = "." + FOCUSED_STATE_CLASS3 + " input, ." + FOCUSED_STATE_CLASS3 + " textarea";
        events_engine_default.trigger(this.$element().find(editorSelector), "change");
        this.callBase();
      },
      _resetValues: function() {
        this._itemsRunTimeInfo.each(function(_2, itemRunTimeInfo) {
          if (isDefined(itemRunTimeInfo.widgetInstance) && editor_default.isEditor(itemRunTimeInfo.widgetInstance)) {
            itemRunTimeInfo.widgetInstance.reset();
            itemRunTimeInfo.widgetInstance.option("isValid", true);
          }
        });
        validation_engine_default.resetGroup(this._getValidationGroup());
      },
      _updateData: function(data2, value2, isComplexData) {
        var that = this;
        var _data = isComplexData ? value2 : data2;
        if (isObject2(_data)) {
          each(_data, function(dataField, fieldValue) {
            that._updateData(isComplexData ? data2 + "." + dataField : dataField, fieldValue, isObject2(fieldValue));
          });
        } else if (isString2(data2)) {
          that._updateFieldValue(data2, value2);
        }
      },
      registerKeyHandler: function(key, handler) {
        this.callBase(key, handler);
        this._itemsRunTimeInfo.each(function(_2, itemRunTimeInfo) {
          if (isDefined(itemRunTimeInfo.widgetInstance)) {
            itemRunTimeInfo.widgetInstance.registerKeyHandler(key, handler);
          }
        });
      },
      _focusTarget: function() {
        return this.$element().find("." + FIELD_ITEM_CONTENT_CLASS + " [tabindex]").first();
      },
      _visibilityChanged: function(visible2) {
        if (visible2 && browser_default.msie) {
          this._refresh();
        }
      },
      _dispose: function() {
        validation_engine_default.removeGroup(this._getValidationGroup());
        this.callBase();
      },
      resetValues: function() {
        this._resetValues();
      },
      updateData: function(data2, value2) {
        this._updateData(data2, value2);
      },
      getEditor: function(dataField) {
        return this._itemsRunTimeInfo.findWidgetInstanceByDataField(dataField) || this._itemsRunTimeInfo.findWidgetInstanceByName(dataField);
      },
      getButton: function(name2) {
        return this._itemsRunTimeInfo.findWidgetInstanceByName(name2);
      },
      updateDimensions: function() {
        var that = this;
        var deferred = new Deferred();
        if (that._scrollable) {
          that._scrollable.update().done(function() {
            deferred.resolveWith(that);
          });
        } else {
          deferred.resolveWith(that);
        }
        return deferred.promise();
      },
      itemOption: function(id, option, value2) {
        var items = this._generateItemsFromData(this.option("items"));
        var item = this._getItemByField(id, items);
        var path = getItemPath(items, item);
        if (!item) {
          return;
        }
        switch (arguments.length) {
          case 1:
            return item;
          case 3:
            var itemAction = this._tryCreateItemOptionAction(option, item, value2, item[option], path);
            this._changeItemOption(item, option, value2);
            var fullName = getFullOptionName(path, option);
            if (!this._tryExecuteItemOptionAction(itemAction) && !this._tryChangeLayoutManagerItemOption(fullName, value2)) {
              this.option("items", items);
            }
            break;
          default:
            if (isObject2(option)) {
              if (!this._tryChangeLayoutManagerItemOptions(path, option)) {
                var allowUpdateItems;
                each(option, (optionName, optionValue) => {
                  var itemAction2 = this._tryCreateItemOptionAction(optionName, item, optionValue, item[optionName], path);
                  this._changeItemOption(item, optionName, optionValue);
                  if (!allowUpdateItems && !this._tryExecuteItemOptionAction(itemAction2)) {
                    allowUpdateItems = true;
                  }
                });
                allowUpdateItems && this.option("items", items);
              }
            }
        }
      },
      validate: function() {
        return validation_engine_default.validateGroup(this._getValidationGroup());
      },
      getItemID: function(name2) {
        return "dx_" + this.option("formID") + "_" + (name2 || new guid_default());
      },
      getTargetScreenFactor: function() {
        return this._targetScreenFactor;
      }
    });
    component_registrator_default("dxForm", Form);
    ui_form_default = Form;
  }
});

// node_modules/devextreme/esm/ui/form.js
var form_default;
var init_form = __esm({
  "node_modules/devextreme/esm/ui/form.js"() {
    init_ui_form();
    form_default = ui_form_default;
  }
});

// node_modules/devextreme/esm/ui/grid_core/ui.grid_core.editing_form_based.js
var EDIT_FORM_ITEM_CLASS, EDIT_POPUP_CLASS, SCROLLABLE_CONTAINER_CLASS2, EDIT_POPUP_FORM_CLASS, BUTTON_CLASS, FORM_BUTTONS_CONTAINER_CLASS, getEditorType, forEachFormItems, editingFormBasedModule;
var init_ui_grid_core_editing_form_based = __esm({
  "node_modules/devextreme/esm/ui/grid_core/ui.grid_core.editing_form_based.js"() {
    init_renderer();
    init_window();
    init_events_engine();
    init_guid();
    init_type();
    init_iterator();
    init_extend();
    init_button();
    init_devices();
    init_form();
    init_deferred();
    init_common();
    init_ui_scrollable();
    init_popup();
    init_ui_grid_core_editing_constants();
    EDIT_FORM_ITEM_CLASS = "edit-form-item";
    EDIT_POPUP_CLASS = "edit-popup";
    SCROLLABLE_CONTAINER_CLASS2 = "dx-scrollable-container";
    EDIT_POPUP_FORM_CLASS = "edit-popup-form";
    BUTTON_CLASS = "dx-button";
    FORM_BUTTONS_CONTAINER_CLASS = "form-buttons-container";
    getEditorType = (item) => {
      var _column$formItem;
      var column = item.column;
      return item.isCustomEditorType ? item.editorType : null === (_column$formItem = column.formItem) || void 0 === _column$formItem ? void 0 : _column$formItem.editorType;
    };
    forEachFormItems = (items, callBack) => {
      items.forEach((item) => {
        if (item.items || item.tabs) {
          forEachFormItems(item.items || item.tabs, callBack);
        } else {
          callBack(item);
        }
      });
    };
    editingFormBasedModule = {
      extenders: {
        controllers: {
          editing: {
            init: function() {
              this._editForm = null;
              this._updateEditFormDeferred = null;
              this.callBase.apply(this, arguments);
            },
            isFormOrPopupEditMode: function() {
              return this.isPopupEditMode() || this.isFormEditMode();
            },
            isPopupEditMode: function() {
              var editMode = this.option("editing.mode");
              return editMode === EDIT_MODE_POPUP;
            },
            isFormEditMode: function() {
              var editMode = this.option("editing.mode");
              return editMode === EDIT_MODE_FORM;
            },
            getFirstEditableColumnIndex: function() {
              var firstFormItem = this._firstFormItem;
              if (this.isFormEditMode() && firstFormItem) {
                var editRowKey = this.option(EDITING_EDITROWKEY_OPTION_NAME);
                var editRowIndex = this._dataController.getRowIndexByKey(editRowKey);
                var $editFormElements = this._rowsView.getCellElements(editRowIndex);
                return this._rowsView._getEditFormEditorVisibleIndex($editFormElements, firstFormItem.column);
              }
              return this.callBase.apply(this, arguments);
            },
            getEditFormRowIndex: function() {
              return this.isFormOrPopupEditMode() ? this._getVisibleEditRowIndex() : this.callBase.apply(this, arguments);
            },
            _isEditColumnVisible: function() {
              var result2 = this.callBase.apply(this, arguments);
              var editingOptions = this.option("editing");
              return this.isFormOrPopupEditMode() ? editingOptions.allowUpdating || result2 : result2;
            },
            _handleDataChanged: function(args) {
              if (this.isPopupEditMode()) {
                var _args$items;
                var editRowKey = this.option("editing.editRowKey");
                var hasEditRow = null === args || void 0 === args ? void 0 : null === (_args$items = args.items) || void 0 === _args$items ? void 0 : _args$items.some((item) => equalByValue(item.key, editRowKey));
                if ("refresh" === args.changeType || hasEditRow) {
                  this._repaintEditPopup();
                }
              }
              this.callBase.apply(this, arguments);
            },
            getPopupContent: function() {
              var _this$_editPopup;
              var popupVisible = null === (_this$_editPopup = this._editPopup) || void 0 === _this$_editPopup ? void 0 : _this$_editPopup.option("visible");
              if (this.isPopupEditMode() && popupVisible) {
                return this._$popupContent;
              }
            },
            _showAddedRow: function(rowIndex) {
              if (this.isPopupEditMode()) {
                this._showEditPopup(rowIndex);
              } else {
                this.callBase.apply(this, arguments);
              }
            },
            _cancelEditDataCore: function() {
              this.callBase.apply(this, arguments);
              if (this.isPopupEditMode()) {
                this._hideEditPopup();
              }
            },
            _updateEditRowCore: function(row, skipCurrentRow, isCustomSetCellValue) {
              var editForm = this._editForm;
              if (this.isPopupEditMode()) {
                if (this.option("repaintChangesOnly")) {
                  var _row$update;
                  null === (_row$update = row.update) || void 0 === _row$update ? void 0 : _row$update.call(row, row);
                } else if (editForm) {
                  this._updateEditFormDeferred = new Deferred().done(() => editForm.repaint());
                  if (!this._updateLockCount) {
                    this._updateEditFormDeferred.resolve();
                  }
                }
              } else {
                this.callBase.apply(this, arguments);
              }
            },
            _showEditPopup: function(rowIndex, repaintForm) {
              var isMobileDevice = "desktop" !== devices_default.current().deviceType;
              var popupOptions = extend2({
                showTitle: false,
                fullScreen: isMobileDevice,
                toolbarItems: [{
                  toolbar: "bottom",
                  location: "after",
                  widget: "dxButton",
                  options: this._getSaveButtonConfig()
                }, {
                  toolbar: "bottom",
                  location: "after",
                  widget: "dxButton",
                  options: this._getCancelButtonConfig()
                }],
                contentTemplate: this._getPopupEditFormTemplate(rowIndex)
              }, this.option(EDITING_POPUP_OPTION_NAME));
              if (!this._editPopup) {
                var $popupContainer = renderer_default("<div>").appendTo(this.component.$element()).addClass(this.addWidgetPrefix(EDIT_POPUP_CLASS));
                this._editPopup = this._createComponent($popupContainer, popup_default, {});
                this._editPopup.on("hiding", this._getEditPopupHiddenHandler());
                this._editPopup.on("shown", (e) => {
                  events_engine_default.trigger(e.component.$content().find(FOCUSABLE_ELEMENT_SELECTOR).not("." + SCROLLABLE_CONTAINER_CLASS2).first(), "focus");
                  if (repaintForm) {
                    var _this$_editForm;
                    null === (_this$_editForm = this._editForm) || void 0 === _this$_editForm ? void 0 : _this$_editForm.repaint();
                  }
                });
              }
              this._editPopup.option(popupOptions);
              this._editPopup.show();
              this.callBase.apply(this, arguments);
            },
            _getPopupEditFormTemplate: function(rowIndex) {
              var row = this.component.getVisibleRows()[rowIndex];
              var templateOptions = {
                row,
                values: row.values,
                rowType: row.rowType,
                key: row.key,
                rowIndex
              };
              this._rowsView._addWatchMethod(templateOptions, row);
              return (container) => {
                var formTemplate = this.getEditFormTemplate();
                var scrollable = this._createComponent(renderer_default("<div>").appendTo(container), ui_scrollable_default);
                this._$popupContent = scrollable.$content();
                formTemplate(this._$popupContent, templateOptions, true);
                this._rowsView.renderDelayedTemplates();
              };
            },
            _repaintEditPopup: function() {
              var _this$_editPopup2;
              var rowIndex = this._getVisibleEditRowIndex();
              if (null !== (_this$_editPopup2 = this._editPopup) && void 0 !== _this$_editPopup2 && _this$_editPopup2.option("visible") && rowIndex >= 0) {
                var defaultAnimation = this._editPopup.option("animation");
                this._editPopup.option("animation", null);
                this._showEditPopup(rowIndex, true);
                this._editPopup.option("animation", defaultAnimation);
              }
            },
            _hideEditPopup: function() {
              var _this$_editPopup3;
              null === (_this$_editPopup3 = this._editPopup) || void 0 === _this$_editPopup3 ? void 0 : _this$_editPopup3.option("visible", false);
            },
            optionChanged: function(args) {
              if ("editing" === args.name && this.isFormOrPopupEditMode()) {
                var fullName = args.fullName;
                if (0 === fullName.indexOf(EDITING_FORM_OPTION_NAME)) {
                  this._handleFormOptionChange(args);
                  args.handled = true;
                } else if (0 === fullName.indexOf(EDITING_POPUP_OPTION_NAME)) {
                  this._handlePopupOptionChange(args);
                  args.handled = true;
                }
              }
              this.callBase.apply(this, arguments);
            },
            _handleFormOptionChange: function(args) {
              var _this$_editPopup4;
              if (this.isFormEditMode()) {
                var editRowIndex = this._getVisibleEditRowIndex();
                if (editRowIndex >= 0) {
                  this._dataController.updateItems({
                    changeType: "update",
                    rowIndices: [editRowIndex]
                  });
                }
              } else if (null !== (_this$_editPopup4 = this._editPopup) && void 0 !== _this$_editPopup4 && _this$_editPopup4.option("visible") && 0 === args.fullName.indexOf(EDITING_FORM_OPTION_NAME)) {
                this._repaintEditPopup();
              }
            },
            _handlePopupOptionChange: function(args) {
              var editPopup = this._editPopup;
              if (editPopup) {
                var popupOptionName = args.fullName.slice(EDITING_POPUP_OPTION_NAME.length + 1);
                if (popupOptionName) {
                  editPopup.option(popupOptionName, args.value);
                } else {
                  editPopup.option(args.value);
                }
              }
            },
            renderFormEditTemplate: function(detailCellOptions, item, form, container, isReadOnly) {
              var that = this;
              var $container = renderer_default(container);
              var column = item.column;
              var editorType = getEditorType(item);
              var rowData = null === detailCellOptions || void 0 === detailCellOptions ? void 0 : detailCellOptions.row.data;
              var cellOptions = extend2({}, detailCellOptions, {
                data: rowData,
                cellElement: null,
                isOnForm: true,
                item,
                column: extend2({}, column, {
                  editorType,
                  editorOptions: item.editorOptions
                }),
                id: form.getItemID(item.name || item.dataField),
                columnIndex: column.index,
                setValue: !isReadOnly && column.allowEditing && function(value2) {
                  that.updateFieldValue(cellOptions, value2);
                }
              });
              cellOptions.value = column.calculateCellValue(rowData);
              var template = this._getFormEditItemTemplate.bind(this)(cellOptions, column);
              this._rowsView.renderTemplate($container, template, cellOptions, !!$container.closest(getWindow().document).length).done(() => {
                this._rowsView._updateCell($container, cellOptions);
              });
              return cellOptions;
            },
            getFormEditorTemplate: function(cellOptions, item) {
              var column = this.component.columnOption(item.dataField);
              return (options2, container) => {
                var _cellOptions$row$watc, _cellOptions$row;
                var $container = renderer_default(container);
                null === (_cellOptions$row$watc = (_cellOptions$row = cellOptions.row).watch) || void 0 === _cellOptions$row$watc ? void 0 : _cellOptions$row$watc.call(_cellOptions$row, function() {
                  return column.selector(cellOptions.row.data);
                }, () => {
                  var _validator;
                  var $editorElement = $container.find(".dx-widget").first();
                  var validator = $editorElement.data("dxValidator");
                  var validatorOptions = null === (_validator = validator) || void 0 === _validator ? void 0 : _validator.option();
                  $container.contents().remove();
                  cellOptions = this.renderFormEditTemplate.bind(this)(cellOptions, item, options2.component, $container);
                  $editorElement = $container.find(".dx-widget").first();
                  validator = $editorElement.data("dxValidator");
                  if (validatorOptions && !validator) {
                    $editorElement.dxValidator({
                      validationRules: validatorOptions.validationRules,
                      validationGroup: validatorOptions.validationGroup,
                      dataGetter: validatorOptions.dataGetter
                    });
                  }
                });
                cellOptions = this.renderFormEditTemplate.bind(this)(cellOptions, item, options2.component, $container);
              };
            },
            getEditFormOptions: function(detailOptions) {
              var _this$_getValidationG;
              var editFormOptions = null === (_this$_getValidationG = this._getValidationGroupsInForm) || void 0 === _this$_getValidationG ? void 0 : _this$_getValidationG.call(this, detailOptions);
              var userCustomizeItem = this.option("editing.form.customizeItem");
              var editFormItemClass = this.addWidgetPrefix(EDIT_FORM_ITEM_CLASS);
              var items = this.option("editing.form.items");
              var isCustomEditorType = {};
              if (!items) {
                var columns = this.getController("columns").getColumns();
                items = [];
                each(columns, function(_2, column) {
                  if (!column.isBand && !column.type) {
                    items.push({
                      column,
                      name: column.name,
                      dataField: column.dataField
                    });
                  }
                });
              } else {
                forEachFormItems(items, (item) => {
                  var itemId = (null === item || void 0 === item ? void 0 : item.name) || (null === item || void 0 === item ? void 0 : item.dataField);
                  if (itemId) {
                    isCustomEditorType[itemId] = !!item.editorType;
                  }
                });
              }
              return extend2({}, editFormOptions, {
                items,
                formID: "dx-" + new guid_default(),
                customizeItem: (item) => {
                  var column;
                  var itemId = item.name || item.dataField;
                  if (item.column || itemId) {
                    column = item.column || this._columnsController.columnOption(item.name ? "name:" + item.name : "dataField:" + item.dataField);
                  }
                  if (column) {
                    item.label = item.label || {};
                    item.label.text = item.label.text || column.caption;
                    item.template = item.template || this.getFormEditorTemplate(detailOptions, item);
                    item.column = column;
                    item.isCustomEditorType = isCustomEditorType[itemId];
                    if (column.formItem) {
                      extend2(item, column.formItem);
                    }
                    if (void 0 === item.isRequired && column.validationRules) {
                      item.isRequired = column.validationRules.some(function(rule) {
                        return "required" === rule.type;
                      });
                      item.validationRules = [];
                    }
                    var itemVisible = isDefined(item.visible) ? item.visible : true;
                    if (!this._firstFormItem && itemVisible) {
                      this._firstFormItem = item;
                    }
                  }
                  null === userCustomizeItem || void 0 === userCustomizeItem ? void 0 : userCustomizeItem.call(this, item);
                  item.cssClass = isString2(item.cssClass) ? item.cssClass + " " + editFormItemClass : editFormItemClass;
                }
              });
            },
            getEditFormTemplate: function() {
              return ($container, detailOptions, isPopupForm) => {
                var editFormOptions = this.option(EDITING_FORM_OPTION_NAME);
                var baseEditFormOptions = this.getEditFormOptions(detailOptions);
                var $formContainer = renderer_default("<div>").appendTo($container);
                this._firstFormItem = void 0;
                if (isPopupForm) {
                  $formContainer.addClass(this.addWidgetPrefix(EDIT_POPUP_FORM_CLASS));
                }
                this._editForm = this._createComponent($formContainer, form_default, extend2({}, editFormOptions, baseEditFormOptions));
                if (!isPopupForm) {
                  var $buttonsContainer = renderer_default("<div>").addClass(this.addWidgetPrefix(FORM_BUTTONS_CONTAINER_CLASS)).appendTo($container);
                  this._createComponent(renderer_default("<div>").appendTo($buttonsContainer), button_default, this._getSaveButtonConfig());
                  this._createComponent(renderer_default("<div>").appendTo($buttonsContainer), button_default, this._getCancelButtonConfig());
                }
                this._editForm.on("contentReady", () => {
                  var _this$_editPopup5;
                  null === (_this$_editPopup5 = this._editPopup) || void 0 === _this$_editPopup5 ? void 0 : _this$_editPopup5.repaint();
                });
              };
            },
            getEditForm: function() {
              return this._editForm;
            },
            _endUpdateCore: function() {
              var _this$_updateEditForm;
              null === (_this$_updateEditForm = this._updateEditFormDeferred) || void 0 === _this$_updateEditForm ? void 0 : _this$_updateEditForm.resolve();
            },
            _beforeEndSaving: function() {
              this.callBase.apply(this, arguments);
              if (this.isPopupEditMode()) {
                var _this$_editPopup6;
                null === (_this$_editPopup6 = this._editPopup) || void 0 === _this$_editPopup6 ? void 0 : _this$_editPopup6.hide();
              }
            },
            _processDataItemCore: function(item, _ref) {
              var {
                type: type2
              } = _ref;
              if (this.isPopupEditMode() && type2 === DATA_EDIT_DATA_INSERT_TYPE) {
                item.visible = false;
              }
              this.callBase.apply(this, arguments);
            },
            _editRowFromOptionChangedCore: function(rowIndices, rowIndex) {
              var isPopupEditMode = this.isPopupEditMode();
              this.callBase(rowIndices, rowIndex, isPopupEditMode);
              if (isPopupEditMode) {
                this._showEditPopup(rowIndex);
              }
            }
          },
          data: {
            _updateEditItem: function(item) {
              if (this._editingController.isFormEditMode()) {
                item.rowType = "detail";
              }
            },
            _getChangedColumnIndices: function(oldItem, newItem, visibleRowIndex, isLiveUpdate) {
              if (false === isLiveUpdate && newItem.isEditing && this._editingController.isFormEditMode()) {
                return;
              }
              return this.callBase.apply(this, arguments);
            }
          }
        },
        views: {
          rowsView: {
            _renderCellContent: function($cell, options2) {
              if ("data" === options2.rowType && this._editingController.isPopupEditMode() && false === options2.row.visible) {
                return;
              }
              this.callBase.apply(this, arguments);
            },
            getCellElements: function(rowIndex) {
              var $cellElements = this.callBase(rowIndex);
              var editingController = this._editingController;
              var editForm = editingController.getEditForm();
              var editFormRowIndex = editingController.getEditFormRowIndex();
              if (editFormRowIndex === rowIndex && $cellElements && editForm) {
                return editForm.$element().find("." + this.addWidgetPrefix(EDIT_FORM_ITEM_CLASS) + ", ." + BUTTON_CLASS);
              }
              return $cellElements;
            },
            _getVisibleColumnIndex: function($cells, rowIndex, columnIdentifier) {
              var editFormRowIndex = this._editingController.getEditFormRowIndex();
              if (editFormRowIndex === rowIndex && isString2(columnIdentifier)) {
                var column = this._columnsController.columnOption(columnIdentifier);
                return this._getEditFormEditorVisibleIndex($cells, column);
              }
              return this.callBase.apply(this, arguments);
            },
            _getEditFormEditorVisibleIndex: function($cells, column) {
              var visibleIndex = -1;
              each($cells, function(index2, cellElement) {
                var item = renderer_default(cellElement).find(".dx-field-item-content").data("dx-form-item");
                if (null !== item && void 0 !== item && item.column && column && item.column.index === column.index) {
                  visibleIndex = index2;
                  return false;
                }
              });
              return visibleIndex;
            },
            _isFormItem: function(parameters) {
              var isDetailRow2 = "detail" === parameters.rowType || "detailAdaptive" === parameters.rowType;
              var isPopupEditing = "data" === parameters.rowType && this._editingController.isPopupEditMode();
              return (isDetailRow2 || isPopupEditing) && parameters.item;
            },
            _updateCell: function($cell, parameters) {
              if (this._isFormItem(parameters)) {
                this._formItemPrepared(parameters, $cell);
              } else {
                this.callBase($cell, parameters);
              }
            }
          }
        }
      }
    };
  }
});

// node_modules/devextreme/esm/ui/grid_core/ui.grid_core.editing_cell_based.js
var FOCUS_OVERLAY_CLASS, ADD_ROW_BUTTON_CLASS, DROPDOWN_EDITOR_OVERLAY_CLASS, EDITOR_CELL_CLASS3, ROW_CLASS4, CELL_MODIFIED_CLASS, DATA_ROW_CLASS2, ROW_REMOVED, EDITING_EDITROWKEY_OPTION_NAME2, EDITING_EDITCOLUMNNAME_OPTION_NAME2, DATA_EDIT_DATA_REMOVE_TYPE2, ui_grid_core_editing_cell_based_default;
var init_ui_grid_core_editing_cell_based = __esm({
  "node_modules/devextreme/esm/ui/grid_core/ui.grid_core.editing_cell_based.js"() {
    init_renderer();
    init_dom_adapter();
    init_window();
    init_events_engine();
    init_type();
    init_click();
    init_pointer();
    init_utils2();
    init_hold();
    init_deferred();
    init_common();
    init_array_utils();
    init_ui_grid_core_editing_constants();
    FOCUS_OVERLAY_CLASS = "focus-overlay";
    ADD_ROW_BUTTON_CLASS = "addrow-button";
    DROPDOWN_EDITOR_OVERLAY_CLASS = "dx-dropdowneditor-overlay";
    EDITOR_CELL_CLASS3 = "dx-editor-cell";
    ROW_CLASS4 = "dx-row";
    CELL_MODIFIED_CLASS = "dx-cell-modified";
    DATA_ROW_CLASS2 = "dx-data-row";
    ROW_REMOVED = "dx-row-removed";
    EDITING_EDITROWKEY_OPTION_NAME2 = "editing.editRowKey";
    EDITING_EDITCOLUMNNAME_OPTION_NAME2 = "editing.editColumnName";
    DATA_EDIT_DATA_REMOVE_TYPE2 = "remove";
    ui_grid_core_editing_cell_based_default = {
      extenders: {
        controllers: {
          editing: {
            init: function() {
              var needCreateHandlers = !this._saveEditorHandler;
              this.callBase.apply(this, arguments);
              if (needCreateHandlers) {
                var $pointerDownTarget;
                var isResizing;
                this._pointerUpEditorHandler = () => {
                  var _this$getController;
                  isResizing = null === (_this$getController = this.getController("columnsResizer")) || void 0 === _this$getController ? void 0 : _this$getController.isResizing();
                };
                this._pointerDownEditorHandler = (e) => $pointerDownTarget = renderer_default(e.target);
                this._saveEditorHandler = this.createAction(function(e) {
                  var event = e.event;
                  var $target = renderer_default(event.target);
                  var targetComponent = event[TARGET_COMPONENT_NAME];
                  var component = this.component;
                  if ($pointerDownTarget && $pointerDownTarget.is("input") && !$pointerDownTarget.is($target)) {
                    return;
                  }
                  function checkEditorPopup($element) {
                    if (!$element) {
                      return false;
                    }
                    var $dropDownEditorOverlay = $element.closest(".".concat(DROPDOWN_EDITOR_OVERLAY_CLASS));
                    var $componentElement = component.$element();
                    return $dropDownEditorOverlay.length > 0 && 0 === $componentElement.closest($dropDownEditorOverlay).length;
                  }
                  if (this.isCellOrBatchEditMode() && !this._editCellInProgress) {
                    var isEditorPopup = checkEditorPopup($target) || checkEditorPopup(null === targetComponent || void 0 === targetComponent ? void 0 : targetComponent.$element());
                    var isDomElement = !!$target.closest(getWindow().document).length;
                    var isAnotherComponent = targetComponent && !targetComponent._disposed && targetComponent !== this.component;
                    var isAddRowButton = !!$target.closest(".".concat(this.addWidgetPrefix(ADD_ROW_BUTTON_CLASS))).length;
                    var isFocusOverlay = $target.hasClass(this.addWidgetPrefix(FOCUS_OVERLAY_CLASS));
                    var isCellEditMode = this.isCellEditMode();
                    if (!isResizing && !isEditorPopup && !isFocusOverlay && !(isAddRowButton && isCellEditMode && this.isEditing()) && (isDomElement || isAnotherComponent)) {
                      this._closeEditItem.bind(this)($target);
                    }
                  }
                });
                events_engine_default.on(dom_adapter_default.getDocument(), pointer_default.up, this._pointerUpEditorHandler);
                events_engine_default.on(dom_adapter_default.getDocument(), pointer_default.down, this._pointerDownEditorHandler);
                events_engine_default.on(dom_adapter_default.getDocument(), CLICK_EVENT_NAME, this._saveEditorHandler);
              }
            },
            isCellEditMode: function() {
              return this.option("editing.mode") === EDIT_MODE_CELL;
            },
            isBatchEditMode: function() {
              return this.option("editing.mode") === EDIT_MODE_BATCH;
            },
            isCellOrBatchEditMode: function() {
              return this.isCellEditMode() || this.isBatchEditMode();
            },
            _needToCloseEditableCell: function($targetElement) {
              var $element = this.component.$element();
              var result2 = this.isEditing();
              var isCurrentComponentElement = !$element || !!$targetElement.closest($element).length;
              if (isCurrentComponentElement) {
                var isDataRow2 = $targetElement.closest("." + DATA_ROW_CLASS2).length;
                if (isDataRow2) {
                  var rowsView = this.getView("rowsView");
                  var $targetCell = $targetElement.closest("." + ROW_CLASS4 + "> td");
                  var rowIndex = rowsView.getRowIndex($targetCell.parent());
                  var columnIndex = rowsView.getCellElements(rowIndex).index($targetCell);
                  var visibleColumns = this._columnsController.getVisibleColumns();
                  var allowEditing = visibleColumns[columnIndex] && visibleColumns[columnIndex].allowEditing;
                  result2 = result2 && !allowEditing && !this.isEditCell(rowIndex, columnIndex);
                }
              }
              return result2 || this.callBase.apply(this, arguments);
            },
            _closeEditItem: function($targetElement) {
              if (this._needToCloseEditableCell($targetElement)) {
                this.closeEditCell();
              }
            },
            _focusEditorIfNeed: function() {
              if (this._needFocusEditor && this.isCellOrBatchEditMode()) {
                var _this$_rowsView;
                var editColumnIndex = this._getVisibleEditColumnIndex();
                var $cell = null === (_this$_rowsView = this._rowsView) || void 0 === _this$_rowsView ? void 0 : _this$_rowsView._getCellElement(this._getVisibleEditRowIndex(), editColumnIndex);
                if ($cell && !$cell.find(":focus").length) {
                  this._focusEditingCell(() => {
                    this._editCellInProgress = false;
                  }, $cell, true);
                } else {
                  this._editCellInProgress = false;
                }
                this._needFocusEditor = false;
              } else {
                this.callBase.apply(this, arguments);
              }
            },
            isEditing: function() {
              if (this.isCellOrBatchEditMode()) {
                var isEditRowKeyDefined = isDefined(this.option(EDITING_EDITROWKEY_OPTION_NAME2));
                var isEditColumnNameDefined = isDefined(this.option(EDITING_EDITCOLUMNNAME_OPTION_NAME2));
                return isEditRowKeyDefined && isEditColumnNameDefined;
              }
              return this.callBase.apply(this, arguments);
            },
            _handleEditColumnNameChange: function(args) {
              var oldRowIndex = this._getVisibleEditRowIndex(args.previousValue);
              if (this.isCellOrBatchEditMode() && -1 !== oldRowIndex && isDefined(args.value) && args.value !== args.previousValue) {
                var columnIndex = this._columnsController.getVisibleColumnIndex(args.value);
                var oldColumnIndex = this._columnsController.getVisibleColumnIndex(args.previousValue);
                this._editCellFromOptionChanged(columnIndex, oldColumnIndex, oldRowIndex);
              }
            },
            _addRow: function(parentKey, deferred) {
              if (this.isCellEditMode() && this.hasChanges()) {
                var _deferred = new Deferred();
                this.saveEditData().done(() => {
                  if (!this.hasChanges()) {
                    this.addRow(parentKey).done(_deferred.resolve).fail(_deferred.reject);
                  } else {
                    _deferred.reject("cancel");
                  }
                });
                return _deferred.promise();
              }
              return this.callBase.apply(this, arguments);
            },
            editCell: function(rowIndex, columnIndex) {
              return this._editCell({
                rowIndex,
                columnIndex
              });
            },
            _editCell: function(options2) {
              var d = new Deferred();
              var coreResult;
              this.executeOperation(d, () => {
                coreResult = this._editCellCore(options2);
                when(coreResult).done(d.resolve).fail(d.reject);
              });
              return void 0 !== coreResult ? coreResult : d.promise();
            },
            _editCellCore: function(options2) {
              var dataController = this._dataController;
              var isEditByOptionChanged = isDefined(options2.oldColumnIndex) || isDefined(options2.oldRowIndex);
              var {
                columnIndex,
                rowIndex,
                column,
                item
              } = this._getNormalizedEditCellOptions(options2);
              var params = {
                data: null === item || void 0 === item ? void 0 : item.data,
                cancel: false,
                column
              };
              if (void 0 === item.key) {
                this._dataController.fireError("E1043");
                return;
              }
              if (column && item && ("data" === item.rowType || "detailAdaptive" === item.rowType) && !item.removed && this.isCellOrBatchEditMode()) {
                if (!isEditByOptionChanged && this.isEditCell(rowIndex, columnIndex)) {
                  return true;
                }
                var editRowIndex = rowIndex + dataController.getRowIndexOffset();
                return when(this._beforeEditCell(rowIndex, columnIndex, item)).done((cancel2) => {
                  if (cancel2) {
                    return;
                  }
                  if (!this._prepareEditCell(params, item, columnIndex, editRowIndex)) {
                    this._processCanceledEditingCell();
                  }
                });
              }
              return false;
            },
            _beforeEditCell: function(rowIndex, columnIndex, item) {
              if (this.isCellEditMode() && !item.isNewRow && this.hasChanges()) {
                var d = new Deferred();
                this.saveEditData().always(() => {
                  d.resolve(this.hasChanges());
                });
                return d;
              }
            },
            publicMethods: function() {
              var publicMethods = this.callBase.apply(this, arguments);
              return publicMethods.concat(["editCell", "closeEditCell"]);
            },
            _getNormalizedEditCellOptions: function(_ref) {
              var {
                oldColumnIndex,
                oldRowIndex,
                columnIndex,
                rowIndex
              } = _ref;
              var columnsController = this._columnsController;
              var visibleColumns = columnsController.getVisibleColumns();
              var items = this._dataController.items();
              var item = items[rowIndex];
              var oldColumn;
              if (isDefined(oldColumnIndex)) {
                oldColumn = visibleColumns[oldColumnIndex];
              } else {
                oldColumn = this._getEditColumn();
              }
              if (!isDefined(oldRowIndex)) {
                oldRowIndex = this._getVisibleEditRowIndex();
              }
              if (isString2(columnIndex)) {
                columnIndex = columnsController.columnOption(columnIndex, "index");
                columnIndex = columnsController.getVisibleIndex(columnIndex);
              }
              var column = visibleColumns[columnIndex];
              return {
                oldColumn,
                columnIndex,
                oldRowIndex,
                rowIndex,
                column,
                item
              };
            },
            _prepareEditCell: function(params, item, editColumnIndex, editRowIndex) {
              if (!item.isNewRow) {
                params.key = item.key;
              }
              if (this._isEditingStart(params)) {
                return false;
              }
              this._pageIndex = this._dataController.pageIndex();
              this._setEditRowKey(item.key);
              this._setEditColumnNameByIndex(editColumnIndex);
              if (!params.column.showEditorAlways) {
                var _item$oldData;
                this._addInternalData({
                  key: item.key,
                  oldData: null !== (_item$oldData = item.oldData) && void 0 !== _item$oldData ? _item$oldData : item.data
                });
              }
              return true;
            },
            closeEditCell: function(isError, withoutSaveEditData) {
              var result2 = when();
              var oldEditRowIndex = this._getVisibleEditRowIndex();
              if (this.isCellOrBatchEditMode()) {
                var deferred = new Deferred();
                result2 = new Deferred();
                this.executeOperation(deferred, () => {
                  this._closeEditCellCore(isError, oldEditRowIndex, withoutSaveEditData).always(result2.resolve);
                });
              }
              return result2.promise();
            },
            _closeEditCellCore: function(isError, oldEditRowIndex, withoutSaveEditData) {
              var dataController = this._dataController;
              var deferred = new Deferred();
              var promise2 = deferred.promise();
              if (this.isCellEditMode() && this.hasChanges()) {
                if (!withoutSaveEditData) {
                  this.saveEditData().done((error) => {
                    if (!this.hasChanges()) {
                      this.closeEditCell(!!error).always(deferred.resolve);
                      return;
                    }
                    deferred.resolve();
                  });
                  return promise2;
                }
              } else {
                this._resetEditRowKey();
                this._resetEditColumnName();
                if (oldEditRowIndex >= 0) {
                  var rowIndices = [oldEditRowIndex];
                  this._beforeCloseEditCellInBatchMode(rowIndices);
                  if (!isError) {
                    dataController.updateItems({
                      changeType: "update",
                      rowIndices
                    });
                  }
                }
              }
              deferred.resolve();
              return promise2;
            },
            _resetModifiedClassCells: function(changes) {
              if (this.isBatchEditMode()) {
                var columnsCount = this._columnsController.getVisibleColumns().length;
                changes.forEach((_ref2) => {
                  var {
                    key
                  } = _ref2;
                  var rowIndex = this._dataController.getRowIndexByKey(key);
                  if (-1 !== rowIndex) {
                    for (var columnIndex = 0; columnIndex < columnsCount; columnIndex++) {
                      this._rowsView._getCellElement(rowIndex, columnIndex).removeClass(CELL_MODIFIED_CLASS);
                    }
                  }
                });
              }
            },
            _prepareChange: function(options2, value2, text) {
              var $cellElement = renderer_default(options2.cellElement);
              if (this.isBatchEditMode() && void 0 !== options2.key) {
                this._applyModified($cellElement, options2);
              }
              return this.callBase.apply(this, arguments);
            },
            _cancelSaving: function() {
              var dataController = this._dataController;
              if (this.isCellOrBatchEditMode()) {
                if (this.isBatchEditMode()) {
                  this._resetEditIndices();
                }
                dataController.updateItems();
              }
              this.callBase.apply(this, arguments);
            },
            optionChanged: function(args) {
              var fullName = args.fullName;
              if ("editing" === args.name && fullName === EDITING_EDITCOLUMNNAME_OPTION_NAME2) {
                this._handleEditColumnNameChange(args);
                args.handled = true;
              } else {
                this.callBase(args);
              }
            },
            _editCellFromOptionChanged: function(columnIndex, oldColumnIndex, oldRowIndex) {
              var columns = this._columnsController.getVisibleColumns();
              if (columnIndex > -1) {
                deferRender(() => {
                  this._repaintEditCell(columns[columnIndex], columns[oldColumnIndex], oldRowIndex);
                });
              }
            },
            _handleEditRowKeyChange: function(args) {
              if (this.isCellOrBatchEditMode()) {
                var columnIndex = this._getVisibleEditColumnIndex();
                var oldRowIndexCorrection = this._getEditRowIndexCorrection();
                var oldRowIndex = this._dataController.getRowIndexByKey(args.previousValue) + oldRowIndexCorrection;
                if (isDefined(args.value) && args.value !== args.previousValue) {
                  var _this$_editCellFromOp;
                  null === (_this$_editCellFromOp = this._editCellFromOptionChanged) || void 0 === _this$_editCellFromOp ? void 0 : _this$_editCellFromOp.call(this, columnIndex, columnIndex, oldRowIndex);
                }
              } else {
                this.callBase.apply(this, arguments);
              }
            },
            deleteRow: function(rowIndex) {
              if (this.isCellEditMode() && this.isEditing()) {
                var isNewRow = this._dataController.items()[rowIndex].isNewRow;
                var rowKey = this._dataController.getKeyByRowIndex(rowIndex);
                this.closeEditCell(null, isNewRow).always(() => {
                  rowIndex = this._dataController.getRowIndexByKey(rowKey);
                  this._checkAndDeleteRow(rowIndex);
                });
              } else {
                this.callBase.apply(this, arguments);
              }
            },
            _checkAndDeleteRow: function(rowIndex) {
              if (this.isBatchEditMode()) {
                this._deleteRowCore(rowIndex);
              } else {
                this.callBase.apply(this, arguments);
              }
            },
            _refreshCore: function(params) {
              var {
                isPageChanged
              } = null !== params && void 0 !== params ? params : {};
              var needResetIndexes = this.isBatchEditMode() || isPageChanged && "virtual" !== this.option("scrolling.mode");
              if (this.isCellOrBatchEditMode()) {
                if (needResetIndexes) {
                  this._resetEditColumnName();
                  this._resetEditRowKey();
                }
              } else {
                this.callBase.apply(this, arguments);
              }
            },
            _allowRowAdding: function(params) {
              if (this.isBatchEditMode()) {
                return true;
              }
              return this.callBase.apply(this, arguments);
            },
            _afterDeleteRow: function(rowIndex, oldEditRowIndex) {
              var dataController = this._dataController;
              if (this.isBatchEditMode()) {
                dataController.updateItems({
                  changeType: "update",
                  rowIndices: [oldEditRowIndex, rowIndex]
                });
                return new Deferred().resolve();
              }
              return this.callBase.apply(this, arguments);
            },
            _updateEditRow: function(row, forceUpdateRow, isCustomSetCellValue) {
              if (this.isCellOrBatchEditMode()) {
                this._updateRowImmediately(row, forceUpdateRow, isCustomSetCellValue);
              } else {
                this.callBase.apply(this, arguments);
              }
            },
            _isDefaultButtonVisible: function(button, options2) {
              if (this.isCellOrBatchEditMode()) {
                var isBatchMode = this.isBatchEditMode();
                switch (button.name) {
                  case "save":
                  case "cancel":
                  case "edit":
                    return false;
                  case "delete":
                    return this.callBase.apply(this, arguments) && (!isBatchMode || !options2.row.removed);
                  case "undelete":
                    return isBatchMode && this.allowDeleting(options2) && options2.row.removed;
                  default:
                    return this.callBase.apply(this, arguments);
                }
              }
              return this.callBase.apply(this, arguments);
            },
            _isRowDeleteAllowed: function() {
              var callBase = this.callBase.apply(this, arguments);
              return callBase || this.isBatchEditMode();
            },
            _beforeEndSaving: function(changes) {
              if (this.isCellEditMode()) {
                var _changes$;
                if ("update" !== (null === (_changes$ = changes[0]) || void 0 === _changes$ ? void 0 : _changes$.type)) {
                  this.callBase.apply(this, arguments);
                }
              } else {
                if (this.isBatchEditMode()) {
                  this._resetModifiedClassCells(changes);
                }
                this.callBase.apply(this, arguments);
              }
            },
            prepareEditButtons: function(headerPanel) {
              var editingOptions = this.option("editing") || {};
              var buttonItems = this.callBase.apply(this, arguments);
              if ((editingOptions.allowUpdating || editingOptions.allowAdding || editingOptions.allowDeleting) && this.isBatchEditMode()) {
                buttonItems.push(this.prepareButtonItem(headerPanel, "save", "saveEditData", 21));
                buttonItems.push(this.prepareButtonItem(headerPanel, "revert", "cancelEditData", 22));
              }
              return buttonItems;
            },
            _saveEditDataInner: function() {
              var _deferred2;
              var editRow = this._dataController.getVisibleRows()[this.getEditRowIndex()];
              var editColumn = this._getEditColumn();
              var showEditorAlways = null === editColumn || void 0 === editColumn ? void 0 : editColumn.showEditorAlways;
              var isUpdateInCellMode = this.isCellEditMode() && !(null !== editRow && void 0 !== editRow && editRow.isNewRow);
              var deferred;
              if (isUpdateInCellMode && showEditorAlways) {
                deferred = new Deferred();
                this.addDeferred(deferred);
              }
              return this.callBase.apply(this, arguments).always(null === (_deferred2 = deferred) || void 0 === _deferred2 ? void 0 : _deferred2.resolve);
            },
            _applyChange: function(options2, params, forceUpdateRow) {
              var isUpdateInCellMode = this.isCellEditMode() && options2.row && !options2.row.isNewRow;
              var showEditorAlways = options2.column.showEditorAlways;
              var isCustomSetCellValue = options2.column.setCellValue !== options2.column.defaultSetCellValue;
              var focusPreviousEditingCell = showEditorAlways && !forceUpdateRow && isUpdateInCellMode && this.hasEditData() && !this.isEditCell(options2.rowIndex, options2.columnIndex);
              if (focusPreviousEditingCell) {
                this._focusEditingCell();
                this._updateEditRow(options2.row, true, isCustomSetCellValue);
                return;
              }
              return this.callBase.apply(this, arguments);
            },
            _applyChangeCore: function(options2, forceUpdateRow) {
              var showEditorAlways = options2.column.showEditorAlways;
              var isUpdateInCellMode = this.isCellEditMode() && options2.row && !options2.row.isNewRow;
              if (showEditorAlways && !forceUpdateRow) {
                if (isUpdateInCellMode) {
                  this._setEditRowKey(options2.row.key, true);
                  this._setEditColumnNameByIndex(options2.columnIndex, true);
                  return this.saveEditData();
                } else if (this.isBatchEditMode()) {
                  forceUpdateRow = this._needUpdateRow(options2.column);
                  return this.callBase(options2, forceUpdateRow);
                }
              }
              return this.callBase.apply(this, arguments);
            },
            _processDataItemCore: function(item, _ref3) {
              var {
                data: data2,
                type: type2
              } = _ref3;
              if (this.isBatchEditMode() && type2 === DATA_EDIT_DATA_REMOVE_TYPE2) {
                item.data = createObjectWithChanges(item.data, data2);
              }
              this.callBase.apply(this, arguments);
            },
            _processRemoveCore: function(changes, editIndex, processIfBatch) {
              if (this.isBatchEditMode() && !processIfBatch) {
                return;
              }
              return this.callBase.apply(this, arguments);
            },
            _processRemoveIfError: function() {
              if (this.isBatchEditMode()) {
                return;
              }
              return this.callBase.apply(this, arguments);
            },
            _beforeFocusElementInRow: function(rowIndex) {
              this.callBase.apply(this, arguments);
              var editRowIndex = rowIndex >= 0 ? rowIndex : 0;
              var columnIndex = this.getFirstEditableColumnIndex();
              columnIndex >= 0 && this.editCell(editRowIndex, columnIndex);
            }
          }
        },
        views: {
          rowsView: {
            _createTable: function() {
              var $table = this.callBase.apply(this, arguments);
              var editingController = this._editingController;
              if (editingController.isCellOrBatchEditMode() && this.option("editing.allowUpdating")) {
                events_engine_default.on($table, addNamespace2(hold_default.name, "dxDataGridRowsView"), "td:not(." + EDITOR_CELL_CLASS3 + ")", this.createAction(() => {
                  if (editingController.isEditing()) {
                    editingController.closeEditCell();
                  }
                }));
              }
              return $table;
            },
            _createRow: function(row) {
              var $row = this.callBase(row);
              if (row) {
                var editingController = this._editingController;
                var isRowRemoved = !!row.removed;
                if (editingController.isBatchEditMode()) {
                  isRowRemoved && $row.addClass(ROW_REMOVED);
                }
              }
              return $row;
            }
          },
          headerPanel: {
            isVisible: function() {
              var editingOptions = this.getController("editing").option("editing");
              return this.callBase() || editingOptions && (editingOptions.allowUpdating || editingOptions.allowDeleting) && editingOptions.mode === EDIT_MODE_BATCH;
            }
          }
        }
      }
    };
  }
});

// node_modules/devextreme/esm/ui/grid_core/ui.grid_core.validating.js
var INVALIDATE_CLASS, REVERT_TOOLTIP_CLASS, ROWS_VIEW_CLASS, INVALID_MESSAGE_CLASS, WIDGET_INVALID_MESSAGE_CLASS, INVALID_MESSAGE_ALWAYS_CLASS, REVERT_BUTTON_CLASS, VALIDATOR_CLASS3, PENDING_INDICATOR_CLASS, VALIDATION_PENDING_CLASS, CONTENT_CLASS2, INSERT_INDEX2, PADDING_BETWEEN_TOOLTIPS, EDIT_MODE_ROW2, EDIT_MODE_FORM2, EDIT_MODE_BATCH2, EDIT_MODE_CELL2, EDIT_MODE_POPUP2, GROUP_CELL_CLASS2, FORM_BASED_MODES, COMMAND_TRANSPARENT, VALIDATION_STATUS, EDIT_DATA_INSERT_TYPE, EDIT_DATA_REMOVE_TYPE, VALIDATION_CANCELLED, NEW_SCROLLING_MODE2, validationResultIsValid, cellValueShouldBeValidated, ValidatingController, validatingModule;
var init_ui_grid_core_validating = __esm({
  "node_modules/devextreme/esm/ui/grid_core/ui.grid_core.validating.js"() {
    init_renderer();
    init_events_engine();
    init_ui_grid_core_modules();
    init_ui_grid_core_utils();
    init_array_utils();
    init_common();
    init_iterator();
    init_type();
    init_extend();
    init_selectors();
    init_message();
    init_button();
    init_pointer();
    init_validation_engine();
    init_validator();
    init_ui_overlay();
    init_ui_errors();
    init_deferred();
    init_load_indicator();
    init_string();
    init_browser();
    INVALIDATE_CLASS = "invalid";
    REVERT_TOOLTIP_CLASS = "revert-tooltip";
    ROWS_VIEW_CLASS = "rowsview";
    INVALID_MESSAGE_CLASS = "dx-invalid-message";
    WIDGET_INVALID_MESSAGE_CLASS = "invalid-message";
    INVALID_MESSAGE_ALWAYS_CLASS = "dx-invalid-message-always";
    REVERT_BUTTON_CLASS = "dx-revert-button";
    VALIDATOR_CLASS3 = "validator";
    PENDING_INDICATOR_CLASS = "dx-pending-indicator";
    VALIDATION_PENDING_CLASS = "dx-validation-pending";
    CONTENT_CLASS2 = "content";
    INSERT_INDEX2 = "__DX_INSERT_INDEX__";
    PADDING_BETWEEN_TOOLTIPS = 2;
    EDIT_MODE_ROW2 = "row";
    EDIT_MODE_FORM2 = "form";
    EDIT_MODE_BATCH2 = "batch";
    EDIT_MODE_CELL2 = "cell";
    EDIT_MODE_POPUP2 = "popup";
    GROUP_CELL_CLASS2 = "dx-group-cell";
    FORM_BASED_MODES = [EDIT_MODE_POPUP2, EDIT_MODE_FORM2];
    COMMAND_TRANSPARENT = "transparent";
    VALIDATION_STATUS = {
      valid: "valid",
      invalid: "invalid",
      pending: "pending"
    };
    EDIT_DATA_INSERT_TYPE = "insert";
    EDIT_DATA_REMOVE_TYPE = "remove";
    VALIDATION_CANCELLED = "cancel";
    NEW_SCROLLING_MODE2 = "scrolling.newMode";
    validationResultIsValid = function(result2) {
      return isDefined(result2) && result2 !== VALIDATION_CANCELLED;
    };
    cellValueShouldBeValidated = function(value2, rowOptions) {
      return void 0 !== value2 || void 0 === value2 && rowOptions && !rowOptions.isNewRow;
    };
    ValidatingController = ui_grid_core_modules_default.Controller.inherit({
      init: function() {
        this._editingController = this.getController("editing");
        this.createAction("onRowValidating");
        if (!this._validationState) {
          this._validationState = [];
        }
      },
      _rowIsValidated: function(change) {
        var validationData = this._getValidationData(null === change || void 0 === change ? void 0 : change.key);
        return !!validationData && !!validationData.validated;
      },
      _getValidationData: function(key, create2) {
        var validationData = this._validationState.filter((data2) => equalByValue(data2.key, key))[0];
        if (!validationData && create2) {
          validationData = {
            key,
            isValid: true
          };
          this._validationState.push(validationData);
        }
        return validationData;
      },
      _getBrokenRules: function(validationData, validationResults) {
        var brokenRules;
        if (validationResults) {
          brokenRules = validationResults.brokenRules || validationResults.brokenRule && [validationResults.brokenRule];
        } else {
          brokenRules = validationData.brokenRules || [];
        }
        return brokenRules;
      },
      _rowValidating: function(validationData, validationResults) {
        var deferred = new Deferred();
        var change = this._editingController.getChangeByKey(null === validationData || void 0 === validationData ? void 0 : validationData.key);
        var brokenRules = this._getBrokenRules(validationData, validationResults);
        var isValid = validationResults ? validationResults.isValid : validationData.isValid;
        var parameters = {
          brokenRules,
          isValid,
          key: change.key,
          newData: change.data,
          oldData: this._editingController._getOldData(change.key),
          promise: null,
          errorText: this.getHiddenValidatorsErrorText(brokenRules)
        };
        this.executeAction("onRowValidating", parameters);
        when(fromPromise(parameters.promise)).always(function() {
          validationData.isValid = parameters.isValid;
          validationData.errorText = parameters.errorText;
          deferred.resolve(parameters);
        });
        return deferred.promise();
      },
      getHiddenValidatorsErrorText: function(brokenRules) {
        var brokenRulesMessages = [];
        each(brokenRules, function(_2, brokenRule) {
          var column = brokenRule.column;
          var isGroupExpandColumn = column && void 0 !== column.groupIndex && !column.showWhenGrouped;
          var isVisibleColumn = column && column.visible;
          if (!brokenRule.validator.$element().parent().length && (!isVisibleColumn || isGroupExpandColumn)) {
            brokenRulesMessages.push(brokenRule.message);
          }
        });
        return brokenRulesMessages.join(", ");
      },
      validate: function(isFull) {
        var isValid = true;
        var editingController = this._editingController;
        var deferred = new Deferred();
        var completeList = [];
        var editMode = editingController.getEditMode();
        isFull = isFull || editMode === EDIT_MODE_ROW2;
        if (this._isValidationInProgress) {
          return deferred.resolve(false).promise();
        }
        this._isValidationInProgress = true;
        if (isFull) {
          editingController.addDeferred(deferred);
          var changes = editingController.getChanges();
          each(changes, (index2, _ref) => {
            var {
              type: type2,
              key
            } = _ref;
            if ("remove" !== type2) {
              var validationData = this._getValidationData(key, true);
              var validationResult2 = this.validateGroup(validationData);
              completeList.push(validationResult2);
              validationResult2.done((validationResult3) => {
                validationData.validated = true;
                isValid = isValid && validationResult3.isValid;
              });
            }
          });
        } else if (this._currentCellValidator) {
          var validationResult = this.validateGroup(this._currentCellValidator._findGroup());
          completeList.push(validationResult);
          validationResult.done((validationResult2) => {
            isValid = validationResult2.isValid;
          });
        }
        when(...completeList).done(() => {
          this._isValidationInProgress = false;
          deferred.resolve(isValid);
        });
        return deferred.promise();
      },
      validateGroup: function(validationData) {
        var _validationResult;
        var result2 = new Deferred();
        var validateGroup = validationData && validation_engine_default.getGroupConfig(validationData);
        var validationResult;
        if (null !== validateGroup && void 0 !== validateGroup && validateGroup.validators.length) {
          this.resetRowValidationResults(validationData);
          validationResult = validation_engine_default.validateGroup(validationData);
        }
        when((null === (_validationResult = validationResult) || void 0 === _validationResult ? void 0 : _validationResult.complete) || validationResult).done((validationResult2) => {
          when(this._rowValidating(validationData, validationResult2)).done(result2.resolve);
        });
        return result2.promise();
      },
      isRowDataModified: (change) => !isEmptyObject(change.data),
      updateValidationState: function(change) {
        var editMode = this._editingController.getEditMode();
        var key = change.key;
        var validationData = this._getValidationData(key, true);
        if (-1 === FORM_BASED_MODES.indexOf(editMode)) {
          if (change.type === EDIT_DATA_INSERT_TYPE && !this.isRowDataModified(change)) {
            validationData.isValid = true;
            return;
          }
          this.setDisableApplyValidationResults(true);
          var groupConfig = validation_engine_default.getGroupConfig(validationData);
          if (groupConfig) {
            var validationResult = validation_engine_default.validateGroup(validationData);
            when(validationResult.complete || validationResult).done((validationResult2) => {
              validationData.isValid = validationResult2.isValid;
              validationData.brokenRules = validationResult2.brokenRules;
            });
          } else if (!validationData.brokenRules || !validationData.brokenRules.length) {
            validationData.isValid = true;
          }
          this.setDisableApplyValidationResults(false);
        } else {
          validationData.isValid = true;
        }
      },
      setValidator: function(validator) {
        this._currentCellValidator = validator;
      },
      renderCellPendingIndicator: function($container) {
        var $indicator = $container.find("." + PENDING_INDICATOR_CLASS);
        if (!$indicator.length) {
          var $indicatorContainer = $container;
          $indicator = renderer_default("<div>").appendTo($indicatorContainer).addClass(PENDING_INDICATOR_CLASS);
          this._createComponent($indicator, load_indicator_default);
          $container.addClass(VALIDATION_PENDING_CLASS);
        }
      },
      disposeCellPendingIndicator: function($container) {
        var $indicator = $container.find("." + PENDING_INDICATOR_CLASS);
        if ($indicator.length) {
          var indicator = load_indicator_default.getInstance($indicator);
          if (indicator) {
            indicator.dispose();
            indicator.$element().remove();
          }
          $container.removeClass(VALIDATION_PENDING_CLASS);
        }
      },
      validationStatusChanged: function(result2) {
        var validator = result2.validator;
        var validationGroup = validator.option("validationGroup");
        var column = validator.option("dataGetter")().column;
        this.updateCellValidationResult({
          rowKey: validationGroup.key,
          columnIndex: column.index,
          validationResult: result2
        });
      },
      validatorInitialized: function(arg) {
        arg.component.on("validating", this.validationStatusChanged.bind(this));
        arg.component.on("validated", this.validationStatusChanged.bind(this));
      },
      validatorDisposing: function(arg) {
        var validator = arg.component;
        var validationGroup = validator.option("validationGroup");
        var column = validator.option("dataGetter")().column;
        var result2 = this.getCellValidationResult({
          rowKey: null === validationGroup || void 0 === validationGroup ? void 0 : validationGroup.key,
          columnIndex: column.index
        });
        if (validationResultIsValid(result2) && result2.status === VALIDATION_STATUS.pending) {
          this.cancelCellValidationResult({
            change: validationGroup,
            columnIndex: column.index
          });
        }
      },
      applyValidationResult: function($container, result2) {
        var validator = result2.validator;
        var validationGroup = validator.option("validationGroup");
        var column = validator.option("dataGetter")().column;
        result2.brokenRules && result2.brokenRules.forEach((rule) => {
          rule.columnIndex = column.index;
          rule.column = column;
        });
        if ($container) {
          var validationResult = this.getCellValidationResult({
            rowKey: validationGroup.key,
            columnIndex: column.index
          });
          var requestIsDisabled = validationResultIsValid(validationResult) && validationResult.disabledPendingId === result2.id;
          if (this._disableApplyValidationResults || requestIsDisabled) {
            return;
          }
          if (result2.status === VALIDATION_STATUS.invalid) {
            var $focus = $container.find(":focus");
            if (!focused($focus)) {
              events_engine_default.trigger($focus, "focus");
              events_engine_default.trigger($focus, pointer_default.down);
            }
          }
          var editor = !column.editCellTemplate && this.getController("editorFactory").getEditorInstance($container);
          if (result2.status === VALIDATION_STATUS.pending) {
            if (editor) {
              editor.option("validationStatus", VALIDATION_STATUS.pending);
            } else {
              this.renderCellPendingIndicator($container);
            }
          } else if (editor) {
            editor.option("validationStatus", VALIDATION_STATUS.valid);
          } else {
            this.disposeCellPendingIndicator($container);
          }
          $container.toggleClass(this.addWidgetPrefix(INVALIDATE_CLASS), result2.status === VALIDATION_STATUS.invalid);
        }
      },
      _syncInternalEditingData: function(parameters) {
        var _parameters$row;
        var editingController = this._editingController;
        var change = editingController.getChangeByKey(parameters.key);
        var oldDataFromState = editingController._getOldData(parameters.key);
        var oldData = null === (_parameters$row = parameters.row) || void 0 === _parameters$row ? void 0 : _parameters$row.oldData;
        if (change && oldData && !oldDataFromState) {
          editingController._addInternalData({
            key: parameters.key,
            oldData
          });
        }
      },
      createValidator: function(parameters, $container) {
        var editingController = this._editingController;
        var column = parameters.column;
        var showEditorAlways = column.showEditorAlways;
        if (isDefined(column.command) || !column.validationRules || !Array.isArray(column.validationRules) || !column.validationRules.length) {
          return;
        }
        var editIndex = editingController.getIndexByKey(parameters.key, editingController.getChanges());
        var needCreateValidator = editIndex > -1;
        if (!needCreateValidator) {
          if (!showEditorAlways) {
            var columnsController = this.getController("columns");
            var visibleColumns = (null === columnsController || void 0 === columnsController ? void 0 : columnsController.getVisibleColumns()) || [];
            showEditorAlways = visibleColumns.some(function(column2) {
              return column2.showEditorAlways;
            });
          }
          var isEditRow = equalByValue(this.option("editing.editRowKey"), parameters.key);
          var isCellOrBatchEditingAllowed = editingController.isCellOrBatchEditMode() && editingController.allowUpdating({
            row: parameters.row
          });
          needCreateValidator = isEditRow || isCellOrBatchEditingAllowed && showEditorAlways;
          if (isCellOrBatchEditingAllowed && showEditorAlways) {
            var _parameters$row$oldDa, _parameters$row2;
            editingController._addInternalData({
              key: parameters.key,
              oldData: null !== (_parameters$row$oldDa = null === (_parameters$row2 = parameters.row) || void 0 === _parameters$row2 ? void 0 : _parameters$row2.oldData) && void 0 !== _parameters$row$oldDa ? _parameters$row$oldDa : parameters.data
            });
          }
        }
        if (needCreateValidator) {
          if ($container && !$container.length) {
            ui_errors_default.log("E1050");
            return;
          }
          this._syncInternalEditingData(parameters);
          var validationData = this._getValidationData(parameters.key, true);
          var getValue = () => {
            var change = editingController.getChangeByKey(null === validationData || void 0 === validationData ? void 0 : validationData.key);
            var value2 = column.calculateCellValue((null === change || void 0 === change ? void 0 : change.data) || {});
            return void 0 !== value2 ? value2 : parameters.value;
          };
          var useDefaultValidator = $container && $container.hasClass("dx-widget");
          $container && $container.addClass(this.addWidgetPrefix(VALIDATOR_CLASS3));
          var validator = new validator_default($container || renderer_default("<div>"), {
            name: column.caption,
            validationRules: extend2(true, [], column.validationRules),
            validationGroup: validationData,
            adapter: useDefaultValidator ? null : {
              getValue,
              applyValidationResults: (result2) => {
                this.applyValidationResult($container, result2);
              }
            },
            dataGetter: function() {
              var key = null === validationData || void 0 === validationData ? void 0 : validationData.key;
              var change = editingController.getChangeByKey(key);
              var oldData = editingController._getOldData(key);
              return {
                data: createObjectWithChanges(oldData, null === change || void 0 === change ? void 0 : change.data),
                column
              };
            },
            onInitialized: this.validatorInitialized.bind(this),
            onDisposing: this.validatorDisposing.bind(this)
          });
          if (useDefaultValidator) {
            var adapter = validator.option("adapter");
            if (adapter) {
              adapter.getValue = getValue;
              adapter.validationRequestsCallbacks = [];
              adapter.bypass = () => parameters.row.isNewRow && !this._isValidationInProgress && !editingController.isCellModified(parameters);
            }
          }
          return validator;
        }
      },
      setDisableApplyValidationResults: function(flag) {
        this._disableApplyValidationResults = flag;
      },
      getDisableApplyValidationResults: function() {
        return this._disableApplyValidationResults;
      },
      isCurrentValidatorProcessing: function(_ref2) {
        var {
          rowKey,
          columnIndex
        } = _ref2;
        return this._currentCellValidator && equalByValue(this._currentCellValidator.option("validationGroup").key, rowKey) && this._currentCellValidator.option("dataGetter")().column.index === columnIndex;
      },
      validateCell: function(validator) {
        var cellParams = {
          rowKey: validator.option("validationGroup").key,
          columnIndex: validator.option("dataGetter")().column.index
        };
        var validationResult = this.getCellValidationResult(cellParams);
        var stateRestored = validationResultIsValid(validationResult);
        if (!stateRestored) {
          validationResult = validator.validate();
        }
        var deferred = new Deferred();
        var adapter = validator.option("adapter");
        if (stateRestored && validationResult.status === VALIDATION_STATUS.pending) {
          this.updateCellValidationResult(cellParams);
          adapter.applyValidationResults(validationResult);
        }
        when(validationResult.complete || validationResult).done((validationResult2) => {
          stateRestored && adapter.applyValidationResults(validationResult2);
          deferred.resolve(validationResult2);
        });
        return deferred.promise();
      },
      updateCellValidationResult: function(_ref3) {
        var {
          rowKey,
          columnIndex,
          validationResult
        } = _ref3;
        var validationData = this._getValidationData(rowKey);
        if (!validationData) {
          return;
        }
        if (!validationData.validationResults) {
          validationData.validationResults = {};
        }
        var result2;
        if (validationResult) {
          result2 = extend2({}, validationResult);
          validationData.validationResults[columnIndex] = result2;
          if (validationResult.status === VALIDATION_STATUS.pending) {
            if (this._editingController.getEditMode() === EDIT_MODE_CELL2) {
              result2.deferred = new Deferred();
              result2.complete.always(() => {
                result2.deferred.resolve();
              });
              this._editingController.addDeferred(result2.deferred);
            }
            if (this._disableApplyValidationResults) {
              result2.disabledPendingId = validationResult.id;
              return;
            }
          }
        } else {
          result2 = validationData.validationResults[columnIndex];
        }
        if (result2 && result2.disabledPendingId) {
          delete result2.disabledPendingId;
        }
      },
      getCellValidationResult: function(_ref4) {
        var _validationData$valid;
        var {
          rowKey,
          columnIndex
        } = _ref4;
        var validationData = this._getValidationData(rowKey, true);
        return null === validationData || void 0 === validationData ? void 0 : null === (_validationData$valid = validationData.validationResults) || void 0 === _validationData$valid ? void 0 : _validationData$valid[columnIndex];
      },
      removeCellValidationResult: function(_ref5) {
        var {
          change,
          columnIndex
        } = _ref5;
        var validationData = this._getValidationData(null === change || void 0 === change ? void 0 : change.key);
        if (validationData && validationData.validationResults) {
          this.cancelCellValidationResult({
            change,
            columnIndex
          });
          delete validationData.validationResults[columnIndex];
        }
      },
      cancelCellValidationResult: function(_ref6) {
        var {
          change,
          columnIndex
        } = _ref6;
        var validationData = this._getValidationData(change.key);
        if (change && validationData.validationResults) {
          var result2 = validationData.validationResults[columnIndex];
          if (result2) {
            result2.deferred && result2.deferred.reject(VALIDATION_CANCELLED);
            validationData.validationResults[columnIndex] = VALIDATION_CANCELLED;
          }
        }
      },
      resetRowValidationResults: function(validationData) {
        if (validationData) {
          validationData.validationResults && delete validationData.validationResults;
          delete validationData.validated;
        }
      },
      isInvalidCell: function(_ref7) {
        var {
          rowKey,
          columnIndex
        } = _ref7;
        var result2 = this.getCellValidationResult({
          rowKey,
          columnIndex
        });
        return validationResultIsValid(result2) && result2.status === VALIDATION_STATUS.invalid;
      },
      getCellValidator: function(_ref8) {
        var {
          rowKey,
          columnIndex
        } = _ref8;
        var validationData = this._getValidationData(rowKey);
        var groupConfig = validationData && validation_engine_default.getGroupConfig(validationData);
        var validators = groupConfig && groupConfig.validators;
        return validators && validators.filter((v) => {
          var column = v.option("dataGetter")().column;
          return column ? column.index === columnIndex : false;
        })[0];
      },
      setCellValidationStatus: function(cellOptions) {
        var validationResult = this.getCellValidationResult({
          rowKey: cellOptions.key,
          columnIndex: cellOptions.column.index
        });
        if (isDefined(validationResult)) {
          cellOptions.validationStatus = validationResult !== VALIDATION_CANCELLED ? validationResult.status : VALIDATION_CANCELLED;
        } else {
          delete cellOptions.validationStatus;
        }
      }
    });
    validatingModule = {
      defaultOptions: function() {
        return {
          editing: {
            texts: {
              validationCancelChanges: message_default.format("dxDataGrid-validationCancelChanges")
            }
          }
        };
      },
      controllers: {
        validating: ValidatingController
      },
      extenders: {
        controllers: {
          editing: {
            _addChange: function(changeParams) {
              var index2 = this.callBase.apply(this, arguments);
              var validatingController = this.getController("validating");
              if (index2 >= 0 && changeParams.type !== EDIT_DATA_REMOVE_TYPE) {
                var change = this.getChanges()[index2];
                change && validatingController.updateValidationState(change);
              }
              return index2;
            },
            _handleChangesChange: function(args) {
              this.callBase.apply(this, arguments);
              var validatingController = this.getController("validating");
              args.value.forEach((change) => {
                if (void 0 === validatingController._getValidationData(change.key)) {
                  validatingController.updateValidationState(change);
                }
              });
            },
            _updateRowAndPageIndices: function() {
              var that = this;
              var startInsertIndex = that.getView("rowsView").getTopVisibleItemIndex();
              var rowIndex = startInsertIndex;
              each(that.getChanges(), (_2, _ref9) => {
                var {
                  key,
                  type: type2
                } = _ref9;
                var validationData = this.getController("validating")._getValidationData(key);
                if (validationData && !validationData.isValid && validationData.pageIndex !== that._pageIndex) {
                  validationData.pageIndex = that._pageIndex;
                  if (type2 === EDIT_DATA_INSERT_TYPE) {
                    validationData.rowIndex = startInsertIndex;
                  } else {
                    validationData.rowIndex = rowIndex;
                  }
                  rowIndex++;
                }
              });
            },
            _getValidationGroupsInForm: function(detailOptions) {
              var validatingController = this.getController("validating");
              var validationData = validatingController._getValidationData(detailOptions.key, true);
              return {
                validationGroup: validationData
              };
            },
            _validateEditFormAfterUpdate: function(row, isCustomSetCellValue) {
              if (isCustomSetCellValue && this._editForm) {
                this._editForm.validate();
              }
              this.callBase.apply(this, arguments);
            },
            _needInsertItem: function(change) {
              var result2 = this.callBase.apply(this, arguments);
              var {
                key,
                pageIndex
              } = change;
              var validationData = this.getController("validating")._getValidationData(key);
              var scrollingMode = this.option("scrolling.mode");
              var virtualMode = "virtual" === scrollingMode;
              var appendMode = "infinite" === scrollingMode;
              if (result2 && !(null !== validationData && void 0 !== validationData && validationData.isValid) && !virtualMode && !(appendMode && this.option(NEW_SCROLLING_MODE2))) {
                result2 = pageIndex === this._pageIndex;
              }
              return result2;
            },
            _prepareEditCell: function(params) {
              var isNotCanceled = this.callBase.apply(this, arguments);
              var validatingController = this.getController("validating");
              if (isNotCanceled && params.column.showEditorAlways) {
                validatingController.updateValidationState({
                  key: params.key
                });
              }
              return isNotCanceled;
            },
            processItems: function(items, changeType) {
              var changes = this.getChanges();
              var dataController = this.getController("data");
              var validatingController = this.getController("validating");
              items = this.callBase(items, changeType);
              var itemsCount = items.length;
              var addInValidItem = function(change, validationData) {
                var data2 = {
                  key: change.key
                };
                var index2 = function(change2, items2) {
                  var index3 = -1;
                  var isInsert = change2.type === EDIT_DATA_INSERT_TYPE;
                  var key = change2.key;
                  each(items2, function(i, item) {
                    if (equalByValue(key, isInsert ? item.key : dataController.keyOf(item))) {
                      index3 = i;
                      return false;
                    }
                  });
                  return index3;
                }(change, items);
                if (index2 >= 0) {
                  return;
                }
                validationData.rowIndex = validationData.rowIndex > itemsCount ? validationData.rowIndex % itemsCount : validationData.rowIndex;
                var rowIndex = validationData.rowIndex;
                data2[INSERT_INDEX2] = 1;
                items.splice(rowIndex, 0, data2);
              };
              if (this.getEditMode() === EDIT_MODE_BATCH2 && "prepend" !== changeType && "append" !== changeType) {
                changes.forEach((change) => {
                  var key = change.key;
                  var validationData = validatingController._getValidationData(key);
                  if (validationData && change.type && validationData.pageIndex === this._pageIndex && (null === change || void 0 === change ? void 0 : change.pageIndex) !== this._pageIndex) {
                    addInValidItem(change, validationData);
                  }
                });
              }
              return items;
            },
            processDataItem: function(item) {
              var isInserted = item.data[INSERT_INDEX2];
              var key = isInserted ? item.data.key : item.key;
              var editMode = this.getEditMode();
              if (editMode === EDIT_MODE_BATCH2 && isInserted && key) {
                var changes = this.getChanges();
                var editIndex = ui_grid_core_utils_default.getIndexByKey(key, changes);
                if (editIndex >= 0) {
                  var change = changes[editIndex];
                  if (change.type !== EDIT_DATA_INSERT_TYPE) {
                    var oldData = this._getOldData(change.key);
                    item.data = extend2(true, {}, oldData, change.data);
                    item.key = key;
                  }
                }
              }
              this.callBase.apply(this, arguments);
            },
            _createInvisibleColumnValidators: function(changes) {
              var that = this;
              var validatingController = this.getController("validating");
              var columnsController = this.getController("columns");
              var columns = columnsController.getColumns();
              var invisibleColumns = columnsController.getInvisibleColumns().filter((column) => !column.isBand);
              var groupColumns = columnsController.getGroupColumns().filter((column) => !column.showWhenGrouped && -1 === invisibleColumns.indexOf(column));
              var invisibleColumnValidators = [];
              var isCellVisible = (column, rowKey) => this._dataController.getRowIndexByKey(rowKey) >= 0 && invisibleColumns.indexOf(column) < 0;
              invisibleColumns.push(...groupColumns);
              if (-1 === FORM_BASED_MODES.indexOf(this.getEditMode())) {
                each(columns, function(_2, column) {
                  changes.forEach(function(change) {
                    var data2;
                    if (isCellVisible(column, change.key)) {
                      return;
                    }
                    if (change.type === EDIT_DATA_INSERT_TYPE) {
                      data2 = change.data;
                    } else if ("update" === change.type) {
                      var oldData = that._getOldData(change.key);
                      data2 = createObjectWithChanges(oldData, change.data);
                    }
                    if (data2) {
                      var validator = validatingController.createValidator({
                        column,
                        key: change.key,
                        value: column.calculateCellValue(data2)
                      });
                      if (validator) {
                        invisibleColumnValidators.push(validator);
                      }
                    }
                  });
                });
              }
              return function() {
                invisibleColumnValidators.forEach(function(validator) {
                  validator.dispose();
                });
              };
            },
            _beforeSaveEditData: function(change, editIndex) {
              var result2 = this.callBase.apply(this, arguments);
              var validatingController = this.getController("validating");
              var validationData = validatingController._getValidationData(null === change || void 0 === change ? void 0 : change.key);
              if (change) {
                var isValid = "remove" === change.type || validationData.isValid;
                result2 = result2 || !isValid;
              } else {
                var disposeValidators = this._createInvisibleColumnValidators(this.getChanges());
                result2 = new Deferred();
                this.executeOperation(result2, () => {
                  validatingController.validate(true).done((isFullValid) => {
                    disposeValidators();
                    this._updateRowAndPageIndices();
                    switch (this.getEditMode()) {
                      case EDIT_MODE_CELL2:
                        if (!isFullValid) {
                          this._focusEditingCell();
                        }
                        break;
                      case EDIT_MODE_BATCH2:
                        if (!isFullValid) {
                          this._resetEditRowKey();
                          this._resetEditColumnName();
                          this.getController("data").updateItems();
                        }
                    }
                    result2.resolve(!isFullValid);
                  });
                });
              }
              return result2.promise ? result2.promise() : result2;
            },
            _beforeEditCell: function(rowIndex, columnIndex, item) {
              var result2 = this.callBase(rowIndex, columnIndex, item);
              if (this.getEditMode() === EDIT_MODE_CELL2) {
                var $cell = this._rowsView._getCellElement(rowIndex, columnIndex);
                var validator = $cell && $cell.data("dxValidator");
                var rowOptions = $cell && $cell.closest(".dx-row").data("options");
                var value2 = validator && validator.option("adapter").getValue();
                if (validator && cellValueShouldBeValidated(value2, rowOptions)) {
                  var validatingController = this.getController("validating");
                  var deferred = new Deferred();
                  when(validatingController.validateCell(validator), result2).done((validationResult, result3) => {
                    deferred.resolve(validationResult.status === VALIDATION_STATUS.valid && result3);
                  });
                  return deferred.promise();
                } else if (!validator) {
                  return result2;
                }
              }
            },
            _afterSaveEditData: function(cancel2) {
              var $firstErrorRow;
              var isCellEditMode = this.getEditMode() === EDIT_MODE_CELL2;
              each(this.getChanges(), (_2, change) => {
                var $errorRow = this._showErrorRow(change);
                $firstErrorRow = $firstErrorRow || $errorRow;
              });
              if ($firstErrorRow) {
                var scrollable = this._rowsView.getScrollable();
                if (scrollable) {
                  scrollable.update();
                  scrollable.scrollToElement($firstErrorRow);
                }
              }
              if (cancel2 && isCellEditMode && this._needUpdateRow()) {
                var editRowIndex = this.getEditRowIndex();
                this._dataController.updateItems({
                  changeType: "update",
                  rowIndices: [editRowIndex]
                });
                this._focusEditingCell();
              } else if (!cancel2) {
                var shouldResetValidationState = true;
                if (isCellEditMode) {
                  var columns = this.getController("columns").getColumns();
                  var columnsWithValidatingEditors = columns.filter((col) => {
                    var _col$validationRules;
                    return col.showEditorAlways && (null === (_col$validationRules = col.validationRules) || void 0 === _col$validationRules ? void 0 : _col$validationRules.length) > 0;
                  }).length > 0;
                  shouldResetValidationState = !columnsWithValidatingEditors;
                }
                if (shouldResetValidationState) {
                  this.getController("validating")._validationState = [];
                }
              }
            },
            _handleDataChanged: function(args) {
              var validationState = this.getController("validating")._validationState;
              if ("standard" === this.option("scrolling.mode")) {
                this.resetRowAndPageIndices();
              }
              if ("prepend" === args.changeType) {
                each(validationState, function(_2, validationData) {
                  validationData.rowIndex += args.items.length;
                });
              }
              this.callBase(args);
            },
            resetRowAndPageIndices: function() {
              var validationState = this.getController("validating")._validationState;
              each(validationState, (_2, validationData) => {
                if (validationData.pageIndex !== this._pageIndex) {
                  delete validationData.pageIndex;
                  delete validationData.rowIndex;
                }
              });
            },
            _beforeCancelEditData: function() {
              var validatingController = this.getController("validating");
              validatingController._validationState = [];
              this.callBase();
            },
            _showErrorRow: function(change) {
              var $popupContent;
              var errorHandling = this.getController("errorHandling");
              var items = this.getController("data").items();
              var rowIndex = this.getIndexByKey(change.key, items);
              var validationData = this.getController("validating")._getValidationData(change.key);
              if (!(null !== validationData && void 0 !== validationData && validationData.isValid) && null !== validationData && void 0 !== validationData && validationData.errorText && rowIndex >= 0) {
                $popupContent = this.getPopupContent();
                return errorHandling && errorHandling.renderErrorRow(null === validationData || void 0 === validationData ? void 0 : validationData.errorText, rowIndex, $popupContent);
              }
            },
            updateFieldValue: function(e) {
              var validatingController = this.getController("validating");
              var deferred = new Deferred();
              validatingController.removeCellValidationResult({
                change: this.getChangeByKey(e.key),
                columnIndex: e.column.index
              });
              this.callBase.apply(this, arguments).done(() => {
                var currentValidator = validatingController.getCellValidator({
                  rowKey: e.key,
                  columnIndex: e.column.index
                });
                when(currentValidator && validatingController.validateCell(currentValidator)).done((validationResult) => {
                  this.getController("editorFactory").refocus();
                  deferred.resolve(validationResult);
                });
              });
              return deferred.promise();
            },
            highlightDataCell: function($cell, parameters) {
              this.callBase.apply(this, arguments);
              var validatingController = this.getController("validating");
              validatingController.setCellValidationStatus(parameters);
              var isEditableCell = !!parameters.setValue;
              var cellModified = this.isCellModified(parameters);
              var isValidated = isDefined(parameters.validationStatus);
              var needValidation = cellModified && parameters.column.setCellValue || isEditableCell && !cellModified && !(parameters.row.isNewRow || !isValidated);
              if (needValidation) {
                var validator = $cell.data("dxValidator");
                if (validator) {
                  when(this.getController("validating").validateCell(validator)).done(() => {
                    validatingController.setCellValidationStatus(parameters);
                  });
                }
              }
            },
            getChangeByKey: function(key) {
              var changes = this.getChanges();
              return changes[ui_grid_core_utils_default.getIndexByKey(key, changes)];
            },
            isCellModified: function(parameters) {
              var cellModified = this.callBase(parameters);
              var change = this.getChangeByKey(parameters.key);
              var isCellInvalid = !!parameters.row && this.getController("validating").isInvalidCell({
                rowKey: parameters.key,
                columnIndex: parameters.column.index
              });
              return cellModified || this.getController("validating")._rowIsValidated(change) && isCellInvalid;
            }
          },
          editorFactory: {
            _showRevertButton: function($container) {
              if (!$container || !$container.length) {
                return;
              }
              var $tooltipElement = this._rowsView.element().find("." + this.addWidgetPrefix(REVERT_TOOLTIP_CLASS));
              var $overlayContainer = $container.closest(".".concat(this.addWidgetPrefix(CONTENT_CLASS2)));
              $tooltipElement && $tooltipElement.remove();
              $tooltipElement = renderer_default("<div>").addClass(this.addWidgetPrefix(REVERT_TOOLTIP_CLASS)).appendTo($container);
              var tooltipOptions = {
                animation: null,
                visible: true,
                width: "auto",
                height: "auto",
                target: $container,
                shading: false,
                container: $overlayContainer,
                propagateOutsideClick: true,
                closeOnOutsideClick: false,
                closeOnTargetScroll: false,
                contentTemplate: () => {
                  var $buttonElement = renderer_default("<div>").addClass(REVERT_BUTTON_CLASS);
                  var buttonOptions = {
                    icon: "revert",
                    hint: this.option("editing.texts.validationCancelChanges"),
                    onClick: () => {
                      this._editingController.cancelEditData();
                    }
                  };
                  return new button_default($buttonElement, buttonOptions).$element();
                },
                position: {
                  my: "left top",
                  at: "right top",
                  offset: "1 0",
                  collision: "flip",
                  boundaryOffset: "0 0",
                  boundary: this._rowsView.element()
                },
                onPositioned: this._positionedHandler.bind(this)
              };
              return new ui_overlay_default($tooltipElement, tooltipOptions);
            },
            _hideFixedGroupCell: function($cell, overlayOptions) {
              var $nextFixedRowElement;
              var $groupCellElement;
              var isFixedColumns = this._rowsView.isFixedColumns();
              var isFormOrPopupEditMode = this._editingController.isFormOrPopupEditMode();
              if (isFixedColumns && !isFormOrPopupEditMode) {
                var nextRowOptions = $cell.closest(".dx-row").next().data("options");
                if (nextRowOptions && "group" === nextRowOptions.rowType) {
                  $nextFixedRowElement = renderer_default(this._rowsView.getRowElement(nextRowOptions.rowIndex)).last();
                  $groupCellElement = $nextFixedRowElement.find("." + GROUP_CELL_CLASS2);
                  if ($groupCellElement.length && "hidden" !== $groupCellElement.get(0).style.visibility) {
                    $groupCellElement.css("visibility", "hidden");
                    overlayOptions.onDisposing = function() {
                      $groupCellElement.css("visibility", "");
                    };
                  }
                }
              }
            },
            _positionedHandler: function(e, isOverlayVisible) {
              if (!e.component.__skipPositionProcessing) {
                var isRevertButton = renderer_default(e.element).hasClass(this.addWidgetPrefix(REVERT_TOOLTIP_CLASS));
                var needRepaint = !isRevertButton && this._rowsView.updateFreeSpaceRowHeight();
                var normalizedPosition = this._normalizeValidationMessagePositionAndMaxWidth(e, isRevertButton, isOverlayVisible);
                e.component.__skipPositionProcessing = !!(needRepaint || normalizedPosition);
                if (normalizedPosition) {
                  e.component.option(normalizedPosition);
                } else if (needRepaint) {
                  e.component.repaint();
                }
              }
            },
            _showValidationMessage: function($cell, messages, alignment, revertTooltip) {
              var editorPopup = $cell.find(".dx-dropdowneditor-overlay").data("dxPopup");
              var isOverlayVisible = editorPopup && editorPopup.option("visible");
              var myPosition = isOverlayVisible ? "top right" : "top " + alignment;
              var atPosition = isOverlayVisible ? "top left" : "bottom " + alignment;
              var $overlayContainer = $cell.closest(".".concat(this.addWidgetPrefix(CONTENT_CLASS2)));
              var errorMessageText = "";
              messages && messages.forEach(function(message) {
                errorMessageText += (errorMessageText.length ? "<br/>" : "") + encodeHtml(message);
              });
              var invalidMessageClass = this.addWidgetPrefix(WIDGET_INVALID_MESSAGE_CLASS);
              this._rowsView.element().find("." + invalidMessageClass).remove();
              var $overlayElement = renderer_default("<div>").addClass(INVALID_MESSAGE_CLASS).addClass(INVALID_MESSAGE_ALWAYS_CLASS).addClass(invalidMessageClass).html(errorMessageText).appendTo($cell);
              var overlayOptions = {
                target: $cell,
                container: $overlayContainer,
                shading: false,
                width: "auto",
                height: "auto",
                visible: true,
                animation: false,
                propagateOutsideClick: true,
                closeOnOutsideClick: false,
                closeOnTargetScroll: false,
                position: {
                  collision: "flip",
                  boundary: this._rowsView.element(),
                  boundaryOffset: "0 0",
                  offset: {
                    x: 0,
                    y: !isOverlayVisible && (browser_default.mozilla || browser_default.msie) ? -1 : 0
                  },
                  my: myPosition,
                  at: atPosition
                },
                onPositioned: (e) => {
                  this._positionedHandler(e, isOverlayVisible);
                  this._shiftValidationMessageIfNeed(e.component.$content(), revertTooltip && revertTooltip.$content(), $cell);
                }
              };
              this._hideFixedGroupCell($cell, overlayOptions);
              new ui_overlay_default($overlayElement, overlayOptions);
            },
            _normalizeValidationMessagePositionAndMaxWidth: function(options2, isRevertButton, isOverlayVisible) {
              var fixedColumns = this._columnsController.getFixedColumns();
              if (!fixedColumns || !fixedColumns.length) {
                return;
              }
              var position3;
              var visibleTableWidth = !isRevertButton && (that = this, element = options2.element, rowIndex = renderer_default(element).closest("tr").index(), $cellElements = renderer_default(that._rowsView.getRowElement(rowIndex)).first().children().filter(":not(.dx-hidden-cell)"), that._rowsView._getWidths($cellElements).reduce((w1, w2) => w1 + w2, 0));
              var that, element, rowIndex, $cellElements;
              var $overlayContentElement = options2.component.$content();
              var validationMessageWidth = $overlayContentElement.outerWidth(true);
              var needMaxWidth = !isRevertButton && validationMessageWidth > visibleTableWidth;
              var columnIndex = this._rowsView.getCellIndex(renderer_default(options2.element).closest("td"));
              var boundaryNonFixedColumnsInfo = function(fixedColumns2) {
                var firstNonFixedColumnIndex;
                var lastNonFixedColumnIndex;
                fixedColumns2.some((column, index2) => {
                  if (column.command === COMMAND_TRANSPARENT) {
                    firstNonFixedColumnIndex = 0 === index2 ? -1 : index2;
                    lastNonFixedColumnIndex = index2 === fixedColumns2.length - 1 ? -1 : index2 + column.colspan - 1;
                    return true;
                  }
                });
                return {
                  startColumnIndex: firstNonFixedColumnIndex,
                  endColumnIndex: lastNonFixedColumnIndex
                };
              }(fixedColumns);
              if (!isRevertButton && (columnIndex === boundaryNonFixedColumnsInfo.startColumnIndex || needMaxWidth)) {
                position3 = {
                  collision: "none flip",
                  my: "top left",
                  at: isOverlayVisible ? "top right" : "bottom left"
                };
              } else if (columnIndex === boundaryNonFixedColumnsInfo.endColumnIndex) {
                position3 = {
                  collision: "none flip",
                  my: "top right",
                  at: isRevertButton || isOverlayVisible ? "top left" : "bottom right"
                };
                if (isRevertButton) {
                  position3.offset = "-1 0";
                }
              }
              return position3 && {
                position: position3,
                maxWidth: needMaxWidth ? visibleTableWidth - 2 : void 0
              };
            },
            _shiftValidationMessageIfNeed: function($content, $revertContent, $cell) {
              if (!$revertContent) {
                return;
              }
              var contentOffset = $content.offset();
              var revertContentOffset = $revertContent.offset();
              if (contentOffset.top === revertContentOffset.top && contentOffset.left + $content.width() > revertContentOffset.left) {
                var left = $revertContent.width() + PADDING_BETWEEN_TOOLTIPS;
                $content.css("left", revertContentOffset.left < $cell.offset().left ? -left : left);
              }
            },
            _getTooltipsSelector: function() {
              var invalidMessageClass = this.addWidgetPrefix(WIDGET_INVALID_MESSAGE_CLASS);
              var revertTooltipClass = this.addWidgetPrefix(REVERT_TOOLTIP_CLASS);
              return ".dx-editor-cell ." + revertTooltipClass + ", .dx-editor-cell ." + invalidMessageClass + ", .dx-cell-modified ." + invalidMessageClass;
            },
            init: function() {
              this.callBase();
              this._editingController = this.getController("editing");
              this._columnsController = this.getController("columns");
              this._rowsView = this.getView("rowsView");
            },
            loseFocus: function(skipValidator) {
              if (!skipValidator) {
                this.getController("validating").setValidator(null);
              }
              this.callBase();
            },
            updateCellState: function($element, validationResult, hideBorder) {
              var _change$data;
              var $focus = null === $element || void 0 === $element ? void 0 : $element.closest(this._getFocusCellSelector());
              var $cell = null !== $focus && void 0 !== $focus && $focus.is("td") ? $focus : null;
              var rowOptions = null === $focus || void 0 === $focus ? void 0 : $focus.closest(".dx-row").data("options");
              var change = rowOptions ? this.getController("editing").getChangeByKey(rowOptions.key) : null;
              var column = $cell && this.getController("columns").getVisibleColumns()[$cell.index()];
              var isCellModified = void 0 !== (null === change || void 0 === change ? void 0 : null === (_change$data = change.data) || void 0 === _change$data ? void 0 : _change$data[null === column || void 0 === column ? void 0 : column.name]) && !this._editingController.isSaving();
              var revertTooltip;
              if ((null === validationResult || void 0 === validationResult ? void 0 : validationResult.status) === VALIDATION_STATUS.invalid || isCellModified) {
                if (this._editingController.getEditMode() === EDIT_MODE_CELL2) {
                  revertTooltip = this._showRevertButton($focus);
                }
              }
              var showValidationMessage = validationResult && validationResult.status === VALIDATION_STATUS.invalid;
              if (showValidationMessage && $cell && column && validationResult && validationResult.brokenRules) {
                var errorMessages2 = [];
                validationResult.brokenRules.forEach(function(rule) {
                  if (rule.message) {
                    errorMessages2.push(rule.message);
                  }
                });
                if (errorMessages2.length) {
                  this._showValidationMessage($focus, errorMessages2, column.alignment || "left", revertTooltip);
                }
              }
              !hideBorder && this._rowsView.element() && this._rowsView.updateFreeSpaceRowHeight();
            },
            focus: function($element, hideBorder) {
              if (!arguments.length) {
                return this.callBase();
              }
              var $tooltips = $element && $element.closest("." + this.addWidgetPrefix(ROWS_VIEW_CLASS)).find(this._getTooltipsSelector());
              $tooltips && $tooltips.remove();
              if (null !== $element && void 0 !== $element && $element.hasClass("dx-row")) {
                return this.callBase($element, hideBorder);
              }
              var $focus = null === $element || void 0 === $element ? void 0 : $element.closest(this._getFocusCellSelector());
              var callBase = this.callBase;
              var validator = $focus && ($focus.data("dxValidator") || $element.find("." + this.addWidgetPrefix(VALIDATOR_CLASS3)).eq(0).data("dxValidator"));
              var rowOptions = $focus && $focus.closest(".dx-row").data("options");
              var editingController = this.getController("editing");
              var change = rowOptions ? editingController.getChangeByKey(rowOptions.key) : null;
              var validationResult;
              var validatingController = this.getController("validating");
              if (validator) {
                validatingController.setValidator(validator);
                var value2 = validator.option("adapter").getValue();
                if (cellValueShouldBeValidated(value2, rowOptions) || validatingController._rowIsValidated(change)) {
                  editingController.waitForDeferredOperations().done(() => {
                    when(validatingController.validateCell(validator)).done((result2) => {
                      validationResult = result2;
                      var column = validationResult.validator.option("dataGetter")().column;
                      if (change && column && !validatingController.isCurrentValidatorProcessing({
                        rowKey: change.key,
                        columnIndex: column.index
                      })) {
                        return;
                      }
                      if (validationResult.status === VALIDATION_STATUS.invalid) {
                        hideBorder = true;
                      }
                      this.updateCellState($element, validationResult, hideBorder);
                      callBase.call(this, $element, hideBorder);
                    });
                  });
                  return this.callBase($element, hideBorder);
                }
              }
              this.updateCellState($element, validationResult, hideBorder);
              return this.callBase($element, hideBorder);
            },
            getEditorInstance: function($container) {
              var $editor = $container.find(".dx-texteditor").eq(0);
              return ui_grid_core_utils_default.getWidgetInstance($editor);
            }
          },
          data: {
            _isCellChanged: function(oldRow, newRow, visibleRowIndex, columnIndex, isLiveUpdate) {
              var _oldRow$cells, _cell$column$validati;
              var cell = null === (_oldRow$cells = oldRow.cells) || void 0 === _oldRow$cells ? void 0 : _oldRow$cells[columnIndex];
              var oldValidationStatus = cell && cell.validationStatus;
              var validatingController = this.getController("validating");
              var validationResult = validatingController.getCellValidationResult({
                rowKey: oldRow.key,
                columnIndex
              });
              var validationData = validatingController._getValidationData(oldRow.key);
              var newValidationStatus = validationResultIsValid(validationResult) ? validationResult.status : validationResult;
              var rowIsModified = JSON.stringify(newRow.modifiedValues) !== JSON.stringify(oldRow.modifiedValues);
              var cellIsMarkedAsInvalid = renderer_default(null === cell || void 0 === cell ? void 0 : cell.cellElement).hasClass(this.addWidgetPrefix(INVALIDATE_CLASS));
              var editingChanged = oldRow.isEditing !== newRow.isEditing;
              var hasValidationRules = null === cell || void 0 === cell ? void 0 : null === (_cell$column$validati = cell.column.validationRules) || void 0 === _cell$column$validati ? void 0 : _cell$column$validati.length;
              if (editingChanged && hasValidationRules || oldValidationStatus !== newValidationStatus && rowIsModified || validationData.isValid && cellIsMarkedAsInvalid) {
                return true;
              }
              return this.callBase.apply(this, arguments);
            }
          }
        },
        views: {
          rowsView: {
            updateFreeSpaceRowHeight: function($table) {
              var $rowElements;
              var $freeSpaceRowElement;
              var $freeSpaceRowElements;
              var $element = this.element();
              var $tooltipContent = $element && $element.find("." + this.addWidgetPrefix(WIDGET_INVALID_MESSAGE_CLASS) + " .dx-overlay-content");
              this.callBase($table);
              if ($tooltipContent && $tooltipContent.length) {
                $rowElements = this._getRowElements();
                $freeSpaceRowElements = this._getFreeSpaceRowElements($table);
                $freeSpaceRowElement = $freeSpaceRowElements.first();
                if ($freeSpaceRowElement && 1 === $rowElements.length && (!$freeSpaceRowElement.is(":visible") || $tooltipContent.outerHeight() > $freeSpaceRowElement.outerHeight())) {
                  $freeSpaceRowElements.show();
                  $freeSpaceRowElements.height($tooltipContent.outerHeight());
                  return true;
                }
              }
            },
            _formItemPrepared: function(cellOptions, $container) {
              this.callBase.apply(this, arguments);
              deferUpdate(() => {
                var $editor = $container.find(".dx-widget").first();
                var isEditorDisposed = $editor.length && !$editor.children().length;
                if (!isEditorDisposed) {
                  this.getController("validating").createValidator(cellOptions, $editor);
                }
              });
            },
            _cellPrepared: function($cell, parameters) {
              if (!this.getController("editing").isFormOrPopupEditMode()) {
                this.getController("validating").createValidator(parameters, $cell);
              }
              this.callBase.apply(this, arguments);
            }
          }
        }
      }
    };
  }
});

// node_modules/devextreme/esm/ui/grid_core/ui.grid.core.virtual_data_loader.js
var NEW_SCROLLING_MODE3, needTwoPagesLoading, getBeginPageIndex, getEndPageIndex, fireChanged, processDelayChanged, getViewportPageCount, getPreloadPageCount, getPageIndexForLoad, loadCore, processChanged, VirtualDataLoader;
var init_ui_grid_core_virtual_data_loader = __esm({
  "node_modules/devextreme/esm/ui/grid_core/ui.grid.core.virtual_data_loader.js"() {
    init_deferred();
    init_type();
    NEW_SCROLLING_MODE3 = "scrolling.newMode";
    needTwoPagesLoading = (that) => that.option("scrolling.loadTwoPagesOnStart") || that._controller.isVirtual() || that._controller.getViewportItemIndex() > 0;
    getBeginPageIndex = (that) => that._cache.length ? that._cache[0].pageIndex : -1;
    getEndPageIndex = (that) => that._cache.length ? that._cache[that._cache.length - 1].pageIndex : -1;
    fireChanged = (that, changed, args) => {
      that._isChangedFiring = true;
      changed(args);
      that._isChangedFiring = false;
    };
    processDelayChanged = (that, changed, args) => {
      if (that._isDelayChanged) {
        that._isDelayChanged = false;
        fireChanged(that, changed, args);
        return true;
      }
    };
    getViewportPageCount = (that) => {
      var pageSize = that._dataOptions.pageSize();
      var preventPreload = that.option("scrolling.preventPreload");
      if (preventPreload) {
        return 0;
      }
      var realViewportSize = that._controller.viewportSize();
      if (that._controller.isVirtualMode() && that.option("scrolling.removeInvisiblePages")) {
        realViewportSize = 0;
        var viewportSize = that._controller.viewportSize() * that._controller.viewportItemSize();
        var offset2 = that._controller.getContentOffset();
        var position3 = that._controller.getViewportPosition();
        var virtualItemsCount = that._controller.virtualItemsCount();
        var totalItemsCount = that._dataOptions.totalItemsCount();
        for (var itemIndex = virtualItemsCount.begin; itemIndex < totalItemsCount; itemIndex++) {
          if (offset2 >= position3 + viewportSize) {
            break;
          }
          var itemSize = that._controller.getItemSizes()[itemIndex] || that._controller.viewportItemSize();
          offset2 += itemSize;
          if (offset2 >= position3) {
            realViewportSize++;
          }
        }
      }
      return pageSize && realViewportSize > 0 ? Math.ceil(realViewportSize / pageSize) : 1;
    };
    getPreloadPageCount = (that, previous) => {
      var preloadEnabled = that.option("scrolling.preloadEnabled");
      var pageCount = getViewportPageCount(that);
      var isAppendMode2 = that._controller.isAppendMode();
      if (pageCount) {
        if (previous) {
          pageCount = preloadEnabled ? 1 : 0;
        } else {
          if (preloadEnabled) {
            pageCount++;
          }
          if (isAppendMode2 || !needTwoPagesLoading(that)) {
            pageCount--;
          }
        }
      }
      return pageCount;
    };
    getPageIndexForLoad = (that) => {
      var result2 = -1;
      var beginPageIndex = getBeginPageIndex(that);
      var dataOptions = that._dataOptions;
      if (beginPageIndex < 0) {
        result2 = that._pageIndex;
      } else if (!that._cache[that._pageIndex - beginPageIndex]) {
        result2 = that._pageIndex;
      } else if (beginPageIndex >= 0 && that._controller.viewportSize() >= 0) {
        if (beginPageIndex > 0) {
          var needToLoadPageBeforeLast = getEndPageIndex(that) + 1 === dataOptions.pageCount() && that._cache.length < getPreloadPageCount(that) + 1;
          var needToLoadPrevPage = needToLoadPageBeforeLast || that._pageIndex === beginPageIndex && getPreloadPageCount(that, true);
          if (needToLoadPrevPage) {
            result2 = beginPageIndex - 1;
          }
        }
        if (result2 < 0) {
          var needToLoadNextPage = beginPageIndex + that._cache.length <= that._pageIndex + getPreloadPageCount(that);
          if (needToLoadNextPage) {
            result2 = beginPageIndex + that._cache.length;
          }
        }
      }
      if (that._loadingPageIndexes[result2]) {
        result2 = -1;
      }
      return result2;
    };
    loadCore = (that, pageIndex) => {
      var dataOptions = that._dataOptions;
      if (pageIndex === that.pageIndex() || !dataOptions.isLoading() && pageIndex < dataOptions.pageCount() || !dataOptions.hasKnownLastPage() && pageIndex === dataOptions.pageCount()) {
        dataOptions.pageIndex(pageIndex);
        that._loadingPageIndexes[pageIndex] = true;
        return when(dataOptions.load()).always(() => {
          that._loadingPageIndexes[pageIndex] = false;
        });
      }
    };
    processChanged = (that, changed, changeType, isDelayChanged, removeCacheItem) => {
      var dataOptions = that._dataOptions;
      var items = dataOptions.items().slice();
      var change = isObject2(changeType) ? changeType : void 0;
      var isPrepend = "prepend" === changeType;
      var viewportItems = dataOptions.viewportItems();
      if (changeType && isString2(changeType) && !that._isDelayChanged) {
        change = {
          changeType,
          items
        };
        if (removeCacheItem) {
          change.removeCount = removeCacheItem.itemsCount;
          if (change.removeCount && dataOptions.correctCount) {
            change.removeCount = dataOptions.correctCount(viewportItems, change.removeCount, isPrepend);
          }
        }
      }
      var removeItemCount = removeCacheItem ? removeCacheItem.itemsLength : 0;
      if (removeItemCount && dataOptions.correctCount) {
        removeItemCount = dataOptions.correctCount(viewportItems, removeItemCount, isPrepend);
      }
      if ("append" === changeType) {
        viewportItems.push.apply(viewportItems, items);
        if (removeCacheItem) {
          viewportItems.splice(0, removeItemCount);
        }
      } else if (isPrepend) {
        viewportItems.unshift.apply(viewportItems, items);
        if (removeCacheItem) {
          viewportItems.splice(-removeItemCount);
        }
      } else {
        that._dataOptions.viewportItems(items);
      }
      dataOptions.updateLoading();
      that._lastPageIndex = that.pageIndex();
      that._isDelayChanged = isDelayChanged;
      if (!isDelayChanged) {
        fireChanged(that, changed, change);
      }
    };
    VirtualDataLoader = class {
      constructor(controller, dataOptions) {
        this._controller = controller;
        this._dataOptions = dataOptions;
        this._pageIndex = this._lastPageIndex = dataOptions.pageIndex();
        this._cache = [];
        this._loadingPageIndexes = {};
      }
      option() {
        return this._controller.option.apply(this._controller, arguments);
      }
      viewportItemIndexChanged(itemIndex) {
        var pageSize = this._dataOptions.pageSize();
        var pageCount = this._dataOptions.pageCount();
        var virtualMode = this._controller.isVirtualMode();
        var appendMode = this._controller.isAppendMode();
        var totalItemsCount = this._dataOptions.totalItemsCount();
        var newPageIndex;
        if (pageSize && (virtualMode || appendMode) && totalItemsCount >= 0) {
          var viewportSize = this._controller.viewportSize();
          if (viewportSize && itemIndex + viewportSize >= totalItemsCount && !this._controller.isVirtual()) {
            if (this._dataOptions.hasKnownLastPage()) {
              newPageIndex = pageCount - 1;
              var lastPageSize = totalItemsCount % pageSize;
              if (newPageIndex > 0 && lastPageSize > 0 && lastPageSize < viewportSize) {
                newPageIndex--;
              }
            } else {
              newPageIndex = pageCount;
            }
          } else {
            newPageIndex = Math.floor(itemIndex / pageSize);
            var maxPageIndex = pageCount - 1;
            newPageIndex = Math.max(newPageIndex, 0);
            newPageIndex = Math.min(newPageIndex, maxPageIndex);
          }
          this.pageIndex(newPageIndex);
          return this.load();
        }
      }
      pageIndex(pageIndex) {
        var isVirtualMode2 = this._controller.isVirtualMode();
        var isAppendMode2 = this._controller.isAppendMode();
        if (!this.option(NEW_SCROLLING_MODE3) && (isVirtualMode2 || isAppendMode2)) {
          if (void 0 !== pageIndex) {
            this._pageIndex = pageIndex;
          }
          return this._pageIndex;
        } else {
          return this._dataOptions.pageIndex(pageIndex);
        }
      }
      beginPageIndex(defaultPageIndex) {
        var beginPageIndex = getBeginPageIndex(this);
        if (beginPageIndex < 0) {
          beginPageIndex = void 0 !== defaultPageIndex ? defaultPageIndex : this.pageIndex();
        }
        return beginPageIndex;
      }
      endPageIndex() {
        var endPageIndex = getEndPageIndex(this);
        return endPageIndex > 0 ? endPageIndex : this._lastPageIndex;
      }
      pageSize() {
        return this._dataOptions.pageSize();
      }
      load() {
        var dataOptions = this._dataOptions;
        var result2;
        var isVirtualMode2 = this._controller.isVirtualMode();
        var isAppendMode2 = this._controller.isAppendMode();
        if (!this.option(NEW_SCROLLING_MODE3) && (isVirtualMode2 || isAppendMode2)) {
          var pageIndexForLoad = getPageIndexForLoad(this);
          if (pageIndexForLoad >= 0) {
            var loadResult = loadCore(this, pageIndexForLoad);
            if (loadResult) {
              result2 = new Deferred();
              loadResult.done(() => {
                var delayDeferred = this._delayDeferred;
                if (delayDeferred) {
                  delayDeferred.done(result2.resolve).fail(result2.reject);
                } else {
                  result2.resolve();
                }
              }).fail(result2.reject);
              dataOptions.updateLoading();
            }
          }
        } else {
          result2 = dataOptions.load();
        }
        if (!result2 && this._lastPageIndex !== this.pageIndex()) {
          this._dataOptions.onChanged({
            changeType: "pageIndex"
          });
        }
        return result2 || new Deferred().resolve();
      }
      loadIfNeed() {
        var isVirtualMode2 = this._controller.isVirtualMode();
        var isAppendMode2 = this._controller.isAppendMode();
        if ((isVirtualMode2 || isAppendMode2) && !this._dataOptions.isLoading() && (!this._isChangedFiring || this._controller.isVirtual())) {
          var position3 = this._controller.getViewportPosition();
          if (position3 > 0) {
            this._controller._setViewportPositionCore(position3);
          } else {
            this.load();
          }
        }
      }
      handleDataChanged(callBase, e) {
        var dataOptions = this._dataOptions;
        var lastCacheLength = this._cache.length;
        var changeType;
        var removeInvisiblePages;
        var isVirtualMode2 = this._controller.isVirtualMode();
        var isAppendMode2 = this._controller.isAppendMode();
        if (e && e.changes) {
          fireChanged(this, callBase, e);
        } else if (!this.option(NEW_SCROLLING_MODE3) && (isVirtualMode2 || isAppendMode2)) {
          var beginPageIndex = getBeginPageIndex(this);
          if (beginPageIndex >= 0) {
            if (isVirtualMode2 && beginPageIndex + this._cache.length !== dataOptions.pageIndex() && beginPageIndex - 1 !== dataOptions.pageIndex()) {
              lastCacheLength = 0;
              this._cache = [];
            }
            if (isAppendMode2) {
              if (0 === dataOptions.pageIndex()) {
                this._cache = [];
              } else if (dataOptions.pageIndex() < getEndPageIndex(this)) {
                fireChanged(this, callBase, {
                  changeType: "append",
                  items: []
                });
                return;
              }
            }
          }
          var cacheItem = {
            pageIndex: dataOptions.pageIndex(),
            itemsLength: dataOptions.items(true).length,
            itemsCount: this.itemsCount(true)
          };
          if (this.option("scrolling.removeInvisiblePages") && isVirtualMode2) {
            removeInvisiblePages = this._cache.length > Math.max(getPreloadPageCount(this) + (this.option("scrolling.preloadEnabled") ? 1 : 0), 2);
          } else {
            processDelayChanged(this, callBase, {
              isDelayed: true
            });
          }
          var removeCacheItem;
          if (beginPageIndex === dataOptions.pageIndex() + 1) {
            if (removeInvisiblePages) {
              removeCacheItem = this._cache.pop();
            }
            changeType = "prepend";
            this._cache.unshift(cacheItem);
          } else {
            if (removeInvisiblePages) {
              removeCacheItem = this._cache.shift();
            }
            changeType = "append";
            this._cache.push(cacheItem);
          }
          var isDelayChanged = isVirtualMode2 && 0 === lastCacheLength && needTwoPagesLoading(this);
          processChanged(this, callBase, this._cache.length > 1 ? changeType : void 0, isDelayChanged, removeCacheItem);
          this._delayDeferred = this.load().done(() => {
            if (processDelayChanged(this, callBase)) {
              this.load();
            }
          });
        } else {
          processChanged(this, callBase, e);
        }
      }
      getDelayDeferred() {
        return this._delayDeferred;
      }
      itemsCount(isBase) {
        var itemsCount = 0;
        var isVirtualMode2 = this._controller.isVirtualMode();
        if (!isBase && isVirtualMode2) {
          this._cache.forEach((cacheItem) => {
            itemsCount += cacheItem.itemsCount;
          });
        } else {
          itemsCount = this._dataOptions.itemsCount();
        }
        return itemsCount;
      }
      virtualItemsCount() {
        var pageIndex = getBeginPageIndex(this);
        if (pageIndex < 0) {
          pageIndex = this._dataOptions.pageIndex();
        }
        var beginItemsCount = pageIndex * this._dataOptions.pageSize();
        var itemsCount = this._cache.length * this._dataOptions.pageSize();
        var endItemsCount = Math.max(0, this._dataOptions.totalItemsCount() - itemsCount - beginItemsCount);
        return {
          begin: beginItemsCount,
          end: endItemsCount
        };
      }
      reset() {
        this._loadingPageIndexes = {};
        this._cache = [];
      }
    };
  }
});

// node_modules/devextreme/esm/ui/grid_core/ui.grid_core.virtual_scrolling_core.js
function getContentHeightLimit(browser) {
  if (browser.msie) {
    return 4e6;
  } else if (browser.mozilla) {
    return 8e6;
  }
  return 15e6 / getPixelRatio(getWindow());
}
function subscribeToExternalScrollers($element, scrollChangedHandler, $targetElement) {
  var $scrollElement;
  var scrollableArray = [];
  var scrollToArray = [];
  var disposeArray = [];
  $targetElement = $targetElement || $element;
  function getElementOffset(scrollable) {
    var $scrollableElement = scrollable.element ? scrollable.$element() : scrollable;
    var scrollableOffset = position_default.offset($scrollableElement);
    if (!scrollableOffset) {
      return $element.offset().top;
    }
    return scrollable.scrollTop() - (scrollableOffset.top - $element.offset().top);
  }
  var widgetScrollStrategy = {
    on: function(scrollable, eventName, handler) {
      scrollable.on("scroll", handler);
    },
    off: function(scrollable, eventName, handler) {
      scrollable.off("scroll", handler);
    }
  };
  function subscribeToScrollEvents($scrollElement2) {
    var isDocument = "#document" === $scrollElement2.get(0).nodeName;
    var scrollable = $scrollElement2.data("dxScrollable");
    var eventsStrategy = widgetScrollStrategy;
    if (!scrollable) {
      scrollable = isDocument && renderer_default(getWindow()) || "auto" === $scrollElement2.css("overflowY") && $scrollElement2;
      eventsStrategy = events_engine_default;
      if (!scrollable) {
        return;
      }
    }
    var handler = /* @__PURE__ */ function(scrollable2) {
      return function() {
        var scrollTop = scrollable2.scrollTop() - getElementOffset(scrollable2);
        scrollTop = scrollTop > 0 ? scrollTop : 0;
        scrollChangedHandler(scrollTop);
      };
    }(scrollable);
    eventsStrategy.on(scrollable, "scroll", handler);
    scrollToArray.push(function(pos) {
      var topOffset = getElementOffset(scrollable);
      var scrollMethod = scrollable.scrollTo ? "scrollTo" : "scrollTop";
      if (pos - topOffset >= 0) {
        scrollable[scrollMethod](pos + topOffset);
      }
    });
    scrollableArray.push(scrollable);
    disposeArray.push(function() {
      eventsStrategy.off(scrollable, "scroll", handler);
    });
  }
  for ($scrollElement = $targetElement.parent(); $scrollElement.length; $scrollElement = $scrollElement.parent()) {
    subscribeToScrollEvents($scrollElement);
  }
  return {
    scrollTo: function(pos) {
      each(scrollToArray, function(_2, scrollTo) {
        scrollTo(pos);
      });
    },
    dispose: function() {
      each(disposeArray, function(_2, dispose) {
        dispose();
      });
    }
  };
}
var SCROLLING_MODE_INFINITE, SCROLLING_MODE_VIRTUAL, NEW_SCROLLING_MODE4, _isVirtualMode, _isAppendMode, getPixelRatio, VirtualScrollController;
var init_ui_grid_core_virtual_scrolling_core = __esm({
  "node_modules/devextreme/esm/ui/grid_core/ui.grid_core.virtual_scrolling_core.js"() {
    init_renderer();
    init_window();
    init_events_engine();
    init_browser();
    init_position2();
    init_iterator();
    init_class();
    init_deferred();
    init_callbacks();
    init_ui_grid_core_virtual_data_loader();
    SCROLLING_MODE_INFINITE = "infinite";
    SCROLLING_MODE_VIRTUAL = "virtual";
    NEW_SCROLLING_MODE4 = "scrolling.newMode";
    _isVirtualMode = (that) => that.option("scrolling.mode") === SCROLLING_MODE_VIRTUAL || that._isVirtual;
    _isAppendMode = (that) => that.option("scrolling.mode") === SCROLLING_MODE_INFINITE && !that._isVirtual;
    getPixelRatio = (window29) => window29.devicePixelRatio || 1;
    VirtualScrollController = class_default.inherit(function() {
      var members = {
        ctor: function(component, dataOptions, isVirtual) {
          this._dataOptions = dataOptions;
          this.component = component;
          this._viewportSize = 0;
          this._viewportItemSize = 20;
          this._viewportItemIndex = 0;
          this._contentSize = 0;
          this._itemSizes = {};
          this._sizeRatio = 1;
          this._isVirtual = isVirtual;
          this.positionChanged = callbacks_default();
          this._dataLoader = new VirtualDataLoader(this, this._dataOptions);
        },
        getItemSizes: function() {
          return this._itemSizes;
        },
        option: function() {
          return this.component.option.apply(this.component, arguments);
        },
        isVirtual: function() {
          return this._isVirtual;
        },
        virtualItemsCount: function() {
          if (_isVirtualMode(this)) {
            var totalItemsCount = this._dataOptions.totalItemsCount();
            if (this.option(NEW_SCROLLING_MODE4) && -1 !== totalItemsCount) {
              var viewportParams = this.getViewportParams();
              var endItemsCount = totalItemsCount - (viewportParams.skip + viewportParams.take);
              return {
                begin: viewportParams.skip,
                end: endItemsCount
              };
            }
            return this._dataLoader.virtualItemsCount.apply(this._dataLoader, arguments);
          }
        },
        setViewportPosition: function(position3) {
          var result2 = new Deferred();
          var scrollingTimeout = Math.min(this.option("scrolling.timeout") || 0, this._dataOptions.changingDuration());
          if (scrollingTimeout < this.option("scrolling.renderingThreshold")) {
            scrollingTimeout = this.option("scrolling.minTimeout") || 0;
          }
          clearTimeout(this._scrollTimeoutID);
          if (scrollingTimeout > 0) {
            this._scrollTimeoutID = setTimeout(() => {
              this._setViewportPositionCore(position3);
              result2.resolve();
            }, scrollingTimeout);
          } else {
            this._setViewportPositionCore(position3);
            result2.resolve();
          }
          return result2.promise();
        },
        getViewportPosition: function() {
          return this._position || 0;
        },
        getItemIndexByPosition: function() {
          var position3 = this._position;
          var defaultItemSize = this.getItemSize();
          var offset2 = 0;
          var itemOffset = 0;
          var itemOffsetsWithSize = Object.keys(this._itemSizes).concat(-1);
          for (var i = 0; i < itemOffsetsWithSize.length && offset2 < position3; i++) {
            var itemOffsetWithSize = parseInt(itemOffsetsWithSize[i]);
            var itemOffsetDiff = (position3 - offset2) / defaultItemSize;
            if (itemOffsetWithSize < 0 || itemOffset + itemOffsetDiff < itemOffsetWithSize) {
              itemOffset += itemOffsetDiff;
              break;
            } else {
              itemOffsetDiff = itemOffsetWithSize - itemOffset;
              offset2 += itemOffsetDiff * defaultItemSize;
              itemOffset += itemOffsetDiff;
            }
            var itemSize = this._itemSizes[itemOffsetWithSize];
            offset2 += itemSize;
            itemOffset += offset2 < position3 ? 1 : (position3 - offset2 + itemSize) / itemSize;
          }
          return Math.round(50 * itemOffset) / 50;
        },
        _setViewportPositionCore: function(position3) {
          this._position = position3;
          var itemIndex = this.getItemIndexByPosition();
          var result2 = this.setViewportItemIndex(itemIndex);
          this.positionChanged.fire();
          return result2;
        },
        setContentItemSizes: function(sizes) {
          var virtualItemsCount = this.virtualItemsCount();
          this._contentSize = sizes.reduce((a, b) => a + b, 0);
          if (virtualItemsCount) {
            sizes.forEach((size, index2) => {
              this._itemSizes[virtualItemsCount.begin + index2] = size;
            });
            var virtualContentSize = (virtualItemsCount.begin + virtualItemsCount.end + this.itemsCount()) * this._viewportItemSize;
            var contentHeightLimit = getContentHeightLimit(browser_default);
            if (virtualContentSize > contentHeightLimit) {
              this._sizeRatio = contentHeightLimit / virtualContentSize;
            } else {
              this._sizeRatio = 1;
            }
          }
        },
        getItemSize: function() {
          return this._viewportItemSize * this._sizeRatio;
        },
        getItemOffset: function(itemIndex, isEnd) {
          var virtualItemsCount = this.virtualItemsCount();
          var itemCount = itemIndex;
          if (!virtualItemsCount) {
            return 0;
          }
          var offset2 = 0;
          var totalItemsCount = this._dataOptions.totalItemsCount();
          Object.keys(this._itemSizes).forEach((currentItemIndex) => {
            if (!itemCount) {
              return;
            }
            if (isEnd ? currentItemIndex >= totalItemsCount - itemIndex : currentItemIndex < itemIndex) {
              offset2 += this._itemSizes[currentItemIndex];
              itemCount--;
            }
          });
          return Math.floor(offset2 + itemCount * this._viewportItemSize * this._sizeRatio);
        },
        getContentOffset: function(type2) {
          var isEnd = "end" === type2;
          var virtualItemsCount = this.virtualItemsCount();
          if (!virtualItemsCount) {
            return 0;
          }
          return this.getItemOffset(isEnd ? virtualItemsCount.end : virtualItemsCount.begin, isEnd);
        },
        getVirtualContentSize: function() {
          var virtualItemsCount = this.virtualItemsCount();
          return virtualItemsCount ? this.getContentOffset("begin") + this.getContentOffset("end") + this._contentSize : 0;
        },
        getViewportItemIndex: function() {
          return this._viewportItemIndex;
        },
        setViewportItemIndex: function(itemIndex) {
          this._viewportItemIndex = itemIndex;
          if (this.option(NEW_SCROLLING_MODE4)) {
            return;
          }
          return this._dataLoader.viewportItemIndexChanged.apply(this._dataLoader, arguments);
        },
        viewportItemSize: function(size) {
          if (void 0 !== size) {
            this._viewportItemSize = size;
          }
          return this._viewportItemSize;
        },
        viewportSize: function(size) {
          if (void 0 !== size) {
            this._viewportSize = size;
          }
          return this._viewportSize;
        },
        reset: function(isRefresh) {
          this._dataLoader.reset();
          if (!isRefresh) {
            this._itemSizes = {};
          }
        },
        subscribeToWindowScrollEvents: function($element) {
          this._windowScroll = this._windowScroll || subscribeToExternalScrollers($element, (scrollTop) => {
            if (this.viewportItemSize()) {
              this.setViewportPosition(scrollTop);
            }
          });
        },
        dispose: function() {
          clearTimeout(this._scrollTimeoutID);
          this._windowScroll && this._windowScroll.dispose();
          this._windowScroll = null;
        },
        scrollTo: function(pos) {
          this._windowScroll && this._windowScroll.scrollTo(pos);
        },
        isVirtualMode: function() {
          return _isVirtualMode(this);
        },
        isAppendMode: function() {
          return _isAppendMode(this);
        },
        getViewportParams: function() {
          var topIndex = this._viewportItemIndex;
          var bottomIndex = this._viewportSize + topIndex;
          var maxGap = this.pageSize();
          var minGap = this.option("scrolling.minGap");
          var virtualMode = this.option("scrolling.mode") === SCROLLING_MODE_VIRTUAL;
          var skip = Math.floor(Math.max(0, topIndex - minGap) / maxGap) * maxGap;
          var take = Math.ceil((bottomIndex + minGap) / maxGap) * maxGap - skip;
          if (virtualMode) {
            var remainedItems = this._dataOptions.totalItemsCount() - skip;
            take = Math.min(take, remainedItems);
          }
          return {
            skip,
            take
          };
        }
      };
      ["pageIndex", "beginPageIndex", "endPageIndex", "pageSize", "load", "loadIfNeed", "handleDataChanged", "itemsCount", "getDelayDeferred"].forEach(function(name2) {
        members[name2] = function() {
          return this._dataLoader[name2].apply(this._dataLoader, arguments);
        };
      });
      return members;
    }());
  }
});

// node_modules/devextreme/esm/ui/grid_core/ui.grid_core.virtual_scrolling.js
var TABLE_CLASS2, BOTTOM_LOAD_PANEL_CLASS, TABLE_CONTENT_CLASS, GROUP_SPACE_CLASS2, CONTENT_CLASS3, ROW_CLASS5, FREESPACE_CLASS, COLUMN_LINES_CLASS, VIRTUAL_ROW_CLASS, SCROLLING_MODE_INFINITE2, SCROLLING_MODE_VIRTUAL2, SCROLLING_MODE_STANDARD, PIXELS_LIMIT, LOAD_TIMEOUT, NEW_SCROLLING_MODE5, isVirtualMode, isAppendMode, isVirtualRowRendering, _correctCount, isItemCountableByDataSource, updateItemIndices, VirtualScrollingDataSourceAdapterExtender, VirtualScrollingRowsViewExtender, virtualScrollingModule;
var init_ui_grid_core_virtual_scrolling = __esm({
  "node_modules/devextreme/esm/ui/grid_core/ui.grid_core.virtual_scrolling.js"() {
    init_renderer();
    init_window();
    init_ui_grid_core_virtual_scrolling_core();
    init_ui_grid_core_utils();
    init_iterator();
    init_deferred();
    init_load_indicator();
    init_browser();
    init_position();
    init_type();
    TABLE_CLASS2 = "table";
    BOTTOM_LOAD_PANEL_CLASS = "bottom-load-panel";
    TABLE_CONTENT_CLASS = "table-content";
    GROUP_SPACE_CLASS2 = "group-space";
    CONTENT_CLASS3 = "content";
    ROW_CLASS5 = "dx-row";
    FREESPACE_CLASS = "dx-freespace-row";
    COLUMN_LINES_CLASS = "dx-column-lines";
    VIRTUAL_ROW_CLASS = "dx-virtual-row";
    SCROLLING_MODE_INFINITE2 = "infinite";
    SCROLLING_MODE_VIRTUAL2 = "virtual";
    SCROLLING_MODE_STANDARD = "standard";
    PIXELS_LIMIT = 25e4;
    LOAD_TIMEOUT = 300;
    NEW_SCROLLING_MODE5 = "scrolling.newMode";
    isVirtualMode = function(that) {
      return that.option("scrolling.mode") === SCROLLING_MODE_VIRTUAL2;
    };
    isAppendMode = function(that) {
      return that.option("scrolling.mode") === SCROLLING_MODE_INFINITE2;
    };
    isVirtualRowRendering = function(that) {
      var rowRenderingMode = that.option("scrolling.rowRenderingMode");
      if (rowRenderingMode === SCROLLING_MODE_VIRTUAL2) {
        return true;
      } else if (rowRenderingMode === SCROLLING_MODE_STANDARD) {
        return false;
      }
    };
    _correctCount = function(items, count, fromEnd, isItemCountableFunc) {
      for (var i = 0; i < count + 1; i++) {
        var item = items[fromEnd ? items.length - 1 - i : i];
        if (item && !isItemCountableFunc(item, i === count, fromEnd)) {
          count++;
        }
      }
      return count;
    };
    isItemCountableByDataSource = function(item, dataSource) {
      return "data" === item.rowType && !item.isNewRow || "group" === item.rowType && dataSource.isGroupItemCountable(item.data);
    };
    updateItemIndices = function(items) {
      items.forEach(function(item, index2) {
        item.rowIndex = index2;
      });
      return items;
    };
    VirtualScrollingDataSourceAdapterExtender = function() {
      var _updateLoading = function(that) {
        var beginPageIndex = that._virtualScrollController.beginPageIndex(-1);
        if (isVirtualMode(that)) {
          if (beginPageIndex < 0 || that.viewportSize() >= 0 && that.getViewportItemIndex() >= 0 && (beginPageIndex * that.pageSize() > that.getViewportItemIndex() || beginPageIndex * that.pageSize() + that.itemsCount() < that.getViewportItemIndex() + that.viewportSize()) && that._dataSource.isLoading()) {
            if (!that._isLoading) {
              that._isLoading = true;
              that.loadingChanged.fire(true);
            }
          } else if (that._isLoading) {
            that._isLoading = false;
            that.loadingChanged.fire(false);
          }
        }
      };
      var result2 = {
        init: function() {
          this.callBase.apply(this, arguments);
          this._items = [];
          this._isLoaded = true;
          this._loadPageCount = 1;
          this._virtualScrollController = new VirtualScrollController(this.component, this._getVirtualScrollDataOptions());
        },
        _getVirtualScrollDataOptions: function() {
          var that = this;
          return {
            pageSize: function() {
              return that.pageSize();
            },
            totalItemsCount: function() {
              return that.totalItemsCount();
            },
            hasKnownLastPage: function() {
              return that.hasKnownLastPage();
            },
            pageIndex: function(index2) {
              return that._dataSource.pageIndex(index2);
            },
            isLoading: function() {
              return that._dataSource.isLoading() && !that.isCustomLoading();
            },
            pageCount: function() {
              return that.pageCount();
            },
            load: function() {
              return that._dataSource.load();
            },
            updateLoading: function() {
              _updateLoading(that);
            },
            itemsCount: function() {
              return that.itemsCount(true);
            },
            items: function() {
              return that._dataSource.items();
            },
            viewportItems: function(items) {
              if (items) {
                that._items = items;
              }
              return that._items;
            },
            onChanged: function(e) {
              that.changed.fire(e);
            },
            changingDuration: function(e) {
              if (that.isLoading()) {
                return LOAD_TIMEOUT;
              }
              return that._renderTime || 0;
            }
          };
        },
        _handleLoadingChanged: function(isLoading) {
          if (this.option(NEW_SCROLLING_MODE5)) {
            this.callBase.apply(this, arguments);
            return;
          }
          if (!isVirtualMode(this) || this._isLoadingAll) {
            this._isLoading = isLoading;
            this.callBase.apply(this, arguments);
          }
          if (isLoading) {
            this._startLoadTime = /* @__PURE__ */ new Date();
          } else {
            this._startLoadTime = void 0;
          }
        },
        _handleLoadError: function() {
          if (!this.option(NEW_SCROLLING_MODE5)) {
            this._isLoading = false;
            this.loadingChanged.fire(false);
          }
          this.callBase.apply(this, arguments);
        },
        _handleDataChanged: function(e) {
          if (this.option(NEW_SCROLLING_MODE5)) {
            this.callBase.apply(this, arguments);
            return;
          }
          var callBase = this.callBase.bind(this);
          this._virtualScrollController.handleDataChanged(callBase, e);
        },
        _customizeRemoteOperations: function(options2, operationTypes) {
          var newMode = this.option(NEW_SCROLLING_MODE5);
          if ((isVirtualMode(this) || isAppendMode(this) && newMode) && !operationTypes.reload && (operationTypes.skip || newMode) && this._renderTime < this.option("scrolling.renderingThreshold")) {
            options2.delay = void 0;
          }
          this.callBase.apply(this, arguments);
        },
        items: function() {
          if (this.option(NEW_SCROLLING_MODE5)) {
            return this._dataSource.items();
          }
          return this._items;
        },
        itemsCount: function(isBase) {
          if (isBase) {
            return this.callBase();
          }
          return this._virtualScrollController.itemsCount();
        },
        load: function(loadOptions) {
          if (this.option(NEW_SCROLLING_MODE5) || loadOptions) {
            return this.callBase(loadOptions);
          }
          return this._virtualScrollController.load();
        },
        isLoading: function() {
          return this._isLoading;
        },
        isLoaded: function() {
          return this._dataSource.isLoaded() && this._isLoaded;
        },
        resetPagesCache: function(isLiveUpdate) {
          if (!isLiveUpdate) {
            this._virtualScrollController.reset(true);
          }
          this.callBase.apply(this, arguments);
        },
        _changeRowExpandCore: function() {
          var result3 = this.callBase.apply(this, arguments);
          if (this.option(NEW_SCROLLING_MODE5)) {
            return result3;
          }
          this.resetPagesCache();
          _updateLoading(this);
          return result3;
        },
        reload: function() {
          this._dataSource.pageIndex(this.pageIndex());
          var virtualScrollController = this._virtualScrollController;
          if (!this.option(NEW_SCROLLING_MODE5) && virtualScrollController) {
            var d = new Deferred();
            this.callBase.apply(this, arguments).done(function(r) {
              var delayDeferred = virtualScrollController.getDelayDeferred();
              if (delayDeferred) {
                delayDeferred.done(d.resolve).fail(d.reject);
              } else {
                d.resolve(r);
              }
            }).fail(d.reject);
            return d;
          } else {
            return this.callBase.apply(this, arguments);
          }
        },
        refresh: function(options2, operationTypes) {
          if (!this.option(NEW_SCROLLING_MODE5)) {
            var storeLoadOptions = options2.storeLoadOptions;
            var dataSource = this._dataSource;
            if (operationTypes.reload) {
              this._virtualScrollController.reset();
              dataSource.items().length = 0;
              this._isLoaded = false;
              _updateLoading(this);
              this._isLoaded = true;
              if (isAppendMode(this)) {
                this.pageIndex(0);
                dataSource.pageIndex(0);
                storeLoadOptions.pageIndex = 0;
                options2.pageIndex = 0;
                storeLoadOptions.skip = 0;
              } else {
                dataSource.pageIndex(this.pageIndex());
                if (dataSource.paginate()) {
                  options2.pageIndex = this.pageIndex();
                  storeLoadOptions.skip = this.pageIndex() * this.pageSize();
                }
              }
            } else if (isAppendMode(this) && storeLoadOptions.skip && this._skipCorrection < 0) {
              storeLoadOptions.skip += this._skipCorrection;
            }
          }
          return this.callBase.apply(this, arguments);
        },
        dispose: function() {
          this._virtualScrollController.dispose();
          this.callBase.apply(this, arguments);
        },
        loadPageCount: function(count) {
          if (!isDefined(count)) {
            return this._loadPageCount;
          }
          this._loadPageCount = count;
        },
        _handleDataLoading: function(options2) {
          var loadPageCount = this.loadPageCount();
          options2.loadPageCount = loadPageCount;
          if (this.option(NEW_SCROLLING_MODE5) && loadPageCount > 1) {
            options2.storeLoadOptions.take = loadPageCount * this.pageSize();
          }
          this.callBase.apply(this, arguments);
        },
        _loadPageSize: function() {
          return this.callBase.apply(this, arguments) * this.loadPageCount();
        }
      };
      ["beginPageIndex", "endPageIndex"].forEach(function(name2) {
        result2[name2] = function() {
          if (this.option(NEW_SCROLLING_MODE5)) {
            var dataSource = this._dataSource;
            return dataSource.pageIndex.apply(dataSource, arguments);
          }
          var virtualScrollController = this._virtualScrollController;
          return virtualScrollController[name2].apply(virtualScrollController, arguments);
        };
      });
      ["virtualItemsCount", "getContentOffset", "getVirtualContentSize", "setContentItemSizes", "setViewportPosition", "getViewportItemIndex", "setViewportItemIndex", "getItemIndexByPosition", "viewportSize", "viewportItemSize", "getItemSize", "getItemSizes", "pageIndex", "loadIfNeed"].forEach(function(name2) {
        result2[name2] = function() {
          var virtualScrollController = this._virtualScrollController;
          return virtualScrollController[name2].apply(virtualScrollController, arguments);
        };
      });
      return result2;
    }();
    VirtualScrollingRowsViewExtender = /* @__PURE__ */ function() {
      var removeEmptyRows = function($emptyRows, className) {
        var tBodies = $emptyRows.toArray().map((row) => renderer_default(row).parent("." + className).get(0)).filter((row) => row);
        if (tBodies.length) {
          $emptyRows = renderer_default(tBodies);
        }
        var rowCount = className === FREESPACE_CLASS ? $emptyRows.length - 1 : $emptyRows.length;
        for (var i = 0; i < rowCount; i++) {
          $emptyRows.eq(i).remove();
        }
      };
      return {
        init: function() {
          var _dataController$state;
          var dataController = this.getController("data");
          this.callBase();
          dataController.pageChanged.add(() => {
            this.scrollToPage(dataController.pageIndex());
          });
          dataController.dataSourceChanged.add(() => {
            !this._scrollTop && this._scrollToCurrentPageOnResize();
          });
          null === (_dataController$state = dataController.stateLoaded) || void 0 === _dataController$state ? void 0 : _dataController$state.add(() => {
            this._scrollToCurrentPageOnResize();
          });
          this._scrollToCurrentPageOnResize();
        },
        _scrollToCurrentPageOnResize: function() {
          var dataController = this.getController("data");
          if (dataController.pageIndex() > 0) {
            var resizeHandler = () => {
              this.resizeCompleted.remove(resizeHandler);
              this.scrollToPage(dataController.pageIndex());
            };
            this.resizeCompleted.add(resizeHandler);
          }
        },
        scrollToPage: function(pageIndex) {
          var dataController = this._dataController;
          var pageSize = dataController ? dataController.pageSize() : 0;
          var scrollPosition;
          if (isVirtualMode(this) || isAppendMode(this)) {
            var itemSize = dataController.getItemSize();
            var itemSizes = dataController.getItemSizes();
            var itemIndex = pageIndex * pageSize;
            scrollPosition = itemIndex * itemSize;
            for (var index2 in itemSizes) {
              if (index2 < itemIndex) {
                scrollPosition += itemSizes[index2] - itemSize;
              }
            }
          } else {
            scrollPosition = 0;
          }
          this.scrollTo({
            y: scrollPosition,
            x: this._scrollLeft
          });
        },
        renderDelayedTemplates: function(e) {
          this._updateContentPosition(true);
          this.callBase.apply(this, arguments);
        },
        _renderCore: function(e) {
          var that = this;
          var startRenderTime = /* @__PURE__ */ new Date();
          that.callBase.apply(that, arguments);
          var dataSource = that._dataController._dataSource;
          if (dataSource && e) {
            var itemCount = e.items ? e.items.length : 20;
            var viewportSize = that._dataController.viewportSize() || 20;
            if (isVirtualRowRendering(that) && itemCount > 0) {
              dataSource._renderTime = (/* @__PURE__ */ new Date() - startRenderTime) * viewportSize / itemCount;
            } else {
              dataSource._renderTime = /* @__PURE__ */ new Date() - startRenderTime;
            }
          }
        },
        _getRowElements: function(tableElement) {
          var $rows = this.callBase(tableElement);
          return $rows && $rows.not("." + VIRTUAL_ROW_CLASS);
        },
        _removeRowsElements: function(contentTable, removeCount, changeType) {
          var rowElements = this._getRowElements(contentTable).toArray();
          if ("append" === changeType) {
            rowElements = rowElements.slice(0, removeCount);
          } else {
            rowElements = rowElements.slice(-removeCount);
          }
          var errorHandlingController = this.getController("errorHandling");
          rowElements.map((rowElement) => {
            var $rowElement = renderer_default(rowElement);
            errorHandlingController && errorHandlingController.removeErrorRow($rowElement.next());
            $rowElement.remove();
          });
        },
        _restoreErrorRow: function(contentTable) {
          var editingController = this.getController("editing");
          editingController && editingController.hasChanges() && this._getRowElements(contentTable).each((_2, item) => {
            var rowOptions = renderer_default(item).data("options");
            if (rowOptions) {
              var change = editingController.getChangeByKey(rowOptions.key);
              change && editingController._showErrorRow(change);
            }
          });
        },
        _updateContent: function(tableElement, change) {
          var $freeSpaceRowElements;
          var contentElement = this._findContentElement();
          var changeType = change && change.changeType;
          if ("append" === changeType || "prepend" === changeType) {
            var contentTable = contentElement.children().first();
            var $tBodies = this._getBodies(tableElement);
            if (1 === $tBodies.length) {
              this._getBodies(contentTable)["append" === changeType ? "append" : "prepend"]($tBodies.children());
            } else {
              $tBodies["append" === changeType ? "appendTo" : "prependTo"](contentTable);
            }
            tableElement.remove();
            $freeSpaceRowElements = this._getFreeSpaceRowElements(contentTable);
            removeEmptyRows($freeSpaceRowElements, FREESPACE_CLASS);
            if (change.removeCount) {
              this._removeRowsElements(contentTable, change.removeCount, changeType);
            }
            this._restoreErrorRow(contentTable);
          } else {
            this.callBase.apply(this, arguments);
          }
          this._updateBottomLoading();
        },
        _addVirtualRow: function($table, isFixed, location, position3) {
          if (!position3) {
            return;
          }
          var $virtualRow = this._createEmptyRow(VIRTUAL_ROW_CLASS, isFixed, position3);
          $virtualRow = this._wrapRowIfNeed($table, $virtualRow);
          this._appendEmptyRow($table, $virtualRow, location);
        },
        _getRowHeights: function() {
          var rowHeights = this._getRowElements(this._tableElement).toArray().map(function(row) {
            return getBoundingRect(row).height;
          });
          return rowHeights;
        },
        _correctRowHeights: function(rowHeights) {
          var dataController = this._dataController;
          var dataSource = dataController._dataSource;
          var correctedRowHeights = [];
          var visibleRows = dataController.getVisibleRows();
          var itemSize = 0;
          var firstCountableItem = true;
          for (var i = 0; i < rowHeights.length; i++) {
            var currentItem = visibleRows[i];
            if (!isDefined(currentItem)) {
              continue;
            }
            if (isItemCountableByDataSource(currentItem, dataSource)) {
              if (firstCountableItem) {
                firstCountableItem = false;
              } else {
                correctedRowHeights.push(itemSize);
                itemSize = 0;
              }
            }
            itemSize += rowHeights[i];
          }
          itemSize > 0 && correctedRowHeights.push(itemSize);
          return correctedRowHeights;
        },
        _updateContentPosition: function(isRender) {
          var dataController = this._dataController;
          var rowHeight = this._rowHeight || 20;
          dataController.viewportItemSize(rowHeight);
          if (isVirtualMode(this) || isVirtualRowRendering(this)) {
            if (!isRender) {
              var rowHeights = this._getRowHeights();
              var correctedRowHeights = this._correctRowHeights(rowHeights);
              dataController.setContentItemSizes(correctedRowHeights);
            }
            var top = dataController.getContentOffset("begin");
            var bottom = dataController.getContentOffset("end");
            var $tables = this.getTableElements();
            var $virtualRows = $tables.children("tbody").children("." + VIRTUAL_ROW_CLASS);
            removeEmptyRows($virtualRows, VIRTUAL_ROW_CLASS);
            $tables.each((index2, element) => {
              var isFixed = index2 > 0;
              var prevFixed = this._isFixedTableRendering;
              this._isFixedTableRendering = isFixed;
              this._addVirtualRow(renderer_default(element), isFixed, "top", top);
              this._addVirtualRow(renderer_default(element), isFixed, "bottom", bottom);
              this._isFixedTableRendering = prevFixed;
            });
          }
        },
        _isTableLinesDisplaysCorrect: function(table) {
          var hasColumnLines = table.find("." + COLUMN_LINES_CLASS).length > 0;
          return hasColumnLines === this.option("showColumnLines");
        },
        _isColumnElementsEqual: function($columns, $virtualColumns) {
          var result2 = $columns.length === $virtualColumns.length;
          if (result2) {
            each($columns, function(index2, element) {
              if (element.style.width !== $virtualColumns[index2].style.width) {
                result2 = false;
                return result2;
              }
            });
          }
          return result2;
        },
        _renderVirtualTableContent: function(container, height) {
          var columns = this._columnsController.getVisibleColumns();
          var html = this._createColGroup(columns).prop("outerHTML");
          var freeSpaceCellsHtml = "";
          var columnLinesClass = this.option("showColumnLines") ? COLUMN_LINES_CLASS : "";
          var createFreeSpaceRowHtml = function(height2) {
            return "<tr style='height:" + height2 + "px;' class='" + FREESPACE_CLASS + " " + ROW_CLASS5 + " " + columnLinesClass + "' >" + freeSpaceCellsHtml + "</tr>";
          };
          for (var i = 0; i < columns.length; i++) {
            var classes = this._getCellClasses(columns[i]);
            var classString = classes.length ? " class='" + classes.join(" ") + "'" : "";
            freeSpaceCellsHtml += "<td" + classString + "/>";
          }
          while (height > PIXELS_LIMIT) {
            html += createFreeSpaceRowHtml(PIXELS_LIMIT);
            height -= PIXELS_LIMIT;
          }
          html += createFreeSpaceRowHtml(height);
          container.addClass(this.addWidgetPrefix(TABLE_CLASS2));
          container.html(html);
        },
        _getCellClasses: function(column) {
          var classes = [];
          var cssClass = column.cssClass;
          var isExpandColumn = "expand" === column.command;
          cssClass && classes.push(cssClass);
          isExpandColumn && classes.push(this.addWidgetPrefix(GROUP_SPACE_CLASS2));
          return classes;
        },
        _findBottomLoadPanel: function($contentElement) {
          var $element = $contentElement || this.element();
          var $bottomLoadPanel = $element && $element.find("." + this.addWidgetPrefix(BOTTOM_LOAD_PANEL_CLASS));
          if ($bottomLoadPanel && $bottomLoadPanel.length) {
            return $bottomLoadPanel;
          }
        },
        _updateBottomLoading: function() {
          var virtualMode = isVirtualMode(this);
          var appendMode = isAppendMode(this);
          var showBottomLoading = !this._dataController.hasKnownLastPage() && this._dataController.isLoaded() && (virtualMode || appendMode);
          var $contentElement = this._findContentElement();
          var bottomLoadPanelElement = this._findBottomLoadPanel($contentElement);
          if (showBottomLoading) {
            if (!bottomLoadPanelElement) {
              renderer_default("<div>").addClass(this.addWidgetPrefix(BOTTOM_LOAD_PANEL_CLASS)).append(this._createComponent(renderer_default("<div>"), load_indicator_default).$element()).appendTo($contentElement);
            }
          } else if (bottomLoadPanelElement) {
            bottomLoadPanelElement.remove();
          }
        },
        _handleScroll: function(e) {
          var that = this;
          if (that._hasHeight && that._rowHeight) {
            that._dataController.setViewportPosition(e.scrollOffset.top);
          }
          that.callBase.apply(that, arguments);
        },
        _needUpdateRowHeight: function(itemsCount) {
          var that = this;
          return that.callBase.apply(that, arguments) || itemsCount > 0 && that.option("scrolling.mode") === SCROLLING_MODE_INFINITE2 && that.option("scrolling.rowRenderingMode") !== SCROLLING_MODE_VIRTUAL2;
        },
        _updateRowHeight: function() {
          this.callBase.apply(this, arguments);
          if (this._rowHeight) {
            this._updateContentPosition();
            var viewportHeight = this._hasHeight ? this.element().outerHeight() : renderer_default(getWindow()).outerHeight();
            var dataController = this._dataController;
            var itemsCount = dataController.items().length;
            var $tableElement = this.getTableElement();
            var rowsHeight = this._getRowsHeight($tableElement);
            var rowHeight = itemsCount ? rowsHeight / itemsCount : this._rowHeight;
            dataController.viewportSize(Math.ceil(viewportHeight / rowHeight));
            if (this.option(NEW_SCROLLING_MODE5) && !isDefined(dataController._loadViewportParams)) {
              var viewportSize = dataController.viewportSize();
              var viewportIsNotFilled = viewportSize > dataController.items().length && (isAppendMode(this) || dataController.totalItemsCount() > viewportSize);
              viewportIsNotFilled && dataController.loadViewport();
            }
          }
        },
        updateFreeSpaceRowHeight: function() {
          var result2 = this.callBase.apply(this, arguments);
          if (result2) {
            this._updateContentPosition();
          }
          return result2;
        },
        setLoading: function(isLoading, messageText) {
          var dataController = this._dataController;
          var hasBottomLoadPanel = dataController.pageIndex() > 0 && dataController.isLoaded() && !!this._findBottomLoadPanel();
          if (this.option(NEW_SCROLLING_MODE5) && isLoading && dataController.isViewportChanging()) {
            return;
          }
          if (hasBottomLoadPanel) {
            isLoading = false;
          }
          this.callBase.call(this, isLoading, messageText);
        },
        _resizeCore: function() {
          var that = this;
          var $element = that.element();
          that.callBase();
          if (that.component.$element() && !that._windowScroll && $element.closest(getWindow().document).length) {
            that._windowScroll = subscribeToExternalScrollers($element, function(scrollPos) {
              if (!that._hasHeight && that._rowHeight) {
                that._dataController.setViewportPosition(scrollPos);
              }
            }, that.component.$element());
            that.on("disposing", function() {
              that._windowScroll.dispose();
            });
          }
          that.loadIfNeed();
        },
        loadIfNeed: function() {
          var _dataController$loadI;
          var dataController = this._dataController;
          null === dataController || void 0 === dataController ? void 0 : null === (_dataController$loadI = dataController.loadIfNeed) || void 0 === _dataController$loadI ? void 0 : _dataController$loadI.call(dataController);
        },
        setColumnWidths: function(widths) {
          var scrollable = this.getScrollable();
          var $content;
          this.callBase.apply(this, arguments);
          if ("virtual" === this.option("scrolling.mode")) {
            $content = scrollable ? renderer_default(scrollable.content()) : this.element();
            this.callBase(widths, $content.children("." + this.addWidgetPrefix(CONTENT_CLASS3)).children(":not(." + this.addWidgetPrefix(TABLE_CONTENT_CLASS) + ")"));
          }
        },
        dispose: function() {
          clearTimeout(this._scrollTimeoutID);
          this.callBase();
        }
      };
    }();
    virtualScrollingModule = {
      defaultOptions: function() {
        return {
          scrolling: {
            timeout: 300,
            updateTimeout: 300,
            minTimeout: 0,
            renderingThreshold: 100,
            removeInvisiblePages: true,
            rowPageSize: 5,
            mode: "standard",
            preloadEnabled: false,
            rowRenderingMode: "standard",
            loadTwoPagesOnStart: false,
            newMode: false,
            minGap: 1
          }
        };
      },
      extenders: {
        dataSourceAdapter: VirtualScrollingDataSourceAdapterExtender,
        controllers: {
          data: function() {
            var members = {
              _refreshDataSource: function() {
                var baseResult = this.callBase.apply(this, arguments) || new Deferred().resolve().promise();
                baseResult.done(this.initVirtualRows.bind(this));
                return baseResult;
              },
              getRowPageSize: function() {
                var rowPageSize = this.option("scrolling.rowPageSize");
                var pageSize = this.pageSize();
                return pageSize && pageSize < rowPageSize ? pageSize : rowPageSize;
              },
              reload: function() {
                var rowsScrollController = this._rowsScrollController || this._dataSource;
                var itemIndex = rowsScrollController && rowsScrollController.getItemIndexByPosition();
                var result2 = this.callBase.apply(this, arguments);
                return result2 && result2.done(() => {
                  if (isVirtualMode(this) || isVirtualRowRendering(this)) {
                    var rowIndexOffset = this.getRowIndexOffset();
                    var rowIndex = Math.floor(itemIndex) - rowIndexOffset;
                    var component = this.component;
                    var scrollable = component.getScrollable && component.getScrollable();
                    var isSortingOperation = this.dataSource().operationTypes().sorting;
                    if (scrollable && !isSortingOperation && rowIndex >= 0) {
                      var rowElement = component.getRowElement(rowIndex);
                      var $rowElement = rowElement && rowElement[0] && renderer_default(rowElement[0]);
                      var top = $rowElement && $rowElement.position().top;
                      var isChromeLatest = browser_default.chrome && browser_default.version >= 91;
                      var allowedTopOffset = browser_default.mozilla || browser_default.msie || isChromeLatest ? 1 : 0;
                      if (top > allowedTopOffset) {
                        top = Math.round(top + $rowElement.outerHeight() * (itemIndex % 1));
                        scrollable.scrollTo({
                          y: top
                        });
                      }
                    }
                  }
                });
              },
              initVirtualRows: function() {
                var virtualRowsRendering = isVirtualRowRendering(this);
                if ("virtual" !== this.option("scrolling.mode") && true !== virtualRowsRendering || false === virtualRowsRendering || !this.option("scrolling.rowPageSize")) {
                  this._visibleItems = null;
                  this._rowsScrollController = null;
                  return;
                }
                var pageIndex = !isVirtualMode(this) && this.pageIndex() >= this.pageCount() ? this.pageCount() - 1 : this.pageIndex();
                this._rowPageIndex = Math.ceil(pageIndex * this.pageSize() / this.getRowPageSize());
                this._uncountableItemCount = 0;
                this._visibleItems = this.option(NEW_SCROLLING_MODE5) ? null : [];
                this._rowsScrollController = new VirtualScrollController(this.component, this._getRowsScrollDataOptions(), true);
                this._viewportChanging = false;
                this._rowsScrollController.positionChanged.add(() => {
                  var _this$_dataSource;
                  if (this.option(NEW_SCROLLING_MODE5)) {
                    this._viewportChanging = true;
                    this.loadViewport();
                    this._viewportChanging = false;
                    return;
                  }
                  null === (_this$_dataSource = this._dataSource) || void 0 === _this$_dataSource ? void 0 : _this$_dataSource.setViewportItemIndex(this._rowsScrollController.getViewportItemIndex());
                });
                if (this.isLoaded() && !this.option(NEW_SCROLLING_MODE5)) {
                  this._rowsScrollController.load();
                }
              },
              isViewportChanging: function() {
                return this._viewportChanging;
              },
              _getRowsScrollDataOptions: function() {
                var that = this;
                var isItemCountable = function(item) {
                  return isItemCountableByDataSource(item, that._dataSource);
                };
                return {
                  pageSize: function() {
                    return that.getRowPageSize();
                  },
                  totalItemsCount: function() {
                    if (that.option(NEW_SCROLLING_MODE5)) {
                      return that.totalItemsCount() + that._uncountableItemCount;
                    }
                    return isVirtualMode(that) ? that.totalItemsCount() : that._items.filter(isItemCountable).length;
                  },
                  hasKnownLastPage: function() {
                    return true;
                  },
                  pageIndex: function(index2) {
                    if (void 0 !== index2) {
                      that._rowPageIndex = index2;
                    }
                    return that._rowPageIndex;
                  },
                  isLoading: function() {
                    return that.isLoading();
                  },
                  pageCount: function() {
                    var pageCount = Math.ceil(this.totalItemsCount() / this.pageSize());
                    return pageCount ? pageCount : 1;
                  },
                  load: function() {
                    if (that._rowsScrollController.pageIndex() >= this.pageCount()) {
                      that._rowPageIndex = this.pageCount() - 1;
                      that._rowsScrollController.pageIndex(that._rowPageIndex);
                    }
                    if (!this.items().length && this.totalItemsCount()) {
                      return;
                    }
                    that._rowsScrollController.handleDataChanged((change) => {
                      change = change || {};
                      change.changeType = change.changeType || "refresh";
                      change.items = change.items || that._visibleItems;
                      that._visibleItems.forEach((item, index2) => {
                        item.rowIndex = index2;
                      });
                      that._fireChanged(change);
                    });
                  },
                  updateLoading: function() {
                  },
                  itemsCount: function() {
                    return this.items().filter(isItemCountable).length;
                  },
                  correctCount: function(items, count, fromEnd) {
                    return _correctCount(items, count, fromEnd, (item, isNextAfterLast, fromEnd2) => {
                      if (item.isNewRow) {
                        return isNextAfterLast && !fromEnd2;
                      }
                      if (isNextAfterLast && fromEnd2) {
                        return !item.isNewRow;
                      }
                      return isItemCountable(item);
                    });
                  },
                  items: function(countableOnly) {
                    var dataSource = that.dataSource();
                    var virtualItemsCount = dataSource && dataSource.virtualItemsCount();
                    var begin = virtualItemsCount ? virtualItemsCount.begin : 0;
                    var rowPageSize = that.getRowPageSize();
                    var skip = that._rowPageIndex * rowPageSize - begin;
                    var take = rowPageSize;
                    var result2 = that._items;
                    if (skip < 0) {
                      return [];
                    }
                    if (skip) {
                      skip = this.correctCount(result2, skip);
                      result2 = result2.slice(skip);
                    }
                    if (take) {
                      take = this.correctCount(result2, take);
                      result2 = result2.slice(0, take);
                    }
                    return countableOnly ? result2.filter(isItemCountable) : result2;
                  },
                  viewportItems: function(items) {
                    if (items && !that.option(NEW_SCROLLING_MODE5)) {
                      that._visibleItems = items;
                    }
                    return that._visibleItems;
                  },
                  onChanged: function() {
                  },
                  changingDuration: function(e) {
                    var dataSource = that.dataSource();
                    if (dataSource.isLoading() && !that.option(NEW_SCROLLING_MODE5)) {
                      return LOAD_TIMEOUT;
                    }
                    return (null === dataSource || void 0 === dataSource ? void 0 : dataSource._renderTime) || 0;
                  }
                };
              },
              _updateItemsCore: function(change) {
                var delta = this.getRowIndexDelta();
                this.callBase.apply(this, arguments);
                if (this.option(NEW_SCROLLING_MODE5) && isVirtualRowRendering(this)) {
                  return;
                }
                var rowsScrollController = this._rowsScrollController;
                if (rowsScrollController) {
                  var visibleItems = this._visibleItems;
                  var isRefresh = "refresh" === change.changeType || change.isLiveUpdate;
                  if ("append" === change.changeType && change.items && !change.items.length) {
                    return;
                  }
                  if (isRefresh || "append" === change.changeType || "prepend" === change.changeType) {
                    change.cancel = true;
                    isRefresh && rowsScrollController.reset(true);
                    rowsScrollController.load();
                  } else {
                    if ("update" === change.changeType) {
                      change.rowIndices.forEach((rowIndex, index2) => {
                        var changeType = change.changeTypes[index2];
                        var newItem = change.items[index2];
                        if ("update" === changeType) {
                          visibleItems[rowIndex] = newItem;
                        } else if ("insert" === changeType) {
                          visibleItems.splice(rowIndex, 0, newItem);
                        } else if ("remove" === changeType) {
                          visibleItems.splice(rowIndex, 1);
                        }
                      });
                    } else {
                      visibleItems.forEach((item, index2) => {
                        visibleItems[index2] = this._items[index2 + delta] || visibleItems[index2];
                      });
                      change.items = visibleItems;
                    }
                    updateItemIndices(visibleItems);
                  }
                }
              },
              _updateLoadViewportParams: function() {
                this._loadViewportParams = this._rowsScrollController.getViewportParams();
              },
              _afterProcessItems: function(items, change) {
                this._uncountableItemCount = 0;
                if (isDefined(this._loadViewportParams)) {
                  this._uncountableItemCount = items.filter((item) => !isItemCountableByDataSource(item, this._dataSource)).length;
                  this._updateLoadViewportParams();
                  var {
                    skipForCurrentPage
                  } = this.getLoadPageParams();
                  change.repaintChangesOnly = "refresh" === change.changeType;
                  return items.slice(skipForCurrentPage, skipForCurrentPage + this._loadViewportParams.take);
                }
                return this.callBase.apply(this, arguments);
              },
              _applyChange: function(change) {
                var that = this;
                var items = change.items;
                var changeType = change.changeType;
                var removeCount = change.removeCount;
                if (removeCount) {
                  var fromEnd = "prepend" === changeType;
                  removeCount = _correctCount(that._items, removeCount, fromEnd, function(item, isNextAfterLast) {
                    return "data" === item.rowType && !item.isNewRow || "group" === item.rowType && (that._dataSource.isGroupItemCountable(item.data) || isNextAfterLast);
                  });
                  change.removeCount = removeCount;
                }
                switch (changeType) {
                  case "prepend":
                    that._items.unshift.apply(that._items, items);
                    if (removeCount) {
                      that._items.splice(-removeCount);
                    }
                    break;
                  case "append":
                    that._items.push.apply(that._items, items);
                    if (removeCount) {
                      that._items.splice(0, removeCount);
                    }
                    break;
                  default:
                    that.callBase(change);
                }
              },
              items: function(allItems) {
                return allItems ? this._items : this._visibleItems || this._items;
              },
              getRowIndexDelta: function() {
                var visibleItems = this._visibleItems;
                var delta = 0;
                if (visibleItems && visibleItems[0]) {
                  delta = this._items.indexOf(visibleItems[0]);
                }
                return delta < 0 ? 0 : delta;
              },
              getRowIndexOffset: function(byLoadedRows) {
                var offset2 = 0;
                var dataSource = this.dataSource();
                var rowsScrollController = this._rowsScrollController;
                var virtualMode = isVirtualMode(this);
                var appendMode = isAppendMode(this);
                var newMode = this.option(NEW_SCROLLING_MODE5);
                if (rowsScrollController && !byLoadedRows) {
                  if (this.option(NEW_SCROLLING_MODE5) && isDefined(this._loadViewportParams)) {
                    var {
                      skipForCurrentPage,
                      pageIndex
                    } = this.getLoadPageParams();
                    offset2 = pageIndex * this.pageSize() + skipForCurrentPage;
                  } else {
                    offset2 = rowsScrollController.beginPageIndex() * rowsScrollController.pageSize();
                  }
                } else if ((virtualMode || appendMode && newMode) && dataSource) {
                  offset2 = dataSource.beginPageIndex() * dataSource.pageSize();
                }
                return offset2;
              },
              viewportSize: function() {
                var rowsScrollController = this._rowsScrollController;
                var dataSource = this._dataSource;
                var result2 = null === rowsScrollController || void 0 === rowsScrollController ? void 0 : rowsScrollController.viewportSize.apply(rowsScrollController, arguments);
                if (this.option(NEW_SCROLLING_MODE5)) {
                  return result2;
                }
                return null === dataSource || void 0 === dataSource ? void 0 : dataSource.viewportSize.apply(dataSource, arguments);
              },
              viewportItemSize: function() {
                var rowsScrollController = this._rowsScrollController;
                var dataSource = this._dataSource;
                var result2 = null === rowsScrollController || void 0 === rowsScrollController ? void 0 : rowsScrollController.viewportItemSize.apply(rowsScrollController, arguments);
                if (this.option(NEW_SCROLLING_MODE5)) {
                  return result2;
                }
                return null === dataSource || void 0 === dataSource ? void 0 : dataSource.viewportItemSize.apply(dataSource, arguments);
              },
              setViewportPosition: function() {
                var rowsScrollController = this._rowsScrollController;
                var dataSource = this._dataSource;
                if (rowsScrollController) {
                  rowsScrollController.setViewportPosition.apply(rowsScrollController, arguments);
                } else {
                  null === dataSource || void 0 === dataSource ? void 0 : dataSource.setViewportPosition.apply(dataSource, arguments);
                }
              },
              setContentItemSizes: function(sizes) {
                var rowsScrollController = this._rowsScrollController;
                var dataSource = this._dataSource;
                var result2 = null === rowsScrollController || void 0 === rowsScrollController ? void 0 : rowsScrollController.setContentItemSizes(sizes);
                if (this.option(NEW_SCROLLING_MODE5)) {
                  return result2;
                }
                return null === dataSource || void 0 === dataSource ? void 0 : dataSource.setContentItemSizes(sizes);
              },
              getLoadPageParams: function() {
                var viewportParams = this._loadViewportParams;
                var pageIndex = Math.floor(viewportParams.skip / this.pageSize());
                var skipForCurrentPage = viewportParams.skip - pageIndex * this.pageSize();
                var loadPageCount = Math.ceil((skipForCurrentPage + viewportParams.take) / this.pageSize());
                return {
                  pageIndex,
                  loadPageCount,
                  skipForCurrentPage
                };
              },
              loadViewport: function() {
                if (isVirtualMode(this) || isAppendMode(this)) {
                  this._updateLoadViewportParams();
                  var {
                    pageIndex,
                    loadPageCount
                  } = this.getLoadPageParams();
                  var dataSourceAdapter = this._dataSource;
                  if (pageIndex !== dataSourceAdapter.pageIndex() || loadPageCount !== dataSourceAdapter.loadPageCount()) {
                    dataSourceAdapter.pageIndex(pageIndex);
                    dataSourceAdapter.loadPageCount(loadPageCount);
                    this.load();
                  } else if (!this._isLoading) {
                    this.updateItems();
                  }
                }
              },
              loadIfNeed: function() {
                if (this.option(NEW_SCROLLING_MODE5)) {
                  return;
                }
                var rowsScrollController = this._rowsScrollController;
                rowsScrollController && rowsScrollController.loadIfNeed();
                var dataSource = this._dataSource;
                return dataSource && dataSource.loadIfNeed();
              },
              getItemSize: function() {
                var rowsScrollController = this._rowsScrollController;
                if (rowsScrollController) {
                  return rowsScrollController.getItemSize.apply(rowsScrollController, arguments);
                }
                var dataSource = this._dataSource;
                return dataSource && dataSource.getItemSize.apply(dataSource, arguments);
              },
              getItemSizes: function() {
                var rowsScrollController = this._rowsScrollController;
                if (rowsScrollController) {
                  return rowsScrollController.getItemSizes.apply(rowsScrollController, arguments);
                }
                var dataSource = this._dataSource;
                return dataSource && dataSource.getItemSizes.apply(dataSource, arguments);
              },
              getContentOffset: function() {
                var rowsScrollController = this._rowsScrollController;
                if (rowsScrollController) {
                  return rowsScrollController.getContentOffset.apply(rowsScrollController, arguments);
                }
                var dataSource = this._dataSource;
                return dataSource && dataSource.getContentOffset.apply(dataSource, arguments);
              },
              refresh: function(options2) {
                var dataSource = this._dataSource;
                if (dataSource && options2 && options2.load && isAppendMode(this)) {
                  dataSource.resetCurrentTotalCount();
                }
                return this.callBase.apply(this, arguments);
              },
              dispose: function() {
                var rowsScrollController = this._rowsScrollController;
                rowsScrollController && rowsScrollController.dispose();
                this.callBase.apply(this, arguments);
              },
              topItemIndex: function() {
                var _this$_loadViewportPa;
                return null === (_this$_loadViewportPa = this._loadViewportParams) || void 0 === _this$_loadViewportPa ? void 0 : _this$_loadViewportPa.skip;
              },
              bottomItemIndex: function() {
                var viewportParams = this._loadViewportParams;
                return viewportParams && viewportParams.skip + viewportParams.take;
              },
              virtualItemsCount: function() {
                var rowsScrollController = this._rowsScrollController;
                if (rowsScrollController) {
                  return rowsScrollController.virtualItemsCount.apply(rowsScrollController, arguments);
                }
                var dataSource = this._dataSource;
                return null === dataSource || void 0 === dataSource ? void 0 : dataSource.virtualItemsCount.apply(dataSource, arguments);
              }
            };
            ui_grid_core_utils_default.proxyMethod(members, "getVirtualContentSize");
            ui_grid_core_utils_default.proxyMethod(members, "setViewportItemIndex");
            return members;
          }(),
          resizing: {
            resize: function() {
              var that = this;
              var callBase = that.callBase;
              var result2;
              if (isVirtualMode(that) || isVirtualRowRendering(that)) {
                clearTimeout(that._resizeTimeout);
                var diff = /* @__PURE__ */ new Date() - that._lastTime;
                var updateTimeout = that.option("scrolling.updateTimeout");
                if (that._lastTime && diff < updateTimeout) {
                  result2 = new Deferred();
                  that._resizeTimeout = setTimeout(function() {
                    callBase.apply(that).done(result2.resolve).fail(result2.reject);
                    that._lastTime = /* @__PURE__ */ new Date();
                  }, updateTimeout);
                  that._lastTime = /* @__PURE__ */ new Date();
                } else {
                  result2 = callBase.apply(that);
                  if (that._dataController.isLoaded()) {
                    that._lastTime = /* @__PURE__ */ new Date();
                  }
                }
              } else {
                result2 = callBase.apply(that);
              }
              return result2;
            },
            dispose: function() {
              this.callBase.apply(this, arguments);
              clearTimeout(this._resizeTimeout);
            }
          }
        },
        views: {
          rowsView: VirtualScrollingRowsViewExtender
        }
      }
    };
  }
});

// node_modules/devextreme/esm/ui/overlay/utils.js
var WINDOW_HEIGHT_PERCENT, getElementMaxHeightByWindow;
var init_utils8 = __esm({
  "node_modules/devextreme/esm/ui/overlay/utils.js"() {
    init_renderer();
    init_window();
    init_type();
    WINDOW_HEIGHT_PERCENT = 0.9;
    getElementMaxHeightByWindow = ($element, startLocation) => {
      var $window = renderer_default(getWindow());
      var {
        top: elementOffset
      } = $element.offset();
      var actualOffset;
      if (isNumeric(startLocation)) {
        if (startLocation < elementOffset) {
          return elementOffset - startLocation;
        } else {
          actualOffset = $window.innerHeight() - startLocation + $window.scrollTop();
        }
      } else {
        var offsetTop = elementOffset - $window.scrollTop();
        var offsetBottom = $window.innerHeight() - offsetTop - $element.outerHeight();
        actualOffset = Math.max(offsetTop, offsetBottom);
      }
      return actualOffset * WINDOW_HEIGHT_PERCENT;
    };
  }
});

// node_modules/devextreme/esm/ui/menu/ui.submenu.js
var DX_CONTEXT_MENU_CONTENT_DELIMITER_CLASS, DX_SUBMENU_CLASS2, Submenu, ui_submenu_default;
var init_ui_submenu = __esm({
  "node_modules/devextreme/esm/ui/menu/ui.submenu.js"() {
    init_renderer();
    init_common();
    init_element();
    init_position2();
    init_extend();
    init_context_menu();
    DX_CONTEXT_MENU_CONTENT_DELIMITER_CLASS = "dx-context-menu-content-delimiter";
    DX_SUBMENU_CLASS2 = "dx-submenu";
    Submenu = class extends context_menu_default {
      _getDefaultOptions() {
        return extend2(super._getDefaultOptions(), {
          orientation: "horizontal",
          tabIndex: null,
          onHoverStart: noop2
        });
      }
      _initDataAdapter() {
        this._dataAdapter = this.option("_dataAdapter");
        if (!this._dataAdapter) {
          super._initDataAdapter();
        }
      }
      _renderContentImpl() {
        this._renderContextMenuOverlay();
        super._renderContentImpl();
        var node = this._dataAdapter.getNodeByKey(this.option("_parentKey"));
        node && this._renderItems(this._getChildNodes(node));
        this._renderDelimiter();
      }
      _renderDelimiter() {
        this.$contentDelimiter = renderer_default("<div>").appendTo(this._itemContainer()).addClass(DX_CONTEXT_MENU_CONTENT_DELIMITER_CLASS);
      }
      _getOverlayOptions() {
        return extend2(super._getOverlayOptions(), {
          onPositioned: this._overlayPositionedActionHandler.bind(this)
        });
      }
      _overlayPositionedActionHandler(arg) {
        this._showDelimiter(arg);
      }
      _hoverEndHandler(e) {
        super._hoverEndHandler(e);
        this._toggleFocusClass(false, e.currentTarget);
      }
      _isMenuHorizontal() {
        return "horizontal" === this.option("orientation");
      }
      _hoverStartHandler(e) {
        var hoverStartAction = this.option("onHoverStart");
        hoverStartAction(e);
        super._hoverStartHandler(e);
        this._toggleFocusClass(true, e.currentTarget);
      }
      _drawSubmenu($rootItem) {
        this._actions.onShowing({
          rootItem: getPublicElement($rootItem),
          submenu: this
        });
        super._drawSubmenu($rootItem);
        this._actions.onShown({
          rootItem: getPublicElement($rootItem),
          submenu: this
        });
      }
      _hideSubmenu($rootItem) {
        this._actions.onHiding({
          cancel: true,
          rootItem: getPublicElement($rootItem),
          submenu: this
        });
        super._hideSubmenu($rootItem);
        this._actions.onHidden({
          rootItem: getPublicElement($rootItem),
          submenu: this
        });
      }
      _showDelimiter(arg) {
        if (!this.$contentDelimiter) {
          return;
        }
        var $submenu = this._itemContainer().children(".".concat(DX_SUBMENU_CLASS2)).eq(0);
        var $rootItem = this.option("position").of;
        var position3 = {
          of: $submenu
        };
        var containerOffset = arg.position;
        var vLocation = containerOffset.v.location;
        var hLocation = containerOffset.h.location;
        var rootOffset = $rootItem.offset();
        var offsetLeft = Math.round(rootOffset.left);
        var offsetTop = Math.round(rootOffset.top);
        var rootWidth = $rootItem.width();
        var rootHeight = $rootItem.height();
        var submenuWidth = $submenu.width();
        var submenuHeight = $submenu.height();
        this.$contentDelimiter.css("display", "block");
        this.$contentDelimiter.width(this._isMenuHorizontal() ? rootWidth < submenuWidth ? rootWidth - 2 : submenuWidth : 2);
        this.$contentDelimiter.height(this._isMenuHorizontal() ? 2 : rootHeight < submenuHeight ? rootHeight - 2 : submenuHeight);
        if (this._isMenuHorizontal()) {
          if (vLocation > offsetTop) {
            if (Math.round(hLocation) === offsetLeft) {
              position3.offset = "1 -1";
              position3.at = position3.my = "left top";
            } else {
              position3.offset = "-1 -1";
              position3.at = position3.my = "right top";
            }
          } else {
            this.$contentDelimiter.height(5);
            if (Math.round(hLocation) === offsetLeft) {
              position3.offset = "1 4";
              position3.at = position3.my = "left bottom";
            } else {
              position3.offset = "-1 2";
              position3.at = position3.my = "right bottom";
            }
          }
        } else if (hLocation > offsetLeft) {
          if (Math.round(vLocation) === offsetTop) {
            position3.offset = "-1 1";
            position3.at = position3.my = "left top";
          } else {
            position3.offset = "-1 -1";
            position3.at = position3.my = "left bottom";
          }
        } else if (Math.round(vLocation) === offsetTop) {
          position3.offset = "1 1";
          position3.at = position3.my = "right top";
        } else {
          position3.offset = "1 -1";
          position3.at = position3.my = "right bottom";
        }
        position_default.setup(this.$contentDelimiter, position3);
      }
      _getContextMenuPosition() {
        return this.option("position");
      }
      isOverlayVisible() {
        return this._overlay.option("visible");
      }
      getOverlayContent() {
        return this._overlay.$content();
      }
    };
    ui_submenu_default = Submenu;
  }
});

// node_modules/devextreme/esm/ui/menu/ui.menu.js
var DX_MENU_CLASS3, DX_MENU_VERTICAL_CLASS, DX_MENU_HORIZONTAL_CLASS, DX_MENU_ITEM_CLASS2, DX_MENU_ITEMS_CONTAINER_CLASS3, DX_MENU_ITEM_EXPANDED_CLASS3, DX_CONTEXT_MENU_CLASS2, DX_CONTEXT_MENU_CONTAINER_BORDER_CLASS, DX_CONTEXT_MENU_CONTENT_DELIMITER_CLASS2, DX_SUBMENU_CLASS3, DX_STATE_DISABLED_CLASS2, DX_STATE_HOVER_CLASS2, DX_STATE_ACTIVE_CLASS, DX_ADAPTIVE_MODE_CLASS, DX_ADAPTIVE_HAMBURGER_BUTTON_CLASS, DX_ADAPTIVE_MODE_OVERLAY_WRAPPER_CLASS, FOCUS_UP3, FOCUS_DOWN3, FOCUS_LEFT3, FOCUS_RIGHT3, SHOW_SUBMENU_OPERATION, NEXTITEM_OPERATION, PREVITEM_OPERATION, DEFAULT_DELAY2, ACTIONS3, Menu, ui_menu_default;
var init_ui_menu = __esm({
  "node_modules/devextreme/esm/ui/menu/ui.menu.js"() {
    init_renderer();
    init_events_engine();
    init_component_registrator();
    init_common();
    init_element();
    init_iterator();
    init_type();
    init_extend();
    init_utils8();
    init_utils2();
    init_pointer();
    init_hover();
    init_ui_menu_base();
    init_ui_overlay();
    init_ui_submenu();
    init_button();
    init_tree_view();
    DX_MENU_CLASS3 = "dx-menu";
    DX_MENU_VERTICAL_CLASS = DX_MENU_CLASS3 + "-vertical";
    DX_MENU_HORIZONTAL_CLASS = DX_MENU_CLASS3 + "-horizontal";
    DX_MENU_ITEM_CLASS2 = DX_MENU_CLASS3 + "-item";
    DX_MENU_ITEMS_CONTAINER_CLASS3 = DX_MENU_CLASS3 + "-items-container";
    DX_MENU_ITEM_EXPANDED_CLASS3 = DX_MENU_ITEM_CLASS2 + "-expanded";
    DX_CONTEXT_MENU_CLASS2 = "dx-context-menu";
    DX_CONTEXT_MENU_CONTAINER_BORDER_CLASS = DX_CONTEXT_MENU_CLASS2 + "-container-border";
    DX_CONTEXT_MENU_CONTENT_DELIMITER_CLASS2 = "dx-context-menu-content-delimiter";
    DX_SUBMENU_CLASS3 = "dx-submenu";
    DX_STATE_DISABLED_CLASS2 = "dx-state-disabled";
    DX_STATE_HOVER_CLASS2 = "dx-state-hover";
    DX_STATE_ACTIVE_CLASS = "dx-state-active";
    DX_ADAPTIVE_MODE_CLASS = DX_MENU_CLASS3 + "-adaptive-mode";
    DX_ADAPTIVE_HAMBURGER_BUTTON_CLASS = DX_MENU_CLASS3 + "-hamburger-button";
    DX_ADAPTIVE_MODE_OVERLAY_WRAPPER_CLASS = DX_ADAPTIVE_MODE_CLASS + "-overlay-wrapper";
    FOCUS_UP3 = "up";
    FOCUS_DOWN3 = "down";
    FOCUS_LEFT3 = "left";
    FOCUS_RIGHT3 = "right";
    SHOW_SUBMENU_OPERATION = "showSubmenu";
    NEXTITEM_OPERATION = "nextItem";
    PREVITEM_OPERATION = "prevItem";
    DEFAULT_DELAY2 = {
      show: 50,
      hide: 300
    };
    ACTIONS3 = ["onSubmenuShowing", "onSubmenuShown", "onSubmenuHiding", "onSubmenuHidden", "onItemContextMenu", "onItemClick", "onSelectionChanged", "onItemRendered"];
    Menu = class extends ui_menu_base_default {
      _getDefaultOptions() {
        return extend2(super._getDefaultOptions(), {
          orientation: "horizontal",
          submenuDirection: "auto",
          showFirstSubmenuMode: {
            name: "onClick",
            delay: {
              show: 50,
              hide: 300
            }
          },
          hideSubmenuOnMouseLeave: false,
          onSubmenuShowing: null,
          onSubmenuShown: null,
          onSubmenuHiding: null,
          onSubmenuHidden: null,
          adaptivityEnabled: false
        });
      }
      _setOptionsByReference() {
        super._setOptionsByReference();
        extend2(this._optionsByReference, {
          animation: true,
          selectedItem: true
        });
      }
      _itemElements() {
        var rootMenuElements = super._itemElements();
        var submenuElements = this._submenuItemElements();
        return rootMenuElements.add(submenuElements);
      }
      _submenuItemElements() {
        var elements = [];
        var itemSelector = ".".concat(DX_MENU_ITEM_CLASS2);
        var currentSubmenu = this._submenus.length && this._submenus[0];
        if (currentSubmenu && currentSubmenu.itemsContainer()) {
          elements = currentSubmenu.itemsContainer().find(itemSelector);
        }
        return elements;
      }
      _focusTarget() {
        return this.$element();
      }
      _isMenuHorizontal() {
        return "horizontal" === this.option("orientation");
      }
      _moveFocus(location) {
        var $items = this._getAvailableItems();
        var isMenuHorizontal = this._isMenuHorizontal();
        var $activeItem = this._getActiveItem(true);
        var argument;
        var operation;
        var navigationAction;
        var $newTarget;
        switch (location) {
          case FOCUS_UP3:
            operation = isMenuHorizontal ? SHOW_SUBMENU_OPERATION : this._getItemsNavigationOperation(PREVITEM_OPERATION);
            argument = isMenuHorizontal ? $activeItem : $items;
            navigationAction = this._getKeyboardNavigationAction(operation, argument);
            $newTarget = navigationAction();
            break;
          case FOCUS_DOWN3:
            operation = isMenuHorizontal ? SHOW_SUBMENU_OPERATION : this._getItemsNavigationOperation(NEXTITEM_OPERATION);
            argument = isMenuHorizontal ? $activeItem : $items;
            navigationAction = this._getKeyboardNavigationAction(operation, argument);
            $newTarget = navigationAction();
            break;
          case FOCUS_RIGHT3:
            operation = isMenuHorizontal ? this._getItemsNavigationOperation(NEXTITEM_OPERATION) : SHOW_SUBMENU_OPERATION;
            argument = isMenuHorizontal ? $items : $activeItem;
            navigationAction = this._getKeyboardNavigationAction(operation, argument);
            $newTarget = navigationAction();
            break;
          case FOCUS_LEFT3:
            operation = isMenuHorizontal ? this._getItemsNavigationOperation(PREVITEM_OPERATION) : SHOW_SUBMENU_OPERATION;
            argument = isMenuHorizontal ? $items : $activeItem;
            navigationAction = this._getKeyboardNavigationAction(operation, argument);
            $newTarget = navigationAction();
            break;
          default:
            return super._moveFocus(location);
        }
        if ($newTarget && 0 !== $newTarget.length) {
          this.option("focusedElement", getPublicElement($newTarget));
        }
      }
      _getItemsNavigationOperation(operation) {
        var navOperation = operation;
        if (this.option("rtlEnabled")) {
          navOperation = operation === PREVITEM_OPERATION ? NEXTITEM_OPERATION : PREVITEM_OPERATION;
        }
        return navOperation;
      }
      _getKeyboardNavigationAction(operation, argument) {
        var action = noop2;
        switch (operation) {
          case SHOW_SUBMENU_OPERATION:
            if (!argument.hasClass(DX_STATE_DISABLED_CLASS2)) {
              action = this._showSubmenu.bind(this, argument);
            }
            break;
          case NEXTITEM_OPERATION:
            action = this._nextItem.bind(this, argument);
            break;
          case PREVITEM_OPERATION:
            action = this._prevItem.bind(this, argument);
        }
        return action;
      }
      _clean() {
        super._clean();
        this.option("templatesRenderAsynchronously") && clearTimeout(this._resizeEventTimer);
      }
      _visibilityChanged(visible2) {
        if (visible2) {
          if (!this._menuItemsWidth) {
            this._updateItemsWidthCache();
          }
          this._dimensionChanged();
        }
      }
      _isAdaptivityEnabled() {
        return this.option("adaptivityEnabled") && "horizontal" === this.option("orientation");
      }
      _updateItemsWidthCache() {
        var $menuItems = this.$element().find("ul").first().children("li").children(".".concat(DX_MENU_ITEM_CLASS2));
        this._menuItemsWidth = this._getSummaryItemsWidth($menuItems, true);
      }
      _dimensionChanged() {
        if (!this._isAdaptivityEnabled()) {
          return;
        }
        var containerWidth = this.$element().outerWidth();
        this._toggleAdaptiveMode(this._menuItemsWidth > containerWidth);
      }
      _init() {
        super._init();
        this._submenus = [];
      }
      _initActions() {
        this._actions = {};
        each(ACTIONS3, (index2, action) => {
          this._actions[action] = this._createActionByOption(action);
        });
      }
      _initMarkup() {
        this._visibleSubmenu = null;
        this.$element().addClass(DX_MENU_CLASS3);
        super._initMarkup();
        this.setAria("role", "menubar");
      }
      _render() {
        super._render();
        this._initAdaptivity();
      }
      _renderHamburgerButton() {
        this._hamburger = new button_default(renderer_default("<div>").addClass(DX_ADAPTIVE_HAMBURGER_BUTTON_CLASS), {
          icon: "menu",
          activeStateEnabled: false,
          onClick: this._toggleTreeView.bind(this)
        });
        return this._hamburger.$element();
      }
      _toggleTreeView(state) {
        if (isPlainObject(state)) {
          state = !this._overlay.option("visible");
        }
        this._overlay.option("visible", state);
        this._toggleHamburgerActiveState(state);
      }
      _toggleHamburgerActiveState(state) {
        this._hamburger && this._hamburger.$element().toggleClass(DX_STATE_ACTIVE_CLASS, state);
      }
      _toggleAdaptiveMode(state) {
        var $menuItemsContainer = this.$element().find(".".concat(DX_MENU_HORIZONTAL_CLASS));
        var $adaptiveElements = this.$element().find(".".concat(DX_ADAPTIVE_MODE_CLASS));
        if (state) {
          this._hideVisibleSubmenu();
        } else {
          this._treeView && this._treeView.collapseAll();
          this._overlay && this._toggleTreeView(state);
        }
        $menuItemsContainer.toggle(!state);
        $adaptiveElements.toggle(state);
      }
      _removeAdaptivity() {
        if (!this._$adaptiveContainer) {
          return;
        }
        this._toggleAdaptiveMode(false);
        this._$adaptiveContainer.remove();
        this._$adaptiveContainer = null;
        this._treeView = null;
        this._hamburger = null;
        this._overlay = null;
      }
      _treeviewItemClickHandler(e) {
        this._actions.onItemClick(e);
        if (!e.node.children.length) {
          this._toggleTreeView(false);
        }
      }
      _getAdaptiveOverlayOptions() {
        var rtl = this.option("rtlEnabled");
        var position3 = rtl ? "right" : "left";
        return {
          maxHeight: () => getElementMaxHeightByWindow(this.$element()),
          deferRendering: false,
          shading: false,
          animation: false,
          closeOnTargetScroll: true,
          onHidden: () => {
            this._toggleHamburgerActiveState(false);
          },
          height: "auto",
          closeOnOutsideClick: (e) => !renderer_default(e.target).closest(".".concat(DX_ADAPTIVE_HAMBURGER_BUTTON_CLASS)).length,
          position: {
            collision: "flipfit",
            at: "bottom " + position3,
            my: "top " + position3,
            of: this._hamburger.$element()
          }
        };
      }
      _getTreeViewOptions() {
        var menuOptions = {};
        each(["rtlEnabled", "width", "accessKey", "activeStateEnabled", "animation", "dataSource", "disabled", "displayExpr", "displayExpr", "focusStateEnabled", "hint", "hoverStateEnabled", "itemsExpr", "items", "itemTemplate", "selectedExpr", "selectionMode", "tabIndex", "visible"], (_2, option) => {
          menuOptions[option] = this.option(option);
        });
        each(["onItemContextMenu", "onSelectionChanged"], (_2, actionName) => {
          menuOptions[actionName] = (e) => {
            this._actions[actionName](e);
          };
        });
        return extend2(menuOptions, {
          dataSource: this.getDataSource(),
          animationEnabled: !!this.option("animation"),
          onItemClick: this._treeviewItemClickHandler.bind(this),
          onItemExpanded: (e) => {
            this._overlay.repaint();
            this._actions.onSubmenuShown(e);
          },
          onItemCollapsed: (e) => {
            this._overlay.repaint();
            this._actions.onSubmenuHidden(e);
          },
          selectNodesRecursive: false,
          selectByClick: this.option("selectByClick"),
          expandEvent: "click"
        });
      }
      _initAdaptivity() {
        if (!this._isAdaptivityEnabled()) {
          return;
        }
        this._$adaptiveContainer = renderer_default("<div>").addClass(DX_ADAPTIVE_MODE_CLASS);
        var $hamburger = this._renderHamburgerButton();
        this._treeView = this._createComponent(renderer_default("<div>"), tree_view_default, this._getTreeViewOptions());
        this._overlay = this._createComponent(renderer_default("<div>"), ui_overlay_default, this._getAdaptiveOverlayOptions());
        this._overlay.$content().append(this._treeView.$element()).addClass(DX_ADAPTIVE_MODE_CLASS).addClass(this.option("cssClass"));
        this._overlay.$wrapper().addClass(DX_ADAPTIVE_MODE_OVERLAY_WRAPPER_CLASS);
        this._$adaptiveContainer.append($hamburger);
        this._$adaptiveContainer.append(this._overlay.$element());
        this.$element().append(this._$adaptiveContainer);
        this._updateItemsWidthCache();
        this._dimensionChanged();
      }
      _getDelay(delayType) {
        var delay = this.option("showFirstSubmenuMode").delay;
        if (!isDefined(delay)) {
          return DEFAULT_DELAY2[delayType];
        } else {
          return isObject2(delay) ? delay[delayType] : delay;
        }
      }
      _keyboardHandler(e) {
        return super._keyboardHandler(e, !!this._visibleSubmenu);
      }
      _renderContainer() {
        var $wrapper = renderer_default("<div>");
        $wrapper.appendTo(this.$element()).addClass(this._isMenuHorizontal() ? DX_MENU_HORIZONTAL_CLASS : DX_MENU_VERTICAL_CLASS);
        return super._renderContainer($wrapper);
      }
      _renderSubmenuItems(node, $itemFrame) {
        var submenu = this._createSubmenu(node, $itemFrame);
        this._submenus.push(submenu);
        this._renderBorderElement($itemFrame);
        return submenu;
      }
      _getKeyboardListeners() {
        return super._getKeyboardListeners().concat(this._visibleSubmenu);
      }
      _createSubmenu(node, $rootItem) {
        var $submenuContainer = renderer_default("<div>").addClass(DX_CONTEXT_MENU_CLASS2).appendTo($rootItem);
        var items = this._getChildNodes(node);
        var result2 = this._createComponent($submenuContainer, ui_submenu_default, extend2(this._getSubmenuOptions(), {
          _dataAdapter: this._dataAdapter,
          _parentKey: node.internalFields.key,
          items,
          onHoverStart: this._clearTimeouts.bind(this),
          position: this.getSubmenuPosition($rootItem)
        }));
        this._attachSubmenuHandlers($rootItem, result2);
        return result2;
      }
      _getSubmenuOptions() {
        var $submenuTarget = renderer_default("<div>");
        var isMenuHorizontal = this._isMenuHorizontal();
        return {
          itemTemplate: this.option("itemTemplate"),
          target: $submenuTarget,
          orientation: this.option("orientation"),
          selectionMode: this.option("selectionMode"),
          cssClass: this.option("cssClass"),
          selectByClick: this.option("selectByClick"),
          hoverStateEnabled: this.option("hoverStateEnabled"),
          activeStateEnabled: this.option("activeStateEnabled"),
          focusStateEnabled: this.option("focusStateEnabled"),
          animation: this.option("animation"),
          showSubmenuMode: this.option("showSubmenuMode"),
          displayExpr: this.option("displayExpr"),
          disabledExpr: this.option("disabledExpr"),
          selectedExpr: this.option("selectedExpr"),
          itemsExpr: this.option("itemsExpr"),
          onFocusedItemChanged: (e) => {
            if (!e.component.option("visible")) {
              return;
            }
            this.option("focusedElement", e.component.option("focusedElement"));
          },
          onSelectionChanged: this._nestedItemOnSelectionChangedHandler.bind(this),
          onItemClick: this._nestedItemOnItemClickHandler.bind(this),
          onItemRendered: this._nestedItemOnItemRenderedHandler.bind(this),
          onLeftFirstItem: isMenuHorizontal ? null : this._moveMainMenuFocus.bind(this, PREVITEM_OPERATION),
          onLeftLastItem: isMenuHorizontal ? null : this._moveMainMenuFocus.bind(this, NEXTITEM_OPERATION),
          onCloseRootSubmenu: this._moveMainMenuFocus.bind(this, isMenuHorizontal ? PREVITEM_OPERATION : null),
          onExpandLastSubmenu: isMenuHorizontal ? this._moveMainMenuFocus.bind(this, NEXTITEM_OPERATION) : null
        };
      }
      _getShowFirstSubmenuMode() {
        if (!this._isDesktopDevice()) {
          return "onClick";
        }
        var optionValue = this.option("showFirstSubmenuMode");
        return isObject2(optionValue) ? optionValue.name : optionValue;
      }
      _moveMainMenuFocus(direction) {
        var $items = this._getAvailableItems();
        var itemCount = $items.length;
        var $currentItem = $items.filter(".".concat(DX_MENU_ITEM_EXPANDED_CLASS3)).eq(0);
        var itemIndex = $items.index($currentItem);
        this._hideSubmenu(this._visibleSubmenu);
        itemIndex += direction === PREVITEM_OPERATION ? -1 : 1;
        if (itemIndex >= itemCount) {
          itemIndex = 0;
        } else if (itemIndex < 0) {
          itemIndex = itemCount - 1;
        }
        var $newItem = $items.eq(itemIndex);
        this.option("focusedElement", getPublicElement($newItem));
      }
      _nestedItemOnSelectionChangedHandler(args) {
        var selectedItem = args.addedItems.length && args.addedItems[0];
        var submenu = ui_submenu_default.getInstance(args.element);
        var onSelectionChanged = this._actions.onSelectionChanged;
        onSelectionChanged(args);
        selectedItem && this._clearSelectionInSubmenus(selectedItem[0], submenu);
        this._clearRootSelection();
        this._setOptionWithoutOptionChange("selectedItem", selectedItem);
      }
      _clearSelectionInSubmenus(item, targetSubmenu) {
        var cleanAllSubmenus = !arguments.length;
        each(this._submenus, (index2, submenu) => {
          var $submenu = submenu._itemContainer();
          var isOtherItem = !$submenu.is(targetSubmenu && targetSubmenu._itemContainer());
          var $selectedItem = $submenu.find(".".concat(this._selectedItemClass()));
          if (isOtherItem && $selectedItem.length || cleanAllSubmenus) {
            $selectedItem.removeClass(this._selectedItemClass());
            var selectedItemData = this._getItemData($selectedItem);
            if (selectedItemData) {
              selectedItemData.selected = false;
            }
            submenu._clearSelectedItems();
          }
        });
      }
      _clearRootSelection() {
        var $prevSelectedItem = this.$element().find(".".concat(DX_MENU_ITEMS_CONTAINER_CLASS3)).first().children().children().filter(".".concat(this._selectedItemClass()));
        if ($prevSelectedItem.length) {
          var prevSelectedItemData = this._getItemData($prevSelectedItem);
          prevSelectedItemData.selected = false;
          $prevSelectedItem.removeClass(this._selectedItemClass());
        }
      }
      _nestedItemOnItemClickHandler(e) {
        this._actions.onItemClick(e);
      }
      _nestedItemOnItemRenderedHandler(e) {
        this._actions.onItemRendered(e);
      }
      _attachSubmenuHandlers($rootItem, submenu) {
        var $submenuOverlayContent = submenu.getOverlayContent();
        var submenus = $submenuOverlayContent.find(".".concat(DX_SUBMENU_CLASS3));
        var submenuMouseLeaveName = addNamespace2(HOVEREND, this.NAME + "_submenu");
        submenu.option({
          onShowing: this._submenuOnShowingHandler.bind(this, $rootItem, submenu),
          onShown: this._submenuOnShownHandler.bind(this, $rootItem, submenu),
          onHiding: this._submenuOnHidingHandler.bind(this, $rootItem, submenu),
          onHidden: this._submenuOnHiddenHandler.bind(this, $rootItem, submenu)
        });
        each(submenus, (index2, submenu2) => {
          events_engine_default.off(submenu2, submenuMouseLeaveName);
          events_engine_default.on(submenu2, submenuMouseLeaveName, null, this._submenuMouseLeaveHandler.bind(this, $rootItem));
        });
      }
      _submenuOnShowingHandler($rootItem, submenu) {
        var $border = $rootItem.children(".".concat(DX_CONTEXT_MENU_CONTAINER_BORDER_CLASS));
        this._actions.onSubmenuShowing({
          rootItem: getPublicElement($rootItem),
          submenu
        });
        $border.show();
        $rootItem.addClass(DX_MENU_ITEM_EXPANDED_CLASS3);
      }
      _submenuOnShownHandler($rootItem, submenu) {
        this._actions.onSubmenuShown({
          rootItem: getPublicElement($rootItem),
          submenu
        });
      }
      _submenuOnHidingHandler($rootItem, submenu, eventArgs) {
        var $border = $rootItem.children(".".concat(DX_CONTEXT_MENU_CONTAINER_BORDER_CLASS));
        var args = eventArgs;
        args.rootItem = getPublicElement($rootItem);
        args.submenu = submenu;
        this._actions.onSubmenuHiding(args);
        eventArgs = args;
        if (!eventArgs.cancel) {
          if (this._visibleSubmenu === submenu) {
            this._visibleSubmenu = null;
          }
          $border.hide();
          $rootItem.removeClass(DX_MENU_ITEM_EXPANDED_CLASS3);
        }
      }
      _submenuOnHiddenHandler($rootItem, submenu) {
        this._actions.onSubmenuHidden({
          rootItem: getPublicElement($rootItem),
          submenu
        });
      }
      _submenuMouseLeaveHandler($rootItem, eventArgs) {
        var target = renderer_default(eventArgs.relatedTarget).parents(".".concat(DX_CONTEXT_MENU_CLASS2))[0];
        var contextMenu = this._getSubmenuByRootElement($rootItem).getOverlayContent()[0];
        if (this.option("hideSubmenuOnMouseLeave") && target !== contextMenu) {
          this._clearTimeouts();
          setTimeout(this._hideSubmenuAfterTimeout.bind(this), this._getDelay("hide"));
        }
      }
      _hideSubmenuAfterTimeout() {
        if (!this._visibleSubmenu) {
          return;
        }
        var isRootItemHovered = renderer_default(this._visibleSubmenu.$element().context).hasClass(DX_STATE_HOVER_CLASS2);
        var isSubmenuItemHovered = this._visibleSubmenu.getOverlayContent().find(".".concat(DX_STATE_HOVER_CLASS2)).length;
        var hoveredElementFromSubMenu = this._visibleSubmenu.getOverlayContent().get(0).querySelector(":hover");
        if (!hoveredElementFromSubMenu && !isSubmenuItemHovered && !isRootItemHovered) {
          this._visibleSubmenu.hide();
        }
      }
      _getSubmenuByRootElement($rootItem) {
        if (!$rootItem) {
          return false;
        }
        var $submenu = $rootItem.children(".".concat(DX_CONTEXT_MENU_CLASS2));
        return $submenu.length && ui_submenu_default.getInstance($submenu);
      }
      getSubmenuPosition($rootItem) {
        var isHorizontalMenu = this._isMenuHorizontal();
        var submenuDirection = this.option("submenuDirection").toLowerCase();
        var rtlEnabled = this.option("rtlEnabled");
        var submenuPosition = {
          collision: "flip",
          of: $rootItem
        };
        switch (submenuDirection) {
          case "leftortop":
            submenuPosition.at = "left top";
            submenuPosition.my = isHorizontalMenu ? "left bottom" : "right top";
            break;
          case "rightorbottom":
            submenuPosition.at = isHorizontalMenu ? "left bottom" : "right top";
            submenuPosition.my = "left top";
            break;
          default:
            if (isHorizontalMenu) {
              submenuPosition.at = rtlEnabled ? "right bottom" : "left bottom";
              submenuPosition.my = rtlEnabled ? "right top" : "left top";
            } else {
              submenuPosition.at = rtlEnabled ? "left top" : "right top";
              submenuPosition.my = rtlEnabled ? "right top" : "left top";
            }
        }
        return submenuPosition;
      }
      _renderBorderElement($item) {
        renderer_default("<div>").appendTo($item).addClass(DX_CONTEXT_MENU_CONTAINER_BORDER_CLASS).hide();
      }
      _itemPointerDownHandler(e) {
        var $target = renderer_default(e.target);
        var $closestItem = $target.closest(this._itemElements());
        if ($closestItem.hasClass("dx-menu-item-has-submenu")) {
          this.option("focusedElement", null);
          return;
        }
        super._itemPointerDownHandler(e);
      }
      _hoverStartHandler(e) {
        var mouseMoveEventName = addNamespace2(pointer_default.move, this.NAME);
        var $item = this._getItemElementByEventArgs(e);
        var node = this._dataAdapter.getNodeByItem(this._getItemData($item));
        var isSelectionActive = isDefined(e.buttons) && 1 === e.buttons || !isDefined(e.buttons) && 1 === e.which;
        if (this._isItemDisabled($item)) {
          return;
        }
        events_engine_default.off($item, mouseMoveEventName);
        if (!this._hasChildren(node)) {
          this._showSubmenuTimer = setTimeout(this._hideSubmenuAfterTimeout.bind(this), this._getDelay("hide"));
          return;
        }
        if ("onHover" === this._getShowFirstSubmenuMode() && !isSelectionActive) {
          var submenu = this._getSubmenuByElement($item);
          this._clearTimeouts();
          if (!submenu.isOverlayVisible()) {
            events_engine_default.on($item, mouseMoveEventName, this._itemMouseMoveHandler.bind(this));
            this._showSubmenuTimer = this._getDelay("hide");
          }
        }
      }
      _hoverEndHandler(eventArg) {
        var $item = this._getItemElementByEventArgs(eventArg);
        var relatedTarget = renderer_default(eventArg.relatedTarget);
        super._hoverEndHandler(eventArg);
        this._clearTimeouts();
        if (this._isItemDisabled($item)) {
          return;
        }
        if (relatedTarget.hasClass(DX_CONTEXT_MENU_CONTENT_DELIMITER_CLASS2)) {
          return;
        }
        if (this.option("hideSubmenuOnMouseLeave") && !relatedTarget.hasClass(DX_MENU_ITEMS_CONTAINER_CLASS3)) {
          this._hideSubmenuTimer = setTimeout(() => {
            this._hideSubmenuAfterTimeout();
          }, this._getDelay("hide"));
        }
      }
      _hideVisibleSubmenu() {
        if (!this._visibleSubmenu) {
          return false;
        }
        this._hideSubmenu(this._visibleSubmenu);
        return true;
      }
      _showSubmenu($itemElement) {
        var submenu = this._getSubmenuByElement($itemElement);
        if (this._visibleSubmenu !== submenu) {
          this._hideVisibleSubmenu();
        }
        if (submenu) {
          this._clearTimeouts();
          submenu.show();
          this.option("focusedElement", submenu.option("focusedElement"));
        }
        this._visibleSubmenu = submenu;
        this._hoveredRootItem = $itemElement;
      }
      _hideSubmenu(submenu) {
        submenu && submenu.hide();
        if (this._visibleSubmenu === submenu) {
          this._visibleSubmenu = null;
        }
        this._hoveredRootItem = null;
      }
      _itemMouseMoveHandler(e) {
        if (e.pointers && e.pointers.length) {
          return;
        }
        var $item = renderer_default(e.currentTarget);
        if (!isDefined(this._showSubmenuTimer)) {
          return;
        }
        this._clearTimeouts();
        this._showSubmenuTimer = setTimeout(() => {
          var submenu = this._getSubmenuByElement($item);
          if (submenu && !submenu.isOverlayVisible()) {
            this._showSubmenu($item);
          }
        }, this._getDelay("show"));
      }
      _clearTimeouts() {
        clearTimeout(this._hideSubmenuTimer);
        clearTimeout(this._showSubmenuTimer);
      }
      _getSubmenuByElement($itemElement, itemData) {
        var submenu = this._getSubmenuByRootElement($itemElement);
        if (submenu) {
          return submenu;
        } else {
          itemData = itemData || this._getItemData($itemElement);
          var node = this._dataAdapter.getNodeByItem(itemData);
          return this._hasChildren(node) && this._renderSubmenuItems(node, $itemElement);
        }
      }
      _updateSubmenuVisibilityOnClick(actionArgs) {
        var args = actionArgs.args.length && actionArgs.args[0];
        if (!args || this._disabledGetter(args.itemData)) {
          return;
        }
        var $itemElement = renderer_default(args.itemElement);
        var currentSubmenu = this._getSubmenuByElement($itemElement, args.itemData);
        this._updateSelectedItemOnClick(actionArgs);
        if (this._visibleSubmenu) {
          if (this._visibleSubmenu === currentSubmenu) {
            if ("onClick" === this.option("showFirstSubmenuMode")) {
              this._hideSubmenu(this._visibleSubmenu);
            }
            return;
          } else {
            this._hideSubmenu(this._visibleSubmenu);
          }
        }
        if (!currentSubmenu) {
          return;
        }
        if (!currentSubmenu.isOverlayVisible()) {
          this._showSubmenu($itemElement);
          return;
        }
      }
      _optionChanged(args) {
        if (ACTIONS3.indexOf(args.name) >= 0) {
          this._initActions();
          return;
        }
        switch (args.name) {
          case "orientation":
          case "submenuDirection":
            this._invalidate();
            break;
          case "showFirstSubmenuMode":
          case "hideSubmenuOnMouseLeave":
            break;
          case "showSubmenuMode":
            this._changeSubmenusOption(args.name, args.value);
            break;
          case "adaptivityEnabled":
            args.value ? this._initAdaptivity() : this._removeAdaptivity();
            break;
          case "width":
            if (this._isAdaptivityEnabled()) {
              this._treeView.option(args.name, args.value);
              this._overlay.option(args.name, args.value);
            }
            super._optionChanged(args);
            this._dimensionChanged();
            break;
          case "animation":
            if (this._isAdaptivityEnabled()) {
              this._treeView.option("animationEnabled", !!args.value);
            }
            super._optionChanged(args);
            break;
          default:
            if (this._isAdaptivityEnabled() && (args.name === args.fullName || "items" === args.name)) {
              this._treeView.option(args.fullName, args.value);
            }
            super._optionChanged(args);
        }
      }
      _changeSubmenusOption(name2, value2) {
        each(this._submenus, (index2, submenu) => {
          submenu.option(name2, value2);
        });
      }
      selectItem(itemElement) {
        this._hideSubmenu(this._visibleSubmenu);
        super.selectItem(itemElement);
      }
      unselectItem(itemElement) {
        this._hideSubmenu(this._visibleSubmenu);
        super.selectItem(itemElement);
      }
    };
    component_registrator_default("dxMenu", Menu);
    ui_menu_default = Menu;
  }
});

// node_modules/devextreme/esm/ui/menu.js
var menu_default;
var init_menu = __esm({
  "node_modules/devextreme/esm/ui/menu.js"() {
    init_ui_menu();
    menu_default = ui_menu_default;
  }
});

// node_modules/devextreme/esm/ui/grid_core/ui.grid_core.filter_row.js
function isOnClickApplyFilterMode(that) {
  return "onClick" === that.option("filterRow.applyFilter");
}
var OPERATION_ICONS, OPERATION_DESCRIPTORS, FILTERING_TIMEOUT, CORRECT_FILTER_RANGE_OVERLAY_WIDTH, FILTER_ROW_CLASS2, FILTER_RANGE_OVERLAY_CLASS, FILTER_RANGE_START_CLASS, FILTER_RANGE_END_CLASS, MENU_CLASS, EDITOR_WITH_MENU_CLASS, EDITOR_CONTAINER_CLASS, EDITOR_CELL_CLASS4, FILTER_MENU, APPLY_BUTTON_CLASS, HIGHLIGHT_OUTLINE_CLASS, FOCUSED_CLASS, CELL_FOCUS_DISABLED_CLASS3, FILTER_RANGE_CONTENT_CLASS, FILTER_MODIFIED_CLASS, EDITORS_INPUT_SELECTOR2, BETWEEN_OPERATION_DATA_TYPES, ColumnHeadersViewFilterRowExtender, DataControllerFilterRowExtender, ApplyFilterViewController, filterRowModule;
var init_ui_grid_core_filter_row = __esm({
  "node_modules/devextreme/esm/ui/grid_core/ui.grid_core.filter_row.js"() {
    init_renderer();
    init_events_engine();
    init_type();
    init_extend();
    init_utils2();
    init_iterator();
    init_ui_grid_core_modules();
    init_ui_grid_core_utils();
    init_message();
    init_editor();
    init_ui_overlay();
    init_menu();
    init_accessibility();
    OPERATION_ICONS = {
      "=": "filter-operation-equals",
      "<>": "filter-operation-not-equals",
      "<": "filter-operation-less",
      "<=": "filter-operation-less-equal",
      ">": "filter-operation-greater",
      ">=": "filter-operation-greater-equal",
      default: "filter-operation-default",
      notcontains: "filter-operation-not-contains",
      contains: "filter-operation-contains",
      startswith: "filter-operation-starts-with",
      endswith: "filter-operation-ends-with",
      between: "filter-operation-between"
    };
    OPERATION_DESCRIPTORS = {
      "=": "equal",
      "<>": "notEqual",
      "<": "lessThan",
      "<=": "lessThanOrEqual",
      ">": "greaterThan",
      ">=": "greaterThanOrEqual",
      startswith: "startsWith",
      contains: "contains",
      notcontains: "notContains",
      endswith: "endsWith",
      between: "between"
    };
    FILTERING_TIMEOUT = 700;
    CORRECT_FILTER_RANGE_OVERLAY_WIDTH = 1;
    FILTER_ROW_CLASS2 = "filter-row";
    FILTER_RANGE_OVERLAY_CLASS = "filter-range-overlay";
    FILTER_RANGE_START_CLASS = "filter-range-start";
    FILTER_RANGE_END_CLASS = "filter-range-end";
    MENU_CLASS = "dx-menu";
    EDITOR_WITH_MENU_CLASS = "dx-editor-with-menu";
    EDITOR_CONTAINER_CLASS = "dx-editor-container";
    EDITOR_CELL_CLASS4 = "dx-editor-cell";
    FILTER_MENU = "dx-filter-menu";
    APPLY_BUTTON_CLASS = "dx-apply-button";
    HIGHLIGHT_OUTLINE_CLASS = "dx-highlight-outline";
    FOCUSED_CLASS = "dx-focused";
    CELL_FOCUS_DISABLED_CLASS3 = "dx-cell-focus-disabled";
    FILTER_RANGE_CONTENT_CLASS = "dx-filter-range-content";
    FILTER_MODIFIED_CLASS = "dx-filter-modified";
    EDITORS_INPUT_SELECTOR2 = "input:not([type='hidden'])";
    BETWEEN_OPERATION_DATA_TYPES = ["date", "datetime", "number"];
    ColumnHeadersViewFilterRowExtender = /* @__PURE__ */ function() {
      var getEditorInstance = function($editorContainer) {
        var $editor = $editorContainer && $editorContainer.children();
        var componentNames2 = $editor && $editor.data("dxComponents");
        var editor = componentNames2 && componentNames2.length && $editor.data(componentNames2[0]);
        if (editor instanceof editor_default) {
          return editor;
        }
      };
      var getRangeTextByFilterValue = function(that, column) {
        var result2 = "";
        var rangeEnd = "";
        var filterValue = getColumnFilterValue(that, column);
        var formatOptions = ui_grid_core_utils_default.getFormatOptionsByColumn(column, "filterRow");
        if (Array.isArray(filterValue)) {
          result2 = ui_grid_core_utils_default.formatValue(filterValue[0], formatOptions);
          rangeEnd = ui_grid_core_utils_default.formatValue(filterValue[1], formatOptions);
          if ("" !== rangeEnd) {
            result2 += " - " + rangeEnd;
          }
        } else if (isDefined(filterValue)) {
          result2 = ui_grid_core_utils_default.formatValue(filterValue, formatOptions);
        }
        return result2;
      };
      function getColumnFilterValue(that, column) {
        if (column) {
          return isOnClickApplyFilterMode(that) && void 0 !== column.bufferedFilterValue ? column.bufferedFilterValue : column.filterValue;
        }
      }
      var getColumnSelectedFilterOperation = function(that, column) {
        if (column) {
          return isOnClickApplyFilterMode(that) && void 0 !== column.bufferedSelectedFilterOperation ? column.bufferedSelectedFilterOperation : column.selectedFilterOperation;
        }
      };
      var getFilterValue2 = function(that, columnIndex, $editorContainer) {
        var column = that._columnsController.columnOption(columnIndex);
        var filterValue = getColumnFilterValue(that, column);
        var isFilterRange = $editorContainer.closest("." + that.addWidgetPrefix(FILTER_RANGE_OVERLAY_CLASS)).length;
        var isRangeStart = $editorContainer.hasClass(that.addWidgetPrefix(FILTER_RANGE_START_CLASS));
        if (filterValue && Array.isArray(filterValue) && "between" === getColumnSelectedFilterOperation(that, column)) {
          if (isRangeStart) {
            return filterValue[0];
          } else {
            return filterValue[1];
          }
        }
        return !isFilterRange && function(filterValue2, column2) {
          if (column2 && BETWEEN_OPERATION_DATA_TYPES.indexOf(column2.dataType) >= 0 && Array.isArray(filterValue2)) {
            return false;
          }
          return void 0 !== filterValue2;
        }(filterValue, column) ? filterValue : null;
      };
      var updateFilterValue = function(that, options2) {
        var value2 = "" === options2.value ? null : options2.value;
        var $editorContainer = options2.container;
        var column = that._columnsController.columnOption(options2.column.index);
        var filterValue = getFilterValue2(that, column.index, $editorContainer);
        if (!isDefined(filterValue) && !isDefined(value2)) {
          return;
        }
        that._applyFilterViewController.setHighLight($editorContainer, filterValue !== value2);
        var columnOptionName = isOnClickApplyFilterMode(that) ? "bufferedFilterValue" : "filterValue";
        var normalizedValue = function(that2, filterValue2, column2, $editorContainer2) {
          if ("between" === getColumnSelectedFilterOperation(that2, column2)) {
            var columnFilterValue = getColumnFilterValue(that2, column2);
            if ($editorContainer2.hasClass(that2.addWidgetPrefix(FILTER_RANGE_START_CLASS))) {
              return [filterValue2, Array.isArray(columnFilterValue) ? columnFilterValue[1] : void 0];
            } else {
              return [Array.isArray(columnFilterValue) ? columnFilterValue[0] : columnFilterValue, filterValue2];
            }
          }
          return filterValue2;
        }(that, value2, column, $editorContainer);
        var isBetween = "between" === getColumnSelectedFilterOperation(that, column);
        var notFireEvent = options2.notFireEvent || isBetween && Array.isArray(normalizedValue) && normalizedValue.indexOf(void 0) >= 0;
        that._columnsController.columnOption(column.index, columnOptionName, normalizedValue, notFireEvent);
      };
      return {
        _updateEditorValue: function(column, $editorContainer) {
          var editor = getEditorInstance($editorContainer);
          editor && editor.option("value", getFilterValue2(this, column.index, $editorContainer));
        },
        _columnOptionChanged: function(e) {
          var optionNames = e.optionNames;
          var $cell;
          var $editorContainer;
          var $editorRangeElements;
          var $menu;
          if (ui_grid_core_utils_default.checkChanges(optionNames, ["filterValue", "bufferedFilterValue", "selectedFilterOperation", "bufferedSelectedFilterOperation", "filterValues", "filterType"]) && void 0 !== e.columnIndex) {
            var visibleIndex = this._columnsController.getVisibleIndex(e.columnIndex);
            var column = this._columnsController.columnOption(e.columnIndex);
            $cell = this._getCellElement(this.element().find("." + this.addWidgetPrefix(FILTER_ROW_CLASS2)).index(), visibleIndex) || renderer_default();
            $editorContainer = $cell.find("." + EDITOR_CONTAINER_CLASS).first();
            if (optionNames.filterValue || optionNames.bufferedFilterValue) {
              this._updateEditorValue(column, $editorContainer);
              var overlayInstance = $cell.find("." + this.addWidgetPrefix(FILTER_RANGE_OVERLAY_CLASS)).data("dxOverlay");
              if (overlayInstance) {
                $editorRangeElements = overlayInstance.$content().find("." + EDITOR_CONTAINER_CLASS);
                this._updateEditorValue(column, $editorRangeElements.first());
                this._updateEditorValue(column, $editorRangeElements.last());
              }
              if (!overlayInstance || !overlayInstance.option("visible")) {
                this._updateFilterRangeContent($cell, getRangeTextByFilterValue(this, column));
              }
            }
            if (optionNames.selectedFilterOperation || optionNames.bufferedSelectedFilterOperation) {
              if (visibleIndex >= 0 && column) {
                $menu = $cell.find("." + MENU_CLASS);
                if ($menu.length) {
                  this._updateFilterOperationChooser($menu, column, $editorContainer);
                  if ("between" === getColumnSelectedFilterOperation(this, column)) {
                    this._renderFilterRangeContent($cell, column);
                  } else if ($editorContainer.find("." + FILTER_RANGE_CONTENT_CLASS).length) {
                    this._renderEditor($editorContainer, this._getEditorOptions($editorContainer, column));
                    this._hideFilterRange();
                  }
                }
              }
            }
            return;
          }
          this.callBase(e);
        },
        _renderCore: function() {
          this._filterRangeOverlayInstance = null;
          this.callBase.apply(this, arguments);
        },
        _resizeCore: function() {
          this.callBase.apply(this, arguments);
          this._filterRangeOverlayInstance && this._filterRangeOverlayInstance.repaint();
        },
        isFilterRowVisible: function() {
          return this._isElementVisible(this.option("filterRow"));
        },
        isVisible: function() {
          return this.callBase() || this.isFilterRowVisible();
        },
        init: function() {
          this.callBase();
          this._applyFilterViewController = this.getController("applyFilter");
        },
        _initFilterRangeOverlay: function($cell, column) {
          var that = this;
          var sharedData = {};
          var $editorContainer = $cell.find(".dx-editor-container");
          var $overlay = renderer_default("<div>").addClass(that.addWidgetPrefix(FILTER_RANGE_OVERLAY_CLASS)).appendTo($cell);
          return that._createComponent($overlay, ui_overlay_default, {
            height: "auto",
            shading: false,
            showTitle: false,
            focusStateEnabled: false,
            closeOnTargetScroll: false,
            closeOnOutsideClick: true,
            animation: false,
            position: {
              my: "top",
              at: "top",
              of: $editorContainer.length && $editorContainer || $cell,
              offset: "0 -1"
            },
            contentTemplate: function(contentElement) {
              var editorOptions;
              var $editor = renderer_default("<div>").addClass(EDITOR_CONTAINER_CLASS + " " + that.addWidgetPrefix(FILTER_RANGE_START_CLASS)).appendTo(contentElement);
              column = that._columnsController.columnOption(column.index);
              editorOptions = that._getEditorOptions($editor, column);
              editorOptions.sharedData = sharedData;
              that._renderEditor($editor, editorOptions);
              events_engine_default.on($editor.find(EDITORS_INPUT_SELECTOR2), "keydown", function(e) {
                var $prevElement = $cell.find("[tabindex]").not(e.target).first();
                if ("tab" === normalizeKeyName(e) && e.shiftKey) {
                  e.preventDefault();
                  that._hideFilterRange();
                  if (!$prevElement.length) {
                    $prevElement = $cell.prev().find("[tabindex]").last();
                  }
                  events_engine_default.trigger($prevElement, "focus");
                }
              });
              $editor = renderer_default("<div>").addClass(EDITOR_CONTAINER_CLASS + " " + that.addWidgetPrefix(FILTER_RANGE_END_CLASS)).appendTo(contentElement);
              editorOptions = that._getEditorOptions($editor, column);
              editorOptions.sharedData = sharedData;
              that._renderEditor($editor, editorOptions);
              events_engine_default.on($editor.find(EDITORS_INPUT_SELECTOR2), "keydown", function(e) {
                if ("tab" === normalizeKeyName(e) && !e.shiftKey) {
                  e.preventDefault();
                  that._hideFilterRange();
                  events_engine_default.trigger($cell.next().find("[tabindex]").first(), "focus");
                }
              });
              return renderer_default(contentElement).addClass(that.getWidgetContainerClass());
            },
            onShown: function(e) {
              var $editor = e.component.$content().find("." + EDITOR_CONTAINER_CLASS).first();
              events_engine_default.trigger($editor.find(EDITORS_INPUT_SELECTOR2), "focus");
            },
            onHidden: function() {
              column = that._columnsController.columnOption(column.index);
              $cell.find("." + MENU_CLASS).parent().addClass(EDITOR_WITH_MENU_CLASS);
              if ("between" === getColumnSelectedFilterOperation(that, column)) {
                that._updateFilterRangeContent($cell, getRangeTextByFilterValue(that, column));
                that.component.updateDimensions();
              }
            }
          });
        },
        _updateFilterRangeOverlay: function(options2) {
          var overlayInstance = this._filterRangeOverlayInstance;
          overlayInstance && overlayInstance.option(options2);
        },
        _showFilterRange: function($cell, column) {
          var $overlay = $cell.children("." + this.addWidgetPrefix(FILTER_RANGE_OVERLAY_CLASS));
          var overlayInstance = $overlay.length && $overlay.data("dxOverlay");
          if (!overlayInstance && column) {
            overlayInstance = this._initFilterRangeOverlay($cell, column);
          }
          if (!overlayInstance.option("visible")) {
            this._filterRangeOverlayInstance && this._filterRangeOverlayInstance.hide();
            this._filterRangeOverlayInstance = overlayInstance;
            this._updateFilterRangeOverlay({
              width: $cell.outerWidth(true) + CORRECT_FILTER_RANGE_OVERLAY_WIDTH
            });
            this._filterRangeOverlayInstance && this._filterRangeOverlayInstance.show();
          }
        },
        _hideFilterRange: function() {
          var overlayInstance = this._filterRangeOverlayInstance;
          overlayInstance && overlayInstance.hide();
        },
        getFilterRangeOverlayInstance: function() {
          return this._filterRangeOverlayInstance;
        },
        _createRow: function(row) {
          var $row = this.callBase(row);
          if ("filter" === row.rowType) {
            $row.addClass(this.addWidgetPrefix(FILTER_ROW_CLASS2));
            if (!this.option("useLegacyKeyboardNavigation")) {
              events_engine_default.on($row, "keydown", (event) => selectView("filterRow", this, event));
            }
          }
          return $row;
        },
        _getRows: function() {
          var result2 = this.callBase();
          if (this.isFilterRowVisible()) {
            result2.push({
              rowType: "filter"
            });
          }
          return result2;
        },
        _renderFilterCell: function(cell, options2) {
          var column = options2.column;
          var $cell = renderer_default(cell);
          if (this.component.option("showColumnHeaders")) {
            this.setAria("describedby", column.headerId, $cell);
          }
          this.setAria("label", message_default.format("dxDataGrid-ariaFilterCell"), $cell);
          $cell.addClass(EDITOR_CELL_CLASS4);
          var $container = renderer_default("<div>").appendTo($cell);
          var $editorContainer = renderer_default("<div>").addClass(EDITOR_CONTAINER_CLASS).appendTo($container);
          if ("between" === getColumnSelectedFilterOperation(this, column)) {
            this._renderFilterRangeContent($cell, column);
          } else {
            var editorOptions = this._getEditorOptions($editorContainer, column);
            this._renderEditor($editorContainer, editorOptions);
          }
          var alignment = column.alignment;
          if (alignment && "center" !== alignment) {
            $cell.find(EDITORS_INPUT_SELECTOR2).first().css("textAlign", column.alignment);
          }
          if (column.filterOperations && column.filterOperations.length) {
            this._renderFilterOperationChooser($container, column, $editorContainer);
          }
        },
        _renderCellContent: function($cell, options2) {
          var that = this;
          var column = options2.column;
          if ("filter" === options2.rowType) {
            if (column.command) {
              $cell.html("&nbsp;");
            } else if (column.allowFiltering) {
              that.renderTemplate($cell, that._renderFilterCell.bind(that), options2).done(() => {
                that._updateCell($cell, options2);
              });
              return;
            }
          }
          that.callBase($cell, options2);
        },
        _getEditorOptions: function($editorContainer, column) {
          var that = this;
          var accessibilityOptions = {
            editorOptions: {
              inputAttr: that._getFilterInputAccessibilityAttributes(column)
            }
          };
          var result2 = extend2(accessibilityOptions, column, {
            value: getFilterValue2(that, column.index, $editorContainer),
            parentType: "filterRow",
            showAllText: that.option("filterRow.showAllText"),
            updateValueTimeout: "onClick" === that.option("filterRow.applyFilter") ? 0 : FILTERING_TIMEOUT,
            width: null,
            setValue: function(value2, notFireEvent) {
              updateFilterValue(that, {
                column,
                value: value2,
                container: $editorContainer,
                notFireEvent
              });
            }
          });
          if ("between" === getColumnSelectedFilterOperation(that, column)) {
            if ($editorContainer.hasClass(that.addWidgetPrefix(FILTER_RANGE_START_CLASS))) {
              result2.placeholder = that.option("filterRow.betweenStartText");
            } else {
              result2.placeholder = that.option("filterRow.betweenEndText");
            }
          }
          return result2;
        },
        _getFilterInputAccessibilityAttributes: function(column) {
          var columnAriaLabel = message_default.format("dxDataGrid-ariaFilterCell");
          if (this.component.option("showColumnHeaders")) {
            return {
              "aria-label": columnAriaLabel,
              "aria-describedby": column.headerId
            };
          }
          return {
            "aria-label": columnAriaLabel
          };
        },
        _renderEditor: function($editorContainer, options2) {
          $editorContainer.empty();
          return this.getController("editorFactory").createEditor(renderer_default("<div>").appendTo($editorContainer), options2);
        },
        _renderFilterRangeContent: function($cell, column) {
          var that = this;
          var $editorContainer = $cell.find("." + EDITOR_CONTAINER_CLASS).first();
          $editorContainer.empty();
          var $filterRangeContent = renderer_default("<div>").addClass(FILTER_RANGE_CONTENT_CLASS).attr("tabindex", this.option("tabIndex"));
          events_engine_default.on($filterRangeContent, "focusin", function() {
            that._showFilterRange($cell, column);
          });
          $filterRangeContent.appendTo($editorContainer);
          that._updateFilterRangeContent($cell, getRangeTextByFilterValue(that, column));
        },
        _updateFilterRangeContent: function($cell, value2) {
          var $filterRangeContent = $cell.find("." + FILTER_RANGE_CONTENT_CLASS);
          if ($filterRangeContent.length) {
            if ("" === value2) {
              $filterRangeContent.html("&nbsp;");
            } else {
              $filterRangeContent.text(value2);
            }
          }
        },
        _updateFilterOperationChooser: function($menu, column, $editorContainer) {
          var that = this;
          var isCellWasFocused;
          var restoreFocus3 = function() {
            var menu = menu_default.getInstance($menu);
            menu && menu.option("focusedElement", null);
            isCellWasFocused && that._focusEditor($editorContainer);
          };
          that._createComponent($menu, menu_default, {
            integrationOptions: {},
            activeStateEnabled: false,
            selectionMode: "single",
            cssClass: that.getWidgetContainerClass() + " " + CELL_FOCUS_DISABLED_CLASS3 + " " + FILTER_MENU,
            showFirstSubmenuMode: "onHover",
            hideSubmenuOnMouseLeave: true,
            items: [{
              disabled: column.filterOperations && column.filterOperations.length ? false : true,
              icon: OPERATION_ICONS[getColumnSelectedFilterOperation(that, column) || "default"],
              selectable: false,
              items: that._getFilterOperationMenuItems(column)
            }],
            onItemClick: function(properties) {
              var selectedFilterOperation = properties.itemData.name;
              var columnSelectedFilterOperation = getColumnSelectedFilterOperation(that, column);
              var notFocusEditor = false;
              var isOnClickMode = isOnClickApplyFilterMode(that);
              var options2 = {};
              if (properties.itemData.items || selectedFilterOperation && selectedFilterOperation === columnSelectedFilterOperation) {
                return;
              }
              if (selectedFilterOperation) {
                options2[isOnClickMode ? "bufferedSelectedFilterOperation" : "selectedFilterOperation"] = selectedFilterOperation;
                if ("between" === selectedFilterOperation || "between" === columnSelectedFilterOperation) {
                  notFocusEditor = "between" === selectedFilterOperation;
                  options2[isOnClickMode ? "bufferedFilterValue" : "filterValue"] = null;
                }
              } else {
                options2[isOnClickMode ? "bufferedFilterValue" : "filterValue"] = null;
                options2[isOnClickMode ? "bufferedSelectedFilterOperation" : "selectedFilterOperation"] = column.defaultSelectedFilterOperation || null;
              }
              that._columnsController.columnOption(column.index, options2);
              that._applyFilterViewController.setHighLight($editorContainer, true);
              if (!selectedFilterOperation) {
                var editor = getEditorInstance($editorContainer);
                if (editor && "dxDateBox" === editor.NAME && !editor.option("isValid")) {
                  editor.reset();
                  editor.option("isValid", true);
                }
              }
              if (!notFocusEditor) {
                that._focusEditor($editorContainer);
              } else {
                that._showFilterRange($editorContainer.closest("." + EDITOR_CELL_CLASS4), column);
              }
            },
            onSubmenuShown: function() {
              isCellWasFocused = that._isEditorFocused($editorContainer);
              that.getController("editorFactory").loseFocus();
            },
            onSubmenuHiding: function() {
              events_engine_default.trigger($menu, "blur");
              restoreFocus3();
            },
            onContentReady: function(e) {
              events_engine_default.on($menu, "blur", () => {
                var menu = e.component;
                menu._hideSubmenu(menu._visibleSubmenu);
                restoreFocus3();
              });
            },
            rtlEnabled: that.option("rtlEnabled")
          });
        },
        _isEditorFocused: function($container) {
          return $container.hasClass(FOCUSED_CLASS) || $container.parents("." + FOCUSED_CLASS).length;
        },
        _focusEditor: function($container) {
          this.getController("editorFactory").focus($container);
          events_engine_default.trigger($container.find(EDITORS_INPUT_SELECTOR2), "focus");
        },
        _renderFilterOperationChooser: function($container, column, $editorContainer) {
          var $menu;
          if (this.option("filterRow.showOperationChooser")) {
            $container.addClass(EDITOR_WITH_MENU_CLASS);
            $menu = renderer_default("<div>").prependTo($container);
            this._updateFilterOperationChooser($menu, column, $editorContainer);
          }
        },
        _getFilterOperationMenuItems: function(column) {
          var that = this;
          var result2 = [{}];
          var filterRowOptions = that.option("filterRow");
          var operationDescriptions = filterRowOptions && filterRowOptions.operationDescriptions || {};
          if (column.filterOperations && column.filterOperations.length) {
            var availableFilterOperations = column.filterOperations.filter(function(value2) {
              return isDefined(OPERATION_DESCRIPTORS[value2]);
            });
            result2 = map(availableFilterOperations, function(value2) {
              var descriptionName = OPERATION_DESCRIPTORS[value2];
              return {
                name: value2,
                selected: (getColumnSelectedFilterOperation(that, column) || column.defaultFilterOperation) === value2,
                text: operationDescriptions[descriptionName],
                icon: OPERATION_ICONS[value2]
              };
            });
            result2.push({
              name: null,
              text: filterRowOptions && filterRowOptions.resetOperationText,
              icon: OPERATION_ICONS.default
            });
          }
          return result2;
        },
        optionChanged: function(args) {
          switch (args.name) {
            case "filterRow":
            case "showColumnLines":
              this._invalidate(true, true);
              args.handled = true;
              break;
            default:
              this.callBase(args);
          }
        }
      };
    }();
    DataControllerFilterRowExtender = {
      skipCalculateColumnFilters: function() {
        return false;
      },
      _calculateAdditionalFilter: function() {
        if (this.skipCalculateColumnFilters()) {
          return this.callBase();
        }
        var filters = [this.callBase()];
        var columns = this._columnsController.getVisibleColumns(null, true);
        each(columns, function() {
          if (this.allowFiltering && this.calculateFilterExpression && isDefined(this.filterValue)) {
            var filter = this.createFilterExpression(this.filterValue, this.selectedFilterOperation || this.defaultFilterOperation, "filterRow");
            filters.push(filter);
          }
        });
        return ui_grid_core_utils_default.combineFilters(filters);
      }
    };
    ApplyFilterViewController = ui_grid_core_modules_default.ViewController.inherit({
      _getHeaderPanel: function() {
        if (!this._headerPanel) {
          this._headerPanel = this.getView("headerPanel");
        }
        return this._headerPanel;
      },
      setHighLight: function($element, value2) {
        if (isOnClickApplyFilterMode(this)) {
          $element && $element.toggleClass(HIGHLIGHT_OUTLINE_CLASS, value2) && $element.closest("." + EDITOR_CELL_CLASS4).toggleClass(FILTER_MODIFIED_CLASS, value2);
          this._getHeaderPanel().enableApplyButton(value2);
        }
      },
      applyFilter: function() {
        var columnsController = this.getController("columns");
        var columns = columnsController.getColumns();
        columnsController.beginUpdate();
        for (var i = 0; i < columns.length; i++) {
          var column = columns[i];
          if (void 0 !== column.bufferedFilterValue) {
            columnsController.columnOption(i, "filterValue", column.bufferedFilterValue);
            column.bufferedFilterValue = void 0;
          }
          if (void 0 !== column.bufferedSelectedFilterOperation) {
            columnsController.columnOption(i, "selectedFilterOperation", column.bufferedSelectedFilterOperation);
            column.bufferedSelectedFilterOperation = void 0;
          }
        }
        columnsController.endUpdate();
        this.removeHighLights();
      },
      removeHighLights: function() {
        if (isOnClickApplyFilterMode(this)) {
          var columnHeadersViewElement = this.getView("columnHeadersView").element();
          columnHeadersViewElement.find("." + this.addWidgetPrefix(FILTER_ROW_CLASS2) + " ." + HIGHLIGHT_OUTLINE_CLASS).removeClass(HIGHLIGHT_OUTLINE_CLASS);
          columnHeadersViewElement.find("." + this.addWidgetPrefix(FILTER_ROW_CLASS2) + " ." + FILTER_MODIFIED_CLASS).removeClass(FILTER_MODIFIED_CLASS);
          this._getHeaderPanel().enableApplyButton(false);
        }
      }
    });
    filterRowModule = {
      defaultOptions: function() {
        return {
          filterRow: {
            visible: false,
            showOperationChooser: true,
            showAllText: message_default.format("dxDataGrid-filterRowShowAllText"),
            resetOperationText: message_default.format("dxDataGrid-filterRowResetOperationText"),
            applyFilter: "auto",
            applyFilterText: message_default.format("dxDataGrid-applyFilterText"),
            operationDescriptions: {
              equal: message_default.format("dxDataGrid-filterRowOperationEquals"),
              notEqual: message_default.format("dxDataGrid-filterRowOperationNotEquals"),
              lessThan: message_default.format("dxDataGrid-filterRowOperationLess"),
              lessThanOrEqual: message_default.format("dxDataGrid-filterRowOperationLessOrEquals"),
              greaterThan: message_default.format("dxDataGrid-filterRowOperationGreater"),
              greaterThanOrEqual: message_default.format("dxDataGrid-filterRowOperationGreaterOrEquals"),
              startsWith: message_default.format("dxDataGrid-filterRowOperationStartsWith"),
              contains: message_default.format("dxDataGrid-filterRowOperationContains"),
              notContains: message_default.format("dxDataGrid-filterRowOperationNotContains"),
              endsWith: message_default.format("dxDataGrid-filterRowOperationEndsWith"),
              between: message_default.format("dxDataGrid-filterRowOperationBetween"),
              isBlank: message_default.format("dxFilterBuilder-filterOperationIsBlank"),
              isNotBlank: message_default.format("dxFilterBuilder-filterOperationIsNotBlank")
            },
            betweenStartText: message_default.format("dxDataGrid-filterRowOperationBetweenStartText"),
            betweenEndText: message_default.format("dxDataGrid-filterRowOperationBetweenEndText")
          }
        };
      },
      controllers: {
        applyFilter: ApplyFilterViewController
      },
      extenders: {
        controllers: {
          data: DataControllerFilterRowExtender,
          columnsResizer: {
            _startResizing: function() {
              var that = this;
              that.callBase.apply(that, arguments);
              if (that.isResizing()) {
                var overlayInstance = that._columnHeadersView.getFilterRangeOverlayInstance();
                if (overlayInstance) {
                  var cellIndex = overlayInstance.$element().closest("td").index();
                  if (cellIndex === that._targetPoint.columnIndex || cellIndex === that._targetPoint.columnIndex + 1) {
                    overlayInstance.$content().hide();
                  }
                }
              }
            },
            _endResizing: function() {
              var that = this;
              var $cell;
              if (that.isResizing()) {
                var overlayInstance = that._columnHeadersView.getFilterRangeOverlayInstance();
                if (overlayInstance) {
                  $cell = overlayInstance.$element().closest("td");
                  that._columnHeadersView._updateFilterRangeOverlay({
                    width: $cell.outerWidth(true) + CORRECT_FILTER_RANGE_OVERLAY_WIDTH
                  });
                  overlayInstance.$content().show();
                }
              }
              that.callBase.apply(that, arguments);
            }
          }
        },
        views: {
          columnHeadersView: ColumnHeadersViewFilterRowExtender,
          headerPanel: {
            _getToolbarItems: function() {
              var items = this.callBase();
              var filterItem = this._prepareFilterItem(items);
              return filterItem.concat(items);
            },
            _prepareFilterItem: function() {
              var that = this;
              var filterItem = [];
              if (that._isShowApplyFilterButton()) {
                var hintText = that.option("filterRow.applyFilterText");
                var columns = that._columnsController.getColumns();
                var disabled = !columns.filter(function(column) {
                  return void 0 !== column.bufferedFilterValue;
                }).length;
                var toolbarItem = {
                  widget: "dxButton",
                  options: {
                    icon: "apply-filter",
                    disabled,
                    onClick: function() {
                      that._applyFilterViewController.applyFilter();
                    },
                    hint: hintText,
                    text: hintText,
                    onInitialized: function(e) {
                      renderer_default(e.element).addClass(that._getToolbarButtonClass(APPLY_BUTTON_CLASS));
                    }
                  },
                  showText: "inMenu",
                  name: "applyFilterButton",
                  location: "after",
                  locateInMenu: "auto",
                  sortIndex: 10
                };
                filterItem.push(toolbarItem);
              }
              return filterItem;
            },
            _isShowApplyFilterButton: function() {
              var filterRowOptions = this.option("filterRow");
              return filterRowOptions && filterRowOptions.visible && "onClick" === filterRowOptions.applyFilter;
            },
            init: function() {
              this.callBase();
              this._dataController = this.getController("data");
              this._applyFilterViewController = this.getController("applyFilter");
            },
            enableApplyButton: function(value2) {
              this.setToolbarItemDisabled("applyFilterButton", !value2);
            },
            isVisible: function() {
              return this.callBase() || this._isShowApplyFilterButton();
            },
            optionChanged: function(args) {
              if ("filterRow" === args.name) {
                this._invalidate();
                args.handled = true;
              } else {
                this.callBase(args);
              }
            }
          }
        }
      }
    };
  }
});

// node_modules/devextreme/esm/ui/grid_core/ui.grid_core.header_filter_core.js
function resetChildrenItemSelection(items) {
  items = items || [];
  for (var i = 0; i < items.length; i++) {
    items[i].selected = false;
    resetChildrenItemSelection(items[i].items);
  }
}
function updateSelectAllState(e, filterValues) {
  if (e.component.option("searchValue")) {
    return;
  }
  var selectAllCheckBox = renderer_default(e.element).find(".dx-list-select-all-checkbox").data("dxCheckBox");
  if (selectAllCheckBox && filterValues && filterValues.length) {
    selectAllCheckBox.option("value", void 0);
  }
}
function isSearchEnabled(that, options2) {
  var headerFilter = options2.headerFilter;
  if (headerFilter && isDefined(headerFilter.allowSearch)) {
    return headerFilter.allowSearch;
  }
  return that.option("headerFilter.allowSearch");
}
function updateHeaderFilterItemSelectionState(item, filterValuesMatch, isExcludeFilter) {
  if (filterValuesMatch ^ isExcludeFilter) {
    item.selected = true;
    if (isExcludeFilter && item.items) {
      for (var j = 0; j < item.items.length; j++) {
        if (!item.items[j].selected) {
          item.selected = void 0;
          break;
        }
      }
    }
  } else if (isExcludeFilter || item.selected) {
    item.selected = false;
    resetChildrenItemSelection(item.items);
  }
}
var HEADER_FILTER_CLASS, HEADER_FILTER_MENU_CLASS, DEFAULT_SEARCH_EXPRESSION, HeaderFilterView, allowHeaderFiltering, headerFilterMixin;
var init_ui_grid_core_header_filter_core = __esm({
  "node_modules/devextreme/esm/ui/grid_core/ui.grid_core.header_filter_core.js"() {
    init_renderer();
    init_ui_grid_core_modules();
    init_ui_grid_core_utils();
    init_type();
    init_iterator();
    init_extend();
    init_popup();
    init_tree_view();
    init_list();
    HEADER_FILTER_CLASS = "dx-header-filter";
    HEADER_FILTER_MENU_CLASS = "dx-header-filter-menu";
    DEFAULT_SEARCH_EXPRESSION = "text";
    HeaderFilterView = ui_grid_core_modules_default.View.inherit({
      getPopupContainer: function() {
        return this._popupContainer;
      },
      getListContainer: function() {
        return this._listContainer;
      },
      applyHeaderFilter: function(options2) {
        var list = this.getListContainer();
        var searchValue = list.option("searchValue");
        var isSelectAll = !searchValue && !options2.isFilterBuilder && list.$element().find(".dx-checkbox").eq(0).hasClass("dx-checkbox-checked");
        var filterValues = [];
        if (!isSelectAll) {
          if ("tree" === options2.type) {
            if (options2.filterType) {
              options2.filterType = "include";
            }
            !function fillSelectedItemKeys(filterValues2, items, isExclude) {
              each(items, function(_2, item) {
                if (void 0 !== item.selected && !!item.selected ^ isExclude) {
                  var node = list._getNode(item);
                  var hasChildren = list._hasChildren(node);
                  var hasChildrenWithSelection = hasChildren && item.items && item.items.some((item2) => item2.selected);
                  if (!searchValue || !hasChildrenWithSelection) {
                    filterValues2.push(item.value);
                    return;
                  }
                }
                if (item.items && item.items.length) {
                  fillSelectedItemKeys(filterValues2, item.items, isExclude);
                }
              });
            }(filterValues, list.option("items"), false);
            options2.filterValues = filterValues;
          }
        } else {
          if ("tree" === options2.type) {
            options2.filterType = "exclude";
          }
          if (Array.isArray(options2.filterValues)) {
            options2.filterValues = [];
          }
        }
        if (options2.filterValues && !options2.filterValues.length) {
          options2.filterValues = null;
        }
        options2.apply();
        this.hideHeaderFilterMenu();
      },
      showHeaderFilterMenu: function($columnElement, options2) {
        if (options2) {
          this._initializePopupContainer(options2);
          var popupContainer = this.getPopupContainer();
          this.hideHeaderFilterMenu();
          this.updatePopup($columnElement, options2);
          popupContainer.show();
        }
      },
      hideHeaderFilterMenu: function() {
        var headerFilterMenu = this.getPopupContainer();
        headerFilterMenu && headerFilterMenu.hide();
      },
      updatePopup: function($element, options2) {
        var showColumnLines = this.option("showColumnLines");
        var alignment = "right" === options2.alignment ^ !showColumnLines ? "left" : "right";
        if (this._popupContainer) {
          this._cleanPopupContent();
          this._popupContainer.option("position", {
            my: alignment + " top",
            at: alignment + " bottom",
            of: $element,
            collision: "flip fit"
          });
        }
      },
      _getSearchExpr: function(options2) {
        var lookup = options2.lookup;
        var useDefaultSearchExpr = options2.useDefaultSearchExpr;
        var headerFilterDataSource = options2.headerFilter && options2.headerFilter.dataSource;
        if (useDefaultSearchExpr || isDefined(headerFilterDataSource) && !isFunction(headerFilterDataSource)) {
          return DEFAULT_SEARCH_EXPRESSION;
        }
        if (lookup) {
          return lookup.displayExpr || "this";
        }
        if (options2.dataSource) {
          var group = options2.dataSource.group;
          if (Array.isArray(group) && group.length > 0) {
            return group[0].selector;
          } else if (isFunction(group) && !options2.remoteFiltering) {
            return group;
          }
        }
        return options2.dataField || options2.selector;
      },
      _cleanPopupContent: function() {
        this._popupContainer && this._popupContainer.$content().empty();
      },
      _initializePopupContainer: function(options2) {
        var that = this;
        var $element = that.element();
        var headerFilterOptions = that.option("headerFilter");
        var width = options2.headerFilter && options2.headerFilter.width || headerFilterOptions && headerFilterOptions.width;
        var height = options2.headerFilter && options2.headerFilter.height || headerFilterOptions && headerFilterOptions.height;
        var dxPopupOptions = {
          width,
          height,
          visible: false,
          shading: false,
          showTitle: false,
          showCloseButton: false,
          closeOnTargetScroll: false,
          dragEnabled: false,
          closeOnOutsideClick: true,
          focusStateEnabled: false,
          toolbarItems: [{
            toolbar: "bottom",
            location: "after",
            widget: "dxButton",
            options: {
              text: headerFilterOptions.texts.ok,
              onClick: function() {
                that.applyHeaderFilter(options2);
              }
            }
          }, {
            toolbar: "bottom",
            location: "after",
            widget: "dxButton",
            options: {
              text: headerFilterOptions.texts.cancel,
              onClick: function() {
                that.hideHeaderFilterMenu();
              }
            }
          }],
          resizeEnabled: true,
          onShowing: function(e) {
            e.component.$content().parent().addClass("dx-dropdowneditor-overlay");
            that._initializeListContainer(options2);
            options2.onShowing && options2.onShowing(e);
          },
          onShown: function() {
            that.getListContainer().focus();
          },
          onHidden: options2.onHidden,
          onInitialized: function(e) {
            var component = e.component;
            component.option("animation", component._getDefaultOptions().animation);
          }
        };
        if (!isDefined(that._popupContainer)) {
          that._popupContainer = that._createComponent($element, popup_default, dxPopupOptions);
        } else {
          that._popupContainer.option(dxPopupOptions);
        }
      },
      _initializeListContainer: function(options2) {
        var that = this;
        var $content = that._popupContainer.$content();
        var widgetOptions = {
          searchEnabled: isSearchEnabled(that, options2),
          searchTimeout: that.option("headerFilter.searchTimeout"),
          searchMode: options2.headerFilter && options2.headerFilter.searchMode || "",
          dataSource: options2.dataSource,
          onContentReady: function() {
            that.renderCompleted.fire();
          },
          itemTemplate: function(data2, _2, element) {
            var $element = renderer_default(element);
            if (options2.encodeHtml) {
              return $element.text(data2.text);
            }
            return $element.html(data2.text);
          }
        };
        function onOptionChanged(e) {
          if ("searchValue" === e.fullName && !options2.isFilterBuilder && false !== that.option("headerFilter.hideSelectAllOnSearch")) {
            if ("tree" === options2.type) {
              e.component.option("showCheckBoxesMode", e.value ? "normal" : "selectAll");
            } else {
              e.component.option("selectionMode", e.value ? "multiple" : "all");
            }
          }
        }
        if ("tree" === options2.type) {
          that._listContainer = that._createComponent(renderer_default("<div>").appendTo($content), tree_view_default, extend2(widgetOptions, {
            showCheckBoxesMode: options2.isFilterBuilder ? "normal" : "selectAll",
            onOptionChanged,
            keyExpr: "id"
          }));
        } else {
          that._listContainer = that._createComponent(renderer_default("<div>").appendTo($content), list_default, extend2(widgetOptions, {
            searchExpr: that._getSearchExpr(options2),
            pageLoadMode: "scrollBottom",
            showSelectionControls: true,
            selectionMode: options2.isFilterBuilder ? "multiple" : "all",
            onOptionChanged,
            onSelectionChanged: function(e) {
              var items = e.component.option("items");
              var selectedItems = e.component.option("selectedItems");
              if (!e.component._selectedItemsUpdating && !e.component.option("searchValue") && !options2.isFilterBuilder) {
                var filterValues = options2.filterValues || [];
                var isExclude = "exclude" === options2.filterType;
                if (0 === selectedItems.length && items.length && (filterValues.length <= 1 || isExclude && filterValues.length === items.length - 1)) {
                  options2.filterType = "include";
                  options2.filterValues = [];
                } else if (selectedItems.length === items.length) {
                  options2.filterType = "exclude";
                  options2.filterValues = [];
                }
              }
              each(items, function(index2, item) {
                var selected = ui_grid_core_utils_default.getIndexByKey(item, selectedItems, null) >= 0;
                var oldSelected = !!item.selected;
                if (oldSelected !== selected) {
                  item.selected = selected;
                  options2.filterValues = options2.filterValues || [];
                  var filterValueIndex = ui_grid_core_utils_default.getIndexByKey(item.value, options2.filterValues, null);
                  if (filterValueIndex >= 0) {
                    options2.filterValues.splice(filterValueIndex, 1);
                  }
                  if (selected ^ "exclude" === options2.filterType) {
                    options2.filterValues.push(item.value);
                  }
                }
              });
              updateSelectAllState(e, options2.filterValues);
            },
            onContentReady: function(e) {
              var component = e.component;
              var items = component.option("items");
              var selectedItems = [];
              each(items, function() {
                if (this.selected) {
                  selectedItems.push(this);
                }
              });
              component._selectedItemsUpdating = true;
              component.option("selectedItems", selectedItems);
              component._selectedItemsUpdating = false;
              updateSelectAllState(e, options2.filterValues);
            }
          }));
        }
      },
      _renderCore: function() {
        this.element().addClass(HEADER_FILTER_MENU_CLASS);
      }
    });
    allowHeaderFiltering = function(column) {
      return isDefined(column.allowHeaderFiltering) ? column.allowHeaderFiltering : column.allowFiltering;
    };
    headerFilterMixin = {
      _applyColumnState: function(options2) {
        var $headerFilterIndicator;
        var rootElement = options2.rootElement;
        var column = options2.column;
        if ("headerFilter" === options2.name) {
          rootElement.find("." + HEADER_FILTER_CLASS).remove();
          if (allowHeaderFiltering(column)) {
            $headerFilterIndicator = this.callBase(options2).toggleClass("dx-header-filter-empty", this._isHeaderFilterEmpty(column));
            if (!this.option("useLegacyKeyboardNavigation")) {
              $headerFilterIndicator.attr("tabindex", this.option("tabindex") || 0);
            }
          }
          return $headerFilterIndicator;
        }
        return this.callBase(options2);
      },
      _isHeaderFilterEmpty: function(column) {
        return !column.filterValues || !column.filterValues.length;
      },
      _getIndicatorClassName: function(name2) {
        if ("headerFilter" === name2) {
          return HEADER_FILTER_CLASS;
        }
        return this.callBase(name2);
      },
      _renderIndicator: function(options2) {
        var $container = options2.container;
        var $indicator = options2.indicator;
        if ("headerFilter" === options2.name) {
          var rtlEnabled = this.option("rtlEnabled");
          if ($container.children().length && (!rtlEnabled && "right" === options2.columnAlignment || rtlEnabled && "left" === options2.columnAlignment)) {
            $container.prepend($indicator);
            return;
          }
        }
        this.callBase(options2);
      },
      optionChanged: function(args) {
        if ("headerFilter" === args.name) {
          var requireReady = "columnHeadersView" === this.name;
          this._invalidate(requireReady, requireReady);
          args.handled = true;
        } else {
          this.callBase(args);
        }
      }
    };
  }
});

// node_modules/devextreme/esm/ui/grid_core/ui.grid_core.header_filter.js
function ungroupUTCDates(items, dateParts, dates) {
  dateParts = dateParts || [];
  dates = dates || [];
  items.forEach((item) => {
    if (isDefined(item.key)) {
      var isMonthPart = 1 === dateParts.length;
      dateParts.push(isMonthPart ? item.key - 1 : item.key);
      if (item.items) {
        ungroupUTCDates(item.items, dateParts, dates);
      } else {
        var date = new Date(Date.UTC.apply(Date, dateParts));
        dates.push(date);
      }
      dateParts.pop();
    } else {
      dates.push(null);
    }
  });
  return dates;
}
function convertDataFromUTCToLocal(data2, column) {
  var dates = ungroupUTCDates(data2);
  var query2 = query_default(dates);
  var group = ui_grid_core_utils_default.getHeaderFilterGroupParameters(_extends({}, column, {
    calculateCellValue: (date) => date
  }));
  return store_helper_default.queryByOptions(query2, {
    group
  }).toArray();
}
function isUTCFormat(format2) {
  return "Z" === (null === format2 || void 0 === format2 ? void 0 : format2.slice(-1)) || "'Z'" === (null === format2 || void 0 === format2 ? void 0 : format2.slice(-3));
}
var DATE_INTERVAL_FORMATS, HeaderFilterController, ColumnHeadersViewHeaderFilterExtender, HeaderPanelHeaderFilterExtender, DataControllerFilterRowExtender2, headerFilterModule;
var init_ui_grid_core_header_filter = __esm({
  "node_modules/devextreme/esm/ui/grid_core/ui.grid_core.header_filter.js"() {
    init_extends();
    init_events_engine();
    init_ui_grid_core_modules();
    init_filtering();
    init_ui_grid_core_utils();
    init_ui_grid_core_header_filter_core();
    init_message();
    init_click();
    init_data();
    init_iterator();
    init_type();
    init_position();
    init_extend();
    init_utils5();
    init_date3();
    init_variable_wrapper();
    init_deferred();
    init_accessibility();
    init_query();
    init_store_helper();
    DATE_INTERVAL_FORMATS = {
      month: function(value2) {
        return date_default3.getMonthNames()[value2 - 1];
      },
      quarter: function(value2) {
        return date_default3.format(new Date(2e3, 3 * value2 - 1), "quarter");
      }
    };
    HeaderFilterController = ui_grid_core_modules_default.ViewController.inherit({
      init: function() {
        this._columnsController = this.getController("columns");
        this._dataController = this.getController("data");
        this._headerFilterView = this.getView("headerFilterView");
      },
      _updateSelectedState: function(items, column) {
        var i = items.length;
        var isExclude = "exclude" === column.filterType;
        while (i--) {
          var item = items[i];
          if ("items" in items[i]) {
            this._updateSelectedState(items[i].items, column);
          }
          updateHeaderFilterItemSelectionState(item, ui_grid_core_utils_default.getIndexByKey(items[i].value, column.filterValues, null) > -1, isExclude);
        }
      },
      _normalizeGroupItem: function(item, currentLevel, options2) {
        var value2;
        var displayValue;
        var path = options2.path;
        var valueSelector = options2.valueSelector;
        var displaySelector = options2.displaySelector;
        var column = options2.column;
        if (valueSelector && displaySelector) {
          value2 = valueSelector(item);
          displayValue = displaySelector(item);
        } else {
          value2 = item.key;
          displayValue = value2;
        }
        if (!isObject2(item)) {
          item = {};
        } else {
          item = extend2({}, item);
        }
        path.push(value2);
        if (1 === path.length) {
          item.value = path[0];
        } else {
          item.value = path.join("/");
        }
        item.text = this.getHeaderItemText(displayValue, column, currentLevel, options2.headerFilterOptions);
        return item;
      },
      getHeaderItemText: function(displayValue, column, currentLevel, headerFilterOptions) {
        var text = ui_grid_core_utils_default.formatValue(displayValue, function(value2, column2, currentLevel2) {
          var groupInterval = filtering_default.getGroupInterval(column2);
          var result2 = ui_grid_core_utils_default.getFormatOptionsByColumn(column2, "headerFilter");
          if (groupInterval) {
            result2.groupInterval = groupInterval[currentLevel2];
            if (ui_grid_core_utils_default.isDateType(column2.dataType)) {
              result2.format = DATE_INTERVAL_FORMATS[groupInterval[currentLevel2]];
            } else if ("number" === column2.dataType) {
              result2.getDisplayFormat = function() {
                var formatOptions = {
                  format: column2.format,
                  target: "headerFilter"
                };
                var firstValueText = ui_grid_core_utils_default.formatValue(value2, formatOptions);
                var secondValue = value2 + groupInterval[currentLevel2];
                var secondValueText = ui_grid_core_utils_default.formatValue(secondValue, formatOptions);
                return firstValueText && secondValueText ? firstValueText + " - " + secondValueText : "";
              };
            }
          }
          return result2;
        }(displayValue, column, currentLevel));
        if (!text) {
          text = headerFilterOptions.texts.emptyValue;
        }
        return text;
      },
      _processGroupItems: function(groupItems, currentLevel, path, options2) {
        var displaySelector;
        var valueSelector;
        var column = options2.column;
        var lookup = column.lookup;
        var level = options2.level;
        path = path || [];
        currentLevel = currentLevel || 0;
        if (lookup) {
          displaySelector = compileGetter(lookup.displayExpr);
          valueSelector = compileGetter(lookup.valueExpr);
        }
        for (var i = 0; i < groupItems.length; i++) {
          groupItems[i] = this._normalizeGroupItem(groupItems[i], currentLevel, {
            column: options2.column,
            headerFilterOptions: options2.headerFilterOptions,
            displaySelector,
            valueSelector,
            path
          });
          if ("items" in groupItems[i]) {
            if (currentLevel === level || !isDefined(groupItems[i].value)) {
              delete groupItems[i].items;
            } else {
              this._processGroupItems(groupItems[i].items, currentLevel + 1, path, options2);
            }
          }
          path.pop();
        }
      },
      getDataSource: function(column) {
        var _column$headerFilter;
        var that = this;
        var dataSource = that._dataController.dataSource();
        var remoteGrouping = null === dataSource || void 0 === dataSource ? void 0 : dataSource.remoteOperations().grouping;
        var group = ui_grid_core_utils_default.getHeaderFilterGroupParameters(column, remoteGrouping);
        var headerFilterDataSource = null === (_column$headerFilter = column.headerFilter) || void 0 === _column$headerFilter ? void 0 : _column$headerFilter.dataSource;
        var headerFilterOptions = that.option("headerFilter");
        var isLookup = false;
        var options2 = {
          component: that.component
        };
        if (!dataSource) {
          return;
        }
        if (isDefined(headerFilterDataSource) && !isFunction(headerFilterDataSource)) {
          options2.dataSource = normalizeDataSourceOptions(headerFilterDataSource);
        } else if (column.lookup) {
          isLookup = true;
          var lookupDataSourceOptions;
          if (column.lookup.items) {
            lookupDataSourceOptions = column.lookup.items;
          } else {
            lookupDataSourceOptions = column.lookup.dataSource;
            if (isFunction(lookupDataSourceOptions) && !variable_wrapper_default.isWrapped(lookupDataSourceOptions)) {
              lookupDataSourceOptions = lookupDataSourceOptions({});
            }
          }
          options2.dataSource = normalizeDataSourceOptions(lookupDataSourceOptions);
        } else {
          var cutoffLevel = Array.isArray(group) ? group.length - 1 : 0;
          that._currentColumn = column;
          var filter = that._dataController.getCombinedFilter();
          that._currentColumn = null;
          options2.dataSource = {
            filter,
            group,
            useDefaultSearch: true,
            load: function(options3) {
              var d = new Deferred();
              options3.dataField = column.dataField || column.name;
              dataSource.load(options3).done(function(data2) {
                var convertUTCDates = remoteGrouping && isUTCFormat(column.serializationFormat) && cutoffLevel > 3;
                if (convertUTCDates) {
                  data2 = convertDataFromUTCToLocal(data2, column);
                }
                that._processGroupItems(data2, null, null, {
                  level: cutoffLevel,
                  column,
                  headerFilterOptions
                });
                d.resolve(data2);
              }).fail(d.reject);
              return d;
            }
          };
        }
        if (isFunction(headerFilterDataSource)) {
          headerFilterDataSource.call(column, options2);
        }
        var origPostProcess = options2.dataSource.postProcess;
        options2.dataSource.postProcess = function(data2) {
          var items = data2;
          if (isLookup) {
            if (0 === this.pageIndex() && !this.searchValue()) {
              items = items.slice(0);
              items.unshift(null);
            }
            that._processGroupItems(items, null, null, {
              level: 0,
              column,
              headerFilterOptions
            });
          }
          items = origPostProcess && origPostProcess.call(this, items) || items;
          that._updateSelectedState(items, column);
          return items;
        };
        return options2.dataSource;
      },
      getCurrentColumn: function() {
        return this._currentColumn;
      },
      showHeaderFilterMenu: function(columnIndex, isGroupPanel) {
        var columnsController = this._columnsController;
        var column = extend2(true, {}, this._columnsController.getColumns()[columnIndex]);
        if (column) {
          var visibleIndex = columnsController.getVisibleIndex(columnIndex);
          var view = isGroupPanel ? this.getView("headerPanel") : this.getView("columnHeadersView");
          var $columnElement = $columnElement || view.getColumnElements().eq(isGroupPanel ? column.groupIndex : visibleIndex);
          this.showHeaderFilterMenuBase({
            columnElement: $columnElement,
            column,
            applyFilter: true,
            apply: function() {
              columnsController.columnOption(columnIndex, {
                filterValues: this.filterValues,
                filterType: this.filterType
              });
            }
          });
        }
      },
      showHeaderFilterMenuBase: function(options2) {
        var that = this;
        var column = options2.column;
        if (column) {
          var groupInterval = filtering_default.getGroupInterval(column);
          var dataSource = that._dataController.dataSource();
          var remoteFiltering = dataSource && dataSource.remoteOperations().filtering;
          extend2(options2, column, {
            type: groupInterval && groupInterval.length > 1 ? "tree" : "list",
            remoteFiltering,
            onShowing: function(e) {
              var dxResizableInstance = e.component.$overlayContent().dxResizable("instance");
              dxResizableInstance && dxResizableInstance.option("onResizeEnd", function(e2) {
                var columnsController = that.getController("columns");
                var headerFilterByColumn = columnsController.columnOption(options2.dataField, "headerFilter");
                headerFilterByColumn = headerFilterByColumn || {};
                headerFilterByColumn.width = e2.width;
                headerFilterByColumn.height = e2.height;
                columnsController.columnOption(options2.dataField, "headerFilter", headerFilterByColumn, true);
              });
            },
            onHidden: () => restoreFocus(this)
          });
          options2.dataSource = that.getDataSource(options2);
          if (options2.isFilterBuilder) {
            options2.dataSource.filter = null;
            options2.alignment = "right";
          }
          that._headerFilterView.showHeaderFilterMenu(options2.columnElement, options2);
        }
      },
      hideHeaderFilterMenu: function() {
        this._headerFilterView.hideHeaderFilterMenu();
      }
    });
    ColumnHeadersViewHeaderFilterExtender = extend2({}, headerFilterMixin, {
      _renderCellContent: function($cell, options2) {
        var $headerFilterIndicator;
        var column = options2.column;
        if (!column.command && allowHeaderFiltering(column) && this.option("headerFilter.visible") && "header" === options2.rowType) {
          $headerFilterIndicator = this._applyColumnState({
            name: "headerFilter",
            rootElement: $cell,
            column,
            showColumnLines: this.option("showColumnLines")
          });
          $headerFilterIndicator && this._subscribeToIndicatorEvent($headerFilterIndicator, column, "headerFilter");
        }
        this.callBase($cell, options2);
      },
      _subscribeToIndicatorEvent: function($indicator, column, indicatorName) {
        var that = this;
        if ("headerFilter" === indicatorName) {
          events_engine_default.on($indicator, CLICK_EVENT_NAME, that.createAction(function(e) {
            e.event.stopPropagation();
            that.getController("headerFilter").showHeaderFilterMenu(column.index, false);
          }));
        }
      },
      _updateIndicator: function($cell, column, indicatorName) {
        var $indicator = this.callBase($cell, column, indicatorName);
        $indicator && this._subscribeToIndicatorEvent($indicator, column, indicatorName);
      },
      _updateHeaderFilterIndicators: function() {
        if (this.option("headerFilter.visible")) {
          this._updateIndicators("headerFilter");
        }
      },
      _needUpdateFilterIndicators: function() {
        return true;
      },
      _columnOptionChanged: function(e) {
        var optionNames = e.optionNames;
        if (ui_grid_core_utils_default.checkChanges(optionNames, ["filterValues", "filterType"])) {
          if (this._needUpdateFilterIndicators()) {
            this._updateHeaderFilterIndicators();
          }
          return;
        }
        this.callBase(e);
      }
    });
    HeaderPanelHeaderFilterExtender = extend2({}, headerFilterMixin, {
      _createGroupPanelItem: function($rootElement, groupColumn) {
        var that = this;
        var $item = that.callBase.apply(that, arguments);
        var $headerFilterIndicator;
        if (!groupColumn.command && allowHeaderFiltering(groupColumn) && that.option("headerFilter.visible")) {
          $headerFilterIndicator = that._applyColumnState({
            name: "headerFilter",
            rootElement: $item,
            column: {
              alignment: getDefaultAlignment(that.option("rtlEnabled")),
              filterValues: groupColumn.filterValues,
              allowHeaderFiltering: true
            },
            showColumnLines: true
          });
          $headerFilterIndicator && events_engine_default.on($headerFilterIndicator, CLICK_EVENT_NAME, that.createAction(function(e) {
            var event = e.event;
            event.stopPropagation();
            that.getController("headerFilter").showHeaderFilterMenu(groupColumn.index, true);
          }));
        }
        return $item;
      }
    });
    DataControllerFilterRowExtender2 = {
      skipCalculateColumnFilters: function() {
        return false;
      },
      _calculateAdditionalFilter: function() {
        if (this.skipCalculateColumnFilters()) {
          return this.callBase();
        }
        var filters = [this.callBase()];
        var columns = this._columnsController.getVisibleColumns(null, true);
        var headerFilterController = this.getController("headerFilter");
        var currentColumn = headerFilterController.getCurrentColumn();
        each(columns, function(_2, column) {
          var filter;
          if (currentColumn && currentColumn.index === column.index) {
            return;
          }
          if (allowHeaderFiltering(column) && column.calculateFilterExpression && Array.isArray(column.filterValues) && column.filterValues.length) {
            var filterValues = [];
            each(column.filterValues, function(_3, filterValue) {
              if (Array.isArray(filterValue)) {
                filter = filterValue;
              } else {
                if (column.deserializeValue && !ui_grid_core_utils_default.isDateType(column.dataType) && "number" !== column.dataType) {
                  filterValue = column.deserializeValue(filterValue);
                }
                filter = column.createFilterExpression(filterValue, "=", "headerFilter");
              }
              if (filter) {
                filter.columnIndex = column.index;
              }
              filterValues.push(filter);
            });
            filterValues = ui_grid_core_utils_default.combineFilters(filterValues, "or");
            filters.push("exclude" === column.filterType ? ["!", filterValues] : filterValues);
          }
        });
        return ui_grid_core_utils_default.combineFilters(filters);
      }
    };
    headerFilterModule = {
      defaultOptions: function() {
        return {
          headerFilter: {
            visible: false,
            width: 252,
            height: 325,
            allowSearch: false,
            searchTimeout: 500,
            texts: {
              emptyValue: message_default.format("dxDataGrid-headerFilterEmptyValue"),
              ok: message_default.format("dxDataGrid-headerFilterOK"),
              cancel: message_default.format("dxDataGrid-headerFilterCancel")
            }
          }
        };
      },
      controllers: {
        headerFilter: HeaderFilterController
      },
      views: {
        headerFilterView: HeaderFilterView
      },
      extenders: {
        controllers: {
          data: DataControllerFilterRowExtender2
        },
        views: {
          columnHeadersView: ColumnHeadersViewHeaderFilterExtender,
          headerPanel: HeaderPanelHeaderFilterExtender
        }
      }
    };
  }
});

// node_modules/devextreme/esm/ui/filter_builder/between.js
function editorTemplate(conditionInfo, container) {
  var $editorStart = renderer_default("<div>").addClass(FILTER_BUILDER_RANGE_START_CLASS);
  var $editorEnd = renderer_default("<div>").addClass(FILTER_BUILDER_RANGE_END_CLASS);
  var values = conditionInfo.value || [];
  var getStartValue = function(values2) {
    return values2 && values2.length > 0 ? values2[0] : null;
  };
  var getEndValue = function(values2) {
    return values2 && 2 === values2.length ? values2[1] : null;
  };
  container.append($editorStart);
  container.append(renderer_default("<span>").addClass(FILTER_BUILDER_RANGE_SEPARATOR_CLASS).text(SEPARATOR));
  container.append($editorEnd);
  container.addClass(FILTER_BUILDER_RANGE_CLASS);
  this._editorFactory.createEditor.call(this, $editorStart, extend2({}, conditionInfo.field, conditionInfo, {
    value: getStartValue(values),
    parentType: "filterBuilder",
    setValue: function(value2) {
      values = [value2, getEndValue(values)];
      conditionInfo.setValue(values);
    }
  }));
  this._editorFactory.createEditor.call(this, $editorEnd, extend2({}, conditionInfo.field, conditionInfo, {
    value: getEndValue(values),
    parentType: "filterBuilder",
    setValue: function(value2) {
      values = [getStartValue(values), value2];
      conditionInfo.setValue(values);
    }
  }));
}
function getConfig(caption, context2) {
  return {
    name: "between",
    caption,
    icon: "range",
    valueSeparator: SEPARATOR,
    dataTypes: ["number", "date", "datetime"],
    editorTemplate: editorTemplate.bind(context2),
    notForLookup: true
  };
}
var FILTER_BUILDER_RANGE_CLASS, FILTER_BUILDER_RANGE_START_CLASS, FILTER_BUILDER_RANGE_END_CLASS, FILTER_BUILDER_RANGE_SEPARATOR_CLASS, SEPARATOR;
var init_between = __esm({
  "node_modules/devextreme/esm/ui/filter_builder/between.js"() {
    init_renderer();
    init_extend();
    FILTER_BUILDER_RANGE_CLASS = "dx-filterbuilder-range";
    FILTER_BUILDER_RANGE_START_CLASS = FILTER_BUILDER_RANGE_CLASS + "-start";
    FILTER_BUILDER_RANGE_END_CLASS = FILTER_BUILDER_RANGE_CLASS + "-end";
    FILTER_BUILDER_RANGE_SEPARATOR_CLASS = FILTER_BUILDER_RANGE_CLASS + "-separator";
    SEPARATOR = "";
  }
});

// node_modules/devextreme/esm/ui/filter_builder/ui.filter_operations_dictionary.js
var OPERATION_ICONS2, OPERATION_NAME, ui_filter_operations_dictionary_default;
var init_ui_filter_operations_dictionary = __esm({
  "node_modules/devextreme/esm/ui/filter_builder/ui.filter_operations_dictionary.js"() {
    OPERATION_ICONS2 = {
      "=": "equal",
      "<>": "notequal",
      "<": "less",
      "<=": "lessorequal",
      ">": "greater",
      ">=": "greaterorequal",
      notcontains: "doesnotcontain",
      contains: "contains",
      startswith: "startswith",
      endswith: "endswith",
      isblank: "isblank",
      isnotblank: "isnotblank"
    };
    OPERATION_NAME = {
      "=": "equal",
      "<>": "notEqual",
      "<": "lessThan",
      "<=": "lessThanOrEqual",
      ">": "greaterThan",
      ">=": "greaterThanOrEqual",
      startswith: "startsWith",
      contains: "contains",
      notcontains: "notContains",
      endswith: "endsWith",
      isblank: "isBlank",
      isnotblank: "isNotBlank",
      between: "between"
    };
    ui_filter_operations_dictionary_default = {
      getIconByFilterOperation: function(filterOperation) {
        return OPERATION_ICONS2[filterOperation];
      },
      getNameByFilterOperation: function(filterOperation) {
        return OPERATION_NAME[filterOperation];
      }
    };
  }
});

// node_modules/devextreme/esm/ui/filter_builder/utils.js
function getFormattedValueText(field, value2) {
  var fieldFormat = field.format || DEFAULT_FORMAT[field.dataType];
  return format_helper_default.format(value2, fieldFormat);
}
function isNegationGroup(group) {
  return group && group.length > 1 && "!" === group[0] && !isCondition(group);
}
function getGroupCriteria(group) {
  return isNegationGroup(group) ? group[1] : group;
}
function setGroupCriteria(group, criteria) {
  if (isNegationGroup(group)) {
    group[1] = criteria;
  } else {
    group = criteria;
  }
  return group;
}
function convertGroupToNewStructure(group, value2) {
  if (function(value3) {
    return -1 !== value3.indexOf("!");
  }(value2)) {
    if (!isNegationGroup(group)) {
      !function(group2) {
        var criteria = group2.slice(0);
        group2.length = 0;
        group2.push("!", criteria);
      }(group);
    }
  } else if (isNegationGroup(group)) {
    !function(group2) {
      var criteria = getGroupCriteria(group2);
      group2.length = 0;
      [].push.apply(group2, criteria);
    }(group);
  }
}
function setGroupValue(group, value2) {
  convertGroupToNewStructure(group, value2);
  var criteria = getGroupCriteria(group);
  var i;
  value2 = function(value3) {
    return -1 === value3.indexOf("!") ? value3 : value3.substring(1);
  }(value2);
  !function(criteria2, value3) {
    for (i = 0; i < criteria2.length; i++) {
      if (!Array.isArray(criteria2[i])) {
        criteria2[i] = value3;
      }
    }
  }(criteria, value2);
  return group;
}
function getGroupMenuItem(group, availableGroups) {
  var groupValue = getGroupValue(group);
  return availableGroups.filter(function(item) {
    return item.value === groupValue;
  })[0];
}
function getCriteriaOperation(criteria) {
  if (isCondition(criteria)) {
    return AND_GROUP_OPERATION;
  }
  var value2 = "";
  for (var i = 0; i < criteria.length; i++) {
    var item = criteria[i];
    if (!Array.isArray(item)) {
      if (value2 && value2 !== item) {
        throw new errors.Error("E4019");
      }
      if ("!" !== item) {
        value2 = item;
      }
    }
  }
  return value2;
}
function getGroupValue(group) {
  var criteria = getGroupCriteria(group);
  var value2 = getCriteriaOperation(criteria);
  if (!value2) {
    value2 = AND_GROUP_OPERATION;
  }
  if (criteria !== group) {
    value2 = "!" + value2;
  }
  return value2;
}
function getDefaultFilterOperations(field) {
  return field.lookup && LOOKUP_OPERATIONS || DATATYPE_OPERATIONS[field.dataType || DEFAULT_DATA_TYPE];
}
function containItems(entity) {
  return Array.isArray(entity) && entity.length;
}
function getFilterOperations(field) {
  var result2 = containItems(field.filterOperations) ? field.filterOperations : getDefaultFilterOperations(field);
  return extend2([], result2);
}
function getCaptionByOperation(operation, filterOperationDescriptions) {
  var operationName = ui_filter_operations_dictionary_default.getNameByFilterOperation(operation);
  return filterOperationDescriptions && filterOperationDescriptions[operationName] ? filterOperationDescriptions[operationName] : operationName;
}
function getOperationFromAvailable(operation, availableOperations) {
  for (var i = 0; i < availableOperations.length; i++) {
    if (availableOperations[i].value === operation) {
      return availableOperations[i];
    }
  }
  throw new ui_errors_default.Error("E1048", operation);
}
function getCustomOperation(customOperations, name2) {
  var filteredOperations = customOperations.filter(function(item) {
    return item.name === name2;
  });
  return filteredOperations.length ? filteredOperations[0] : null;
}
function getAvailableOperations(field, filterOperationDescriptions, customOperations) {
  var filterOperations = getFilterOperations(field);
  var isLookupField = !!field.lookup;
  customOperations.forEach(function(customOperation) {
    if (!field.filterOperations && -1 === filterOperations.indexOf(customOperation.name)) {
      var dataTypes = customOperation && customOperation.dataTypes;
      var isOperationForbidden = isLookupField ? !!customOperation.notForLookup : false;
      if (!isOperationForbidden && dataTypes && dataTypes.indexOf(field.dataType || DEFAULT_DATA_TYPE) >= 0) {
        filterOperations.push(customOperation.name);
      }
    }
  });
  return filterOperations.map(function(operation) {
    var customOperation = getCustomOperation(customOperations, operation);
    if (customOperation) {
      return {
        icon: customOperation.icon || EMPTY_MENU_ICON,
        text: customOperation.caption || captionize(customOperation.name),
        value: customOperation.name,
        isCustom: true
      };
    } else {
      return {
        icon: ui_filter_operations_dictionary_default.getIconByFilterOperation(operation) || EMPTY_MENU_ICON,
        text: getCaptionByOperation(operation, filterOperationDescriptions),
        value: operation
      };
    }
  });
}
function getDefaultOperation(field) {
  return field.defaultFilterOperation || getFilterOperations(field)[0];
}
function createCondition(field, customOperations) {
  var condition = [field.dataField, "", ""];
  var filterOperation = getDefaultOperation(field);
  updateConditionByOperation(condition, filterOperation, customOperations);
  return condition;
}
function removeItem(group, item) {
  var criteria = getGroupCriteria(group);
  var index2 = criteria.indexOf(item);
  criteria.splice(index2, 1);
  if (1 !== criteria.length) {
    criteria.splice(index2, 1);
  }
  return group;
}
function createEmptyGroup(value2) {
  var isNegation = isNegationGroupOperation(value2);
  var groupOperation = isNegation ? getGroupOperationFromNegationOperation(value2) : value2;
  return isNegation ? ["!", [groupOperation]] : [groupOperation];
}
function addItem(item, group) {
  var criteria = getGroupCriteria(group);
  var groupValue = getGroupValue(criteria);
  1 === criteria.length ? criteria.unshift(item) : criteria.push(item, groupValue);
  return group;
}
function getField(dataField, fields) {
  for (var i = 0; i < fields.length; i++) {
    if (fields[i].name === dataField) {
      return fields[i];
    }
    if (fields[i].dataField.toLowerCase() === dataField.toLowerCase()) {
      return fields[i];
    }
  }
  var extendedFields = getItems2(fields, true).filter(function(item) {
    return item.dataField.toLowerCase() === dataField.toLowerCase();
  });
  if (extendedFields.length > 0) {
    return extendedFields[0];
  }
  throw new ui_errors_default.Error("E1047", dataField);
}
function isGroup(criteria) {
  if (!Array.isArray(criteria)) {
    return false;
  }
  return criteria.length < 2 || Array.isArray(criteria[0]) || Array.isArray(criteria[1]);
}
function isCondition(criteria) {
  if (!Array.isArray(criteria)) {
    return false;
  }
  return criteria.length > 1 && !Array.isArray(criteria[0]) && !Array.isArray(criteria[1]);
}
function convertToInnerGroup(group, customOperations, defaultGroupOperation) {
  defaultGroupOperation = defaultGroupOperation || AND_GROUP_OPERATION;
  var groupOperation = getCriteriaOperation(group).toLowerCase() || defaultGroupOperation;
  var innerGroup = [];
  for (var i = 0; i < group.length; i++) {
    if (isGroup(group[i])) {
      innerGroup.push(convertToInnerStructure(group[i], customOperations, defaultGroupOperation));
      innerGroup = appendGroupOperationToGroup(innerGroup, groupOperation);
    } else if (isCondition(group[i])) {
      innerGroup.push(convertToInnerCondition(group[i], customOperations));
      innerGroup = appendGroupOperationToGroup(innerGroup, groupOperation);
    }
  }
  if (0 === innerGroup.length) {
    innerGroup = appendGroupOperationToGroup(innerGroup, groupOperation);
  }
  return innerGroup;
}
function conditionHasCustomOperation(condition, customOperations) {
  var customOperation = getCustomOperation(customOperations, condition[1]);
  return customOperation && customOperation.name === condition[1];
}
function convertToInnerCondition(condition, customOperations) {
  if (conditionHasCustomOperation(condition, customOperations)) {
    return condition;
  }
  if (condition.length < 3) {
    condition[2] = condition[1];
    condition[1] = EQUAL_OPERATION;
  }
  return condition;
}
function isNegationGroupOperation(operation) {
  return -1 !== operation.indexOf("not");
}
function getGroupOperationFromNegationOperation(operation) {
  return operation.substring(3).toLowerCase();
}
function appendGroupOperationToCriteria(criteria, groupOperation) {
  var isNegation = isNegationGroupOperation(groupOperation);
  groupOperation = isNegation ? getGroupOperationFromNegationOperation(groupOperation) : groupOperation;
  return isNegation ? ["!", criteria, groupOperation] : [criteria, groupOperation];
}
function appendGroupOperationToGroup(group, groupOperation) {
  var isNegation = isNegationGroupOperation(groupOperation);
  groupOperation = isNegation ? getGroupOperationFromNegationOperation(groupOperation) : groupOperation;
  group.push(groupOperation);
  var result2 = group;
  if (isNegation) {
    result2 = ["!", result2];
  }
  return result2;
}
function convertToInnerStructure(value2, customOperations, defaultGroupOperation) {
  defaultGroupOperation = defaultGroupOperation || AND_GROUP_OPERATION;
  if (!value2) {
    return createEmptyGroup(defaultGroupOperation);
  }
  value2 = extend2(true, [], value2);
  if (isCondition(value2)) {
    return appendGroupOperationToCriteria(convertToInnerCondition(value2, customOperations), defaultGroupOperation);
  }
  if (isNegationGroup(value2)) {
    return ["!", isCondition(value2[1]) ? appendGroupOperationToCriteria(convertToInnerCondition(value2[1], customOperations), defaultGroupOperation) : isNegationGroup(value2[1]) ? appendGroupOperationToCriteria(convertToInnerStructure(value2[1], customOperations), defaultGroupOperation) : convertToInnerGroup(value2[1], customOperations, defaultGroupOperation)];
  }
  return convertToInnerGroup(value2, customOperations, defaultGroupOperation);
}
function getNormalizedFields(fields) {
  return fields.reduce(function(result2, field) {
    if (isDefined(field.dataField)) {
      var normalizedField = {};
      for (var key in field) {
        if (field[key] && AVAILABLE_FIELD_PROPERTIES.indexOf(key) > -1) {
          normalizedField[key] = field[key];
        }
      }
      normalizedField.defaultCalculateFilterExpression = filtering_default.defaultCalculateFilterExpression;
      if (!isDefined(normalizedField.dataType)) {
        normalizedField.dataType = DEFAULT_DATA_TYPE;
      }
      if (!isDefined(normalizedField.trueText)) {
        normalizedField.trueText = message_default.format("dxDataGrid-trueText");
      }
      if (!isDefined(normalizedField.falseText)) {
        normalizedField.falseText = message_default.format("dxDataGrid-falseText");
      }
      result2.push(normalizedField);
    }
    return result2;
  }, []);
}
function getConditionFilterExpression(condition, fields, customOperations, target) {
  var field = getField(condition[0], fields);
  var filterExpression = convertToInnerCondition(condition, customOperations);
  var customOperation = customOperations.length && getCustomOperation(customOperations, filterExpression[1]);
  if (customOperation && customOperation.calculateFilterExpression) {
    return customOperation.calculateFilterExpression.apply(customOperation, [filterExpression[2], field, fields]);
  } else if (field.createFilterExpression) {
    return field.createFilterExpression.apply(field, [filterExpression[2], filterExpression[1], target]);
  } else if (field.calculateFilterExpression) {
    return field.calculateFilterExpression.apply(field, [filterExpression[2], filterExpression[1], target]);
  } else {
    return field.defaultCalculateFilterExpression.apply(field, [filterExpression[2], filterExpression[1], target]);
  }
}
function getFilterExpression(value2, fields, customOperations, target) {
  if (!isDefined(value2)) {
    return null;
  }
  if (isNegationGroup(value2)) {
    var filterExpression = getFilterExpression(value2[1], fields, customOperations, target);
    return ["!", filterExpression];
  }
  var criteria = getGroupCriteria(value2);
  if (isCondition(criteria)) {
    return getConditionFilterExpression(criteria, fields, customOperations, target) || null;
  } else {
    var result2 = [];
    var _filterExpression;
    var groupValue = getGroupValue(criteria);
    for (var i = 0; i < criteria.length; i++) {
      if (isGroup(criteria[i])) {
        _filterExpression = getFilterExpression(criteria[i], fields, customOperations, target);
        if (_filterExpression) {
          i && result2.push(groupValue);
          result2.push(_filterExpression);
        }
      } else if (isCondition(criteria[i])) {
        _filterExpression = getConditionFilterExpression(criteria[i], fields, customOperations, target);
        if (_filterExpression) {
          result2.length && result2.push(groupValue);
          result2.push(_filterExpression);
        }
      }
    }
    if (1 === result2.length) {
      result2 = result2[0];
    }
    return result2.length ? result2 : null;
  }
}
function getNormalizedFilter(group) {
  var criteria = getGroupCriteria(group);
  var i;
  if (0 === criteria.length) {
    return null;
  }
  var itemsForRemove = [];
  for (i = 0; i < criteria.length; i++) {
    if (isGroup(criteria[i])) {
      var normalizedGroupValue = getNormalizedFilter(criteria[i]);
      if (normalizedGroupValue) {
        criteria[i] = normalizedGroupValue;
      } else {
        itemsForRemove.push(criteria[i]);
      }
    } else if (isCondition(criteria[i])) {
      if (!isValidCondition(criteria[i])) {
        itemsForRemove.push(criteria[i]);
      }
    }
  }
  for (i = 0; i < itemsForRemove.length; i++) {
    removeItem(criteria, itemsForRemove[i]);
  }
  if (1 === criteria.length) {
    return null;
  }
  criteria.splice(criteria.length - 1, 1);
  if (1 === criteria.length) {
    group = setGroupCriteria(group, criteria[0]);
  }
  if (0 === group.length) {
    return null;
  }
  return group;
}
function getCurrentLookupValueText(field, value2, handler) {
  if ("" === value2) {
    handler("");
    return;
  }
  var lookup = field.lookup;
  if (lookup.items) {
    handler(lookup.calculateCellValue(value2) || "");
  } else {
    var lookupDataSource = isFunction(lookup.dataSource) ? lookup.dataSource({}) : lookup.dataSource;
    var dataSource = new DataSource(lookupDataSource);
    dataSource.loadSingle(lookup.valueExpr, value2).done(function(result2) {
      var valueText = "";
      if (result2) {
        valueText = lookup.displayExpr ? compileGetter(lookup.displayExpr)(result2) : result2;
      }
      if (field.customizeText) {
        valueText = field.customizeText({
          value: value2,
          valueText
        });
      }
      handler(valueText);
    }).fail(function() {
      handler("");
    });
  }
}
function getPrimitiveValueText(field, value2, customOperation, target, options2) {
  var valueText;
  if (true === value2) {
    valueText = field.trueText || message_default.format("dxDataGrid-trueText");
  } else if (false === value2) {
    valueText = field.falseText || message_default.format("dxDataGrid-falseText");
  } else {
    valueText = getFormattedValueText(field, value2);
  }
  if (field.customizeText) {
    valueText = field.customizeText.call(field, {
      value: value2,
      valueText,
      target
    });
  }
  if (customOperation && customOperation.customizeText) {
    valueText = customOperation.customizeText.call(customOperation, {
      value: value2,
      valueText,
      field,
      target
    }, options2);
  }
  return valueText;
}
function getArrayValueText(field, value2, customOperation, target) {
  var options2 = {
    values: value2
  };
  return value2.map((v) => getPrimitiveValueText(field, v, customOperation, target, options2));
}
function checkDefaultValue(value2) {
  return "" === value2 || null === value2;
}
function getCurrentValueText(field, value2, customOperation) {
  var target = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "filterBuilder";
  if (checkDefaultValue(value2)) {
    return "";
  }
  if (Array.isArray(value2)) {
    var result2 = new Deferred();
    when.apply(this, getArrayValueText(field, value2, customOperation, target)).done(function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      var text = args.some((item) => !checkDefaultValue(item)) ? args.map((item) => !checkDefaultValue(item) ? item : "?") : "";
      result2.resolve(text);
    });
    return result2;
  } else {
    return getPrimitiveValueText(field, value2, customOperation, target);
  }
}
function itemExists(plainItems, parentId) {
  return plainItems.some(function(item) {
    return item.dataField === parentId;
  });
}
function pushItemAndCheckParent(originalItems, plainItems, item) {
  var dataField = item.dataField;
  if (hasParent(dataField)) {
    item.parentId = getParentIdFromItemDataField(dataField);
    if (!itemExists(plainItems, item.parentId) && !itemExists(originalItems, item.parentId)) {
      pushItemAndCheckParent(originalItems, plainItems, {
        id: item.parentId,
        dataType: "object",
        dataField: item.parentId,
        caption: generateCaptionByDataField(item.parentId, true),
        filterOperations: ["isblank", "isnotblank"]
      });
    }
  }
  plainItems.push(item);
}
function generateCaptionByDataField(dataField, allowHierarchicalFields) {
  var caption = "";
  if (allowHierarchicalFields) {
    dataField = dataField.substring(dataField.lastIndexOf(".") + 1);
  } else if (hasParent(dataField)) {
    dataField.split(".").forEach(function(field, index2, arr) {
      caption += captionize(field);
      if (index2 !== arr.length - 1) {
        caption += ".";
      }
    });
    return caption;
  }
  return captionize(dataField);
}
function getItems2(fields, allowHierarchicalFields) {
  var items = [];
  for (var i = 0; i < fields.length; i++) {
    var item = extend2(true, {
      caption: generateCaptionByDataField(fields[i].dataField, allowHierarchicalFields)
    }, fields[i]);
    item.id = item.name || item.dataField;
    if (allowHierarchicalFields) {
      pushItemAndCheckParent(fields, items, item);
    } else {
      items.push(item);
    }
  }
  return items;
}
function hasParent(dataField) {
  return -1 !== dataField.lastIndexOf(".");
}
function getParentIdFromItemDataField(dataField) {
  return dataField.substring(0, dataField.lastIndexOf("."));
}
function getCaptionWithParents(item, plainItems) {
  if (hasParent(item.dataField)) {
    var parentId = getParentIdFromItemDataField(item.dataField);
    for (var i = 0; i < plainItems.length; i++) {
      if (plainItems[i].dataField === parentId) {
        return getCaptionWithParents(plainItems[i], plainItems) + "." + item.caption;
      }
    }
  }
  return item.caption;
}
function updateConditionByOperation(condition, operation, customOperations) {
  var customOperation = getCustomOperation(customOperations, operation);
  if (customOperation) {
    if (false === customOperation.hasValue) {
      condition[1] = operation;
      condition.length = 2;
    } else {
      condition[1] = operation;
      condition[2] = "";
    }
    return condition;
  }
  if ("isblank" === operation) {
    condition[1] = EQUAL_OPERATION;
    condition[2] = null;
  } else if ("isnotblank" === operation) {
    condition[1] = NOT_EQUAL_OPERATION;
    condition[2] = null;
  } else {
    customOperation = getCustomOperation(customOperations, condition[1]);
    if (customOperation || 2 === condition.length || null === condition[2]) {
      condition[2] = "";
    }
    condition[1] = operation;
  }
  return condition;
}
function getOperationValue(condition) {
  var caption;
  if (null === condition[2]) {
    if (condition[1] === EQUAL_OPERATION) {
      caption = "isblank";
    } else {
      caption = "isnotblank";
    }
  } else {
    caption = condition[1];
  }
  return caption;
}
function isValidCondition(condition) {
  return "" !== condition[2];
}
function getMergedOperations(customOperations, betweenCaption, context2) {
  var result2 = extend2(true, [], customOperations);
  var betweenIndex = -1;
  result2.some(function(customOperation, index2) {
    if ("between" === customOperation.name) {
      betweenIndex = index2;
      return true;
    }
  });
  if (-1 !== betweenIndex) {
    result2[betweenIndex] = extend2(getConfig(betweenCaption, context2), result2[betweenIndex]);
  } else {
    result2.unshift(getConfig(betweenCaption, context2));
  }
  return result2;
}
function isMatchedCondition(filter, addedFilterDataField) {
  return filter[0] === addedFilterDataField;
}
function removeFieldConditionsFromFilter(filter, dataField) {
  if (!filter || 0 === filter.length) {
    return null;
  }
  if (isCondition(filter)) {
    var hasMatchedCondition = isMatchedCondition(filter, dataField);
    return !hasMatchedCondition ? filter : null;
  } else {
    return syncConditionIntoGroup(filter, [dataField], false);
  }
}
function syncConditionIntoGroup(filter, addedFilter, canPush) {
  var result2 = [];
  filter.forEach(function(item) {
    if (isCondition(item)) {
      if (isMatchedCondition(item, addedFilter[0])) {
        if (canPush) {
          result2.push(addedFilter);
          canPush = false;
        } else {
          result2.splice(result2.length - 1, 1);
        }
      } else {
        result2.push(item);
      }
    } else {
      (result2.length || isGroup(item)) && result2.push(item);
    }
  });
  if (0 === result2.length) {
    return null;
  }
  if (canPush) {
    result2.push(AND_GROUP_OPERATION);
    result2.push(addedFilter);
  }
  return 1 === result2.length ? result2[0] : result2;
}
function syncFilters(filter, addedFilter) {
  if (null === filter || 0 === filter.length) {
    return addedFilter;
  }
  if (isCondition(filter)) {
    if (isMatchedCondition(filter, addedFilter[0])) {
      return addedFilter;
    } else {
      return [filter, AND_GROUP_OPERATION, addedFilter];
    }
  }
  var groupValue = getGroupValue(filter);
  if (groupValue !== AND_GROUP_OPERATION) {
    return [addedFilter, "and", filter];
  }
  return syncConditionIntoGroup(filter, addedFilter, true);
}
function getMatchedConditions(filter, dataField) {
  if (null === filter || 0 === filter.length) {
    return [];
  }
  if (isCondition(filter)) {
    if (isMatchedCondition(filter, dataField)) {
      return [filter];
    } else {
      return [];
    }
  }
  var groupValue = getGroupValue(filter);
  if (groupValue !== AND_GROUP_OPERATION) {
    return [];
  }
  var result2 = filter.filter(function(item) {
    return isCondition(item) && isMatchedCondition(item, dataField);
  });
  return result2;
}
function filterHasField(filter, dataField) {
  if (null === filter || 0 === filter.length) {
    return false;
  }
  if (isCondition(filter)) {
    return filter[0] === dataField;
  }
  return filter.some(function(item) {
    return (isCondition(item) || isGroup(item)) && filterHasField(item, dataField);
  });
}
var DEFAULT_DATA_TYPE, EMPTY_MENU_ICON, AND_GROUP_OPERATION, EQUAL_OPERATION, NOT_EQUAL_OPERATION, DATATYPE_OPERATIONS, DEFAULT_FORMAT, LOOKUP_OPERATIONS, AVAILABLE_FIELD_PROPERTIES, FILTER_BUILDER_CLASS, FILTER_BUILDER_ITEM_TEXT_CLASS, FILTER_BUILDER_ITEM_TEXT_PART_CLASS, FILTER_BUILDER_ITEM_TEXT_SEPARATOR_CLASS, FILTER_BUILDER_ITEM_TEXT_SEPARATOR_EMPTY_CLASS, renderValueText;
var init_utils9 = __esm({
  "node_modules/devextreme/esm/ui/filter_builder/utils.js"() {
    init_renderer();
    init_deferred();
    init_errors2();
    init_type();
    init_data();
    init_ui_errors();
    init_filtering();
    init_format_helper();
    init_extend();
    init_inflector();
    init_between();
    init_message();
    init_data_source();
    init_ui_filter_operations_dictionary();
    DEFAULT_DATA_TYPE = "string";
    EMPTY_MENU_ICON = "icon-none";
    AND_GROUP_OPERATION = "and";
    EQUAL_OPERATION = "=";
    NOT_EQUAL_OPERATION = "<>";
    DATATYPE_OPERATIONS = {
      number: ["=", "<>", "<", ">", "<=", ">=", "isblank", "isnotblank"],
      string: ["contains", "notcontains", "startswith", "endswith", "=", "<>", "isblank", "isnotblank"],
      date: ["=", "<>", "<", ">", "<=", ">=", "isblank", "isnotblank"],
      datetime: ["=", "<>", "<", ">", "<=", ">=", "isblank", "isnotblank"],
      boolean: ["=", "<>", "isblank", "isnotblank"],
      object: ["isblank", "isnotblank"]
    };
    DEFAULT_FORMAT = {
      date: "shortDate",
      datetime: "shortDateShortTime"
    };
    LOOKUP_OPERATIONS = ["=", "<>", "isblank", "isnotblank"];
    AVAILABLE_FIELD_PROPERTIES = ["caption", "customizeText", "dataField", "dataType", "editorTemplate", "falseText", "editorOptions", "filterOperations", "format", "lookup", "trueText", "calculateFilterExpression", "name"];
    FILTER_BUILDER_CLASS = "dx-filterbuilder";
    FILTER_BUILDER_ITEM_TEXT_CLASS = FILTER_BUILDER_CLASS + "-text";
    FILTER_BUILDER_ITEM_TEXT_PART_CLASS = FILTER_BUILDER_ITEM_TEXT_CLASS + "-part";
    FILTER_BUILDER_ITEM_TEXT_SEPARATOR_CLASS = FILTER_BUILDER_ITEM_TEXT_CLASS + "-separator";
    FILTER_BUILDER_ITEM_TEXT_SEPARATOR_EMPTY_CLASS = FILTER_BUILDER_ITEM_TEXT_SEPARATOR_CLASS + "-empty";
    renderValueText = function($container, value2, customOperation) {
      if (Array.isArray(value2)) {
        var lastItemIndex = value2.length - 1;
        $container.empty();
        value2.forEach((t, i) => {
          renderer_default("<span>").addClass(FILTER_BUILDER_ITEM_TEXT_PART_CLASS).text(t).appendTo($container);
          if (i !== lastItemIndex) {
            renderer_default("<span>").addClass(FILTER_BUILDER_ITEM_TEXT_SEPARATOR_CLASS).text(customOperation && customOperation.valueSeparator ? customOperation.valueSeparator : "|").addClass(FILTER_BUILDER_ITEM_TEXT_SEPARATOR_EMPTY_CLASS).appendTo($container);
          }
        });
      } else if (value2) {
        $container.text(value2);
      } else {
        $container.text(message_default.format("dxFilterBuilder-enterValueText"));
      }
    };
  }
});

// node_modules/devextreme/esm/ui/grid_core/ui.grid_core.filter_custom_operations.js
function baseOperation(grid) {
  var getFullText = function(itemText, parentText) {
    return parentText ? parentText + "/" + itemText : itemText;
  };
  var headerFilterController = grid && grid.getController("headerFilter");
  return {
    dataTypes: ["string", "date", "datetime", "number", "boolean", "object"],
    calculateFilterExpression: function(filterValue, field, fields) {
      var result2 = [];
      var lastIndex = filterValue.length - 1;
      filterValue && filterValue.forEach(function(value2, index2) {
        if (isCondition(value2) || isGroup(value2)) {
          var filterExpression = getFilterExpression(value2, fields, [], "headerFilter");
          result2.push(filterExpression);
        } else {
          result2.push(getFilterExpression([field.dataField, "=", value2], fields, [], "headerFilter"));
        }
        index2 !== lastIndex && result2.push("or");
      });
      if (1 === result2.length) {
        result2 = result2[0];
      }
      return result2;
    },
    editorTemplate: function(conditionInfo, container) {
      var div = renderer_default("<div>").addClass("dx-filterbuilder-item-value-text").appendTo(container);
      var column = extend2(true, {}, grid.columnOption(conditionInfo.field.dataField));
      renderValueText(div, conditionInfo.text && conditionInfo.text.split("|"));
      column.filterType = "include";
      column.filterValues = conditionInfo.value ? conditionInfo.value.slice() : [];
      headerFilterController.showHeaderFilterMenuBase({
        columnElement: div,
        column,
        apply: function() {
          value2 = this.filterValues, void conditionInfo.setValue(value2);
          var value2;
          headerFilterController.hideHeaderFilterMenu();
          conditionInfo.closeEditor();
        },
        onHidden: function() {
          conditionInfo.closeEditor();
        },
        isFilterBuilder: true
      });
      return container;
    },
    customizeText: function(fieldInfo, options2) {
      options2 = options2 || {};
      var value2 = fieldInfo.value;
      var column = grid.columnOption(fieldInfo.field.dataField);
      var headerFilter = column && column.headerFilter;
      var lookup = column && column.lookup;
      var values = options2.values || [value2];
      if (headerFilter && headerFilter.dataSource || lookup && lookup.dataSource) {
        var result2 = new Deferred();
        var itemsDeferred = options2.items || new Deferred();
        if (!options2.items) {
          column = extend2({}, column, {
            filterType: "include",
            filterValues: values
          });
          var dataSourceOptions = headerFilterController.getDataSource(column);
          dataSourceOptions.paginate = false;
          var dataSource = new DataSource(dataSourceOptions);
          var key = dataSource.store().key();
          if (key) {
            var {
              values: _values
            } = options2;
            if (_values && _values.length > 1) {
              var filter = _values.reduce((result3, value3) => {
                if (result3.length) {
                  result3.push("or");
                }
                result3.push([key, "=", value3]);
                return result3;
              }, []);
              dataSource.filter(filter);
            } else {
              dataSource.filter([key, "=", fieldInfo.value]);
            }
          } else if (fieldInfo.field.calculateDisplayValue) {
            ui_errors_default.log("W1017");
          }
          options2.items = itemsDeferred;
          dataSource.load().done(itemsDeferred.resolve);
        }
        itemsDeferred.done((items) => {
          var index2 = values.indexOf(fieldInfo.value);
          result2.resolve(function getSelectedItemsTexts(items2, parentText) {
            var result3 = [];
            items2.forEach(function(item) {
              if (item.items) {
                var selectedItemsTexts = getSelectedItemsTexts(item.items, getFullText(item.text, parentText));
                result3 = result3.concat(selectedItemsTexts);
              }
              item.selected && result3.push(getFullText(item.text, parentText));
            });
            return result3;
          }(items)[index2]);
        });
        return result2;
      } else {
        var text = headerFilterController.getHeaderItemText(value2, column, 0, grid.option("headerFilter"));
        return text;
      }
    }
  };
}
function anyOf(grid) {
  return extend2(baseOperation(grid), {
    name: "anyof",
    icon: "selectall",
    caption: message_default.format("dxFilterBuilder-filterOperationAnyOf")
  });
}
function noneOf(grid) {
  var baseOp = baseOperation(grid);
  return extend2({}, baseOp, {
    calculateFilterExpression: function(filterValue, field, fields) {
      var baseFilter = baseOp.calculateFilterExpression(filterValue, field, fields);
      if (!baseFilter || 0 === baseFilter.length) {
        return null;
      }
      return "!" === baseFilter[0] ? baseFilter : ["!", baseFilter];
    },
    name: "noneof",
    icon: "unselectall",
    caption: message_default.format("dxFilterBuilder-filterOperationNoneOf")
  });
}
var init_ui_grid_core_filter_custom_operations = __esm({
  "node_modules/devextreme/esm/ui/grid_core/ui.grid_core.filter_custom_operations.js"() {
    init_renderer();
    init_message();
    init_extend();
    init_data_source();
    init_deferred();
    init_utils9();
    init_ui_errors();
  }
});

// node_modules/devextreme/esm/ui/grid_core/ui.grid_core.filter_sync.js
function getColumnIdentifier(column) {
  return column.name || column.dataField;
}
function checkForErrors(columns) {
  columns.forEach((column) => {
    var identifier = getColumnIdentifier(column);
    if (!isDefined(identifier) && column.allowFiltering) {
      throw new ui_errors_default.Error("E1049", column.caption);
    }
  });
}
var FILTER_ROW_OPERATIONS, FILTER_TYPES_INCLUDE, FILTER_TYPES_EXCLUDE, FilterSyncController, DataControllerFilterSyncExtender, ColumnHeadersViewFilterSyncExtender, filterSyncModule;
var init_ui_grid_core_filter_sync = __esm({
  "node_modules/devextreme/esm/ui/grid_core/ui.grid_core.filter_sync.js"() {
    init_type();
    init_ui_grid_core_modules();
    init_utils9();
    init_ui_errors();
    init_ui_grid_core_utils();
    init_filtering();
    init_ui_grid_core_filter_custom_operations();
    FILTER_ROW_OPERATIONS = ["=", "<>", "<", "<=", ">", ">=", "notcontains", "contains", "startswith", "endswith", "between"];
    FILTER_TYPES_INCLUDE = "include";
    FILTER_TYPES_EXCLUDE = "exclude";
    FilterSyncController = ui_grid_core_modules_default.Controller.inherit(/* @__PURE__ */ function() {
      var getEmptyFilterValues = function() {
        return {
          filterType: FILTER_TYPES_INCLUDE,
          filterValues: void 0
        };
      };
      var canSyncHeaderFilterWithFilterRow = function(column) {
        var filterValues = column.filterValues || [];
        return !filtering_default.getGroupInterval(column) && !(column.headerFilter && column.headerFilter.dataSource) || 1 === filterValues.length && null === filterValues[0];
      };
      var getConditionFromFilterRow = function(column) {
        var value2 = column.filterValue;
        if (isDefined(value2)) {
          var operation = column.selectedFilterOperation || column.defaultFilterOperation || getDefaultOperation(column);
          var filter = [getColumnIdentifier(column), operation, column.filterValue];
          return filter;
        } else {
          return null;
        }
      };
      var getConditionFromHeaderFilter = function(column) {
        var selectedOperation;
        var value2;
        var filterValues = column.filterValues;
        if (!filterValues) {
          return null;
        }
        if (1 === filterValues.length && canSyncHeaderFilterWithFilterRow(column) && !Array.isArray(filterValues[0])) {
          column.filterType === FILTER_TYPES_EXCLUDE ? selectedOperation = "<>" : selectedOperation = "=";
          value2 = filterValues[0];
        } else {
          column.filterType === FILTER_TYPES_EXCLUDE ? selectedOperation = "noneof" : selectedOperation = "anyof";
          value2 = filterValues;
        }
        return [getColumnIdentifier(column), selectedOperation, value2];
      };
      var updateHeaderFilterCondition = function(columnsController, column, headerFilterCondition) {
        var headerFilter = function(headerFilterCondition2, column2) {
          if (!headerFilterCondition2) {
            return getEmptyFilterValues();
          }
          var filterType;
          var selectedFilterOperation = headerFilterCondition2[1];
          var value2 = headerFilterCondition2[2];
          var hasArrayValue = Array.isArray(value2);
          if (!hasArrayValue) {
            if (!canSyncHeaderFilterWithFilterRow(column2)) {
              return getEmptyFilterValues();
            }
          }
          switch (selectedFilterOperation) {
            case "anyof":
            case "=":
              filterType = FILTER_TYPES_INCLUDE;
              break;
            case "noneof":
            case "<>":
              filterType = FILTER_TYPES_EXCLUDE;
              break;
            default:
              return getEmptyFilterValues();
          }
          return {
            filterType,
            filterValues: hasArrayValue ? value2 : [value2]
          };
        }(headerFilterCondition, column);
        columnsController.columnOption(getColumnIdentifier(column), headerFilter);
      };
      var updateFilterRowCondition = function(columnsController, column, condition) {
        var filterRowOptions;
        var selectedFilterOperation = null === condition || void 0 === condition ? void 0 : condition[1];
        var filterValue = null === condition || void 0 === condition ? void 0 : condition[2];
        var filterOperations = column.filterOperations || column.defaultFilterOperations;
        if ((!filterOperations || filterOperations.indexOf(selectedFilterOperation) >= 0 || selectedFilterOperation === column.defaultFilterOperation) && FILTER_ROW_OPERATIONS.indexOf(selectedFilterOperation) >= 0 && null !== filterValue) {
          if (selectedFilterOperation === column.defaultFilterOperation && !isDefined(column.selectedFilterOperation)) {
            selectedFilterOperation = column.selectedFilterOperation;
          }
          filterRowOptions = {
            filterValue,
            selectedFilterOperation
          };
        } else {
          filterRowOptions = {
            filterValue: void 0,
            selectedFilterOperation: void 0
          };
        }
        columnsController.columnOption(getColumnIdentifier(column), filterRowOptions);
      };
      return {
        syncFilterValue: function() {
          var that = this;
          var columnsController = that.getController("columns");
          var columns = columnsController.getFilteringColumns();
          this._skipSyncColumnOptions = true;
          columns.forEach(function(column) {
            var filterConditions = getMatchedConditions(that.option("filterValue"), getColumnIdentifier(column));
            if (1 === filterConditions.length) {
              var filterCondition = filterConditions[0];
              updateHeaderFilterCondition(columnsController, column, filterCondition);
              updateFilterRowCondition(columnsController, column, filterCondition);
            } else {
              isDefined(column.filterValues) && updateHeaderFilterCondition(columnsController, column);
              isDefined(column.filterValue) && updateFilterRowCondition(columnsController, column);
            }
          });
          this._skipSyncColumnOptions = false;
        },
        _initSync: function() {
          var columns = this.getController("columns").getColumns();
          var dataController = this.getController("data");
          var pageIndex = dataController.pageIndex();
          checkForErrors(columns);
          if (!this.option("filterValue")) {
            var filteringColumns = this.getController("columns").getFilteringColumns();
            var filterValue = this.getFilterValueFromColumns(filteringColumns);
            this.option("filterValue", filterValue);
          }
          this.syncFilterValue();
          dataController.pageIndex(pageIndex);
        },
        init: function() {
          var dataController = this.getController("data");
          if (dataController.isFilterSyncActive()) {
            if (this.getController("columns").isAllDataTypesDefined()) {
              this._initSync();
            } else {
              dataController.dataSourceChanged.add(() => this._initSync());
            }
          }
        },
        _getSyncFilterRow: function(filterValue, column) {
          var filter = getConditionFromFilterRow(column);
          if (isDefined(filter)) {
            return syncFilters(filterValue, filter);
          } else {
            return removeFieldConditionsFromFilter(filterValue, getColumnIdentifier(column));
          }
        },
        _getSyncHeaderFilter: function(filterValue, column) {
          var filter = getConditionFromHeaderFilter(column);
          if (filter) {
            return syncFilters(filterValue, filter);
          } else {
            return removeFieldConditionsFromFilter(filterValue, getColumnIdentifier(column));
          }
        },
        getFilterValueFromColumns: function(columns) {
          if (!this.getController("data").isFilterSyncActive()) {
            return null;
          }
          var filterValue = ["and"];
          columns && columns.forEach((column) => {
            var headerFilter = getConditionFromHeaderFilter(column);
            var filterRow = getConditionFromFilterRow(column);
            headerFilter && addItem(headerFilter, filterValue);
            filterRow && addItem(filterRow, filterValue);
          });
          return getNormalizedFilter(filterValue);
        },
        syncFilterRow: function(column, value2) {
          this.option("filterValue", this._getSyncFilterRow(this.option("filterValue"), column));
        },
        syncHeaderFilter: function(column) {
          this.option("filterValue", this._getSyncHeaderFilter(this.option("filterValue"), column));
        },
        getCustomFilterOperations: function() {
          var filterBuilderCustomOperations = this.option("filterBuilder.customOperations") || [];
          return [anyOf(this.component), noneOf(this.component)].concat(filterBuilderCustomOperations);
        },
        publicMethods: function() {
          return ["getCustomFilterOperations"];
        }
      };
    }());
    DataControllerFilterSyncExtender = {
      isFilterSyncActive: function() {
        var filterSyncEnabledValue = this.option("filterSyncEnabled");
        return "auto" === filterSyncEnabledValue ? this.option("filterPanel.visible") : filterSyncEnabledValue;
      },
      skipCalculateColumnFilters: function() {
        return isDefined(this.option("filterValue")) && this.isFilterSyncActive();
      },
      _calculateAdditionalFilter: function() {
        if (false === this.option("filterPanel.filterEnabled")) {
          return this.callBase();
        }
        var filters = [this.callBase()];
        var columns = this.getController("columns").getFilteringColumns();
        var filterValue = this.option("filterValue");
        if (this.isFilterSyncActive()) {
          var currentColumn = this.getController("headerFilter").getCurrentColumn();
          if (currentColumn && filterValue) {
            filterValue = removeFieldConditionsFromFilter(filterValue, getColumnIdentifier(currentColumn));
          }
        }
        var customOperations = this.getController("filterSync").getCustomFilterOperations();
        var calculatedFilterValue = getFilterExpression(filterValue, columns, customOperations, "filterBuilder");
        if (calculatedFilterValue) {
          filters.push(calculatedFilterValue);
        }
        return ui_grid_core_utils_default.combineFilters(filters);
      },
      _parseColumnPropertyName: function(fullName) {
        var matched = fullName.match(/.*\.(.*)/);
        if (matched) {
          return matched[1];
        } else {
          return null;
        }
      },
      clearFilter: function(filterName) {
        this.component.beginUpdate();
        if (arguments.length > 0) {
          if ("filterValue" === filterName) {
            this.option("filterValue", null);
          }
          this.callBase(filterName);
        } else {
          this.option("filterValue", null);
          this.callBase();
        }
        this.component.endUpdate();
      },
      optionChanged: function(args) {
        switch (args.name) {
          case "filterValue":
            this._applyFilter();
            this.isFilterSyncActive() && this.getController("filterSync").syncFilterValue();
            args.handled = true;
            break;
          case "filterSyncEnabled":
            args.handled = true;
            break;
          case "columns":
            if (this.isFilterSyncActive()) {
              var column = this.getController("columns").getColumnByPath(args.fullName);
              var filterSyncController = this.getController("filterSync");
              if (column && !filterSyncController._skipSyncColumnOptions) {
                var propertyName = this._parseColumnPropertyName(args.fullName);
                filterSyncController._skipSyncColumnOptions = true;
                if ("filterType" === propertyName) {
                  if (FILTER_TYPES_EXCLUDE === args.value || FILTER_TYPES_EXCLUDE === args.previousValue) {
                    filterSyncController.syncHeaderFilter(column);
                  }
                } else if ("filterValues" === propertyName) {
                  filterSyncController.syncHeaderFilter(column);
                } else if (["filterValue", "selectedFilterOperation"].indexOf(propertyName) > -1) {
                  filterSyncController.syncFilterRow(column, column.filterValue);
                }
                filterSyncController._skipSyncColumnOptions = false;
              }
            }
            this.callBase(args);
            break;
          default:
            this.callBase(args);
        }
      }
    };
    ColumnHeadersViewFilterSyncExtender = {
      _isHeaderFilterEmpty: function(column) {
        if (this.getController("data").isFilterSyncActive()) {
          return !filterHasField(this.option("filterValue"), getColumnIdentifier(column));
        }
        return this.callBase(column);
      },
      _needUpdateFilterIndicators: function() {
        return !this.getController("data").isFilterSyncActive();
      },
      optionChanged: function(args) {
        if ("filterValue" === args.name) {
          this._updateHeaderFilterIndicators();
        } else {
          this.callBase(args);
        }
      }
    };
    filterSyncModule = {
      defaultOptions: function() {
        return {
          filterValue: null,
          filterSyncEnabled: "auto"
        };
      },
      controllers: {
        filterSync: FilterSyncController
      },
      extenders: {
        controllers: {
          data: DataControllerFilterSyncExtender
        },
        views: {
          columnHeadersView: ColumnHeadersViewFilterSyncExtender
        }
      }
    };
  }
});

// node_modules/devextreme/esm/ui/shared/ui.editor_factory_mixin.js
var isWrapped2, CHECKBOX_SIZE_CLASS, EDITOR_INLINE_BLOCK, EditorFactoryMixin, ui_editor_factory_mixin_default;
var init_ui_editor_factory_mixin = __esm({
  "node_modules/devextreme/esm/ui/shared/ui.editor_factory_mixin.js"() {
    init_renderer();
    init_events_engine();
    init_type();
    init_variable_wrapper();
    init_data();
    init_browser();
    init_extend();
    init_devices();
    init_element();
    init_utils5();
    init_utils2();
    init_text_box2();
    init_number_box2();
    init_check_box();
    init_select_box();
    init_date_box();
    ({
      isWrapped: isWrapped2
    } = variable_wrapper_default);
    CHECKBOX_SIZE_CLASS = "checkbox-size";
    EDITOR_INLINE_BLOCK = "dx-editor-inline-block";
    EditorFactoryMixin = /* @__PURE__ */ function() {
      var getResultConfig = function(config2, options2) {
        return extend2(config2, {
          readOnly: options2.readOnly,
          placeholder: options2.placeholder,
          inputAttr: {
            id: options2.id
          },
          tabIndex: options2.tabIndex
        }, options2.editorOptions);
      };
      var checkEnterBug = function() {
        return browser_default.msie || browser_default.mozilla || devices_default.real().ios;
      };
      var getTextEditorConfig = function(options2) {
        var data2 = {};
        var isEnterBug = checkEnterBug();
        var sharedData = options2.sharedData || data2;
        return getResultConfig({
          placeholder: options2.placeholder,
          width: options2.width,
          value: options2.value,
          onValueChanged: function(e) {
            var needDelayedUpdate = "filterRow" === options2.parentType || "searchPanel" === options2.parentType;
            var isInputOrKeyUpEvent = e.event && ("input" === e.event.type || "keyup" === e.event.type);
            var updateValue = function(e2, notFireEvent) {
              options2 && options2.setValue(e2.value, notFireEvent);
            };
            clearTimeout(data2.valueChangeTimeout);
            if (isInputOrKeyUpEvent && needDelayedUpdate) {
              sharedData.valueChangeTimeout = data2.valueChangeTimeout = setTimeout(function() {
                updateValue(e, data2.valueChangeTimeout !== sharedData.valueChangeTimeout);
              }, isDefined(options2.updateValueTimeout) ? options2.updateValueTimeout : 0);
            } else {
              updateValue(e);
            }
          },
          onKeyDown: function(e) {
            if (isEnterBug && "enter" === normalizeKeyName(e.event)) {
              events_engine_default.trigger(renderer_default(e.component._input()), "change");
            }
          },
          valueChangeEvent: "change" + ("filterRow" === options2.parentType ? " keyup input" : "")
        }, options2);
      };
      var prepareBooleanEditor = function(options2) {
        if ("filterRow" === options2.parentType || "filterBuilder" === options2.parentType) {
          prepareSelectBox(extend2(options2, {
            lookup: {
              displayExpr: function(data2) {
                if (true === data2) {
                  return options2.trueText || "true";
                } else if (false === data2) {
                  return options2.falseText || "false";
                }
              },
              dataSource: [true, false]
            }
          }));
        } else {
          !function(options3) {
            options3.editorName = "dxCheckBox";
            options3.editorOptions = getResultConfig({
              elementAttr: {
                id: options3.id
              },
              value: isDefined(options3.value) ? options3.value : void 0,
              hoverStateEnabled: !options3.readOnly,
              focusStateEnabled: !options3.readOnly,
              activeStateEnabled: false,
              onValueChanged: function(e) {
                options3.setValue && options3.setValue(e.value, e);
              }
            }, options3);
          }(options2);
        }
      };
      function prepareSelectBox(options2) {
        var lookup = options2.lookup;
        var displayGetter;
        var dataSource;
        var postProcess2;
        var isFilterRow = "filterRow" === options2.parentType;
        if (lookup) {
          displayGetter = compileGetter(lookup.displayExpr);
          dataSource = lookup.dataSource;
          if (isFunction(dataSource) && !isWrapped2(dataSource)) {
            dataSource = dataSource(options2.row || {});
            !function(options3) {
              if (options3.row && options3.row.watch && "dataRow" === options3.parentType) {
                var editorOptions = options3.editorOptions || {};
                options3.editorOptions = editorOptions;
                var selectBox;
                var onInitialized = editorOptions.onInitialized;
                editorOptions.onInitialized = function(e) {
                  onInitialized && onInitialized.apply(this, arguments);
                  selectBox = e.component;
                  selectBox.on("disposing", stopWatch);
                };
                var dataSource2;
                var stopWatch = options3.row.watch(() => {
                  dataSource2 = options3.lookup.dataSource(options3.row);
                  return dataSource2 && dataSource2.filter;
                }, () => {
                  selectBox.option("dataSource", dataSource2);
                }, (row) => {
                  options3.row = row;
                });
              }
            }(options2);
          }
          if (isObject2(dataSource) || Array.isArray(dataSource)) {
            dataSource = normalizeDataSourceOptions(dataSource);
            if (isFilterRow) {
              postProcess2 = dataSource.postProcess;
              dataSource.postProcess = function(items) {
                if (0 === this.pageIndex()) {
                  items = items.slice(0);
                  items.unshift(null);
                }
                if (postProcess2) {
                  return postProcess2.call(this, items);
                }
                return items;
              };
            }
          }
          var allowClearing = Boolean(lookup.allowClearing && !isFilterRow);
          options2.editorName = "dxSelectBox";
          options2.editorOptions = getResultConfig({
            searchEnabled: true,
            value: options2.value,
            valueExpr: options2.lookup.valueExpr,
            searchExpr: options2.lookup.searchExpr || options2.lookup.displayExpr,
            allowClearing,
            showClearButton: allowClearing,
            displayExpr: function(data2) {
              if (null === data2) {
                return options2.showAllText;
              }
              return displayGetter(data2);
            },
            dataSource,
            onValueChanged: function(e) {
              var params = [e.value];
              !isFilterRow && params.push(e.component.option("text"));
              options2.setValue.apply(this, params);
            }
          }, options2);
        }
      }
      return {
        createEditor: function($container, options2) {
          options2.cancel = false;
          options2.editorElement = getPublicElement($container);
          if (!isDefined(options2.tabIndex)) {
            options2.tabIndex = this.option("tabIndex");
          }
          if (options2.lookup) {
            prepareSelectBox(options2);
          } else {
            switch (options2.dataType) {
              case "date":
              case "datetime":
                !function(options3) {
                  options3.editorName = "dxDateBox";
                  options3.editorOptions = getResultConfig({
                    value: options3.value,
                    onValueChanged: function(args) {
                      options3.setValue(args.value);
                    },
                    onKeyDown: function(_ref) {
                      var {
                        component,
                        event
                      } = _ref;
                      var useMaskBehavior = component.option("useMaskBehavior");
                      if ((checkEnterBug() || useMaskBehavior) && "enter" === normalizeKeyName(event)) {
                        component.blur();
                        component.focus();
                      }
                    },
                    displayFormat: options3.format,
                    type: options3.dataType,
                    dateSerializationFormat: null,
                    width: "filterBuilder" === options3.parentType ? void 0 : "auto"
                  }, options3);
                }(options2);
                break;
              case "boolean":
                prepareBooleanEditor(options2);
                break;
              case "number":
                !function(options3) {
                  var config2 = getTextEditorConfig(options3);
                  config2.value = isDefined(options3.value) ? options3.value : null;
                  options3.editorName = "dxNumberBox";
                  options3.editorOptions = config2;
                }(options2);
                break;
              default:
                !function(options3) {
                  var config2 = getTextEditorConfig(options3);
                  var isSearching = "searchPanel" === options3.parentType;
                  if (options3.editorType && "dxTextBox" !== options3.editorType) {
                    config2.value = options3.value;
                  } else {
                    config2.value = (value2 = options3.value, isDefined(value2) ? value2.toString() : "");
                  }
                  var value2;
                  config2.valueChangeEvent += isSearching ? " keyup input search" : "";
                  config2.mode = config2.mode || (isSearching ? "search" : "text");
                  options3.editorName = "dxTextBox";
                  options3.editorOptions = config2;
                }(options2);
            }
          }
          if ("dataRow" === options2.parentType && options2.editorType) {
            options2.editorName = options2.editorType;
          }
          this.executeAction("onEditorPreparing", options2);
          if (options2.cancel) {
            return;
          }
          if ("dataRow" === options2.parentType && !options2.isOnForm && !isDefined(options2.editorOptions.showValidationMark)) {
            options2.editorOptions.showValidationMark = false;
          }
          !function(that, options3) {
            var $editorElement = renderer_default(options3.editorElement);
            if (options3.editorName && options3.editorOptions && $editorElement[options3.editorName]) {
              if ("dxCheckBox" === options3.editorName || "dxSwitch" === options3.editorName) {
                if (!options3.isOnForm) {
                  $editorElement.addClass(that.addWidgetPrefix(CHECKBOX_SIZE_CLASS));
                  $editorElement.parent().addClass(EDITOR_INLINE_BLOCK);
                }
              }
              that._createComponent($editorElement, options3.editorName, options3.editorOptions);
              if ("dxDateBox" === options3.editorName) {
                var dateBox = $editorElement.dxDateBox("instance");
                var defaultEnterKeyHandler = dateBox._supportedKeys().enter;
                dateBox.registerKeyHandler("enter", (e) => {
                  if (dateBox.option("opened")) {
                    defaultEnterKeyHandler(e);
                  }
                  return true;
                });
              }
              if ("dxTextArea" === options3.editorName) {
                $editorElement.dxTextArea("instance").registerKeyHandler("enter", function(event) {
                  if ("enter" === normalizeKeyName(event) && !event.ctrlKey && !event.shiftKey) {
                    event.stopPropagation();
                  }
                });
              }
            }
          }(this, options2);
          this.executeAction("onEditorPrepared", options2);
        }
      };
    }();
    ui_editor_factory_mixin_default = EditorFactoryMixin;
  }
});

// node_modules/devextreme/esm/ui/filter_builder/filter_builder.js
var FILTER_BUILDER_CLASS2, FILTER_BUILDER_GROUP_CLASS, FILTER_BUILDER_GROUP_ITEM_CLASS, FILTER_BUILDER_GROUP_CONTENT_CLASS, FILTER_BUILDER_GROUP_OPERATIONS_CLASS, FILTER_BUILDER_GROUP_OPERATION_CLASS, FILTER_BUILDER_ACTION_CLASS, FILTER_BUILDER_IMAGE_CLASS, FILTER_BUILDER_IMAGE_ADD_CLASS, FILTER_BUILDER_IMAGE_REMOVE_CLASS, FILTER_BUILDER_ITEM_TEXT_CLASS2, FILTER_BUILDER_ITEM_FIELD_CLASS, FILTER_BUILDER_ITEM_OPERATION_CLASS, FILTER_BUILDER_ITEM_VALUE_CLASS, FILTER_BUILDER_ITEM_VALUE_TEXT_CLASS, FILTER_BUILDER_OVERLAY_CLASS, FILTER_BUILDER_FILTER_OPERATIONS_CLASS, FILTER_BUILDER_FIELDS_CLASS, FILTER_BUILDER_ADD_CONDITION_CLASS, ACTIVE_CLASS, FILTER_BUILDER_MENU_CUSTOM_OPERATION_CLASS, SOURCE, DISABLED_STATE_CLASS5, TAB_KEY2, ENTER_KEY, ESCAPE_KEY, ACTIONS4, OPERATORS, EditorFactory, FilterBuilder, filter_builder_default;
var init_filter_builder = __esm({
  "node_modules/devextreme/esm/ui/filter_builder/filter_builder.js"() {
    init_renderer();
    init_dom_adapter();
    init_class();
    init_events_engine();
    init_ui_widget();
    init_component_registrator();
    init_extend();
    init_message();
    init_deferred();
    init_type();
    init_tree_view();
    init_popup();
    init_utils8();
    init_ui_editor_factory_mixin();
    init_utils2();
    init_utils9();
    FILTER_BUILDER_CLASS2 = "dx-filterbuilder";
    FILTER_BUILDER_GROUP_CLASS = FILTER_BUILDER_CLASS2 + "-group";
    FILTER_BUILDER_GROUP_ITEM_CLASS = FILTER_BUILDER_GROUP_CLASS + "-item";
    FILTER_BUILDER_GROUP_CONTENT_CLASS = FILTER_BUILDER_GROUP_CLASS + "-content";
    FILTER_BUILDER_GROUP_OPERATIONS_CLASS = FILTER_BUILDER_GROUP_CLASS + "-operations";
    FILTER_BUILDER_GROUP_OPERATION_CLASS = FILTER_BUILDER_GROUP_CLASS + "-operation";
    FILTER_BUILDER_ACTION_CLASS = FILTER_BUILDER_CLASS2 + "-action";
    FILTER_BUILDER_IMAGE_CLASS = FILTER_BUILDER_ACTION_CLASS + "-icon";
    FILTER_BUILDER_IMAGE_ADD_CLASS = "dx-icon-plus";
    FILTER_BUILDER_IMAGE_REMOVE_CLASS = "dx-icon-remove";
    FILTER_BUILDER_ITEM_TEXT_CLASS2 = FILTER_BUILDER_CLASS2 + "-text";
    FILTER_BUILDER_ITEM_FIELD_CLASS = FILTER_BUILDER_CLASS2 + "-item-field";
    FILTER_BUILDER_ITEM_OPERATION_CLASS = FILTER_BUILDER_CLASS2 + "-item-operation";
    FILTER_BUILDER_ITEM_VALUE_CLASS = FILTER_BUILDER_CLASS2 + "-item-value";
    FILTER_BUILDER_ITEM_VALUE_TEXT_CLASS = FILTER_BUILDER_CLASS2 + "-item-value-text";
    FILTER_BUILDER_OVERLAY_CLASS = FILTER_BUILDER_CLASS2 + "-overlay";
    FILTER_BUILDER_FILTER_OPERATIONS_CLASS = FILTER_BUILDER_CLASS2 + "-operations";
    FILTER_BUILDER_FIELDS_CLASS = FILTER_BUILDER_CLASS2 + "-fields";
    FILTER_BUILDER_ADD_CONDITION_CLASS = FILTER_BUILDER_CLASS2 + "-add-condition";
    ACTIVE_CLASS = "dx-state-active";
    FILTER_BUILDER_MENU_CUSTOM_OPERATION_CLASS = FILTER_BUILDER_CLASS2 + "-menu-custom-operation";
    SOURCE = "filterBuilder";
    DISABLED_STATE_CLASS5 = "dx-state-disabled";
    TAB_KEY2 = "tab";
    ENTER_KEY = "enter";
    ESCAPE_KEY = "escape";
    ACTIONS4 = [{
      name: "onEditorPreparing",
      config: {
        excludeValidators: ["disabled", "readOnly"],
        category: "rendering"
      }
    }, {
      name: "onEditorPrepared",
      config: {
        excludeValidators: ["disabled", "readOnly"],
        category: "rendering"
      }
    }, {
      name: "onValueChanged",
      config: {
        excludeValidators: ["disabled", "readOnly"]
      }
    }];
    OPERATORS = {
      and: "and",
      or: "or",
      notAnd: "!and",
      notOr: "!or"
    };
    EditorFactory = class_default.inherit(ui_editor_factory_mixin_default);
    FilterBuilder = ui_widget_default.inherit({
      _getDefaultOptions: function() {
        return extend2(this.callBase(), {
          onEditorPreparing: null,
          onEditorPrepared: null,
          onValueChanged: null,
          fields: [],
          groupOperations: ["and", "or", "notAnd", "notOr"],
          maxGroupLevel: void 0,
          value: null,
          allowHierarchicalFields: false,
          groupOperationDescriptions: {
            and: message_default.format("dxFilterBuilder-and"),
            or: message_default.format("dxFilterBuilder-or"),
            notAnd: message_default.format("dxFilterBuilder-notAnd"),
            notOr: message_default.format("dxFilterBuilder-notOr")
          },
          customOperations: [],
          closePopupOnTargetScroll: true,
          filterOperationDescriptions: {
            between: message_default.format("dxFilterBuilder-filterOperationBetween"),
            equal: message_default.format("dxFilterBuilder-filterOperationEquals"),
            notEqual: message_default.format("dxFilterBuilder-filterOperationNotEquals"),
            lessThan: message_default.format("dxFilterBuilder-filterOperationLess"),
            lessThanOrEqual: message_default.format("dxFilterBuilder-filterOperationLessOrEquals"),
            greaterThan: message_default.format("dxFilterBuilder-filterOperationGreater"),
            greaterThanOrEqual: message_default.format("dxFilterBuilder-filterOperationGreaterOrEquals"),
            startsWith: message_default.format("dxFilterBuilder-filterOperationStartsWith"),
            contains: message_default.format("dxFilterBuilder-filterOperationContains"),
            notContains: message_default.format("dxFilterBuilder-filterOperationNotContains"),
            endsWith: message_default.format("dxFilterBuilder-filterOperationEndsWith"),
            isBlank: message_default.format("dxFilterBuilder-filterOperationIsBlank"),
            isNotBlank: message_default.format("dxFilterBuilder-filterOperationIsNotBlank")
          }
        });
      },
      _optionChanged: function(args) {
        switch (args.name) {
          case "closePopupOnTargetScroll":
            break;
          case "onEditorPreparing":
          case "onEditorPrepared":
          case "onValueChanged":
            this._initActions();
            break;
          case "customOperations":
            this._initCustomOperations();
            this._invalidate();
            break;
          case "fields":
          case "maxGroupLevel":
          case "groupOperations":
          case "allowHierarchicalFields":
          case "groupOperationDescriptions":
          case "filterOperationDescriptions":
            this._invalidate();
            break;
          case "value":
            if (args.value !== args.previousValue) {
              var disableInvalidateForValue = this._disableInvalidateForValue;
              if (!disableInvalidateForValue) {
                this._initModel();
                this._invalidate();
              }
              this._disableInvalidateForValue = false;
              this.executeAction("onValueChanged", {
                value: args.value,
                previousValue: args.previousValue
              });
              this._disableInvalidateForValue = disableInvalidateForValue;
            }
            break;
          default:
            this.callBase(args);
        }
      },
      getFilterExpression: function() {
        var fields = this._getNormalizedFields();
        var value2 = extend2(true, [], this._model);
        return getFilterExpression(getNormalizedFilter(value2), fields, this._customOperations, SOURCE);
      },
      _getNormalizedFields: function() {
        return getNormalizedFields(this.option("fields"));
      },
      _updateFilter: function() {
        this._disableInvalidateForValue = true;
        var value2 = extend2(true, [], this._model);
        var normalizedValue = getNormalizedFilter(value2);
        var oldValue = getNormalizedFilter(this._getModel(this.option("value")));
        if (JSON.stringify(oldValue) !== JSON.stringify(normalizedValue)) {
          this.option("value", normalizedValue);
        }
        this._disableInvalidateForValue = false;
        this._fireContentReadyAction();
      },
      _init: function() {
        this._initCustomOperations();
        this._initModel();
        this._initEditorFactory();
        this._initActions();
        this.callBase();
      },
      _initEditorFactory: function() {
        this._editorFactory = new EditorFactory();
      },
      _initCustomOperations: function() {
        this._customOperations = getMergedOperations(this.option("customOperations"), this.option("filterOperationDescriptions.between"), this);
      },
      _getDefaultGroupOperation: function() {
        var _this$option$, _this$option;
        return null !== (_this$option$ = null === (_this$option = this.option("groupOperations")) || void 0 === _this$option ? void 0 : _this$option[0]) && void 0 !== _this$option$ ? _this$option$ : OPERATORS.and;
      },
      _getModel: function(value2) {
        return convertToInnerStructure(value2, this._customOperations, this._getDefaultGroupOperation());
      },
      _initModel: function() {
        this._model = this._getModel(this.option("value"));
      },
      _initActions: function() {
        var that = this;
        that._actions = {};
        ACTIONS4.forEach(function(action) {
          var actionConfig = extend2({}, action.config);
          that._actions[action.name] = that._createActionByOption(action.name, actionConfig);
        });
      },
      executeAction: function(actionName, options2) {
        var action = this._actions[actionName];
        return action && action(options2);
      },
      _initMarkup: function() {
        this.$element().addClass(FILTER_BUILDER_CLASS2);
        this.callBase();
        this._createGroupElementByCriteria(this._model).appendTo(this.$element());
      },
      _createConditionElement: function(condition, parent) {
        return renderer_default("<div>").addClass(FILTER_BUILDER_GROUP_CLASS).append(this._createConditionItem(condition, parent));
      },
      _createGroupElementByCriteria: function(criteria, parent) {
        var groupLevel = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
        var $group = this._createGroupElement(criteria, parent, groupLevel);
        var $groupContent = $group.find("." + FILTER_BUILDER_GROUP_CONTENT_CLASS);
        var groupCriteria = getGroupCriteria(criteria);
        for (var i = 0; i < groupCriteria.length; i++) {
          var innerCriteria = groupCriteria[i];
          if (isGroup(innerCriteria)) {
            this._createGroupElementByCriteria(innerCriteria, criteria, groupLevel + 1).appendTo($groupContent);
          } else if (isCondition(innerCriteria)) {
            this._createConditionElement(innerCriteria, criteria).appendTo($groupContent);
          }
        }
        return $group;
      },
      _createGroupElement: function(criteria, parent, groupLevel) {
        var $groupItem = renderer_default("<div>").addClass(FILTER_BUILDER_GROUP_ITEM_CLASS);
        var $groupContent = renderer_default("<div>").addClass(FILTER_BUILDER_GROUP_CONTENT_CLASS);
        var $group = renderer_default("<div>").addClass(FILTER_BUILDER_GROUP_CLASS).append($groupItem).append($groupContent);
        if (null != parent) {
          this._createRemoveButton(() => {
            removeItem(parent, criteria);
            $group.remove();
            this._updateFilter();
          }).appendTo($groupItem);
        }
        this._createGroupOperationButton(criteria).appendTo($groupItem);
        this._createAddButton(() => {
          var newGroup = createEmptyGroup(this._getDefaultGroupOperation());
          addItem(newGroup, criteria);
          this._createGroupElement(newGroup, criteria, groupLevel + 1).appendTo($groupContent);
          this._updateFilter();
        }, () => {
          var field = this.option("fields")[0];
          var newCondition = createCondition(field, this._customOperations);
          addItem(newCondition, criteria);
          this._createConditionElement(newCondition, criteria).appendTo($groupContent);
          this._updateFilter();
        }, groupLevel).appendTo($groupItem);
        return $group;
      },
      _createButton: function(caption) {
        return renderer_default("<div>").text(caption);
      },
      _createGroupOperationButton: function(criteria) {
        var groupOperations = this._getGroupOperations(criteria);
        var groupMenuItem = getGroupMenuItem(criteria, groupOperations);
        var caption = groupMenuItem.text;
        var $operationButton = groupOperations && groupOperations.length < 2 ? this._createButton(caption).addClass(DISABLED_STATE_CLASS5) : this._createButtonWithMenu({
          caption,
          menu: {
            items: groupOperations,
            displayExpr: "text",
            keyExpr: "value",
            onItemClick: (e) => {
              if (groupMenuItem !== e.itemData) {
                setGroupValue(criteria, e.itemData.value);
                $operationButton.text(e.itemData.text);
                groupMenuItem = e.itemData;
                this._updateFilter();
              }
            },
            onContentReady: function(e) {
              e.component.selectItem(groupMenuItem);
            },
            cssClass: FILTER_BUILDER_GROUP_OPERATIONS_CLASS
          }
        });
        return $operationButton.addClass(FILTER_BUILDER_ITEM_TEXT_CLASS2).addClass(FILTER_BUILDER_GROUP_OPERATION_CLASS).attr("tabindex", 0);
      },
      _createButtonWithMenu: function(options2) {
        var that = this;
        var removeMenu = function() {
          that.$element().find("." + ACTIVE_CLASS).removeClass(ACTIVE_CLASS);
          that.$element().find(".dx-overlay .dx-treeview").remove();
          that.$element().find(".dx-overlay").remove();
        };
        var rtlEnabled = this.option("rtlEnabled");
        var position3 = rtlEnabled ? "right" : "left";
        var $button = this._createButton(options2.caption);
        extend2(options2.menu, {
          focusStateEnabled: true,
          selectionMode: "single",
          onItemClick: (handler = options2.menu.onItemClick, function(e) {
            handler(e);
            if ("dxclick" === e.event.type) {
              removeMenu();
            }
          }),
          onHiding: function(e) {
            $button.removeClass(ACTIVE_CLASS);
          },
          position: {
            my: position3 + " top",
            at: position3 + " bottom",
            offset: "0 1",
            of: $button,
            collision: "flip"
          },
          animation: null,
          onHidden: function() {
            removeMenu();
          },
          cssClass: FILTER_BUILDER_OVERLAY_CLASS + " " + options2.menu.cssClass,
          rtlEnabled
        });
        var handler;
        options2.popup = {
          onShown: function(info) {
            var treeViewElement = renderer_default(info.component.content()).find(".dx-treeview");
            var treeView = treeViewElement.dxTreeView("instance");
            events_engine_default.on(treeViewElement, "keyup keydown", function(e) {
              var keyName = normalizeKeyName(e);
              if ("keydown" === e.type && keyName === TAB_KEY2 || "keyup" === e.type && (keyName === ESCAPE_KEY || keyName === ENTER_KEY)) {
                info.component.hide();
                events_engine_default.trigger(options2.menu.position.of, "focus");
              }
            });
            treeView.focus();
            treeView.option("focusedElement", null);
          }
        };
        this._subscribeOnClickAndEnterKey($button, function() {
          removeMenu();
          that._createPopupWithTreeView(options2, that.$element());
          $button.addClass(ACTIVE_CLASS);
        });
        return $button;
      },
      _hasValueButton: function(condition) {
        var customOperation = getCustomOperation(this._customOperations, condition[1]);
        return customOperation ? false !== customOperation.hasValue : null !== condition[2];
      },
      _createOperationButtonWithMenu: function(condition, field) {
        var that = this;
        var availableOperations = getAvailableOperations(field, this.option("filterOperationDescriptions"), this._customOperations);
        var currentOperation = getOperationFromAvailable(getOperationValue(condition), availableOperations);
        var $operationButton = this._createButtonWithMenu({
          caption: currentOperation.text,
          menu: {
            items: availableOperations,
            displayExpr: "text",
            onItemRendered: function(e) {
              e.itemData.isCustom && renderer_default(e.itemElement).addClass(FILTER_BUILDER_MENU_CUSTOM_OPERATION_CLASS);
            },
            onContentReady: function(e) {
              e.component.selectItem(currentOperation);
            },
            onItemClick: (e) => {
              if (currentOperation !== e.itemData) {
                currentOperation = e.itemData;
                updateConditionByOperation(condition, currentOperation.value, that._customOperations);
                var $valueButton = $operationButton.siblings().filter("." + FILTER_BUILDER_ITEM_VALUE_CLASS);
                if (that._hasValueButton(condition)) {
                  if (0 !== $valueButton.length) {
                    $valueButton.remove();
                  }
                  that._createValueButton(condition, field).appendTo($operationButton.parent());
                } else {
                  $valueButton.remove();
                }
                $operationButton.html(currentOperation.text);
                this._updateFilter();
              }
            },
            cssClass: FILTER_BUILDER_FILTER_OPERATIONS_CLASS
          }
        }).addClass(FILTER_BUILDER_ITEM_TEXT_CLASS2).addClass(FILTER_BUILDER_ITEM_OPERATION_CLASS).attr("tabindex", 0);
        return $operationButton;
      },
      _createOperationAndValueButtons: function(condition, field, $item) {
        this._createOperationButtonWithMenu(condition, field).appendTo($item);
        if (this._hasValueButton(condition)) {
          this._createValueButton(condition, field).appendTo($item);
        }
      },
      _createFieldButtonWithMenu: function(fields, condition, field) {
        var that = this;
        var allowHierarchicalFields = this.option("allowHierarchicalFields");
        var items = getItems2(fields, allowHierarchicalFields);
        var item = getField(field.name || field.dataField, items);
        var getFullCaption = function(item2, items2) {
          return allowHierarchicalFields ? getCaptionWithParents(item2, items2) : item2.caption;
        };
        var $fieldButton = this._createButtonWithMenu({
          caption: getFullCaption(item, items),
          menu: {
            items,
            dataStructure: "plain",
            keyExpr: "id",
            parentId: "parentId",
            displayExpr: "caption",
            onItemClick: (e) => {
              if (item !== e.itemData) {
                item = e.itemData;
                condition[0] = item.name || item.dataField;
                condition[2] = "object" === item.dataType ? null : "";
                updateConditionByOperation(condition, getDefaultOperation(item), that._customOperations);
                $fieldButton.siblings().filter("." + FILTER_BUILDER_ITEM_TEXT_CLASS2).remove();
                that._createOperationAndValueButtons(condition, item, $fieldButton.parent());
                var caption = getFullCaption(item, e.component.option("items"));
                $fieldButton.html(caption);
                this._updateFilter();
              }
            },
            onContentReady: function(e) {
              e.component.selectItem(item);
            },
            cssClass: FILTER_BUILDER_FIELDS_CLASS
          }
        }).addClass(FILTER_BUILDER_ITEM_TEXT_CLASS2).addClass(FILTER_BUILDER_ITEM_FIELD_CLASS).attr("tabindex", 0);
        return $fieldButton;
      },
      _createConditionItem: function(condition, parent) {
        var $item = renderer_default("<div>").addClass(FILTER_BUILDER_GROUP_ITEM_CLASS);
        var fields = this._getNormalizedFields();
        var field = getField(condition[0], fields);
        this._createRemoveButton(() => {
          removeItem(parent, condition);
          var isSingleChild = 1 === $item.parent().children().length;
          if (isSingleChild) {
            $item.parent().remove();
          } else {
            $item.remove();
          }
          this._updateFilter();
        }).appendTo($item);
        this._createFieldButtonWithMenu(fields, condition, field).appendTo($item);
        this._createOperationAndValueButtons(condition, field, $item);
        return $item;
      },
      _getGroupOperations: function(criteria) {
        var groupOperations = this.option("groupOperations");
        var groupOperationDescriptions = this.option("groupOperationDescriptions");
        if (!groupOperations || !groupOperations.length) {
          groupOperations = [getGroupValue(criteria).replace("!", "not")];
        }
        return groupOperations.map((operation) => ({
          text: groupOperationDescriptions[operation],
          value: OPERATORS[operation]
        }));
      },
      _createRemoveButton: function(handler) {
        var $removeButton = renderer_default("<div>").addClass(FILTER_BUILDER_IMAGE_CLASS).addClass(FILTER_BUILDER_IMAGE_REMOVE_CLASS).addClass(FILTER_BUILDER_ACTION_CLASS).attr("tabindex", 0);
        this._subscribeOnClickAndEnterKey($removeButton, handler);
        return $removeButton;
      },
      _createAddButton: function(addGroupHandler, addConditionHandler, groupLevel) {
        var $button;
        var maxGroupLevel = this.option("maxGroupLevel");
        if (isDefined(maxGroupLevel) && groupLevel >= maxGroupLevel) {
          $button = this._createButton();
          this._subscribeOnClickAndEnterKey($button, addConditionHandler);
        } else {
          $button = this._createButtonWithMenu({
            menu: {
              items: [{
                caption: message_default.format("dxFilterBuilder-addCondition"),
                click: addConditionHandler
              }, {
                caption: message_default.format("dxFilterBuilder-addGroup"),
                click: addGroupHandler
              }],
              displayExpr: "caption",
              onItemClick: function(e) {
                e.itemData.click();
              },
              cssClass: FILTER_BUILDER_ADD_CONDITION_CLASS
            }
          });
        }
        return $button.addClass(FILTER_BUILDER_IMAGE_CLASS).addClass(FILTER_BUILDER_IMAGE_ADD_CLASS).addClass(FILTER_BUILDER_ACTION_CLASS).attr("tabindex", 0);
      },
      _createValueText: function(item, field, $container) {
        var that = this;
        var $text = renderer_default("<div>").html("&nbsp;").addClass(FILTER_BUILDER_ITEM_VALUE_TEXT_CLASS).attr("tabindex", 0).appendTo($container);
        var value2 = item[2];
        var customOperation = getCustomOperation(that._customOperations, item[1]);
        if (!customOperation && field.lookup) {
          getCurrentLookupValueText(field, value2, function(result2) {
            renderValueText($text, result2);
          });
        } else {
          when(getCurrentValueText(field, value2, customOperation)).done((result2) => {
            renderValueText($text, result2, customOperation);
          });
        }
        that._subscribeOnClickAndEnterKey($text, function(e) {
          if ("keyup" === e.type) {
            e.stopPropagation();
          }
          that._createValueEditorWithEvents(item, field, $container);
        });
        return $text;
      },
      _updateConditionValue: function(item, value2, callback) {
        var areValuesDifferent = item[2] !== value2;
        if (areValuesDifferent) {
          item[2] = value2;
        }
        callback();
        this._updateFilter();
      },
      _addDocumentKeyUp: function($editor, handler) {
        var isComposing = false;
        var hasCompositionJustEnded = false;
        var document2 = dom_adapter_default.getDocument();
        var documentKeyUpHandler = (e) => {
          if (isComposing || hasCompositionJustEnded) {
            hasCompositionJustEnded = false;
            return;
          }
          handler(e);
        };
        events_engine_default.on(document2, "keyup", documentKeyUpHandler);
        var input = $editor.find("input");
        events_engine_default.on(input, "compositionstart", () => {
          isComposing = true;
        });
        events_engine_default.on(input, "compositionend", () => {
          isComposing = false;
          hasCompositionJustEnded = true;
        });
        events_engine_default.on(input, "keydown", (event) => {
          if (229 !== event.which) {
            hasCompositionJustEnded = false;
          }
        });
        this._documentKeyUpHandler = documentKeyUpHandler;
      },
      _addDocumentClick: function($editor, closeEditorFunc) {
        var document2 = dom_adapter_default.getDocument();
        var documentClickHandler = (e) => {
          if (!this._isFocusOnEditorParts($editor, e.target)) {
            events_engine_default.trigger($editor.find("input"), "change");
            closeEditorFunc();
          }
        };
        events_engine_default.on(document2, "dxpointerdown", documentClickHandler);
        this._documentClickHandler = documentClickHandler;
      },
      _isFocusOnEditorParts: function($editor, target) {
        var activeElement = target || dom_adapter_default.getActiveElement();
        return renderer_default(activeElement).closest($editor.children()).length || renderer_default(activeElement).closest(".dx-dropdowneditor-overlay").length;
      },
      _removeEvents: function() {
        var document2 = dom_adapter_default.getDocument();
        isDefined(this._documentKeyUpHandler) && events_engine_default.off(document2, "keyup", this._documentKeyUpHandler);
        isDefined(this._documentClickHandler) && events_engine_default.off(document2, "dxpointerdown", this._documentClickHandler);
      },
      _dispose: function() {
        this._removeEvents();
        this.callBase();
      },
      _createValueEditorWithEvents: function(item, field, $container) {
        var value2 = item[2];
        var createValueText = () => {
          $container.empty();
          this._removeEvents();
          return this._createValueText(item, field, $container);
        };
        var closeEditor = () => {
          this._updateConditionValue(item, value2, function() {
            createValueText();
          });
        };
        var options2 = {
          value: "" === value2 ? null : value2,
          filterOperation: getOperationValue(item),
          setValue: function(data2) {
            value2 = null === data2 ? "" : data2;
          },
          closeEditor,
          text: $container.text()
        };
        $container.empty();
        var $editor = this._createValueEditor($container, field, options2);
        events_engine_default.trigger($editor.find("input").not(":hidden").eq(0), "focus");
        this._removeEvents();
        this._addDocumentClick($editor, closeEditor);
        this._addDocumentKeyUp($editor, (e) => {
          var keyName = normalizeKeyName(e);
          if (keyName === TAB_KEY2) {
            if (this._isFocusOnEditorParts($editor)) {
              return;
            }
            this._updateConditionValue(item, value2, function() {
              createValueText();
              if (e.shiftKey) {
                events_engine_default.trigger($container.prev(), "focus");
              }
            });
          }
          if (keyName === ESCAPE_KEY) {
            events_engine_default.trigger(createValueText(), "focus");
          }
          if (keyName === ENTER_KEY) {
            this._updateConditionValue(item, value2, function() {
              events_engine_default.trigger(createValueText(), "focus");
            });
          }
        });
        this._fireContentReadyAction();
      },
      _createValueButton: function(item, field) {
        var $valueButton = renderer_default("<div>").addClass(FILTER_BUILDER_ITEM_TEXT_CLASS2).addClass(FILTER_BUILDER_ITEM_VALUE_CLASS);
        this._createValueText(item, field, $valueButton);
        return $valueButton;
      },
      _createValueEditor: function($container, field, options2) {
        var $editor = renderer_default("<div>").attr("tabindex", 0).appendTo($container);
        var customOperation = getCustomOperation(this._customOperations, options2.filterOperation);
        var editorTemplate2 = customOperation && customOperation.editorTemplate ? customOperation.editorTemplate : field.editorTemplate;
        if (editorTemplate2) {
          var template = this._getTemplate(editorTemplate2);
          template.render({
            model: extend2({
              field
            }, options2),
            container: $editor
          });
        } else {
          this._editorFactory.createEditor.call(this, $editor, extend2({}, field, options2, {
            parentType: SOURCE
          }));
        }
        return $editor;
      },
      _createPopupWithTreeView: function(options2, $container) {
        var that = this;
        var $popup = renderer_default("<div>").addClass(options2.menu.cssClass).appendTo($container);
        this._createComponent($popup, popup_default, {
          onHiding: options2.menu.onHiding,
          onHidden: options2.menu.onHidden,
          rtlEnabled: options2.menu.rtlEnabled,
          position: options2.menu.position,
          animation: options2.menu.animation,
          contentTemplate: function(contentElement) {
            var $menuContainer = renderer_default("<div>").appendTo(contentElement);
            that._createComponent($menuContainer, tree_view_default, options2.menu);
            this.repaint();
          },
          maxHeight: function() {
            return getElementMaxHeightByWindow(options2.menu.position.of);
          },
          visible: true,
          focusStateEnabled: false,
          closeOnTargetScroll: this.option("closePopupOnTargetScroll"),
          closeOnOutsideClick: true,
          onShown: options2.popup.onShown,
          shading: false,
          width: "auto",
          height: "auto",
          showTitle: false
        });
      },
      _subscribeOnClickAndEnterKey: function($button, handler) {
        events_engine_default.on($button, "dxclick", handler);
        events_engine_default.on($button, "keyup", function(e) {
          if (normalizeKeyName(e) === ENTER_KEY) {
            handler(e);
          }
        });
      }
    });
    component_registrator_default("dxFilterBuilder", FilterBuilder);
    filter_builder_default = FilterBuilder;
  }
});

// node_modules/devextreme/esm/ui/filter_builder.js
var filter_builder_default2;
var init_filter_builder2 = __esm({
  "node_modules/devextreme/esm/ui/filter_builder.js"() {
    init_filter_builder();
    filter_builder_default2 = filter_builder_default;
  }
});

// node_modules/devextreme/esm/ui/grid_core/ui.grid_core.filter_builder.js
var FilterBuilderView, filterBuilderModule;
var init_ui_grid_core_filter_builder = __esm({
  "node_modules/devextreme/esm/ui/grid_core/ui.grid_core.filter_builder.js"() {
    init_renderer();
    init_ui_grid_core_modules();
    init_extend();
    init_filter_builder2();
    init_message();
    init_scroll_view();
    init_popup();
    init_accessibility();
    FilterBuilderView = ui_grid_core_modules_default.View.inherit({
      _renderCore: function() {
        this._updatePopupOptions();
      },
      _updatePopupOptions: function() {
        if (this.option("filterBuilderPopup.visible")) {
          this._initPopup();
        } else if (this._filterBuilderPopup) {
          this._filterBuilderPopup.hide();
        }
      },
      _disposePopup: function() {
        if (this._filterBuilderPopup) {
          this._filterBuilderPopup.dispose();
          this._filterBuilderPopup = void 0;
        }
        if (this._filterBuilder) {
          this._filterBuilder.dispose();
          this._filterBuilder = void 0;
        }
      },
      _initPopup: function() {
        var that = this;
        that._disposePopup();
        that._filterBuilderPopup = that._createComponent(that.element(), popup_default, extend2({
          title: message_default.format("dxDataGrid-filterBuilderPopupTitle"),
          contentTemplate: function($contentElement) {
            return that._getPopupContentTemplate($contentElement);
          },
          onOptionChanged: function(args) {
            if ("visible" === args.name) {
              that.option("filterBuilderPopup.visible", args.value);
            }
          },
          toolbarItems: that._getPopupToolbarItems()
        }, that.option("filterBuilderPopup"), {
          onHidden: function(e) {
            restoreFocus(that);
            that._disposePopup();
          }
        }));
      },
      _getPopupContentTemplate: function(contentElement) {
        var $contentElement = renderer_default(contentElement);
        var $filterBuilderContainer = renderer_default("<div>").appendTo(renderer_default(contentElement));
        this._filterBuilder = this._createComponent($filterBuilderContainer, filter_builder_default2, extend2({
          value: this.option("filterValue"),
          fields: this.getController("columns").getFilteringColumns()
        }, this.option("filterBuilder"), {
          customOperations: this.getController("filterSync").getCustomFilterOperations()
        }));
        this._createComponent($contentElement, scroll_view_default, {
          direction: "both"
        });
      },
      _getPopupToolbarItems: function() {
        var that = this;
        return [{
          toolbar: "bottom",
          location: "after",
          widget: "dxButton",
          options: {
            text: message_default.format("OK"),
            onClick: function(e) {
              var filter = that._filterBuilder.option("value");
              that.option("filterValue", filter);
              that._filterBuilderPopup.hide();
            }
          }
        }, {
          toolbar: "bottom",
          location: "after",
          widget: "dxButton",
          options: {
            text: message_default.format("Cancel"),
            onClick: function(e) {
              that._filterBuilderPopup.hide();
            }
          }
        }];
      },
      optionChanged: function(args) {
        switch (args.name) {
          case "filterBuilder":
          case "filterBuilderPopup":
            this._invalidate();
            args.handled = true;
            break;
          default:
            this.callBase(args);
        }
      }
    });
    filterBuilderModule = {
      defaultOptions: function() {
        return {
          filterBuilder: {
            groupOperationDescriptions: {
              and: message_default.format("dxFilterBuilder-and"),
              or: message_default.format("dxFilterBuilder-or"),
              notAnd: message_default.format("dxFilterBuilder-notAnd"),
              notOr: message_default.format("dxFilterBuilder-notOr")
            },
            filterOperationDescriptions: {
              between: message_default.format("dxFilterBuilder-filterOperationBetween"),
              equal: message_default.format("dxFilterBuilder-filterOperationEquals"),
              notEqual: message_default.format("dxFilterBuilder-filterOperationNotEquals"),
              lessThan: message_default.format("dxFilterBuilder-filterOperationLess"),
              lessThanOrEqual: message_default.format("dxFilterBuilder-filterOperationLessOrEquals"),
              greaterThan: message_default.format("dxFilterBuilder-filterOperationGreater"),
              greaterThanOrEqual: message_default.format("dxFilterBuilder-filterOperationGreaterOrEquals"),
              startsWith: message_default.format("dxFilterBuilder-filterOperationStartsWith"),
              contains: message_default.format("dxFilterBuilder-filterOperationContains"),
              notContains: message_default.format("dxFilterBuilder-filterOperationNotContains"),
              endsWith: message_default.format("dxFilterBuilder-filterOperationEndsWith"),
              isBlank: message_default.format("dxFilterBuilder-filterOperationIsBlank"),
              isNotBlank: message_default.format("dxFilterBuilder-filterOperationIsNotBlank")
            }
          },
          filterBuilderPopup: {}
        };
      },
      views: {
        filterBuilderView: FilterBuilderView
      }
    };
  }
});

// node_modules/devextreme/esm/ui/grid_core/ui.grid_core.filter_panel.js
var FILTER_PANEL_CLASS, FILTER_PANEL_TEXT_CLASS, FILTER_PANEL_CHECKBOX_CLASS, FILTER_PANEL_CLEAR_FILTER_CLASS, FILTER_PANEL_LEFT_CONTAINER, FILTER_PANEL_TARGET, FilterPanelView, filterPanelModule;
var init_ui_grid_core_filter_panel = __esm({
  "node_modules/devextreme/esm/ui/grid_core/ui.grid_core.filter_panel.js"() {
    init_renderer();
    init_type();
    init_ui_grid_core_modules();
    init_ui_grid_core_utils();
    init_events_engine();
    init_message();
    init_check_box();
    init_utils9();
    init_deferred();
    init_inflector();
    init_ui_grid_core_accessibility();
    FILTER_PANEL_CLASS = "filter-panel";
    FILTER_PANEL_TEXT_CLASS = FILTER_PANEL_CLASS + "-text";
    FILTER_PANEL_CHECKBOX_CLASS = FILTER_PANEL_CLASS + "-checkbox";
    FILTER_PANEL_CLEAR_FILTER_CLASS = FILTER_PANEL_CLASS + "-clear-filter";
    FILTER_PANEL_LEFT_CONTAINER = FILTER_PANEL_CLASS + "-left";
    FILTER_PANEL_TARGET = "filterPanel";
    FilterPanelView = ui_grid_core_modules_default.View.inherit({
      isVisible: function() {
        return this.option("filterPanel.visible") && this.getController("data").dataSource();
      },
      init: function() {
        this.getController("data").dataSourceChanged.add(() => this.render());
      },
      _renderCore: function() {
        var $element = this.element();
        $element.empty().addClass(this.addWidgetPrefix(FILTER_PANEL_CLASS));
        var $leftContainer = renderer_default("<div>").addClass(this.addWidgetPrefix(FILTER_PANEL_LEFT_CONTAINER)).appendTo($element);
        if (this.option("filterValue") || this._filterValueBuffer) {
          $leftContainer.append(this._getCheckElement()).append(this._getFilterElement()).append(this._getTextElement());
          $element.append(this._getRemoveButtonElement());
        } else {
          $leftContainer.append(this._getFilterElement()).append(this._getTextElement());
        }
      },
      _getCheckElement: function() {
        var that = this;
        var $element = renderer_default("<div>").addClass(this.addWidgetPrefix(FILTER_PANEL_CHECKBOX_CLASS));
        that._createComponent($element, check_box_default, {
          value: that.option("filterPanel.filterEnabled"),
          onValueChanged: function(e) {
            that.option("filterPanel.filterEnabled", e.value);
          }
        });
        $element.attr("title", this.option("filterPanel.texts.filterEnabledHint"));
        return $element;
      },
      _getFilterElement: function() {
        var that = this;
        var $element = renderer_default("<div>").addClass("dx-icon-filter");
        events_engine_default.on($element, "click", () => that._showFilterBuilder());
        registerKeyboardAction2("filterPanel", that, $element, void 0, () => that._showFilterBuilder());
        that._addTabIndexToElement($element);
        return $element;
      },
      _getTextElement: function() {
        var that = this;
        var $textElement = renderer_default("<div>").addClass(that.addWidgetPrefix(FILTER_PANEL_TEXT_CLASS));
        var filterText;
        var filterValue = that.option("filterValue");
        if (filterValue) {
          when(that.getFilterText(filterValue, that.getController("filterSync").getCustomFilterOperations())).done(function(filterText2) {
            var customizeText = that.option("filterPanel.customizeText");
            if (customizeText) {
              var customText = customizeText({
                component: that.component,
                filterValue,
                text: filterText2
              });
              if ("string" === typeof customText) {
                filterText2 = customText;
              }
            }
            $textElement.text(filterText2);
          });
        } else {
          filterText = that.option("filterPanel.texts.createFilter");
          $textElement.text(filterText);
        }
        events_engine_default.on($textElement, "click", () => that._showFilterBuilder());
        registerKeyboardAction2("filterPanel", that, $textElement, void 0, () => that._showFilterBuilder());
        that._addTabIndexToElement($textElement);
        return $textElement;
      },
      _showFilterBuilder: function() {
        this.option("filterBuilderPopup.visible", true);
      },
      _getRemoveButtonElement: function() {
        var that = this;
        var clearFilterValue = () => that.option("filterValue", null);
        var $element = renderer_default("<div>").addClass(that.addWidgetPrefix(FILTER_PANEL_CLEAR_FILTER_CLASS)).text(that.option("filterPanel.texts.clearFilter"));
        events_engine_default.on($element, "click", clearFilterValue);
        registerKeyboardAction2("filterPanel", this, $element, void 0, clearFilterValue);
        that._addTabIndexToElement($element);
        return $element;
      },
      _addTabIndexToElement: function($element) {
        if (!this.option("useLegacyKeyboardNavigation")) {
          var tabindex = this.option("tabindex") || 0;
          $element.attr("tabindex", tabindex);
        }
      },
      optionChanged: function(args) {
        switch (args.name) {
          case "filterValue":
            this._invalidate();
            this.option("filterPanel.filterEnabled", true);
            args.handled = true;
            break;
          case "filterPanel":
            this._invalidate();
            args.handled = true;
            break;
          default:
            this.callBase(args);
        }
      },
      _getConditionText: function(fieldText, operationText, valueText) {
        var result2 = "[".concat(fieldText, "] ").concat(operationText);
        if (isDefined(valueText)) {
          result2 += valueText;
        }
        return result2;
      },
      _getValueMaskedText: function(value2) {
        return Array.isArray(value2) ? "('".concat(value2.join("', '"), "')") : " '".concat(value2, "'");
      },
      _getValueText: function(field, customOperation, value2) {
        var deferred = new Deferred();
        var hasCustomOperation = customOperation && customOperation.customizeText;
        if (isDefined(value2) || hasCustomOperation) {
          if (!hasCustomOperation && field.lookup) {
            getCurrentLookupValueText(field, value2, (data2) => {
              deferred.resolve(this._getValueMaskedText(data2));
            });
          } else {
            var displayValue = Array.isArray(value2) ? value2 : ui_grid_core_utils_default.getDisplayValue(field, value2);
            when(getCurrentValueText(field, displayValue, customOperation, FILTER_PANEL_TARGET)).done((data2) => {
              deferred.resolve(this._getValueMaskedText(data2));
            });
          }
        } else {
          deferred.resolve("");
        }
        return deferred.promise();
      },
      getConditionText: function(filterValue, options2) {
        var that = this;
        var operation = filterValue[1];
        var deferred = new Deferred();
        var customOperation = getCustomOperation(options2.customOperations, operation);
        var operationText;
        var field = getField(filterValue[0], options2.columns);
        var fieldText = field.caption || "";
        var value2 = filterValue[2];
        if (customOperation) {
          operationText = customOperation.caption || captionize(customOperation.name);
        } else if (null === value2) {
          operationText = getCaptionByOperation("=" === operation ? "isblank" : "isnotblank", options2.filterOperationDescriptions);
        } else {
          operationText = getCaptionByOperation(operation, options2.filterOperationDescriptions);
        }
        this._getValueText(field, customOperation, value2).done((valueText) => {
          deferred.resolve(that._getConditionText(fieldText, operationText, valueText));
        });
        return deferred;
      },
      getGroupText: function(filterValue, options2, isInnerGroup) {
        var that = this;
        var result2 = new Deferred();
        var textParts = [];
        var groupValue = getGroupValue(filterValue);
        filterValue.forEach((item) => {
          if (isCondition(item)) {
            textParts.push(that.getConditionText(item, options2));
          } else if (isGroup(item)) {
            textParts.push(that.getGroupText(item, options2, true));
          }
        });
        when.apply(this, textParts).done(function() {
          var text;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          if ("!" === groupValue[0]) {
            var groupText = options2.groupOperationDescriptions["not" + groupValue.substring(1, 2).toUpperCase() + groupValue.substring(2)].split(" ");
            text = "".concat(groupText[0], " ").concat(args[0]);
          } else {
            text = args.join(" ".concat(options2.groupOperationDescriptions[groupValue], " "));
          }
          if (isInnerGroup) {
            text = "(".concat(text, ")");
          }
          result2.resolve(text);
        });
        return result2;
      },
      getFilterText: function(filterValue, customOperations) {
        var options2 = {
          customOperations,
          columns: this.getController("columns").getFilteringColumns(),
          filterOperationDescriptions: this.option("filterBuilder.filterOperationDescriptions"),
          groupOperationDescriptions: this.option("filterBuilder.groupOperationDescriptions")
        };
        return isCondition(filterValue) ? this.getConditionText(filterValue, options2) : this.getGroupText(filterValue, options2);
      }
    });
    filterPanelModule = {
      defaultOptions: function() {
        return {
          filterPanel: {
            visible: false,
            filterEnabled: true,
            texts: {
              createFilter: message_default.format("dxDataGrid-filterPanelCreateFilter"),
              clearFilter: message_default.format("dxDataGrid-filterPanelClearFilter"),
              filterEnabledHint: message_default.format("dxDataGrid-filterPanelFilterEnabledHint")
            }
          }
        };
      },
      views: {
        filterPanelView: FilterPanelView
      },
      extenders: {
        controllers: {
          data: {
            optionChanged: function(args) {
              switch (args.name) {
                case "filterPanel":
                  this._applyFilter();
                  args.handled = true;
                  break;
                default:
                  this.callBase(args);
              }
            }
          }
        }
      }
    };
  }
});

// node_modules/devextreme/esm/ui/grid_core/ui.grid_core.search.js
function allowSearch(column) {
  return isDefined(column.allowSearch) ? column.allowSearch : column.allowFiltering;
}
function parseValue2(column, text) {
  var lookup = column.lookup;
  if (!column.parseValue) {
    return text;
  }
  if (lookup) {
    return column.parseValue.call(lookup, text);
  }
  return column.parseValue(text);
}
var SEARCH_PANEL_CLASS, SEARCH_TEXT_CLASS, HEADER_PANEL_CLASS, FILTERING_TIMEOUT2, searchModule;
var init_ui_grid_core_search = __esm({
  "node_modules/devextreme/esm/ui/grid_core/ui.grid_core.search.js"() {
    init_renderer();
    init_dom_adapter();
    init_type();
    init_data();
    init_ui_grid_core_utils();
    init_message();
    init_query();
    SEARCH_PANEL_CLASS = "search-panel";
    SEARCH_TEXT_CLASS = "search-text";
    HEADER_PANEL_CLASS = "header-panel";
    FILTERING_TIMEOUT2 = 700;
    searchModule = {
      defaultOptions: function() {
        return {
          searchPanel: {
            visible: false,
            width: 160,
            placeholder: message_default.format("dxDataGrid-searchPanelPlaceholder"),
            highlightSearchText: true,
            highlightCaseSensitive: false,
            text: "",
            searchVisibleColumnsOnly: false
          }
        };
      },
      extenders: {
        controllers: {
          data: {
            publicMethods: function() {
              return this.callBase().concat(["searchByText"]);
            },
            _calculateAdditionalFilter: function() {
              var filter = this.callBase();
              var searchFilter = function(that, text) {
                var i;
                var column;
                var columns = that._columnsController.getColumns();
                var searchVisibleColumnsOnly = that.option("searchPanel.searchVisibleColumnsOnly");
                var lookup;
                var filters = [];
                if (!text) {
                  return null;
                }
                function onQueryDone(items) {
                  var valueGetter = compileGetter(lookup.valueExpr);
                  for (var _i = 0; _i < items.length; _i++) {
                    var value2 = valueGetter(items[_i]);
                    filters.push(column.createFilterExpression(value2, null, "search"));
                  }
                }
                for (i = 0; i < columns.length; i++) {
                  column = columns[i];
                  if (searchVisibleColumnsOnly && !column.visible) {
                    continue;
                  }
                  if (allowSearch(column) && column.calculateFilterExpression) {
                    lookup = column.lookup;
                    var filterValue = parseValue2(column, text);
                    if (lookup && lookup.items) {
                      query_default(lookup.items).filter(column.createFilterExpression.call({
                        dataField: lookup.displayExpr,
                        dataType: lookup.dataType,
                        calculateFilterExpression: column.calculateFilterExpression
                      }, filterValue, null, "search")).enumerate().done(onQueryDone);
                    } else if (void 0 !== filterValue) {
                      filters.push(column.createFilterExpression(filterValue, null, "search"));
                    }
                  }
                }
                if (0 === filters.length) {
                  return ["!"];
                }
                return ui_grid_core_utils_default.combineFilters(filters, "or");
              }(this, this.option("searchPanel.text"));
              return ui_grid_core_utils_default.combineFilters([filter, searchFilter]);
            },
            searchByText: function(text) {
              this.option("searchPanel.text", text);
            },
            optionChanged: function(args) {
              switch (args.fullName) {
                case "searchPanel.text":
                case "searchPanel":
                  this._applyFilter();
                  args.handled = true;
                  break;
                default:
                  this.callBase(args);
              }
            }
          }
        },
        views: {
          headerPanel: /* @__PURE__ */ function() {
            var getSearchPanelOptions = function(that) {
              return that.option("searchPanel");
            };
            return {
              _getToolbarItems: function() {
                var items = this.callBase();
                return this._prepareSearchItem(items);
              },
              _prepareSearchItem: function(items) {
                var that = this;
                var dataController = that.getController("data");
                var searchPanelOptions = getSearchPanelOptions(that);
                if (searchPanelOptions && searchPanelOptions.visible) {
                  var toolbarItem = {
                    template: function(data2, index2, container) {
                      var $search = renderer_default("<div>").addClass(that.addWidgetPrefix(SEARCH_PANEL_CLASS)).appendTo(container);
                      that.getController("editorFactory").createEditor($search, {
                        width: searchPanelOptions.width,
                        placeholder: searchPanelOptions.placeholder,
                        parentType: "searchPanel",
                        value: that.option("searchPanel.text"),
                        updateValueTimeout: FILTERING_TIMEOUT2,
                        setValue: function(value2) {
                          dataController.searchByText(value2);
                        },
                        editorOptions: {
                          inputAttr: {
                            "aria-label": message_default.format("".concat(that.component.NAME, "-ariaSearchInGrid"))
                          }
                        }
                      });
                      that.resize();
                    },
                    name: "searchPanel",
                    location: "after",
                    locateInMenu: "never",
                    sortIndex: 40
                  };
                  items.push(toolbarItem);
                }
                return items;
              },
              getSearchTextEditor: function() {
                var that = this;
                var $element = that.element();
                var $searchPanel = $element.find("." + that.addWidgetPrefix(SEARCH_PANEL_CLASS)).filter(function() {
                  return renderer_default(this).closest("." + that.addWidgetPrefix(HEADER_PANEL_CLASS)).is($element);
                });
                if ($searchPanel.length) {
                  return $searchPanel.dxTextBox("instance");
                }
                return null;
              },
              isVisible: function() {
                var searchPanelOptions = getSearchPanelOptions(this);
                return this.callBase() || searchPanelOptions && searchPanelOptions.visible;
              },
              optionChanged: function(args) {
                if ("searchPanel" === args.name) {
                  if ("searchPanel.text" === args.fullName) {
                    var editor = this.getSearchTextEditor();
                    if (editor) {
                      editor.option("value", args.value);
                    }
                  } else {
                    this._invalidate();
                  }
                  args.handled = true;
                } else {
                  this.callBase(args);
                }
              }
            };
          }(),
          rowsView: {
            init: function() {
              this.callBase.apply(this, arguments);
              this._searchParams = [];
            },
            _getFormattedSearchText: function(column, searchText) {
              var value2 = parseValue2(column, searchText);
              var formatOptions = ui_grid_core_utils_default.getFormatOptionsByColumn(column, "search");
              return ui_grid_core_utils_default.formatValue(value2, formatOptions);
            },
            _getStringNormalizer: function() {
              var isCaseSensitive = this.option("searchPanel.highlightCaseSensitive");
              return function(str) {
                return isCaseSensitive ? str : str.toLowerCase();
              };
            },
            _findHighlightingTextNodes: function(column, cellElement, searchText) {
              var _$items;
              var $parent = cellElement.parent();
              var $items;
              var stringNormalizer = this._getStringNormalizer();
              var normalizedSearchText = stringNormalizer(searchText);
              var resultTextNodes = [];
              if (!$parent.length) {
                $parent = renderer_default("<div>").append(cellElement);
              } else if (column) {
                if (column.groupIndex >= 0 && !column.showWhenGrouped) {
                  $items = cellElement;
                } else {
                  var columnIndex = this._columnsController.getVisibleIndex(column.index);
                  $items = $parent.children("td").eq(columnIndex).find("*");
                }
              }
              $items = null !== (_$items = $items) && void 0 !== _$items && _$items.length ? $items : $parent.find("*");
              $items.each(function(_2, element) {
                var $contents = renderer_default(element).contents();
                for (var i = 0; i < $contents.length; i++) {
                  var node = $contents.get(i);
                  if (3 === node.nodeType) {
                    var normalizedText = stringNormalizer(node.textContent || node.nodeValue);
                    if (normalizedText.indexOf(normalizedSearchText) > -1) {
                      resultTextNodes.push(node);
                    }
                  }
                }
              });
              return resultTextNodes;
            },
            _highlightSearchTextCore: function($textNode, searchText) {
              var $searchTextSpan = renderer_default("<span>").addClass(this.addWidgetPrefix(SEARCH_TEXT_CLASS));
              var text = $textNode.text();
              var firstContentElement = $textNode[0];
              var stringNormalizer = this._getStringNormalizer();
              var index2 = stringNormalizer(text).indexOf(stringNormalizer(searchText));
              if (index2 >= 0) {
                if (firstContentElement.textContent) {
                  firstContentElement.textContent = text.substr(0, index2);
                } else {
                  firstContentElement.nodeValue = text.substr(0, index2);
                }
                $textNode.after($searchTextSpan.text(text.substr(index2, searchText.length)));
                $textNode = renderer_default(dom_adapter_default.createTextNode(text.substr(index2 + searchText.length))).insertAfter($searchTextSpan);
                return this._highlightSearchTextCore($textNode, searchText);
              }
            },
            _highlightSearchText: function(cellElement, isEquals, column) {
              var that = this;
              var stringNormalizer = this._getStringNormalizer();
              var searchText = that.option("searchPanel.text");
              if (isEquals && column) {
                searchText = searchText && that._getFormattedSearchText(column, searchText);
              }
              if (searchText && that.option("searchPanel.highlightSearchText")) {
                var textNodes = that._findHighlightingTextNodes(column, cellElement, searchText);
                textNodes.forEach((textNode) => {
                  if (isEquals) {
                    if (stringNormalizer(renderer_default(textNode).text()) === stringNormalizer(searchText)) {
                      renderer_default(textNode).replaceWith(renderer_default("<span>").addClass(that.addWidgetPrefix(SEARCH_TEXT_CLASS)).text(renderer_default(textNode).text()));
                    }
                  } else {
                    that._highlightSearchTextCore(renderer_default(textNode), searchText);
                  }
                });
              }
            },
            _renderCore: function() {
              this.callBase.apply(this, arguments);
              if (this.option("rowTemplate")) {
                if (this.option("templatesRenderAsynchronously")) {
                  clearTimeout(this._highlightTimer);
                  this._highlightTimer = setTimeout((function() {
                    this._highlightSearchText(this.getTableElement());
                  }).bind(this));
                } else {
                  this._highlightSearchText(this.getTableElement());
                }
              }
            },
            _updateCell: function($cell, parameters) {
              var column = parameters.column;
              var dataType = column.lookup && column.lookup.dataType || column.dataType;
              var isEquals = "string" !== dataType;
              if (allowSearch(column) && !parameters.isOnForm) {
                if (this.option("templatesRenderAsynchronously")) {
                  if (!this._searchParams.length) {
                    clearTimeout(this._highlightTimer);
                    this._highlightTimer = setTimeout((function() {
                      this._searchParams.forEach((function(params) {
                        this._highlightSearchText.apply(this, params);
                      }).bind(this));
                      this._searchParams = [];
                    }).bind(this));
                  }
                  this._searchParams.push([$cell, isEquals, column]);
                } else {
                  this._highlightSearchText($cell, isEquals, column);
                }
              }
              this.callBase($cell, parameters);
            },
            dispose: function() {
              clearTimeout(this._highlightTimer);
              this.callBase();
            }
          }
        }
      }
    };
  }
});

// node_modules/inferno/dist/index.esm.js
function isStringOrNumber(o) {
  var type2 = typeof o;
  return type2 === "string" || type2 === "number";
}
function isNullOrUndef(o) {
  return o === void 0 || o === null;
}
function isInvalid(o) {
  return o === null || o === false || o === true || o === void 0;
}
function isFunction2(o) {
  return typeof o === "function";
}
function isString3(o) {
  return typeof o === "string";
}
function isNumber(o) {
  return typeof o === "number";
}
function isNull(o) {
  return o === null;
}
function isUndefined(o) {
  return o === void 0;
}
function combineFrom(first, second) {
  var out = {};
  if (first) {
    for (var key in first) {
      out[key] = first[key];
    }
  }
  if (second) {
    for (var key$1 in second) {
      out[key$1] = second[key$1];
    }
  }
  return out;
}
function isLinkEventObject(o) {
  return !isNull(o) && typeof o === "object";
}
function normalizeEventName(name2) {
  return name2.substr(2).toLowerCase();
}
function appendChild(parentDOM, dom) {
  parentDOM.appendChild(dom);
}
function insertOrAppend(parentDOM, newNode, nextNode) {
  if (isNull(nextNode)) {
    appendChild(parentDOM, newNode);
  } else {
    parentDOM.insertBefore(newNode, nextNode);
  }
}
function documentCreateElement(tag, isSVG) {
  if (isSVG) {
    return document.createElementNS("http://www.w3.org/2000/svg", tag);
  }
  return document.createElement(tag);
}
function replaceChild(parentDOM, newDom, lastDom) {
  parentDOM.replaceChild(newDom, lastDom);
}
function removeChild(parentDOM, childNode) {
  parentDOM.removeChild(childNode);
}
function callAll(arrayFn) {
  for (var i = 0; i < arrayFn.length; i++) {
    arrayFn[i]();
  }
}
function findChildVNode(vNode, startEdge, flags) {
  var children = vNode.children;
  if (flags & 4) {
    return children.$LI;
  }
  if (flags & 8192) {
    return vNode.childFlags === 2 ? children : children[startEdge ? 0 : children.length - 1];
  }
  return children;
}
function findDOMfromVNode(vNode, startEdge) {
  var flags;
  while (vNode) {
    flags = vNode.flags;
    if (flags & 2033) {
      return vNode.dom;
    }
    vNode = findChildVNode(vNode, startEdge, flags);
  }
  return null;
}
function removeVNodeDOM(vNode, parentDOM) {
  do {
    var flags = vNode.flags;
    if (flags & 2033) {
      removeChild(parentDOM, vNode.dom);
      return;
    }
    var children = vNode.children;
    if (flags & 4) {
      vNode = children.$LI;
    }
    if (flags & 8) {
      vNode = children;
    }
    if (flags & 8192) {
      if (vNode.childFlags === 2) {
        vNode = children;
      } else {
        for (var i = 0, len = children.length; i < len; ++i) {
          removeVNodeDOM(children[i], parentDOM);
        }
        return;
      }
    }
  } while (vNode);
}
function moveVNodeDOM(vNode, parentDOM, nextNode) {
  do {
    var flags = vNode.flags;
    if (flags & 2033) {
      insertOrAppend(parentDOM, vNode.dom, nextNode);
      return;
    }
    var children = vNode.children;
    if (flags & 4) {
      vNode = children.$LI;
    }
    if (flags & 8) {
      vNode = children;
    }
    if (flags & 8192) {
      if (vNode.childFlags === 2) {
        vNode = children;
      } else {
        for (var i = 0, len = children.length; i < len; ++i) {
          moveVNodeDOM(children[i], parentDOM, nextNode);
        }
        return;
      }
    }
  } while (vNode);
}
function createDerivedState(instance, nextProps, state) {
  if (instance.constructor.getDerivedStateFromProps) {
    return combineFrom(state, instance.constructor.getDerivedStateFromProps(nextProps, state));
  }
  return state;
}
function setTextContent(dom, children) {
  dom.textContent = children;
}
function isLastValueSameLinkEvent(lastValue, nextValue) {
  return isLinkEventObject(lastValue) && lastValue.event === nextValue.event && lastValue.data === nextValue.data;
}
function mergeUnsetProperties(to, from) {
  for (var propName in from) {
    if (isUndefined(to[propName])) {
      to[propName] = from[propName];
    }
  }
  return to;
}
function safeCall1(method, arg1) {
  return !!isFunction2(method) && (method(arg1), true);
}
function V(childFlags, children, className, flags, key, props, ref, type2) {
  this.childFlags = childFlags;
  this.children = children;
  this.className = className;
  this.dom = null;
  this.flags = flags;
  this.key = key === void 0 ? null : key;
  this.props = props === void 0 ? null : props;
  this.ref = ref === void 0 ? null : ref;
  this.type = type2;
}
function createVNode(flags, type2, className, children, childFlags, props, key, ref) {
  var childFlag = childFlags === void 0 ? 1 : childFlags;
  var vNode = new V(childFlag, children, className, flags, key, props, ref, type2);
  if (options.createVNode) {
    options.createVNode(vNode);
  }
  if (childFlag === 0) {
    normalizeChildren(vNode, vNode.children);
  }
  return vNode;
}
function mergeDefaultHooks(flags, type2, ref) {
  if (flags & 4) {
    return ref;
  }
  var defaultHooks = (flags & 32768 ? type2.render : type2).defaultHooks;
  if (isNullOrUndef(defaultHooks)) {
    return ref;
  }
  if (isNullOrUndef(ref)) {
    return defaultHooks;
  }
  return mergeUnsetProperties(ref, defaultHooks);
}
function mergeDefaultProps(flags, type2, props) {
  var defaultProps = (flags & 32768 ? type2.render : type2).defaultProps;
  if (isNullOrUndef(defaultProps)) {
    return props;
  }
  if (isNullOrUndef(props)) {
    return combineFrom(defaultProps, null);
  }
  return mergeUnsetProperties(props, defaultProps);
}
function resolveComponentFlags(flags, type2) {
  if (flags & 12) {
    return flags;
  }
  if (type2.prototype && type2.prototype.render) {
    return 4;
  }
  if (type2.render) {
    return 32776;
  }
  return 8;
}
function createComponentVNode(flags, type2, props, key, ref) {
  flags = resolveComponentFlags(flags, type2);
  var vNode = new V(1, null, null, flags, key, mergeDefaultProps(flags, type2, props), mergeDefaultHooks(flags, type2, ref), type2);
  if (options.createVNode) {
    options.createVNode(vNode);
  }
  return vNode;
}
function createTextVNode(text, key) {
  return new V(1, isNullOrUndef(text) || text === true || text === false ? "" : text, null, 16, key, null, null, null);
}
function createFragment(children, childFlags, key) {
  var fragment = createVNode(8192, 8192, null, children, childFlags, null, key, null);
  switch (fragment.childFlags) {
    case 1:
      fragment.children = createVoidVNode();
      fragment.childFlags = 2;
      break;
    case 16:
      fragment.children = [createTextVNode(children)];
      fragment.childFlags = 4;
      break;
  }
  return fragment;
}
function normalizeProps(vNode) {
  var props = vNode.props;
  if (props) {
    var flags = vNode.flags;
    if (flags & 481) {
      if (props.children !== void 0 && isNullOrUndef(vNode.children)) {
        normalizeChildren(vNode, props.children);
      }
      if (props.className !== void 0) {
        if (isNullOrUndef(vNode.className)) {
          vNode.className = props.className || null;
        }
        props.className = void 0;
      }
    }
    if (props.key !== void 0) {
      vNode.key = props.key;
      props.key = void 0;
    }
    if (props.ref !== void 0) {
      if (flags & 8) {
        vNode.ref = combineFrom(vNode.ref, props.ref);
      } else {
        vNode.ref = props.ref;
      }
      props.ref = void 0;
    }
  }
  return vNode;
}
function cloneFragment(vNodeToClone) {
  var oldChildren = vNodeToClone.children;
  var childFlags = vNodeToClone.childFlags;
  return createFragment(childFlags === 2 ? directClone(oldChildren) : oldChildren.map(directClone), childFlags, vNodeToClone.key);
}
function directClone(vNodeToClone) {
  var flags = vNodeToClone.flags & -16385;
  var props = vNodeToClone.props;
  if (flags & 14) {
    if (!isNull(props)) {
      var propsToClone = props;
      props = {};
      for (var key in propsToClone) {
        props[key] = propsToClone[key];
      }
    }
  }
  if ((flags & 8192) === 0) {
    return new V(vNodeToClone.childFlags, vNodeToClone.children, vNodeToClone.className, flags, vNodeToClone.key, props, vNodeToClone.ref, vNodeToClone.type);
  }
  return cloneFragment(vNodeToClone);
}
function createVoidVNode() {
  return createTextVNode("", null);
}
function _normalizeVNodes(nodes, result2, index2, currentKey) {
  for (var len = nodes.length; index2 < len; index2++) {
    var n = nodes[index2];
    if (!isInvalid(n)) {
      var newKey = currentKey + keyPrefix + index2;
      if (isArray2(n)) {
        _normalizeVNodes(n, result2, 0, newKey);
      } else {
        if (isStringOrNumber(n)) {
          n = createTextVNode(n, newKey);
        } else {
          var oldKey = n.key;
          var isPrefixedKey = isString3(oldKey) && oldKey[0] === keyPrefix;
          if (n.flags & 81920 || isPrefixedKey) {
            n = directClone(n);
          }
          n.flags |= 65536;
          if (!isPrefixedKey) {
            if (isNull(oldKey)) {
              n.key = newKey;
            } else {
              n.key = currentKey + oldKey;
            }
          } else if (oldKey.substring(0, currentKey.length) !== currentKey) {
            n.key = currentKey + oldKey;
          }
        }
        result2.push(n);
      }
    }
  }
}
function getFlagsForElementVnode(type2) {
  switch (type2) {
    case "svg":
      return 32;
    case "input":
      return 64;
    case "select":
      return 256;
    case "textarea":
      return 128;
    case Fragment:
      return 8192;
    default:
      return 1;
  }
}
function normalizeChildren(vNode, children) {
  var newChildren;
  var newChildFlags = 1;
  if (isInvalid(children)) {
    newChildren = children;
  } else if (isStringOrNumber(children)) {
    newChildFlags = 16;
    newChildren = children;
  } else if (isArray2(children)) {
    var len = children.length;
    for (var i = 0; i < len; ++i) {
      var n = children[i];
      if (isInvalid(n) || isArray2(n)) {
        newChildren = newChildren || children.slice(0, i);
        _normalizeVNodes(children, newChildren, i, "");
        break;
      } else if (isStringOrNumber(n)) {
        newChildren = newChildren || children.slice(0, i);
        newChildren.push(createTextVNode(n, keyPrefix + i));
      } else {
        var key = n.key;
        var needsCloning = (n.flags & 81920) > 0;
        var isNullKey = isNull(key);
        var isPrefixed = isString3(key) && key[0] === keyPrefix;
        if (needsCloning || isNullKey || isPrefixed) {
          newChildren = newChildren || children.slice(0, i);
          if (needsCloning || isPrefixed) {
            n = directClone(n);
          }
          if (isNullKey || isPrefixed) {
            n.key = keyPrefix + i;
          }
          newChildren.push(n);
        } else if (newChildren) {
          newChildren.push(n);
        }
        n.flags |= 65536;
      }
    }
    newChildren = newChildren || children;
    if (newChildren.length === 0) {
      newChildFlags = 1;
    } else {
      newChildFlags = 8;
    }
  } else {
    newChildren = children;
    newChildren.flags |= 65536;
    if (children.flags & 81920) {
      newChildren = directClone(children);
    }
    newChildFlags = 2;
  }
  vNode.children = newChildren;
  vNode.childFlags = newChildFlags;
  return vNode;
}
function normalizeRoot(input) {
  if (isInvalid(input) || isStringOrNumber(input)) {
    return createTextVNode(input, null);
  }
  if (isArray2(input)) {
    return createFragment(input, 0, null);
  }
  return input.flags & 16384 ? directClone(input) : input;
}
function getDelegatedEventObject(v) {
  return {
    onClick: v,
    onDblClick: v,
    onFocusIn: v,
    onFocusOut: v,
    onKeyDown: v,
    onKeyPress: v,
    onKeyUp: v,
    onMouseDown: v,
    onMouseMove: v,
    onMouseUp: v,
    onTouchEnd: v,
    onTouchMove: v,
    onTouchStart: v
  };
}
function updateOrAddSyntheticEvent(name2, dom) {
  var eventsObject = dom.$EV;
  if (!eventsObject) {
    eventsObject = dom.$EV = getDelegatedEventObject(null);
  }
  if (!eventsObject[name2]) {
    if (++attachedEventCounts[name2] === 1) {
      attachedEvents[name2] = attachEventToDocument(name2);
    }
  }
  return eventsObject;
}
function unmountSyntheticEvent(name2, dom) {
  var eventsObject = dom.$EV;
  if (eventsObject && eventsObject[name2]) {
    if (--attachedEventCounts[name2] === 0) {
      document.removeEventListener(normalizeEventName(name2), attachedEvents[name2]);
      attachedEvents[name2] = null;
    }
    eventsObject[name2] = null;
  }
}
function handleSyntheticEvent(name2, lastEvent, nextEvent, dom) {
  if (isFunction2(nextEvent)) {
    updateOrAddSyntheticEvent(name2, dom)[name2] = nextEvent;
  } else if (isLinkEventObject(nextEvent)) {
    if (isLastValueSameLinkEvent(lastEvent, nextEvent)) {
      return;
    }
    updateOrAddSyntheticEvent(name2, dom)[name2] = nextEvent;
  } else {
    unmountSyntheticEvent(name2, dom);
  }
}
function getTargetNode(event) {
  return isFunction2(event.composedPath) ? event.composedPath()[0] : event.target;
}
function dispatchEvents(event, isClick, name2, eventData2) {
  var dom = getTargetNode(event);
  do {
    if (isClick && dom.disabled) {
      return;
    }
    var eventsObject = dom.$EV;
    if (eventsObject) {
      var currentEvent = eventsObject[name2];
      if (currentEvent) {
        eventData2.dom = dom;
        currentEvent.event ? currentEvent.event(currentEvent.data, event) : currentEvent(event);
        if (event.cancelBubble) {
          return;
        }
      }
    }
    dom = dom.parentNode;
  } while (!isNull(dom));
}
function stopPropagation() {
  this.cancelBubble = true;
  if (!this.immediatePropagationStopped) {
    this.stopImmediatePropagation();
  }
}
function isDefaultPrevented() {
  return this.defaultPrevented;
}
function isPropagationStopped() {
  return this.cancelBubble;
}
function extendEventProperties(event) {
  var eventData2 = {
    dom: document
  };
  event.isDefaultPrevented = isDefaultPrevented;
  event.isPropagationStopped = isPropagationStopped;
  event.stopPropagation = stopPropagation;
  Object.defineProperty(event, "currentTarget", {
    configurable: true,
    get: function get() {
      return eventData2.dom;
    }
  });
  return eventData2;
}
function rootClickEvent(name2) {
  return function(event) {
    if (event.button !== 0) {
      event.stopPropagation();
      return;
    }
    dispatchEvents(event, true, name2, extendEventProperties(event));
  };
}
function rootEvent(name2) {
  return function(event) {
    dispatchEvents(event, false, name2, extendEventProperties(event));
  };
}
function attachEventToDocument(name2) {
  var attachedEvent = name2 === "onClick" || name2 === "onDblClick" ? rootClickEvent(name2) : rootEvent(name2);
  document.addEventListener(normalizeEventName(name2), attachedEvent);
  return attachedEvent;
}
function isSameInnerHTML(dom, innerHTML) {
  var tempdom = document.createElement("i");
  tempdom.innerHTML = innerHTML;
  return tempdom.innerHTML === dom.innerHTML;
}
function triggerEventListener(props, methodName, e) {
  if (props[methodName]) {
    var listener = props[methodName];
    if (listener.event) {
      listener.event(listener.data, e);
    } else {
      listener(e);
    }
  } else {
    var nativeListenerName = methodName.toLowerCase();
    if (props[nativeListenerName]) {
      props[nativeListenerName](e);
    }
  }
}
function createWrappedFunction(methodName, applyValue) {
  var fnMethod = function(e) {
    var vNode = this.$V;
    if (!vNode) {
      return;
    }
    var props = vNode.props || EMPTY_OBJ2;
    var dom = vNode.dom;
    if (isString3(methodName)) {
      triggerEventListener(props, methodName, e);
    } else {
      for (var i = 0; i < methodName.length; ++i) {
        triggerEventListener(props, methodName[i], e);
      }
    }
    if (isFunction2(applyValue)) {
      var newVNode = this.$V;
      var newProps = newVNode.props || EMPTY_OBJ2;
      applyValue(newProps, dom, false, newVNode);
    }
  };
  Object.defineProperty(fnMethod, "wrapped", {
    configurable: false,
    enumerable: false,
    value: true,
    writable: false
  });
  return fnMethod;
}
function attachEvent2(dom, eventName, handler) {
  var previousKey = "$" + eventName;
  var previousArgs = dom[previousKey];
  if (previousArgs) {
    if (previousArgs[1].wrapped) {
      return;
    }
    dom.removeEventListener(previousArgs[0], previousArgs[1]);
    dom[previousKey] = null;
  }
  if (isFunction2(handler)) {
    dom.addEventListener(eventName, handler);
    dom[previousKey] = [eventName, handler];
  }
}
function isCheckedType(type2) {
  return type2 === "checkbox" || type2 === "radio";
}
function emptywrapper(event) {
  event.stopPropagation();
}
function inputEvents(dom, nextPropsOrEmpty) {
  if (isCheckedType(nextPropsOrEmpty.type)) {
    attachEvent2(dom, "change", wrappedOnChange);
    attachEvent2(dom, "click", emptywrapper);
  } else {
    attachEvent2(dom, "input", onTextInputChange);
  }
}
function applyValueInput(nextPropsOrEmpty, dom) {
  var type2 = nextPropsOrEmpty.type;
  var value2 = nextPropsOrEmpty.value;
  var checked = nextPropsOrEmpty.checked;
  var multiple = nextPropsOrEmpty.multiple;
  var defaultValue = nextPropsOrEmpty.defaultValue;
  var hasValue = !isNullOrUndef(value2);
  if (type2 && type2 !== dom.type) {
    dom.setAttribute("type", type2);
  }
  if (!isNullOrUndef(multiple) && multiple !== dom.multiple) {
    dom.multiple = multiple;
  }
  if (!isNullOrUndef(defaultValue) && !hasValue) {
    dom.defaultValue = defaultValue + "";
  }
  if (isCheckedType(type2)) {
    if (hasValue) {
      dom.value = value2;
    }
    if (!isNullOrUndef(checked)) {
      dom.checked = checked;
    }
  } else {
    if (hasValue && dom.value !== value2) {
      dom.defaultValue = value2;
      dom.value = value2;
    } else if (!isNullOrUndef(checked)) {
      dom.checked = checked;
    }
  }
}
function updateChildOptions(vNode, value2) {
  if (vNode.type === "option") {
    updateChildOption(vNode, value2);
  } else {
    var children = vNode.children;
    var flags = vNode.flags;
    if (flags & 4) {
      updateChildOptions(children.$LI, value2);
    } else if (flags & 8) {
      updateChildOptions(children, value2);
    } else if (vNode.childFlags === 2) {
      updateChildOptions(children, value2);
    } else if (vNode.childFlags & 12) {
      for (var i = 0, len = children.length; i < len; ++i) {
        updateChildOptions(children[i], value2);
      }
    }
  }
}
function updateChildOption(vNode, value2) {
  var props = vNode.props || EMPTY_OBJ2;
  var dom = vNode.dom;
  dom.value = props.value;
  if (props.value === value2 || isArray2(value2) && value2.indexOf(props.value) !== -1) {
    dom.selected = true;
  } else if (!isNullOrUndef(value2) || !isNullOrUndef(props.selected)) {
    dom.selected = props.selected || false;
  }
}
function selectEvents(dom) {
  attachEvent2(dom, "change", onSelectChange);
}
function applyValueSelect(nextPropsOrEmpty, dom, mounting, vNode) {
  var multiplePropInBoolean = Boolean(nextPropsOrEmpty.multiple);
  if (!isNullOrUndef(nextPropsOrEmpty.multiple) && multiplePropInBoolean !== dom.multiple) {
    dom.multiple = multiplePropInBoolean;
  }
  var index2 = nextPropsOrEmpty.selectedIndex;
  if (index2 === -1) {
    dom.selectedIndex = -1;
  }
  var childFlags = vNode.childFlags;
  if (childFlags !== 1) {
    var value2 = nextPropsOrEmpty.value;
    if (isNumber(index2) && index2 > -1 && dom.options[index2]) {
      value2 = dom.options[index2].value;
    }
    if (mounting && isNullOrUndef(value2)) {
      value2 = nextPropsOrEmpty.defaultValue;
    }
    updateChildOptions(vNode, value2);
  }
}
function textAreaEvents(dom, nextPropsOrEmpty) {
  attachEvent2(dom, "input", onTextareaInputChange);
  if (nextPropsOrEmpty.onChange) {
    attachEvent2(dom, "change", wrappedOnChange$1);
  }
}
function applyValueTextArea(nextPropsOrEmpty, dom, mounting) {
  var value2 = nextPropsOrEmpty.value;
  var domValue = dom.value;
  if (isNullOrUndef(value2)) {
    if (mounting) {
      var defaultValue = nextPropsOrEmpty.defaultValue;
      if (!isNullOrUndef(defaultValue) && defaultValue !== domValue) {
        dom.defaultValue = defaultValue;
        dom.value = defaultValue;
      }
    }
  } else if (domValue !== value2) {
    dom.defaultValue = value2;
    dom.value = value2;
  }
}
function processElement(flags, vNode, dom, nextPropsOrEmpty, mounting, isControlled) {
  if (flags & 64) {
    applyValueInput(nextPropsOrEmpty, dom);
  } else if (flags & 256) {
    applyValueSelect(nextPropsOrEmpty, dom, mounting, vNode);
  } else if (flags & 128) {
    applyValueTextArea(nextPropsOrEmpty, dom, mounting);
  }
  if (isControlled) {
    dom.$V = vNode;
  }
}
function addFormElementEventHandlers(flags, dom, nextPropsOrEmpty) {
  if (flags & 64) {
    inputEvents(dom, nextPropsOrEmpty);
  } else if (flags & 256) {
    selectEvents(dom);
  } else if (flags & 128) {
    textAreaEvents(dom, nextPropsOrEmpty);
  }
}
function isControlledFormElement(nextPropsOrEmpty) {
  return nextPropsOrEmpty.type && isCheckedType(nextPropsOrEmpty.type) ? !isNullOrUndef(nextPropsOrEmpty.checked) : !isNullOrUndef(nextPropsOrEmpty.value);
}
function createRef() {
  return {
    current: null
  };
}
function unmountRef(ref) {
  if (ref) {
    if (!safeCall1(ref, null) && ref.current) {
      ref.current = null;
    }
  }
}
function mountRef(ref, value2, lifecycle) {
  if (ref && (isFunction2(ref) || ref.current !== void 0)) {
    lifecycle.push(function() {
      if (!safeCall1(ref, value2) && ref.current !== void 0) {
        ref.current = value2;
      }
    });
  }
}
function remove3(vNode, parentDOM) {
  unmount(vNode);
  removeVNodeDOM(vNode, parentDOM);
}
function unmount(vNode) {
  var flags = vNode.flags;
  var children = vNode.children;
  var ref;
  if (flags & 481) {
    ref = vNode.ref;
    var props = vNode.props;
    unmountRef(ref);
    var childFlags = vNode.childFlags;
    if (!isNull(props)) {
      var keys = Object.keys(props);
      for (var i = 0, len = keys.length; i < len; i++) {
        var key = keys[i];
        if (syntheticEvents[key]) {
          unmountSyntheticEvent(key, vNode.dom);
        }
      }
    }
    if (childFlags & 12) {
      unmountAllChildren(children);
    } else if (childFlags === 2) {
      unmount(children);
    }
  } else if (children) {
    if (flags & 4) {
      if (isFunction2(children.componentWillUnmount)) {
        children.componentWillUnmount();
      }
      unmountRef(vNode.ref);
      children.$UN = true;
      unmount(children.$LI);
    } else if (flags & 8) {
      ref = vNode.ref;
      if (!isNullOrUndef(ref) && isFunction2(ref.onComponentWillUnmount)) {
        ref.onComponentWillUnmount(findDOMfromVNode(vNode, true), vNode.props || EMPTY_OBJ2);
      }
      unmount(children);
    } else if (flags & 1024) {
      remove3(children, vNode.ref);
    } else if (flags & 8192) {
      if (vNode.childFlags & 12) {
        unmountAllChildren(children);
      }
    }
  }
}
function unmountAllChildren(children) {
  for (var i = 0, len = children.length; i < len; ++i) {
    unmount(children[i]);
  }
}
function clearDOM(dom) {
  dom.textContent = "";
}
function removeAllChildren(dom, vNode, children) {
  unmountAllChildren(children);
  if (vNode.flags & 8192) {
    removeVNodeDOM(vNode, dom);
  } else {
    clearDOM(dom);
  }
}
function wrapLinkEvent(nextValue) {
  var ev = nextValue.event;
  return function(e) {
    ev(nextValue.data, e);
  };
}
function patchEvent(name2, lastValue, nextValue, dom) {
  if (isLinkEventObject(nextValue)) {
    if (isLastValueSameLinkEvent(lastValue, nextValue)) {
      return;
    }
    nextValue = wrapLinkEvent(nextValue);
  }
  attachEvent2(dom, normalizeEventName(name2), nextValue);
}
function patchStyle(lastAttrValue, nextAttrValue, dom) {
  if (isNullOrUndef(nextAttrValue)) {
    dom.removeAttribute("style");
    return;
  }
  var domStyle = dom.style;
  var style;
  var value2;
  if (isString3(nextAttrValue)) {
    domStyle.cssText = nextAttrValue;
    return;
  }
  if (!isNullOrUndef(lastAttrValue) && !isString3(lastAttrValue)) {
    for (style in nextAttrValue) {
      value2 = nextAttrValue[style];
      if (value2 !== lastAttrValue[style]) {
        domStyle.setProperty(style, value2);
      }
    }
    for (style in lastAttrValue) {
      if (isNullOrUndef(nextAttrValue[style])) {
        domStyle.removeProperty(style);
      }
    }
  } else {
    for (style in nextAttrValue) {
      value2 = nextAttrValue[style];
      domStyle.setProperty(style, value2);
    }
  }
}
function patchDangerInnerHTML(lastValue, nextValue, lastVNode, dom) {
  var lastHtml = lastValue && lastValue.__html || "";
  var nextHtml = nextValue && nextValue.__html || "";
  if (lastHtml !== nextHtml) {
    if (!isNullOrUndef(nextHtml) && !isSameInnerHTML(dom, nextHtml)) {
      if (!isNull(lastVNode)) {
        if (lastVNode.childFlags & 12) {
          unmountAllChildren(lastVNode.children);
        } else if (lastVNode.childFlags === 2) {
          unmount(lastVNode.children);
        }
        lastVNode.children = null;
        lastVNode.childFlags = 1;
      }
      dom.innerHTML = nextHtml;
    }
  }
}
function patchProp(prop, lastValue, nextValue, dom, isSVG, hasControlledValue, lastVNode) {
  switch (prop) {
    case "children":
    case "childrenType":
    case "className":
    case "defaultValue":
    case "key":
    case "multiple":
    case "ref":
    case "selectedIndex":
      break;
    case "autoFocus":
      dom.autofocus = !!nextValue;
      break;
    case "allowfullscreen":
    case "autoplay":
    case "capture":
    case "checked":
    case "controls":
    case "default":
    case "disabled":
    case "hidden":
    case "indeterminate":
    case "loop":
    case "muted":
    case "novalidate":
    case "open":
    case "readOnly":
    case "required":
    case "reversed":
    case "scoped":
    case "seamless":
    case "selected":
      dom[prop] = !!nextValue;
      break;
    case "defaultChecked":
    case "value":
    case "volume":
      if (hasControlledValue && prop === "value") {
        break;
      }
      var value2 = isNullOrUndef(nextValue) ? "" : nextValue;
      if (dom[prop] !== value2) {
        dom[prop] = value2;
      }
      break;
    case "style":
      patchStyle(lastValue, nextValue, dom);
      break;
    case "dangerouslySetInnerHTML":
      patchDangerInnerHTML(lastValue, nextValue, lastVNode, dom);
      break;
    default:
      if (syntheticEvents[prop]) {
        handleSyntheticEvent(prop, lastValue, nextValue, dom);
      } else if (prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110) {
        patchEvent(prop, lastValue, nextValue, dom);
      } else if (isNullOrUndef(nextValue)) {
        dom.removeAttribute(prop);
      } else if (isSVG && namespaces[prop]) {
        dom.setAttributeNS(namespaces[prop], prop, nextValue);
      } else {
        dom.setAttribute(prop, nextValue);
      }
      break;
  }
}
function mountProps(vNode, flags, props, dom, isSVG) {
  var hasControlledValue = false;
  var isFormElement = (flags & 448) > 0;
  if (isFormElement) {
    hasControlledValue = isControlledFormElement(props);
    if (hasControlledValue) {
      addFormElementEventHandlers(flags, dom, props);
    }
  }
  for (var prop in props) {
    patchProp(prop, null, props[prop], dom, isSVG, hasControlledValue, null);
  }
  if (isFormElement) {
    processElement(flags, vNode, dom, props, true, hasControlledValue);
  }
}
function renderNewInput(instance, props, context2) {
  var nextInput = normalizeRoot(instance.render(props, instance.state, context2));
  var childContext = context2;
  if (isFunction2(instance.getChildContext)) {
    childContext = combineFrom(context2, instance.getChildContext());
  }
  instance.$CX = childContext;
  return nextInput;
}
function createClassComponentInstance(vNode, Component4, props, context2, isSVG, lifecycle) {
  var instance = new Component4(props, context2);
  var usesNewAPI = instance.$N = Boolean(Component4.getDerivedStateFromProps || instance.getSnapshotBeforeUpdate);
  instance.$SVG = isSVG;
  instance.$L = lifecycle;
  vNode.children = instance;
  instance.$BS = false;
  instance.context = context2;
  if (instance.props === EMPTY_OBJ2) {
    instance.props = props;
  }
  if (!usesNewAPI) {
    if (isFunction2(instance.componentWillMount)) {
      instance.$BR = true;
      instance.componentWillMount();
      var pending = instance.$PS;
      if (!isNull(pending)) {
        var state = instance.state;
        if (isNull(state)) {
          instance.state = pending;
        } else {
          for (var key in pending) {
            state[key] = pending[key];
          }
        }
        instance.$PS = null;
      }
      instance.$BR = false;
    }
  } else {
    instance.state = createDerivedState(instance, props, instance.state);
  }
  instance.$LI = renderNewInput(instance, props, context2);
  return instance;
}
function renderFunctionalComponent(vNode, context2) {
  var props = vNode.props || EMPTY_OBJ2;
  return vNode.flags & 32768 ? vNode.type.render(props, vNode.ref, context2) : vNode.type(props, context2);
}
function mount(vNode, parentDOM, context2, isSVG, nextNode, lifecycle) {
  var flags = vNode.flags |= 16384;
  if (flags & 481) {
    mountElement(vNode, parentDOM, context2, isSVG, nextNode, lifecycle);
  } else if (flags & 4) {
    mountClassComponent(vNode, parentDOM, context2, isSVG, nextNode, lifecycle);
  } else if (flags & 8) {
    mountFunctionalComponent(vNode, parentDOM, context2, isSVG, nextNode, lifecycle);
    mountFunctionalComponentCallbacks(vNode, lifecycle);
  } else if (flags & 512 || flags & 16) {
    mountText(vNode, parentDOM, nextNode);
  } else if (flags & 8192) {
    mountFragment(vNode, context2, parentDOM, isSVG, nextNode, lifecycle);
  } else if (flags & 1024) {
    mountPortal(vNode, context2, parentDOM, nextNode, lifecycle);
  } else
    ;
}
function mountPortal(vNode, context2, parentDOM, nextNode, lifecycle) {
  mount(vNode.children, vNode.ref, context2, false, null, lifecycle);
  var placeHolderVNode = createVoidVNode();
  mountText(placeHolderVNode, parentDOM, nextNode);
  vNode.dom = placeHolderVNode.dom;
}
function mountFragment(vNode, context2, parentDOM, isSVG, nextNode, lifecycle) {
  var children = vNode.children;
  var childFlags = vNode.childFlags;
  if (childFlags & 12 && children.length === 0) {
    childFlags = vNode.childFlags = 2;
    children = vNode.children = createVoidVNode();
  }
  if (childFlags === 2) {
    mount(children, parentDOM, context2, isSVG, nextNode, lifecycle);
  } else {
    mountArrayChildren(children, parentDOM, context2, isSVG, nextNode, lifecycle);
  }
}
function mountText(vNode, parentDOM, nextNode) {
  var dom = vNode.dom = document.createTextNode(vNode.children);
  if (!isNull(parentDOM)) {
    insertOrAppend(parentDOM, dom, nextNode);
  }
}
function mountElement(vNode, parentDOM, context2, isSVG, nextNode, lifecycle) {
  var flags = vNode.flags;
  var props = vNode.props;
  var className = vNode.className;
  var childFlags = vNode.childFlags;
  var dom = vNode.dom = documentCreateElement(vNode.type, isSVG = isSVG || (flags & 32) > 0);
  var children = vNode.children;
  if (!isNullOrUndef(className) && className !== "") {
    if (isSVG) {
      dom.setAttribute("class", className);
    } else {
      dom.className = className;
    }
  }
  if (childFlags === 16) {
    setTextContent(dom, children);
  } else if (childFlags !== 1) {
    var childrenIsSVG = isSVG && vNode.type !== "foreignObject";
    if (childFlags === 2) {
      if (children.flags & 16384) {
        vNode.children = children = directClone(children);
      }
      mount(children, dom, context2, childrenIsSVG, null, lifecycle);
    } else if (childFlags === 8 || childFlags === 4) {
      mountArrayChildren(children, dom, context2, childrenIsSVG, null, lifecycle);
    }
  }
  if (!isNull(parentDOM)) {
    insertOrAppend(parentDOM, dom, nextNode);
  }
  if (!isNull(props)) {
    mountProps(vNode, flags, props, dom, isSVG);
  }
  mountRef(vNode.ref, dom, lifecycle);
}
function mountArrayChildren(children, dom, context2, isSVG, nextNode, lifecycle) {
  for (var i = 0; i < children.length; ++i) {
    var child = children[i];
    if (child.flags & 16384) {
      children[i] = child = directClone(child);
    }
    mount(child, dom, context2, isSVG, nextNode, lifecycle);
  }
}
function mountClassComponent(vNode, parentDOM, context2, isSVG, nextNode, lifecycle) {
  var instance = createClassComponentInstance(vNode, vNode.type, vNode.props || EMPTY_OBJ2, context2, isSVG, lifecycle);
  mount(instance.$LI, parentDOM, instance.$CX, isSVG, nextNode, lifecycle);
  mountClassComponentCallbacks(vNode.ref, instance, lifecycle);
}
function mountFunctionalComponent(vNode, parentDOM, context2, isSVG, nextNode, lifecycle) {
  mount(vNode.children = normalizeRoot(renderFunctionalComponent(vNode, context2)), parentDOM, context2, isSVG, nextNode, lifecycle);
}
function createClassMountCallback(instance) {
  return function() {
    instance.componentDidMount();
  };
}
function mountClassComponentCallbacks(ref, instance, lifecycle) {
  mountRef(ref, instance, lifecycle);
  if (isFunction2(instance.componentDidMount)) {
    lifecycle.push(createClassMountCallback(instance));
  }
}
function createOnMountCallback(ref, vNode) {
  return function() {
    ref.onComponentDidMount(findDOMfromVNode(vNode, true), vNode.props || EMPTY_OBJ2);
  };
}
function mountFunctionalComponentCallbacks(vNode, lifecycle) {
  var ref = vNode.ref;
  if (!isNullOrUndef(ref)) {
    safeCall1(ref.onComponentWillMount, vNode.props || EMPTY_OBJ2);
    if (isFunction2(ref.onComponentDidMount)) {
      lifecycle.push(createOnMountCallback(ref, vNode));
    }
  }
}
function replaceWithNewNode(lastVNode, nextVNode, parentDOM, context2, isSVG, lifecycle) {
  unmount(lastVNode);
  if ((nextVNode.flags & lastVNode.flags & 2033) !== 0) {
    mount(nextVNode, null, context2, isSVG, null, lifecycle);
    replaceChild(parentDOM, nextVNode.dom, lastVNode.dom);
  } else {
    mount(nextVNode, parentDOM, context2, isSVG, findDOMfromVNode(lastVNode, true), lifecycle);
    removeVNodeDOM(lastVNode, parentDOM);
  }
}
function patch(lastVNode, nextVNode, parentDOM, context2, isSVG, nextNode, lifecycle) {
  var nextFlags = nextVNode.flags |= 16384;
  if (lastVNode.flags !== nextFlags || lastVNode.type !== nextVNode.type || lastVNode.key !== nextVNode.key || nextFlags & 2048) {
    if (lastVNode.flags & 16384) {
      replaceWithNewNode(lastVNode, nextVNode, parentDOM, context2, isSVG, lifecycle);
    } else {
      mount(nextVNode, parentDOM, context2, isSVG, nextNode, lifecycle);
    }
  } else if (nextFlags & 481) {
    patchElement(lastVNode, nextVNode, context2, isSVG, nextFlags, lifecycle);
  } else if (nextFlags & 4) {
    patchClassComponent(lastVNode, nextVNode, parentDOM, context2, isSVG, nextNode, lifecycle);
  } else if (nextFlags & 8) {
    patchFunctionalComponent(lastVNode, nextVNode, parentDOM, context2, isSVG, nextNode, lifecycle);
  } else if (nextFlags & 16) {
    patchText(lastVNode, nextVNode);
  } else if (nextFlags & 512) {
    nextVNode.dom = lastVNode.dom;
  } else if (nextFlags & 8192) {
    patchFragment(lastVNode, nextVNode, parentDOM, context2, isSVG, lifecycle);
  } else {
    patchPortal(lastVNode, nextVNode, context2, lifecycle);
  }
}
function patchSingleTextChild(lastChildren, nextChildren, parentDOM) {
  if (lastChildren !== nextChildren) {
    if (lastChildren !== "") {
      parentDOM.firstChild.nodeValue = nextChildren;
    } else {
      setTextContent(parentDOM, nextChildren);
    }
  }
}
function patchContentEditableChildren(dom, nextChildren) {
  if (dom.textContent !== nextChildren) {
    dom.textContent = nextChildren;
  }
}
function patchFragment(lastVNode, nextVNode, parentDOM, context2, isSVG, lifecycle) {
  var lastChildren = lastVNode.children;
  var nextChildren = nextVNode.children;
  var lastChildFlags = lastVNode.childFlags;
  var nextChildFlags = nextVNode.childFlags;
  var nextNode = null;
  if (nextChildFlags & 12 && nextChildren.length === 0) {
    nextChildFlags = nextVNode.childFlags = 2;
    nextChildren = nextVNode.children = createVoidVNode();
  }
  var nextIsSingle = (nextChildFlags & 2) !== 0;
  if (lastChildFlags & 12) {
    var lastLen = lastChildren.length;
    if (
      // It uses keyed algorithm
      lastChildFlags & 8 && nextChildFlags & 8 || // It transforms from many to single
      nextIsSingle || // It will append more nodes
      !nextIsSingle && nextChildren.length > lastLen
    ) {
      nextNode = findDOMfromVNode(lastChildren[lastLen - 1], false).nextSibling;
    }
  }
  patchChildren(lastChildFlags, nextChildFlags, lastChildren, nextChildren, parentDOM, context2, isSVG, nextNode, lastVNode, lifecycle);
}
function patchPortal(lastVNode, nextVNode, context2, lifecycle) {
  var lastContainer = lastVNode.ref;
  var nextContainer = nextVNode.ref;
  var nextChildren = nextVNode.children;
  patchChildren(lastVNode.childFlags, nextVNode.childFlags, lastVNode.children, nextChildren, lastContainer, context2, false, null, lastVNode, lifecycle);
  nextVNode.dom = lastVNode.dom;
  if (lastContainer !== nextContainer && !isInvalid(nextChildren)) {
    var node = nextChildren.dom;
    removeChild(lastContainer, node);
    appendChild(nextContainer, node);
  }
}
function patchElement(lastVNode, nextVNode, context2, isSVG, nextFlags, lifecycle) {
  var dom = nextVNode.dom = lastVNode.dom;
  var lastProps = lastVNode.props;
  var nextProps = nextVNode.props;
  var isFormElement = false;
  var hasControlledValue = false;
  var nextPropsOrEmpty;
  isSVG = isSVG || (nextFlags & 32) > 0;
  if (lastProps !== nextProps) {
    var lastPropsOrEmpty = lastProps || EMPTY_OBJ2;
    nextPropsOrEmpty = nextProps || EMPTY_OBJ2;
    if (nextPropsOrEmpty !== EMPTY_OBJ2) {
      isFormElement = (nextFlags & 448) > 0;
      if (isFormElement) {
        hasControlledValue = isControlledFormElement(nextPropsOrEmpty);
      }
      for (var prop in nextPropsOrEmpty) {
        var lastValue = lastPropsOrEmpty[prop];
        var nextValue = nextPropsOrEmpty[prop];
        if (lastValue !== nextValue) {
          patchProp(prop, lastValue, nextValue, dom, isSVG, hasControlledValue, lastVNode);
        }
      }
    }
    if (lastPropsOrEmpty !== EMPTY_OBJ2) {
      for (var prop$1 in lastPropsOrEmpty) {
        if (isNullOrUndef(nextPropsOrEmpty[prop$1]) && !isNullOrUndef(lastPropsOrEmpty[prop$1])) {
          patchProp(prop$1, lastPropsOrEmpty[prop$1], null, dom, isSVG, hasControlledValue, lastVNode);
        }
      }
    }
  }
  var nextChildren = nextVNode.children;
  var nextClassName = nextVNode.className;
  if (lastVNode.className !== nextClassName) {
    if (isNullOrUndef(nextClassName)) {
      dom.removeAttribute("class");
    } else if (isSVG) {
      dom.setAttribute("class", nextClassName);
    } else {
      dom.className = nextClassName;
    }
  }
  if (nextFlags & 4096) {
    patchContentEditableChildren(dom, nextChildren);
  } else {
    patchChildren(lastVNode.childFlags, nextVNode.childFlags, lastVNode.children, nextChildren, dom, context2, isSVG && nextVNode.type !== "foreignObject", null, lastVNode, lifecycle);
  }
  if (isFormElement) {
    processElement(nextFlags, nextVNode, dom, nextPropsOrEmpty, false, hasControlledValue);
  }
  var nextRef = nextVNode.ref;
  var lastRef = lastVNode.ref;
  if (lastRef !== nextRef) {
    unmountRef(lastRef);
    mountRef(nextRef, dom, lifecycle);
  }
}
function replaceOneVNodeWithMultipleVNodes(lastChildren, nextChildren, parentDOM, context2, isSVG, lifecycle) {
  unmount(lastChildren);
  mountArrayChildren(nextChildren, parentDOM, context2, isSVG, findDOMfromVNode(lastChildren, true), lifecycle);
  removeVNodeDOM(lastChildren, parentDOM);
}
function patchChildren(lastChildFlags, nextChildFlags, lastChildren, nextChildren, parentDOM, context2, isSVG, nextNode, parentVNode, lifecycle) {
  switch (lastChildFlags) {
    case 2:
      switch (nextChildFlags) {
        case 2:
          patch(lastChildren, nextChildren, parentDOM, context2, isSVG, nextNode, lifecycle);
          break;
        case 1:
          remove3(lastChildren, parentDOM);
          break;
        case 16:
          unmount(lastChildren);
          setTextContent(parentDOM, nextChildren);
          break;
        default:
          replaceOneVNodeWithMultipleVNodes(lastChildren, nextChildren, parentDOM, context2, isSVG, lifecycle);
          break;
      }
      break;
    case 1:
      switch (nextChildFlags) {
        case 2:
          mount(nextChildren, parentDOM, context2, isSVG, nextNode, lifecycle);
          break;
        case 1:
          break;
        case 16:
          setTextContent(parentDOM, nextChildren);
          break;
        default:
          mountArrayChildren(nextChildren, parentDOM, context2, isSVG, nextNode, lifecycle);
          break;
      }
      break;
    case 16:
      switch (nextChildFlags) {
        case 16:
          patchSingleTextChild(lastChildren, nextChildren, parentDOM);
          break;
        case 2:
          clearDOM(parentDOM);
          mount(nextChildren, parentDOM, context2, isSVG, nextNode, lifecycle);
          break;
        case 1:
          clearDOM(parentDOM);
          break;
        default:
          clearDOM(parentDOM);
          mountArrayChildren(nextChildren, parentDOM, context2, isSVG, nextNode, lifecycle);
          break;
      }
      break;
    default:
      switch (nextChildFlags) {
        case 16:
          unmountAllChildren(lastChildren);
          setTextContent(parentDOM, nextChildren);
          break;
        case 2:
          removeAllChildren(parentDOM, parentVNode, lastChildren);
          mount(nextChildren, parentDOM, context2, isSVG, nextNode, lifecycle);
          break;
        case 1:
          removeAllChildren(parentDOM, parentVNode, lastChildren);
          break;
        default:
          var lastLength = lastChildren.length | 0;
          var nextLength = nextChildren.length | 0;
          if (lastLength === 0) {
            if (nextLength > 0) {
              mountArrayChildren(nextChildren, parentDOM, context2, isSVG, nextNode, lifecycle);
            }
          } else if (nextLength === 0) {
            removeAllChildren(parentDOM, parentVNode, lastChildren);
          } else if (nextChildFlags === 8 && lastChildFlags === 8) {
            patchKeyedChildren(lastChildren, nextChildren, parentDOM, context2, isSVG, lastLength, nextLength, nextNode, parentVNode, lifecycle);
          } else {
            patchNonKeyedChildren(lastChildren, nextChildren, parentDOM, context2, isSVG, lastLength, nextLength, nextNode, lifecycle);
          }
          break;
      }
      break;
  }
}
function createDidUpdate(instance, lastProps, lastState, snapshot, lifecycle) {
  lifecycle.push(function() {
    instance.componentDidUpdate(lastProps, lastState, snapshot);
  });
}
function updateClassComponent(instance, nextState, nextProps, parentDOM, context2, isSVG, force, nextNode, lifecycle) {
  var lastState = instance.state;
  var lastProps = instance.props;
  var usesNewAPI = Boolean(instance.$N);
  var hasSCU = isFunction2(instance.shouldComponentUpdate);
  if (usesNewAPI) {
    nextState = createDerivedState(instance, nextProps, nextState !== lastState ? combineFrom(lastState, nextState) : nextState);
  }
  if (force || !hasSCU || hasSCU && instance.shouldComponentUpdate(nextProps, nextState, context2)) {
    if (!usesNewAPI && isFunction2(instance.componentWillUpdate)) {
      instance.componentWillUpdate(nextProps, nextState, context2);
    }
    instance.props = nextProps;
    instance.state = nextState;
    instance.context = context2;
    var snapshot = null;
    var nextInput = renderNewInput(instance, nextProps, context2);
    if (usesNewAPI && isFunction2(instance.getSnapshotBeforeUpdate)) {
      snapshot = instance.getSnapshotBeforeUpdate(lastProps, lastState);
    }
    patch(instance.$LI, nextInput, parentDOM, instance.$CX, isSVG, nextNode, lifecycle);
    instance.$LI = nextInput;
    if (isFunction2(instance.componentDidUpdate)) {
      createDidUpdate(instance, lastProps, lastState, snapshot, lifecycle);
    }
  } else {
    instance.props = nextProps;
    instance.state = nextState;
    instance.context = context2;
  }
}
function patchClassComponent(lastVNode, nextVNode, parentDOM, context2, isSVG, nextNode, lifecycle) {
  var instance = nextVNode.children = lastVNode.children;
  if (isNull(instance)) {
    return;
  }
  instance.$L = lifecycle;
  var nextProps = nextVNode.props || EMPTY_OBJ2;
  var nextRef = nextVNode.ref;
  var lastRef = lastVNode.ref;
  var nextState = instance.state;
  if (!instance.$N) {
    if (isFunction2(instance.componentWillReceiveProps)) {
      instance.$BR = true;
      instance.componentWillReceiveProps(nextProps, context2);
      if (instance.$UN) {
        return;
      }
      instance.$BR = false;
    }
    if (!isNull(instance.$PS)) {
      nextState = combineFrom(nextState, instance.$PS);
      instance.$PS = null;
    }
  }
  updateClassComponent(instance, nextState, nextProps, parentDOM, context2, isSVG, false, nextNode, lifecycle);
  if (lastRef !== nextRef) {
    unmountRef(lastRef);
    mountRef(nextRef, instance, lifecycle);
  }
}
function patchFunctionalComponent(lastVNode, nextVNode, parentDOM, context2, isSVG, nextNode, lifecycle) {
  var shouldUpdate = true;
  var nextProps = nextVNode.props || EMPTY_OBJ2;
  var nextRef = nextVNode.ref;
  var lastProps = lastVNode.props;
  var nextHooksDefined = !isNullOrUndef(nextRef);
  var lastInput = lastVNode.children;
  if (nextHooksDefined && isFunction2(nextRef.onComponentShouldUpdate)) {
    shouldUpdate = nextRef.onComponentShouldUpdate(lastProps, nextProps);
  }
  if (shouldUpdate !== false) {
    if (nextHooksDefined && isFunction2(nextRef.onComponentWillUpdate)) {
      nextRef.onComponentWillUpdate(lastProps, nextProps);
    }
    var nextInput = normalizeRoot(renderFunctionalComponent(nextVNode, context2));
    patch(lastInput, nextInput, parentDOM, context2, isSVG, nextNode, lifecycle);
    nextVNode.children = nextInput;
    if (nextHooksDefined && isFunction2(nextRef.onComponentDidUpdate)) {
      nextRef.onComponentDidUpdate(lastProps, nextProps);
    }
  } else {
    nextVNode.children = lastInput;
  }
}
function patchText(lastVNode, nextVNode) {
  var nextText = nextVNode.children;
  var dom = nextVNode.dom = lastVNode.dom;
  if (nextText !== lastVNode.children) {
    dom.nodeValue = nextText;
  }
}
function patchNonKeyedChildren(lastChildren, nextChildren, dom, context2, isSVG, lastChildrenLength, nextChildrenLength, nextNode, lifecycle) {
  var commonLength = lastChildrenLength > nextChildrenLength ? nextChildrenLength : lastChildrenLength;
  var i = 0;
  var nextChild;
  var lastChild;
  for (; i < commonLength; ++i) {
    nextChild = nextChildren[i];
    lastChild = lastChildren[i];
    if (nextChild.flags & 16384) {
      nextChild = nextChildren[i] = directClone(nextChild);
    }
    patch(lastChild, nextChild, dom, context2, isSVG, nextNode, lifecycle);
    lastChildren[i] = nextChild;
  }
  if (lastChildrenLength < nextChildrenLength) {
    for (i = commonLength; i < nextChildrenLength; ++i) {
      nextChild = nextChildren[i];
      if (nextChild.flags & 16384) {
        nextChild = nextChildren[i] = directClone(nextChild);
      }
      mount(nextChild, dom, context2, isSVG, nextNode, lifecycle);
    }
  } else if (lastChildrenLength > nextChildrenLength) {
    for (i = commonLength; i < lastChildrenLength; ++i) {
      remove3(lastChildren[i], dom);
    }
  }
}
function patchKeyedChildren(a, b, dom, context2, isSVG, aLength, bLength, outerEdge, parentVNode, lifecycle) {
  var aEnd = aLength - 1;
  var bEnd = bLength - 1;
  var j = 0;
  var aNode = a[j];
  var bNode = b[j];
  var nextPos;
  var nextNode;
  outer: {
    while (aNode.key === bNode.key) {
      if (bNode.flags & 16384) {
        b[j] = bNode = directClone(bNode);
      }
      patch(aNode, bNode, dom, context2, isSVG, outerEdge, lifecycle);
      a[j] = bNode;
      ++j;
      if (j > aEnd || j > bEnd) {
        break outer;
      }
      aNode = a[j];
      bNode = b[j];
    }
    aNode = a[aEnd];
    bNode = b[bEnd];
    while (aNode.key === bNode.key) {
      if (bNode.flags & 16384) {
        b[bEnd] = bNode = directClone(bNode);
      }
      patch(aNode, bNode, dom, context2, isSVG, outerEdge, lifecycle);
      a[aEnd] = bNode;
      aEnd--;
      bEnd--;
      if (j > aEnd || j > bEnd) {
        break outer;
      }
      aNode = a[aEnd];
      bNode = b[bEnd];
    }
  }
  if (j > aEnd) {
    if (j <= bEnd) {
      nextPos = bEnd + 1;
      nextNode = nextPos < bLength ? findDOMfromVNode(b[nextPos], true) : outerEdge;
      while (j <= bEnd) {
        bNode = b[j];
        if (bNode.flags & 16384) {
          b[j] = bNode = directClone(bNode);
        }
        ++j;
        mount(bNode, dom, context2, isSVG, nextNode, lifecycle);
      }
    }
  } else if (j > bEnd) {
    while (j <= aEnd) {
      remove3(a[j++], dom);
    }
  } else {
    patchKeyedChildrenComplex(a, b, context2, aLength, bLength, aEnd, bEnd, j, dom, isSVG, outerEdge, parentVNode, lifecycle);
  }
}
function patchKeyedChildrenComplex(a, b, context2, aLength, bLength, aEnd, bEnd, j, dom, isSVG, outerEdge, parentVNode, lifecycle) {
  var aNode;
  var bNode;
  var nextPos;
  var i = 0;
  var aStart = j;
  var bStart = j;
  var aLeft = aEnd - j + 1;
  var bLeft = bEnd - j + 1;
  var sources = new Int32Array(bLeft + 1);
  var canRemoveWholeContent = aLeft === aLength;
  var moved = false;
  var pos = 0;
  var patched = 0;
  if (bLength < 4 || (aLeft | bLeft) < 32) {
    for (i = aStart; i <= aEnd; ++i) {
      aNode = a[i];
      if (patched < bLeft) {
        for (j = bStart; j <= bEnd; j++) {
          bNode = b[j];
          if (aNode.key === bNode.key) {
            sources[j - bStart] = i + 1;
            if (canRemoveWholeContent) {
              canRemoveWholeContent = false;
              while (aStart < i) {
                remove3(a[aStart++], dom);
              }
            }
            if (pos > j) {
              moved = true;
            } else {
              pos = j;
            }
            if (bNode.flags & 16384) {
              b[j] = bNode = directClone(bNode);
            }
            patch(aNode, bNode, dom, context2, isSVG, outerEdge, lifecycle);
            ++patched;
            break;
          }
        }
        if (!canRemoveWholeContent && j > bEnd) {
          remove3(aNode, dom);
        }
      } else if (!canRemoveWholeContent) {
        remove3(aNode, dom);
      }
    }
  } else {
    var keyIndex = {};
    for (i = bStart; i <= bEnd; ++i) {
      keyIndex[b[i].key] = i;
    }
    for (i = aStart; i <= aEnd; ++i) {
      aNode = a[i];
      if (patched < bLeft) {
        j = keyIndex[aNode.key];
        if (j !== void 0) {
          if (canRemoveWholeContent) {
            canRemoveWholeContent = false;
            while (i > aStart) {
              remove3(a[aStart++], dom);
            }
          }
          sources[j - bStart] = i + 1;
          if (pos > j) {
            moved = true;
          } else {
            pos = j;
          }
          bNode = b[j];
          if (bNode.flags & 16384) {
            b[j] = bNode = directClone(bNode);
          }
          patch(aNode, bNode, dom, context2, isSVG, outerEdge, lifecycle);
          ++patched;
        } else if (!canRemoveWholeContent) {
          remove3(aNode, dom);
        }
      } else if (!canRemoveWholeContent) {
        remove3(aNode, dom);
      }
    }
  }
  if (canRemoveWholeContent) {
    removeAllChildren(dom, parentVNode, a);
    mountArrayChildren(b, dom, context2, isSVG, outerEdge, lifecycle);
  } else if (moved) {
    var seq = lis_algorithm(sources);
    j = seq.length - 1;
    for (i = bLeft - 1; i >= 0; i--) {
      if (sources[i] === 0) {
        pos = i + bStart;
        bNode = b[pos];
        if (bNode.flags & 16384) {
          b[pos] = bNode = directClone(bNode);
        }
        nextPos = pos + 1;
        mount(bNode, dom, context2, isSVG, nextPos < bLength ? findDOMfromVNode(b[nextPos], true) : outerEdge, lifecycle);
      } else if (j < 0 || i !== seq[j]) {
        pos = i + bStart;
        bNode = b[pos];
        nextPos = pos + 1;
        moveVNodeDOM(bNode, dom, nextPos < bLength ? findDOMfromVNode(b[nextPos], true) : outerEdge);
      } else {
        j--;
      }
    }
  } else if (patched !== bLeft) {
    for (i = bLeft - 1; i >= 0; i--) {
      if (sources[i] === 0) {
        pos = i + bStart;
        bNode = b[pos];
        if (bNode.flags & 16384) {
          b[pos] = bNode = directClone(bNode);
        }
        nextPos = pos + 1;
        mount(bNode, dom, context2, isSVG, nextPos < bLength ? findDOMfromVNode(b[nextPos], true) : outerEdge, lifecycle);
      }
    }
  }
}
function lis_algorithm(arr) {
  var arrI = 0;
  var i = 0;
  var j = 0;
  var k = 0;
  var u = 0;
  var v = 0;
  var c = 0;
  var len = arr.length;
  if (len > maxLen) {
    maxLen = len;
    result = new Int32Array(len);
    p = new Int32Array(len);
  }
  for (; i < len; ++i) {
    arrI = arr[i];
    if (arrI !== 0) {
      j = result[k];
      if (arr[j] < arrI) {
        p[i] = j;
        result[++k] = i;
        continue;
      }
      u = 0;
      v = k;
      while (u < v) {
        c = u + v >> 1;
        if (arr[result[c]] < arrI) {
          u = c + 1;
        } else {
          v = c;
        }
      }
      if (arrI < arr[result[u]]) {
        if (u > 0) {
          p[i] = result[u - 1];
        }
        result[u] = i;
      }
    }
  }
  u = k + 1;
  var seq = new Int32Array(u);
  v = result[u - 1];
  while (u-- > 0) {
    seq[u] = v;
    v = p[v];
    result[u] = 0;
  }
  return seq;
}
function __render(input, parentDOM, callback, context2) {
  var lifecycle = [];
  var rootInput = parentDOM.$V;
  renderCheck.v = true;
  if (isNullOrUndef(rootInput)) {
    if (!isNullOrUndef(input)) {
      if (input.flags & 16384) {
        input = directClone(input);
      }
      mount(input, parentDOM, context2, false, null, lifecycle);
      parentDOM.$V = input;
      rootInput = input;
    }
  } else {
    if (isNullOrUndef(input)) {
      remove3(rootInput, parentDOM);
      parentDOM.$V = null;
    } else {
      if (input.flags & 16384) {
        input = directClone(input);
      }
      patch(rootInput, input, parentDOM, context2, false, null, lifecycle);
      rootInput = parentDOM.$V = input;
    }
  }
  callAll(lifecycle);
  renderCheck.v = false;
  if (isFunction2(callback)) {
    callback();
  }
  if (isFunction2(options.renderComplete)) {
    options.renderComplete(rootInput, parentDOM);
  }
}
function render2(input, parentDOM, callback, context2) {
  if (callback === void 0)
    callback = null;
  if (context2 === void 0)
    context2 = EMPTY_OBJ2;
  __render(input, parentDOM, callback, context2);
}
function queueStateChanges(component, newState, callback, force) {
  var pending = component.$PS;
  if (isFunction2(newState)) {
    newState = newState(pending ? combineFrom(component.state, pending) : component.state, component.props, component.context);
  }
  if (isNullOrUndef(pending)) {
    component.$PS = newState;
  } else {
    for (var stateKey in newState) {
      pending[stateKey] = newState[stateKey];
    }
  }
  if (!component.$BR) {
    if (!renderCheck.v) {
      if (QUEUE.length === 0) {
        applyState(component, force);
        if (isFunction2(callback)) {
          callback.call(component);
        }
        return;
      }
    }
    if (QUEUE.indexOf(component) === -1) {
      QUEUE.push(component);
    }
    if (force) {
      component.$F = true;
    }
    if (!microTaskPending) {
      microTaskPending = true;
      nextTick(rerender);
    }
    if (isFunction2(callback)) {
      var QU = component.$QU;
      if (!QU) {
        QU = component.$QU = [];
      }
      QU.push(callback);
    }
  } else if (isFunction2(callback)) {
    component.$L.push(callback.bind(component));
  }
}
function callSetStateCallbacks(component) {
  var queue = component.$QU;
  for (var i = 0; i < queue.length; ++i) {
    queue[i].call(component);
  }
  component.$QU = null;
}
function rerender() {
  var component;
  microTaskPending = false;
  while (component = QUEUE.shift()) {
    if (!component.$UN) {
      var force = component.$F;
      component.$F = false;
      applyState(component, force);
      if (component.$QU) {
        callSetStateCallbacks(component);
      }
    }
  }
}
function applyState(component, force) {
  if (force || !component.$BR) {
    var pendingState = component.$PS;
    component.$PS = null;
    var lifecycle = [];
    renderCheck.v = true;
    updateClassComponent(component, combineFrom(component.state, pendingState), component.props, findDOMfromVNode(component.$LI, true).parentNode, component.context, component.$SVG, force, null, lifecycle);
    callAll(lifecycle);
    renderCheck.v = false;
  } else {
    component.state = component.$PS;
    component.$PS = null;
  }
}
var isArray2, EMPTY_OBJ2, Fragment, renderCheck, options, keyPrefix, xlinkNS, xmlNS, namespaces, attachedEventCounts, attachedEvents, syntheticEvents, onTextInputChange, wrappedOnChange, onSelectChange, onTextareaInputChange, wrappedOnChange$1, result, p, maxLen, hasDocumentAvailable, QUEUE, nextTick, microTaskPending, Component2;
var init_index_esm = __esm({
  "node_modules/inferno/dist/index.esm.js"() {
    isArray2 = Array.isArray;
    EMPTY_OBJ2 = {};
    Fragment = "$F";
    renderCheck = {
      v: false
    };
    options = {
      componentComparator: null,
      createVNode: null,
      renderComplete: null
    };
    keyPrefix = "$";
    xlinkNS = "http://www.w3.org/1999/xlink";
    xmlNS = "http://www.w3.org/XML/1998/namespace";
    namespaces = {
      "xlink:actuate": xlinkNS,
      "xlink:arcrole": xlinkNS,
      "xlink:href": xlinkNS,
      "xlink:role": xlinkNS,
      "xlink:show": xlinkNS,
      "xlink:title": xlinkNS,
      "xlink:type": xlinkNS,
      "xml:base": xmlNS,
      "xml:lang": xmlNS,
      "xml:space": xmlNS
    };
    attachedEventCounts = getDelegatedEventObject(0);
    attachedEvents = getDelegatedEventObject(null);
    syntheticEvents = getDelegatedEventObject(true);
    onTextInputChange = createWrappedFunction("onInput", applyValueInput);
    wrappedOnChange = createWrappedFunction(["onClick", "onChange"], applyValueInput);
    emptywrapper.wrapped = true;
    onSelectChange = createWrappedFunction("onChange", applyValueSelect);
    onTextareaInputChange = createWrappedFunction("onInput", applyValueTextArea);
    wrappedOnChange$1 = createWrappedFunction("onChange");
    maxLen = 0;
    hasDocumentAvailable = typeof document !== "undefined";
    if (hasDocumentAvailable) {
      if (window.Node) {
        Node.prototype.$EV = null;
        Node.prototype.$V = null;
      }
    }
    QUEUE = [];
    nextTick = typeof Promise !== "undefined" ? Promise.resolve().then.bind(Promise.resolve()) : function(a) {
      window.setTimeout(a, 0);
    };
    microTaskPending = false;
    Component2 = function Component3(props, context2) {
      this.state = null;
      this.$BR = false;
      this.$BS = true;
      this.$PS = null;
      this.$LI = null;
      this.$UN = false;
      this.$CX = null;
      this.$QU = null;
      this.$N = false;
      this.$L = null;
      this.$SVG = false;
      this.$F = false;
      this.props = props || EMPTY_OBJ2;
      this.context = context2 || EMPTY_OBJ2;
    };
    Component2.prototype.forceUpdate = function forceUpdate(callback) {
      if (this.$UN) {
        return;
      }
      queueStateChanges(this, {}, callback, true);
    };
    Component2.prototype.setState = function setState(newState, callback) {
      if (this.$UN) {
        return;
      }
      if (!this.$BS) {
        queueStateChanges(this, newState, callback, false);
      }
    };
    Component2.prototype.render = function render3(_nextProps, _nextState, _nextContext) {
      return null;
    };
  }
});

// node_modules/inferno/index.esm.js
var init_index_esm2 = __esm({
  "node_modules/inferno/index.esm.js"() {
    init_index_esm();
    if (true) {
      console.warn("You are running production build of Inferno in development mode. Use dev:module entry point.");
    }
  }
});

// node_modules/inferno-create-element/dist/index.esm.js
function isNullOrUndef2(o) {
  return o === void 0 || o === null;
}
function isString4(o) {
  return typeof o === "string";
}
function isUndefined2(o) {
  return o === void 0;
}
function createElement(type2, props, _children) {
  var arguments$1 = arguments;
  var children;
  var ref = null;
  var key = null;
  var className = null;
  var flags = 0;
  var newProps;
  var childLen = arguments.length - 2;
  if (childLen === 1) {
    children = _children;
  } else if (childLen > 1) {
    children = [];
    while (childLen-- > 0) {
      children[childLen] = arguments$1[childLen + 2];
    }
  }
  if (isString4(type2)) {
    flags = getFlagsForElementVnode(type2);
    if (!isNullOrUndef2(props)) {
      newProps = {};
      for (var prop in props) {
        if (prop === "className" || prop === "class") {
          className = props[prop];
        } else if (prop === "key") {
          key = props.key;
        } else if (prop === "children" && isUndefined2(children)) {
          children = props.children;
        } else if (prop === "ref") {
          ref = props.ref;
        } else {
          if (prop === "contenteditable") {
            flags |= 4096;
          }
          newProps[prop] = props[prop];
        }
      }
    }
  } else {
    flags = 2;
    if (!isUndefined2(children)) {
      if (!props) {
        props = {};
      }
      props.children = children;
    }
    if (!isNullOrUndef2(props)) {
      newProps = {};
      for (var prop$1 in props) {
        if (prop$1 === "key") {
          key = props.key;
        } else if (prop$1 === "ref") {
          ref = props.ref;
        } else if (componentHooks[prop$1] === 1) {
          if (!ref) {
            ref = {};
          }
          ref[prop$1] = props[prop$1];
        } else {
          newProps[prop$1] = props[prop$1];
        }
      }
    }
    return createComponentVNode(flags, type2, newProps, key, ref);
  }
  if (flags & 8192) {
    return createFragment(childLen === 1 ? [children] : children, 0, key);
  }
  return createVNode(flags, type2, className, children, 0, newProps, key, ref);
}
var componentHooks;
var init_index_esm3 = __esm({
  "node_modules/inferno-create-element/dist/index.esm.js"() {
    init_index_esm2();
    componentHooks = {
      onComponentDidMount: 1,
      onComponentDidUpdate: 1,
      onComponentShouldUpdate: 1,
      onComponentWillMount: 1,
      onComponentWillUnmount: 1,
      onComponentWillUpdate: 1
    };
  }
});

// node_modules/inferno-hydrate/dist/index.esm.js
function isNullOrUndef3(o) {
  return o === void 0 || o === null;
}
function isInvalid2(o) {
  return o === null || o === false || o === true || o === void 0;
}
function isFunction3(o) {
  return typeof o === "function";
}
function isNull2(o) {
  return o === null;
}
function throwError(message) {
  if (!message) {
    message = ERROR_MSG;
  }
  throw new Error("Inferno Error: " + message);
}
function isSameInnerHTML2(dom, innerHTML) {
  var tempdom = document.createElement("i");
  tempdom.innerHTML = innerHTML;
  return tempdom.innerHTML === dom.innerHTML;
}
function findLastDOMFromVNode(vNode) {
  var flags;
  var children;
  while (vNode) {
    flags = vNode.flags;
    if (flags & 2033) {
      return vNode.dom;
    }
    children = vNode.children;
    if (flags & 8192) {
      vNode = vNode.childFlags === 2 ? children : children[children.length - 1];
    } else if (flags & 4) {
      vNode = children.$LI;
    } else {
      vNode = children;
    }
  }
  return null;
}
function isSamePropsInnerHTML(dom, props) {
  return Boolean(props && props.dangerouslySetInnerHTML && props.dangerouslySetInnerHTML.__html && isSameInnerHTML2(dom, props.dangerouslySetInnerHTML.__html));
}
function hydrateComponent(vNode, parentDOM, dom, context2, isSVG, isClass, lifecycle) {
  var type2 = vNode.type;
  var ref = vNode.ref;
  var props = vNode.props || EMPTY_OBJ2;
  var currentNode;
  if (isClass) {
    var instance = createClassComponentInstance(vNode, type2, props, context2, isSVG, lifecycle);
    var input = instance.$LI;
    currentNode = hydrateVNode(input, parentDOM, dom, instance.$CX, isSVG, lifecycle);
    mountClassComponentCallbacks(ref, instance, lifecycle);
  } else {
    var input$1 = normalizeRoot(renderFunctionalComponent(vNode, context2));
    currentNode = hydrateVNode(input$1, parentDOM, dom, context2, isSVG, lifecycle);
    vNode.children = input$1;
    mountFunctionalComponentCallbacks(vNode, lifecycle);
  }
  return currentNode;
}
function hydrateChildren(parentVNode, parentNode, currentNode, context2, isSVG, lifecycle) {
  var childFlags = parentVNode.childFlags;
  var children = parentVNode.children;
  var props = parentVNode.props;
  var flags = parentVNode.flags;
  if (childFlags !== 1) {
    if (childFlags === 2) {
      if (isNull2(currentNode)) {
        mount(children, parentNode, context2, isSVG, null, lifecycle);
      } else {
        currentNode = hydrateVNode(children, parentNode, currentNode, context2, isSVG, lifecycle);
        currentNode = currentNode ? currentNode.nextSibling : null;
      }
    } else if (childFlags === 16) {
      if (isNull2(currentNode)) {
        parentNode.appendChild(document.createTextNode(children));
      } else if (parentNode.childNodes.length !== 1 || currentNode.nodeType !== 3) {
        parentNode.textContent = children;
      } else {
        if (currentNode.nodeValue !== children) {
          currentNode.nodeValue = children;
        }
      }
      currentNode = null;
    } else if (childFlags & 12) {
      var prevVNodeIsTextNode = false;
      for (var i = 0, len = children.length; i < len; ++i) {
        var child = children[i];
        if (isNull2(currentNode) || prevVNodeIsTextNode && (child.flags & 16) > 0) {
          mount(child, parentNode, context2, isSVG, currentNode, lifecycle);
        } else {
          currentNode = hydrateVNode(child, parentNode, currentNode, context2, isSVG, lifecycle);
          currentNode = currentNode ? currentNode.nextSibling : null;
        }
        prevVNodeIsTextNode = (child.flags & 16) > 0;
      }
    }
    if ((flags & 8192) === 0) {
      var nextSibling = null;
      while (currentNode) {
        nextSibling = currentNode.nextSibling;
        parentNode.removeChild(currentNode);
        currentNode = nextSibling;
      }
    }
  } else if (!isNull2(parentNode.firstChild) && !isSamePropsInnerHTML(parentNode, props)) {
    parentNode.textContent = "";
    if (flags & 448) {
      parentNode.defaultValue = "";
    }
  }
}
function hydrateElement(vNode, parentDOM, dom, context2, isSVG, lifecycle) {
  var props = vNode.props;
  var className = vNode.className;
  var flags = vNode.flags;
  var ref = vNode.ref;
  isSVG = isSVG || (flags & 32) > 0;
  if (dom.nodeType !== 1 || dom.tagName.toLowerCase() !== vNode.type) {
    mountElement(vNode, null, context2, isSVG, null, lifecycle);
    parentDOM.replaceChild(vNode.dom, dom);
  } else {
    vNode.dom = dom;
    hydrateChildren(vNode, dom, dom.firstChild, context2, isSVG, lifecycle);
    if (!isNull2(props)) {
      mountProps(vNode, flags, props, dom, isSVG);
    }
    if (isNullOrUndef3(className)) {
      if (dom.className !== "") {
        dom.removeAttribute("class");
      }
    } else if (isSVG) {
      dom.setAttribute("class", className);
    } else {
      dom.className = className;
    }
    mountRef(ref, dom, lifecycle);
  }
  return vNode.dom;
}
function hydrateText(vNode, parentDOM, dom) {
  if (dom.nodeType !== 3) {
    parentDOM.replaceChild(vNode.dom = document.createTextNode(vNode.children), dom);
  } else {
    var text = vNode.children;
    if (dom.nodeValue !== text) {
      dom.nodeValue = text;
    }
    vNode.dom = dom;
  }
  return vNode.dom;
}
function hydrateFragment(vNode, parentDOM, dom, context2, isSVG, lifecycle) {
  var children = vNode.children;
  if (vNode.childFlags === 2) {
    hydrateText(children, parentDOM, dom);
    return children.dom;
  }
  hydrateChildren(vNode, parentDOM, dom, context2, isSVG, lifecycle);
  return findLastDOMFromVNode(children[children.length - 1]);
}
function hydrateVNode(vNode, parentDOM, currentDom, context2, isSVG, lifecycle) {
  var flags = vNode.flags |= 16384;
  if (flags & 14) {
    return hydrateComponent(vNode, parentDOM, currentDom, context2, isSVG, (flags & 4) > 0, lifecycle);
  }
  if (flags & 481) {
    return hydrateElement(vNode, parentDOM, currentDom, context2, isSVG, lifecycle);
  }
  if (flags & 16) {
    return hydrateText(vNode, parentDOM, currentDom);
  }
  if (flags & 512) {
    return vNode.dom = currentDom;
  }
  if (flags & 8192) {
    return hydrateFragment(vNode, parentDOM, currentDom, context2, isSVG, lifecycle);
  }
  throwError();
  return null;
}
function hydrate(input, parentDOM, callback) {
  var dom = parentDOM.firstChild;
  if (isNull2(dom)) {
    render2(input, parentDOM, callback);
  } else {
    var lifecycle = [];
    if (!isInvalid2(input)) {
      dom = hydrateVNode(input, parentDOM, dom, {}, false, lifecycle);
    }
    while (dom && (dom = dom.nextSibling)) {
      parentDOM.removeChild(dom);
    }
    if (lifecycle.length > 0) {
      var listener;
      while ((listener = lifecycle.shift()) !== void 0) {
        listener();
      }
    }
  }
  parentDOM.$V = input;
  if (isFunction3(callback)) {
    callback();
  }
}
var ERROR_MSG;
var init_index_esm4 = __esm({
  "node_modules/inferno-hydrate/dist/index.esm.js"() {
    init_index_esm2();
    ERROR_MSG = "a runtime error occured! Use Inferno in development environment to find the error.";
  }
});

// node_modules/@devextreme/vdom/dist/esm/effect_host.js
var InfernoEffectHost;
var init_effect_host = __esm({
  "node_modules/@devextreme/vdom/dist/esm/effect_host.js"() {
    InfernoEffectHost = {
      lockCount: 0,
      lock() {
        this.lockCount++;
      },
      callbacks: [],
      callEffects() {
        this.lockCount--;
        if (this.lockCount < 0) {
          throw "Unexpected Effect Call";
        }
        if (this.lockCount === 0) {
          const effects = this.callbacks;
          this.callbacks = [];
          effects.forEach((callback) => callback());
        }
      }
    };
  }
});

// node_modules/@devextreme/vdom/dist/esm/base_component.js
var areObjectsEqual, BaseInfernoComponent, InfernoComponent, InfernoWrapperComponent;
var init_base_component = __esm({
  "node_modules/@devextreme/vdom/dist/esm/base_component.js"() {
    init_index_esm2();
    init_effect_host();
    areObjectsEqual = (firstObject, secondObject) => {
      const bothAreObjects = firstObject instanceof Object && secondObject instanceof Object;
      if (!bothAreObjects) {
        return firstObject === secondObject;
      }
      const firstObjectKeys = Object.keys(firstObject);
      const secondObjectKeys = Object.keys(secondObject);
      if (firstObjectKeys.length !== secondObjectKeys.length) {
        return false;
      }
      const hasDifferentElement = firstObjectKeys.some((key) => firstObject[key] !== secondObject[key]);
      return !hasDifferentElement;
    };
    BaseInfernoComponent = class extends Component2 {
      constructor() {
        super(...arguments);
        this._pendingContext = this.context;
      }
      componentWillReceiveProps(_2, context2) {
        this._pendingContext = context2 !== null && context2 !== void 0 ? context2 : {};
      }
      shouldComponentUpdate(nextProps, nextState) {
        return !areObjectsEqual(this.props, nextProps) || !areObjectsEqual(this.state, nextState) || !areObjectsEqual(this.context, this._pendingContext);
      }
    };
    InfernoComponent = class extends BaseInfernoComponent {
      constructor() {
        super(...arguments);
        this._effects = [];
      }
      createEffects() {
        return [];
      }
      updateEffects() {
      }
      componentWillMount() {
        InfernoEffectHost.lock();
      }
      componentWillUpdate() {
        InfernoEffectHost.lock();
      }
      componentDidMount() {
        InfernoEffectHost.callbacks.push(() => {
          this._effects = this.createEffects();
        });
        InfernoEffectHost.callEffects();
      }
      componentDidUpdate() {
        InfernoEffectHost.callbacks.push(() => this.updateEffects());
        InfernoEffectHost.callEffects();
      }
      destroyEffects() {
        this._effects.forEach((e) => e.dispose());
      }
      componentWillUnmount() {
        this.destroyEffects();
      }
    };
    InfernoWrapperComponent = class extends InfernoComponent {
      constructor() {
        super(...arguments);
        this.vDomElement = null;
        this.vDomPreviousClasses = [];
        this.vDomRemovedClasses = [];
        this.vDomAddedClasses = [];
      }
      vDomUpdateClasses() {
        var _a;
        const currentClasses = ((_a = this.vDomElement) === null || _a === void 0 ? void 0 : _a.className.length) ? this.vDomElement.className.split(" ") : [];
        const addedClasses = currentClasses.filter((className) => this.vDomPreviousClasses.indexOf(className) < 0);
        const removedClasses = this.vDomPreviousClasses.filter((className) => currentClasses.indexOf(className) < 0);
        addedClasses.forEach((value2) => {
          const indexInRemoved = this.vDomRemovedClasses.indexOf(value2);
          if (indexInRemoved > -1) {
            this.vDomRemovedClasses.splice(indexInRemoved, 1);
          } else {
            this.vDomAddedClasses.push(value2);
          }
        });
        removedClasses.forEach((value2) => {
          const indexInAdded = this.vDomAddedClasses.indexOf(value2);
          if (indexInAdded > -1) {
            this.vDomAddedClasses.splice(indexInAdded, 1);
          } else {
            this.vDomRemovedClasses.push(value2);
          }
        });
      }
      componentDidMount() {
        var _a;
        super.componentDidMount();
        this.vDomElement = findDOMfromVNode(this.$LI, true);
        this.vDomPreviousClasses = ((_a = this.vDomElement) === null || _a === void 0 ? void 0 : _a.className.length) ? this.vDomElement.className.split(" ") : [];
      }
      componentDidUpdate() {
        var _a;
        super.componentDidUpdate();
        const element = this.vDomElement;
        if (element !== null) {
          this.vDomAddedClasses.forEach((className) => element.classList.add(className));
          this.vDomRemovedClasses.forEach((className) => element.classList.remove(className));
          this.vDomPreviousClasses = ((_a = this.vDomElement) === null || _a === void 0 ? void 0 : _a.className.length) ? this.vDomElement.className.split(" ") : [];
        }
      }
      shouldComponentUpdate(nextProps, nextState) {
        const shouldUpdate = super.shouldComponentUpdate(nextProps, nextState);
        if (shouldUpdate) {
          this.vDomUpdateClasses();
        }
        return shouldUpdate;
      }
    };
  }
});

// node_modules/@devextreme/vdom/dist/esm/create_context.js
var createContext;
var init_create_context = __esm({
  "node_modules/@devextreme/vdom/dist/esm/create_context.js"() {
    createContext = function(defaultValue) {
      return defaultValue;
    };
  }
});

// node_modules/@devextreme/vdom/dist/esm/effect.js
var InfernoEffect;
var init_effect = __esm({
  "node_modules/@devextreme/vdom/dist/esm/effect.js"() {
    InfernoEffect = class {
      constructor(effect, dependency) {
        this.effect = effect;
        this.dependency = dependency;
        this.destroy = effect();
      }
      update(dependency) {
        if (!dependency || dependency.some((d, i) => this.dependency[i] !== d)) {
          this.dispose();
          this.destroy = this.effect();
        }
        if (dependency) {
          this.dependency = dependency;
        }
      }
      dispose() {
        if (this.destroy) {
          this.destroy();
        }
      }
    };
  }
});

// node_modules/@devextreme/vdom/dist/esm/portal.js
var init_portal = __esm({
  "node_modules/@devextreme/vdom/dist/esm/portal.js"() {
    init_index_esm2();
  }
});

// node_modules/@devextreme/vdom/dist/esm/utils.js
var NUMBER_STYLES, uppercasePattern, kebabCase, isNumeric2, getNumberStyleValue, normalizeStyles;
var init_utils10 = __esm({
  "node_modules/@devextreme/vdom/dist/esm/utils.js"() {
    NUMBER_STYLES = [
      "animation-iteration-count",
      "border-image-outset",
      "border-image-slice",
      "border-image-width",
      "box-flex",
      "box-flex-group",
      "box-ordinal-group",
      "column-count",
      "fill-opacity",
      "flex",
      "flex-grow",
      "flex-negative",
      "flex-order",
      "flex-positive",
      "flex-shrink",
      "flood-opacity",
      "font-weight",
      "grid-column",
      "grid-row",
      "line-clamp",
      "line-height",
      "opacity",
      "order",
      "orphans",
      "stop-opacity",
      "stroke-dasharray",
      "stroke-dashoffset",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke-width",
      "tab-size",
      "widows",
      "z-index",
      "zoom"
    ];
    uppercasePattern = /[A-Z]/g;
    kebabCase = (str) => str.replace(uppercasePattern, "-$&").toLowerCase();
    isNumeric2 = (value2) => {
      if (typeof value2 === "number")
        return true;
      return !isNaN(Number(value2));
    };
    getNumberStyleValue = (style, value2) => NUMBER_STYLES.indexOf(style) > -1 ? value2 : `${value2}px`;
    normalizeStyles = (styles) => {
      if (!(styles instanceof Object))
        return void 0;
      return Object.keys(styles).reduce((result2, key) => {
        const value2 = styles[key];
        const kebabString = kebabCase(key);
        result2[kebabString] = isNumeric2(value2) ? getNumberStyleValue(kebabString, value2) : value2;
        return result2;
      }, {});
    };
  }
});

// node_modules/@devextreme/vdom/dist/esm/mocked/shared.js
var init_shared = __esm({
  "node_modules/@devextreme/vdom/dist/esm/mocked/shared.js"() {
  }
});

// node_modules/@devextreme/vdom/dist/esm/mocked/hydrate.js
var init_hydrate = __esm({
  "node_modules/@devextreme/vdom/dist/esm/mocked/hydrate.js"() {
    init_index_esm2();
    init_shared();
  }
});

// node_modules/@devextreme/vdom/dist/esm/index.js
var init_esm = __esm({
  "node_modules/@devextreme/vdom/dist/esm/index.js"() {
    init_base_component();
    init_create_context();
    init_effect();
    init_effect_host();
    init_portal();
    init_utils10();
    init_hydrate();
  }
});

// node_modules/devextreme/esm/renovation/component_wrapper/utils.js
function updatePropsImmutable(props, option, name2, fullName) {
  var currentPropsValue = option[name2];
  var result2 = props;
  if (name2 !== fullName) {
    if (Array.isArray(currentPropsValue)) {
      var newArray = [...currentPropsValue];
      result2[name2] = newArray;
      var matchIndex = /\[\s*(\d+)\s*\]/g.exec(fullName);
      if (matchIndex) {
        var index2 = parseInt(matchIndex[1], 10);
        if (isPlainObject(newArray[index2])) {
          newArray[index2] = _extends({}, currentPropsValue[index2]);
        }
      }
      return;
    }
  }
  if (isPlainObject(currentPropsValue)) {
    result2[name2] = _extends({}, currentPropsValue);
  } else {
    result2[name2] = currentPropsValue;
  }
}
var removeDifferentElements;
var init_utils11 = __esm({
  "node_modules/devextreme/esm/renovation/component_wrapper/utils.js"() {
    init_extends();
    init_iterator();
    init_type();
    removeDifferentElements = ($children, $newChildren) => {
      each($newChildren, (__, element) => {
        var hasComponent = false;
        each($children, (_2, oldElement) => {
          if (element === oldElement) {
            hasComponent = true;
          }
        });
        if (!hasComponent && element.parentNode) {
          element.parentNode.removeChild(element);
        }
      });
    };
  }
});

// node_modules/devextreme/esm/core/polyfills/number.js
var number, number_default3;
var init_number4 = __esm({
  "node_modules/devextreme/esm/core/polyfills/number.js"() {
    init_window();
    number = hasWindow() ? getWindow().Number : Number;
    number.isFinite = number.isFinite || function(value2) {
      return "number" === typeof value2 && isFinite(value2);
    };
    number_default3 = number;
  }
});

// node_modules/devextreme/esm/renovation/component_wrapper/template_wrapper.js
var TemplateWrapper;
var init_template_wrapper = __esm({
  "node_modules/devextreme/esm/renovation/component_wrapper/template_wrapper.js"() {
    init_extends();
    init_esm();
    init_index_esm2();
    init_renderer();
    init_dom_adapter();
    init_element();
    init_utils11();
    init_number4();
    TemplateWrapper = class extends InfernoComponent {
      constructor(props) {
        super(props);
        this.renderTemplate = this.renderTemplate.bind(this);
      }
      renderTemplate() {
        var node = findDOMfromVNode(this.$LI, true);
        if (node) {
          var {
            parentNode
          } = node;
          if (parentNode) {
            var _this$props$model;
            parentNode.removeChild(node);
            var $parent = renderer_default(parentNode);
            var $children = $parent.contents();
            var {
              data: data2,
              index: index2
            } = null !== (_this$props$model = this.props.model) && void 0 !== _this$props$model ? _this$props$model : {
              data: {}
            };
            Object.keys(data2).forEach((name2) => {
              if (data2[name2] && dom_adapter_default.isNode(data2[name2])) {
                data2[name2] = getPublicElement(renderer_default(data2[name2]));
              }
            });
            this.props.template.render(_extends({
              container: getPublicElement($parent),
              transclude: this.props.transclude
            }, !this.props.transclude ? {
              model: data2
            } : {}, !this.props.transclude && number_default3.isFinite(index2) ? {
              index: index2
            } : {}));
            return () => {
              removeDifferentElements($children, $parent.contents());
              parentNode.appendChild(node);
            };
          }
        }
        return;
      }
      createEffects() {
        return [new InfernoEffect(this.renderTemplate, [this.props.template, this.props.model])];
      }
      updateEffects() {
        this._effects[0].update([this.props.template, this.props.model]);
      }
      componentWillUnmount() {
      }
      render() {
        return null;
      }
    };
  }
});

// node_modules/devextreme/esm/renovation/component_wrapper/component.js
var setDefaultOptionValue, ComponentWrapper;
var init_component2 = __esm({
  "node_modules/devextreme/esm/renovation/component_wrapper/component.js"() {
    init_extends();
    init_index_esm2();
    init_index_esm3();
    init_index_esm4();
    init_renderer();
    init_dom_adapter();
    init_dom_component();
    init_extend();
    init_element();
    init_type();
    init_esm();
    init_template_wrapper();
    init_utils11();
    setDefaultOptionValue = (options2, defaultValueGetter) => (name2) => {
      if (options2.hasOwnProperty(name2) && void 0 === options2[name2]) {
        options2[name2] = defaultValueGetter(name2);
      }
    };
    ComponentWrapper = class extends dom_component_default {
      constructor() {
        super(...arguments);
        this._disposeMethodCalled = false;
      }
      get _propsInfo() {
        return {
          allowNull: [],
          twoWay: [],
          elements: [],
          templates: [],
          props: []
        };
      }
      get viewRef() {
        var _this$_viewRef;
        return null === (_this$_viewRef = this._viewRef) || void 0 === _this$_viewRef ? void 0 : _this$_viewRef.current;
      }
      _getDefaultOptions() {
        return extend2(true, super._getDefaultOptions(), this._viewComponent.defaultProps, this._propsInfo.twoWay.reduce((options2, _ref) => {
          var [name2, defaultValue, eventName] = _ref;
          return _extends({}, options2, {
            [name2]: defaultValue,
            [eventName]: (value2) => this.option(name2, value2)
          });
        }, {}), this._propsInfo.templates.reduce((options2, name2) => _extends({}, options2, {
          [name2]: null
        }), {}));
      }
      _initMarkup() {
        var props = this.getProps();
        this._renderWrapper(props);
      }
      _renderWrapper(props) {
        var containerNode = this.$element()[0];
        var parentNode = containerNode.parentNode;
        if (!this._isNodeReplaced) {
          var nextNode = null === containerNode || void 0 === containerNode ? void 0 : containerNode.nextSibling;
          var rootNode = dom_adapter_default.createElement("div");
          rootNode.appendChild(containerNode);
          var mountNode = this._documentFragment.appendChild(rootNode);
          InfernoEffectHost.lock();
          hydrate(createElement(this._viewComponent, props), mountNode);
          containerNode.$V = mountNode.$V;
          if (parentNode) {
            parentNode.insertBefore(containerNode, nextNode);
          }
          InfernoEffectHost.callEffects();
          this._isNodeReplaced = true;
        } else {
          render2(createElement(this._viewComponent, props), containerNode);
        }
      }
      _render() {
      }
      dispose() {
        this._disposeMethodCalled = true;
        super.dispose();
      }
      _dispose() {
        var containerNode = this.$element()[0];
        var parentNode = containerNode.parentNode;
        parentNode.$V = containerNode.$V;
        containerNode.$V = null;
        render2(this._disposeMethodCalled ? createElement(containerNode.tagName, this.elementAttr) : null, parentNode);
        delete parentNode.$V;
        super._dispose();
      }
      get elementAttr() {
        var _this$_storedClasses;
        if (!this._elementAttr) {
          var {
            attributes
          } = this.$element()[0];
          this._elementAttr = _extends({}, Object.keys(attributes).reduce((a, key) => {
            if (attributes[key].specified) {
              a[attributes[key].name] = attributes[key].value;
            }
            return a;
          }, {}));
        }
        var elemStyle = this.$element()[0].style;
        var style = {};
        for (var i = 0; i < elemStyle.length; i++) {
          style[elemStyle[i]] = elemStyle.getPropertyValue(elemStyle[i]);
        }
        this._elementAttr.style = style;
        var cssClass = this.$element()[0].getAttribute("class") || "";
        this._storedClasses = null !== (_this$_storedClasses = this._storedClasses) && void 0 !== _this$_storedClasses ? _this$_storedClasses : cssClass.split(" ").filter((name2) => 0 === name2.indexOf("dx-")).join(" ");
        this._elementAttr.class = cssClass.split(" ").filter((name2) => 0 !== name2.indexOf("dx-")).concat(this._storedClasses).join(" ").trim();
        return this._elementAttr;
      }
      _patchOptionValues(options2) {
        var {
          allowNull,
          elements,
          props,
          twoWay
        } = this._propsInfo;
        var defaultProps = this._viewComponent.defaultProps;
        var widgetProps = props.reduce((acc, propName) => {
          if (options2.hasOwnProperty(propName)) {
            acc[propName] = options2[propName];
          }
          return acc;
        }, {
          ref: options2.ref,
          children: options2.children
        });
        allowNull.forEach(setDefaultOptionValue(widgetProps, () => null));
        Object.keys(defaultProps).forEach(setDefaultOptionValue(widgetProps, (name2) => defaultProps[name2]));
        twoWay.forEach((_ref2) => {
          var [name2, defaultValue] = _ref2;
          return setDefaultOptionValue(widgetProps, () => defaultValue)(name2);
        });
        elements.forEach((name2) => {
          if (name2 in widgetProps) {
            var value2 = widgetProps[name2];
            if (isRenderer(value2)) {
              widgetProps[name2] = this._patchElementParam(value2);
            }
          }
        });
        return widgetProps;
      }
      getProps() {
        var {
          elementAttr
        } = this.option();
        var options2 = this._patchOptionValues(_extends({}, this._props, {
          ref: this._viewRef,
          children: this._extractDefaultSlot()
        }));
        this._propsInfo.templates.forEach((template) => {
          options2[template] = this._componentTemplates[template];
        });
        return _extends({}, options2, this.elementAttr, elementAttr, {
          className: [...(this.elementAttr.class || "").split(" "), ...(elementAttr.class || "").split(" ")].filter((c, i, a) => c && a.indexOf(c) === i).join(" ").trim(),
          class: ""
        }, this._actionsMap);
      }
      _getActionConfigs() {
        return {};
      }
      _init() {
        super._init();
        this._props = _extends({}, this.option());
        this._documentFragment = dom_adapter_default.createDocumentFragment();
        this._actionsMap = {};
        this._componentTemplates = {};
        this._propsInfo.templates.forEach((template) => {
          this._componentTemplates[template] = this._createTemplateComponent(this._props[template]);
        });
        Object.keys(this._getActionConfigs()).forEach((name2) => this._addAction(name2));
        this._viewRef = createRef();
        this._supportedKeys = () => ({});
      }
      _addAction(event, action) {
        if (!action) {
          var actionByOption = this._createActionByOption(event, this._getActionConfigs()[event]);
          action = function(actArgs) {
            Object.keys(actArgs).forEach((name2) => {
              if (isDefined(actArgs[name2]) && dom_adapter_default.isNode(actArgs[name2])) {
                actArgs[name2] = getPublicElement(renderer_default(actArgs[name2]));
              }
            });
            return actionByOption(actArgs);
          };
        }
        this._actionsMap[event] = action;
      }
      _optionChanged(option) {
        var {
          fullName,
          name: name2,
          value: value2
        } = option;
        updatePropsImmutable(this._props, this.option(), name2, fullName);
        if (this._propsInfo.templates.indexOf(name2) > -1) {
          this._componentTemplates[name2] = this._createTemplateComponent(value2);
        }
        if (name2 && this._getActionConfigs()[name2]) {
          this._addAction(name2);
        }
        super._optionChanged(option);
        this._invalidate();
      }
      _extractDefaultSlot() {
        if (this.option("_hasAnonymousTemplateContent")) {
          return createElement(TemplateWrapper, {
            template: this._getTemplate(this._templateManager.anonymousTemplateName),
            transclude: true
          });
        }
        return null;
      }
      _createTemplateComponent(templateOption) {
        if (!templateOption) {
          return;
        }
        var template = this._getTemplate(templateOption);
        return (model) => createElement(TemplateWrapper, {
          template,
          model
        });
      }
      _wrapKeyDownHandler(handler) {
        return (options2) => {
          var {
            keyName,
            originalEvent,
            which
          } = options2;
          var keys = this._supportedKeys();
          var func = keys[keyName] || keys[which];
          if (void 0 !== func) {
            var _handler = func.bind(this);
            var result2 = _handler(originalEvent, options2);
            if (!result2) {
              originalEvent.cancel = true;
              return originalEvent;
            }
          }
          return null === handler || void 0 === handler ? void 0 : handler(originalEvent, options2);
        };
      }
      _toPublicElement(element) {
        return getPublicElement(renderer_default(element));
      }
      _patchElementParam(value2) {
        var _result, _result2;
        var result2;
        try {
          result2 = renderer_default(value2);
        } catch (error) {
          return value2;
        }
        result2 = null === (_result = result2) || void 0 === _result ? void 0 : _result.get(0);
        return null !== (_result2 = result2) && void 0 !== _result2 && _result2.nodeType ? result2 : value2;
      }
      repaint() {
        this._isNodeReplaced = false;
        this._refresh();
      }
      registerKeyHandler(key, handler) {
        var currentKeys = this._supportedKeys();
        this._supportedKeys = () => _extends({}, currentKeys, {
          [key]: handler
        });
      }
      setAria(name2, value2) {
        throw new Error('"setAria" method is deprecated, use "aria" property instead');
      }
    };
    ComponentWrapper.IS_RENOVATED_WIDGET = false;
    ComponentWrapper.IS_RENOVATED_WIDGET = true;
  }
});

// node_modules/devextreme/esm/renovation/component_wrapper/grid_pager.js
var GridPagerWrapper;
var init_grid_pager = __esm({
  "node_modules/devextreme/esm/renovation/component_wrapper/grid_pager.js"() {
    init_component2();
    GridPagerWrapper = class extends ComponentWrapper {
      _optionChanged(args) {
        switch (args.name) {
          case "pageIndex":
            var pageIndexChanged = this.option("pageIndexChanged");
            if (pageIndexChanged) {
              pageIndexChanged(args.value);
            }
            break;
          case "pageSize":
            var pageSizeChanged = this.option("pageSizeChanged");
            if (pageSizeChanged) {
              pageSizeChanged(args.value);
            }
        }
        super._optionChanged(args);
      }
    };
  }
});

// node_modules/devextreme/esm/renovation/utils/get_computed_style.js
function getElementComputedStyle(el) {
  var _window$getComputedSt, _window;
  return el ? null === (_window$getComputedSt = (_window = window).getComputedStyle) || void 0 === _window$getComputedSt ? void 0 : _window$getComputedSt.call(_window, el) : null;
}
var init_get_computed_style = __esm({
  "node_modules/devextreme/esm/renovation/utils/get_computed_style.js"() {
  }
});

// node_modules/devextreme/esm/renovation/utils/type_conversion.js
function toNumber2(attribute) {
  return attribute ? Number(attribute.replace("px", "")) : 0;
}
var init_type_conversion = __esm({
  "node_modules/devextreme/esm/renovation/utils/type_conversion.js"() {
  }
});

// node_modules/devextreme/esm/renovation/ui/pager/utils/get_element_width.js
function getElementStyle(name2, element) {
  var computedStyle = getElementComputedStyle(element) || {};
  return toNumber2(computedStyle[name2]);
}
function getElementWidth2(element) {
  return getElementStyle("width", element);
}
function getElementMinWidth(element) {
  return getElementStyle("minWidth", element);
}
var init_get_element_width = __esm({
  "node_modules/devextreme/esm/renovation/ui/pager/utils/get_element_width.js"() {
    init_get_computed_style();
    init_type_conversion();
  }
});

// node_modules/devextreme/esm/renovation/ui/pager/resizable_container.js
function calculateAdaptivityProps(_ref2) {
  var {
    info: infoWidth,
    pageSizes: pageSizesWidth,
    pages: pagesWidth,
    parent: parentWidth
  } = _ref2;
  var minimalWidth = pageSizesWidth + pagesWidth + infoWidth;
  var infoTextVisible = parentWidth - minimalWidth > 0;
  var isLargeDisplayMode = parentWidth - (pageSizesWidth + pagesWidth) > 0;
  return {
    infoTextVisible,
    isLargeDisplayMode
  };
}
function getElementsWidth(_ref3) {
  var {
    info,
    pageSizes,
    pages,
    parent
  } = _ref3;
  var parentWidth = getElementWidth2(parent);
  var pageSizesWidth = getElementWidth2(pageSizes);
  var infoWidth = getElementWidth2(info);
  var pagesHtmlWidth = getElementWidth2(pages);
  return {
    parent: parentWidth,
    pageSizes: pageSizesWidth,
    info: infoWidth + getElementStyle("marginLeft", info) + getElementStyle("marginRight", info),
    pages: pagesHtmlWidth
  };
}
var _excluded3, viewFunction, ResizableContainerProps, getTemplate, ResizableContainer;
var init_resizable_container = __esm({
  "node_modules/devextreme/esm/renovation/ui/pager/resizable_container.js"() {
    init_objectWithoutPropertiesLoose();
    init_extends();
    init_index_esm2();
    init_esm();
    init_resize_callbacks();
    init_get_element_width();
    init_type();
    init_index_esm2();
    _excluded3 = ["contentTemplate", "pagerProps"];
    viewFunction = (_ref) => {
      var {
        infoTextRef,
        infoTextVisible,
        isLargeDisplayMode,
        pageSizesRef,
        pagesRef,
        parentRef,
        props: {
          contentTemplate: Content,
          pagerProps
        },
        restAttributes
      } = _ref;
      return Content(_extends({
        rootElementRef: parentRef,
        pageSizesRef,
        infoTextRef,
        pagesRef,
        infoTextVisible,
        isLargeDisplayMode
      }, _extends({}, pagerProps, restAttributes)));
    };
    ResizableContainerProps = {};
    getTemplate = (TemplateProp) => TemplateProp && (TemplateProp.defaultProps ? (props) => normalizeProps(createComponentVNode(2, TemplateProp, _extends({}, props))) : TemplateProp);
    ResizableContainer = class extends InfernoComponent {
      constructor(props) {
        super(props);
        this._currentState = null;
        this.parentRef = createRef();
        this.pageSizesRef = createRef();
        this.infoTextRef = createRef();
        this.pagesRef = createRef();
        this.state = {
          infoTextVisible: true,
          isLargeDisplayMode: true
        };
        this.subscribeToResize = this.subscribeToResize.bind(this);
        this.effectUpdateChildProps = this.effectUpdateChildProps.bind(this);
        this.updateAdaptivityProps = this.updateAdaptivityProps.bind(this);
      }
      createEffects() {
        return [new InfernoEffect(this.subscribeToResize, [this.infoTextVisible, this.isLargeDisplayMode]), new InfernoEffect(this.effectUpdateChildProps, [this.infoTextVisible, this.isLargeDisplayMode, this.props.pagerProps, this.props.contentTemplate])];
      }
      updateEffects() {
        var _this$_effects$, _this$_effects$2;
        null === (_this$_effects$ = this._effects[0]) || void 0 === _this$_effects$ ? void 0 : _this$_effects$.update([this.infoTextVisible, this.isLargeDisplayMode]);
        null === (_this$_effects$2 = this._effects[1]) || void 0 === _this$_effects$2 ? void 0 : _this$_effects$2.update([this.infoTextVisible, this.isLargeDisplayMode, this.props.pagerProps, this.props.contentTemplate]);
      }
      get infoTextVisible() {
        var state = this._currentState || this.state;
        return state.infoTextVisible;
      }
      set_infoTextVisible(value2) {
        this.setState((state) => {
          this._currentState = state;
          var newValue = value2();
          this._currentState = null;
          return {
            infoTextVisible: newValue
          };
        });
      }
      get isLargeDisplayMode() {
        var state = this._currentState || this.state;
        return state.isLargeDisplayMode;
      }
      set_isLargeDisplayMode(value2) {
        this.setState((state) => {
          this._currentState = state;
          var newValue = value2();
          this._currentState = null;
          return {
            isLargeDisplayMode: newValue
          };
        });
      }
      subscribeToResize() {
        var callback = () => {
          this.updateAdaptivityProps();
        };
        resize_callbacks_default.add(callback);
        return () => {
          resize_callbacks_default.remove(callback);
        };
      }
      effectUpdateChildProps() {
        var parentWidth = this.parentRef.current ? getElementWidth2(this.parentRef.current) : 0;
        if (parentWidth > 0) {
          this.updateAdaptivityProps();
        }
      }
      updateAdaptivityProps() {
        var currentElementsWidth = getElementsWidth({
          parent: this.parentRef.current,
          pageSizes: this.pageSizesRef.current,
          info: this.infoTextRef.current,
          pages: this.pagesRef.current
        });
        if (isDefined(this.actualAdaptivityProps) && (this.actualAdaptivityProps.infoTextVisible !== this.infoTextVisible || this.actualAdaptivityProps.isLargeDisplayMode !== this.isLargeDisplayMode)) {
          return;
        }
        var isEmpty3 = !isDefined(this.elementsWidth);
        if (isEmpty3) {
          this.elementsWidth = {};
        }
        if (isEmpty3 || this.isLargeDisplayMode) {
          this.elementsWidth.pageSizes = currentElementsWidth.pageSizes;
          this.elementsWidth.pages = currentElementsWidth.pages;
        }
        if (isEmpty3 || this.infoTextVisible) {
          this.elementsWidth.info = currentElementsWidth.info;
        }
        this.actualAdaptivityProps = calculateAdaptivityProps(_extends({
          parent: currentElementsWidth.parent
        }, this.elementsWidth));
        this.set_infoTextVisible(() => this.actualAdaptivityProps.infoTextVisible);
        this.set_isLargeDisplayMode(() => this.actualAdaptivityProps.isLargeDisplayMode);
      }
      get restAttributes() {
        var _this$props = this.props, restProps = _objectWithoutPropertiesLoose(_this$props, _excluded3);
        return restProps;
      }
      render() {
        var props = this.props;
        return viewFunction({
          props: _extends({}, props, {
            contentTemplate: getTemplate(props.contentTemplate)
          }),
          infoTextVisible: this.infoTextVisible,
          isLargeDisplayMode: this.isLargeDisplayMode,
          parentRef: this.parentRef,
          pageSizesRef: this.pageSizesRef,
          infoTextRef: this.infoTextRef,
          pagesRef: this.pagesRef,
          updateAdaptivityProps: this.updateAdaptivityProps,
          restAttributes: this.restAttributes
        });
      }
    };
    ResizableContainer.defaultProps = _extends({}, ResizableContainerProps);
  }
});

// node_modules/devextreme/esm/renovation/ui/pager/common/pager_props.js
var PagerProps;
var init_pager_props = __esm({
  "node_modules/devextreme/esm/renovation/ui/pager/common/pager_props.js"() {
    PagerProps = {
      gridCompatibility: true,
      showInfo: false,
      displayMode: "adaptive",
      maxPagesCount: 10,
      pageCount: 10,
      visible: true,
      hasKnownLastPage: true,
      pagesNavigatorVisible: "auto",
      showPageSizes: true,
      pageSizes: [5, 10],
      showNavigationButtons: false,
      totalCount: 0,
      defaultPageIndex: 1,
      defaultPageSize: 5
    };
  }
});

// node_modules/devextreme/esm/renovation/ui/pager/info.js
var _excluded4, PAGER_INFO_CLASS, viewFunction2, InfoTextPropsType, InfoText;
var init_info = __esm({
  "node_modules/devextreme/esm/renovation/ui/pager/info.js"() {
    init_extends();
    init_objectWithoutPropertiesLoose();
    init_index_esm2();
    init_esm();
    init_string();
    init_message();
    init_pager_props();
    _excluded4 = ["defaultPageIndex", "infoText", "pageCount", "pageIndex", "pageIndexChange", "rootElementRef", "totalCount"];
    PAGER_INFO_CLASS = "dx-info";
    viewFunction2 = (_ref) => {
      var {
        props: {
          rootElementRef
        },
        text
      } = _ref;
      return createVNode(1, "div", PAGER_INFO_CLASS, text, 0, null, null, rootElementRef);
    };
    InfoTextPropsType = {
      pageCount: PagerProps.pageCount,
      totalCount: PagerProps.totalCount,
      defaultPageIndex: PagerProps.pageIndex,
      pageIndexChange: () => {
      }
    };
    InfoText = class extends BaseInfernoComponent {
      constructor(props) {
        super(props);
        this._currentState = null;
        this.state = {
          pageIndex: void 0 !== this.props.pageIndex ? this.props.pageIndex : this.props.defaultPageIndex
        };
      }
      get __state_pageIndex() {
        var state = this._currentState || this.state;
        return void 0 !== this.props.pageIndex ? this.props.pageIndex : state.pageIndex;
      }
      set_pageIndex(value2) {
        this.setState((state) => {
          this._currentState = state;
          var newValue = value2();
          this.props.pageIndexChange(newValue);
          this._currentState = null;
          return {
            pageIndex: newValue
          };
        });
      }
      get infoText() {
        return this.props.infoText || message_default.getFormatter("dxPager-infoText")();
      }
      get text() {
        var {
          pageCount,
          totalCount
        } = this.props;
        return format(this.infoText, (this.__state_pageIndex + 1).toString(), pageCount.toString(), totalCount.toString());
      }
      get restAttributes() {
        var _this$props$pageIndex = _extends({}, this.props, {
          pageIndex: this.__state_pageIndex
        }), restProps = _objectWithoutPropertiesLoose(_this$props$pageIndex, _excluded4);
        return restProps;
      }
      render() {
        var props = this.props;
        return viewFunction2({
          props: _extends({}, props, {
            pageIndex: this.__state_pageIndex
          }),
          infoText: this.infoText,
          text: this.text,
          restAttributes: this.restAttributes
        });
      }
    };
    InfoText.defaultProps = _extends({}, InfoTextPropsType);
  }
});

// node_modules/devextreme/esm/renovation/utils/subscribe_to_event.js
function subscribeToEvent(eventName) {
  return (element, handler) => {
    if (handler && element) {
      events_engine_default.on(element, eventName, handler);
      return () => events_engine_default.off(element, eventName, handler);
    }
    return;
  };
}
var subscribeToClickEvent, subscribeToScrollEvent;
var init_subscribe_to_event = __esm({
  "node_modules/devextreme/esm/renovation/utils/subscribe_to_event.js"() {
    init_events_engine();
    init_click();
    subscribeToClickEvent = subscribeToEvent(CLICK_EVENT_NAME);
    subscribeToScrollEvent = subscribeToEvent("scroll");
  }
});

// node_modules/devextreme/esm/renovation/ui/pager/common/keyboard_action_context.js
var KeyboardActionContext;
var init_keyboard_action_context = __esm({
  "node_modules/devextreme/esm/renovation/ui/pager/common/keyboard_action_context.js"() {
    init_esm();
    KeyboardActionContext = createContext(void 0);
  }
});

// node_modules/devextreme/esm/renovation/ui/pager/common/light_button.js
var _excluded5, viewFunction3, LightButtonProps, LightButton;
var init_light_button = __esm({
  "node_modules/devextreme/esm/renovation/ui/pager/common/light_button.js"() {
    init_extends();
    init_objectWithoutPropertiesLoose();
    init_index_esm2();
    init_esm();
    init_subscribe_to_event();
    init_keyboard_action_context();
    init_index_esm2();
    _excluded5 = ["children", "className", "label", "onClick"];
    viewFunction3 = (_ref) => {
      var {
        props: {
          children,
          className,
          label
        },
        widgetRef
      } = _ref;
      return createVNode(1, "div", className, children, 0, {
        tabIndex: 0,
        role: "button",
        "aria-label": label
      }, null, widgetRef);
    };
    LightButtonProps = {
      className: "",
      label: ""
    };
    LightButton = class extends InfernoComponent {
      constructor(props) {
        super(props);
        this.state = {};
        this.widgetRef = createRef();
        this.keyboardEffect = this.keyboardEffect.bind(this);
        this.subscribeToClick = this.subscribeToClick.bind(this);
      }
      get keyboardContext() {
        if ("KeyboardActionContext" in this.context) {
          return this.context.KeyboardActionContext;
        }
        return KeyboardActionContext;
      }
      createEffects() {
        return [new InfernoEffect(this.keyboardEffect, [this.keyboardContext, this.props.onClick]), new InfernoEffect(this.subscribeToClick, [this.props.onClick])];
      }
      updateEffects() {
        var _this$_effects$, _this$_effects$2;
        null === (_this$_effects$ = this._effects[0]) || void 0 === _this$_effects$ ? void 0 : _this$_effects$.update([this.keyboardContext, this.props.onClick]);
        null === (_this$_effects$2 = this._effects[1]) || void 0 === _this$_effects$2 ? void 0 : _this$_effects$2.update([this.props.onClick]);
      }
      keyboardEffect() {
        return this.keyboardContext.registerKeyboardAction(this.widgetRef.current, this.props.onClick);
      }
      subscribeToClick() {
        return subscribeToClickEvent(this.widgetRef.current, this.props.onClick);
      }
      get restAttributes() {
        var _this$props = this.props, restProps = _objectWithoutPropertiesLoose(_this$props, _excluded5);
        return restProps;
      }
      render() {
        var props = this.props;
        return viewFunction3({
          props: _extends({}, props),
          widgetRef: this.widgetRef,
          keyboardContext: this.keyboardContext,
          restAttributes: this.restAttributes
        });
      }
    };
    LightButton.defaultProps = _extends({}, LightButtonProps);
  }
});

// node_modules/devextreme/esm/renovation/ui/pager/common/consts.js
var PAGER_CLASS, LIGHT_MODE_CLASS, PAGER_PAGES_CLASS, PAGER_PAGE_INDEXES_CLASS, PAGER_PAGE_CLASS, PAGER_SELECTION_CLASS, PAGER_PAGE_SIZE_CLASS, PAGER_PAGE_SIZES_CLASS, PAGER_SELECTED_PAGE_SIZE_CLASS;
var init_consts2 = __esm({
  "node_modules/devextreme/esm/renovation/ui/pager/common/consts.js"() {
    PAGER_CLASS = "dx-pager";
    LIGHT_MODE_CLASS = "dx-light-mode";
    PAGER_PAGES_CLASS = "dx-pages";
    PAGER_PAGE_INDEXES_CLASS = "dx-page-indexes";
    PAGER_PAGE_CLASS = "dx-page";
    PAGER_SELECTION_CLASS = "dx-selection";
    PAGER_PAGE_SIZE_CLASS = "dx-page-size";
    PAGER_PAGE_SIZES_CLASS = "dx-page-sizes";
    PAGER_SELECTED_PAGE_SIZE_CLASS = "".concat(PAGER_PAGE_SIZE_CLASS, " ").concat(PAGER_SELECTION_CLASS);
  }
});

// node_modules/devextreme/esm/renovation/utils/combine_classes.js
function combineClasses(classesMap) {
  return Object.keys(classesMap).filter((p2) => classesMap[p2]).join(" ");
}
var init_combine_classes = __esm({
  "node_modules/devextreme/esm/renovation/utils/combine_classes.js"() {
  }
});

// node_modules/devextreme/esm/renovation/ui/pager/pages/page.js
var _excluded6, viewFunction4, PageProps, Page;
var init_page = __esm({
  "node_modules/devextreme/esm/renovation/ui/pager/pages/page.js"() {
    init_extends();
    init_objectWithoutPropertiesLoose();
    init_index_esm2();
    init_esm();
    init_light_button();
    init_consts2();
    init_combine_classes();
    _excluded6 = ["className", "index", "onClick", "selected"];
    viewFunction4 = (_ref) => {
      var {
        className,
        label,
        props: {
          onClick
        },
        value: value2
      } = _ref;
      return createComponentVNode(2, LightButton, {
        className,
        label,
        onClick,
        children: value2
      });
    };
    PageProps = {
      index: 0,
      selected: false,
      className: PAGER_PAGE_CLASS
    };
    Page = class extends BaseInfernoComponent {
      constructor(props) {
        super(props);
        this.state = {};
      }
      get label() {
        return "Page ".concat(this.value);
      }
      get value() {
        return this.props.index + 1;
      }
      get className() {
        var {
          selected
        } = this.props;
        return combineClasses({
          ["".concat(this.props.className)]: !!this.props.className,
          [PAGER_SELECTION_CLASS]: !!selected
        });
      }
      get restAttributes() {
        var _this$props = this.props, restProps = _objectWithoutPropertiesLoose(_this$props, _excluded6);
        return restProps;
      }
      render() {
        var props = this.props;
        return viewFunction4({
          props: _extends({}, props),
          label: this.label,
          value: this.value,
          className: this.className,
          restAttributes: this.restAttributes
        });
      }
    };
    Page.defaultProps = _extends({}, PageProps);
  }
});

// node_modules/devextreme/esm/renovation/common/config_context.js
var ConfigContext;
var init_config_context = __esm({
  "node_modules/devextreme/esm/renovation/common/config_context.js"() {
    init_esm();
    ConfigContext = createContext(void 0);
  }
});

// node_modules/devextreme/esm/renovation/ui/pager/pages/large.js
function getDelimiterType(startIndex, slidingWindowSize, pageCount) {
  if (1 === startIndex) {
    return "high";
  }
  if (startIndex + slidingWindowSize === pageCount - 1) {
    return "low";
  }
  return "both";
}
function createPageIndexesBySlidingWindowIndexes(slidingWindowIndexes, pageCount, delimiter) {
  var pageIndexes = [];
  var indexesForReuse = [];
  switch (delimiter) {
    case "none":
      pageIndexes = [...slidingWindowIndexes];
      break;
    case "both":
      pageIndexes = [0, "low", ...slidingWindowIndexes, "high", pageCount - 1];
      indexesForReuse = slidingWindowIndexes.slice(1, -1);
      break;
    case "high":
      pageIndexes = [0, ...slidingWindowIndexes, "high", pageCount - 1];
      indexesForReuse = slidingWindowIndexes.slice(0, -1);
      break;
    case "low":
      pageIndexes = [0, "low", ...slidingWindowIndexes, pageCount - 1];
      indexesForReuse = slidingWindowIndexes.slice(1);
  }
  return {
    slidingWindowIndexes,
    indexesForReuse,
    pageIndexes
  };
}
function createPageIndexes(startIndex, slidingWindowSize, pageCount, delimiter) {
  var slidingWindowIndexes = [];
  for (var i = 0; i < slidingWindowSize; i += 1) {
    slidingWindowIndexes.push(i + startIndex);
  }
  return createPageIndexesBySlidingWindowIndexes(slidingWindowIndexes, pageCount, delimiter);
}
var _excluded7, _excluded22, PAGER_PAGE_SEPARATOR_CLASS, viewFunction5, PAGES_LIMITER, PagesLargePropsType, PagesLarge;
var init_large = __esm({
  "node_modules/devextreme/esm/renovation/ui/pager/pages/large.js"() {
    init_extends();
    init_objectWithoutPropertiesLoose();
    init_index_esm2();
    init_index_esm2();
    init_esm();
    init_page();
    init_pager_props();
    init_config_context();
    _excluded7 = ["pageIndexes"];
    _excluded22 = ["defaultPageIndex", "maxPagesCount", "pageCount", "pageIndex", "pageIndexChange"];
    PAGER_PAGE_SEPARATOR_CLASS = "dx-separator";
    viewFunction5 = (_ref) => {
      var {
        pages
      } = _ref;
      var PagesMarkup = pages.map((_ref2) => {
        var {
          key,
          pageProps
        } = _ref2;
        return pageProps ? createComponentVNode(2, Page, {
          index: pageProps.index,
          selected: pageProps.selected,
          onClick: pageProps.onClick
        }, key) : createVNode(1, "div", PAGER_PAGE_SEPARATOR_CLASS, ". . .", 16, null, key);
      });
      return createFragment(PagesMarkup, 0);
    };
    PAGES_LIMITER = 4;
    PagesLargePropsType = {
      maxPagesCount: PagerProps.maxPagesCount,
      pageCount: PagerProps.pageCount,
      defaultPageIndex: PagerProps.pageIndex
    };
    PagesLarge = class extends BaseInfernoComponent {
      constructor(props) {
        super(props);
        this._currentState = null;
        this.state = {
          pageIndex: void 0 !== this.props.pageIndex ? this.props.pageIndex : this.props.defaultPageIndex
        };
        this.canReuseSlidingWindow = this.canReuseSlidingWindow.bind(this);
        this.generatePageIndexes = this.generatePageIndexes.bind(this);
        this.isSlidingWindowMode = this.isSlidingWindowMode.bind(this);
        this.onPageClick = this.onPageClick.bind(this);
      }
      get config() {
        if ("ConfigContext" in this.context) {
          return this.context.ConfigContext;
        }
        return ConfigContext;
      }
      get __state_pageIndex() {
        var state = this._currentState || this.state;
        return void 0 !== this.props.pageIndex ? this.props.pageIndex : state.pageIndex;
      }
      set_pageIndex(value2) {
        this.setState((state) => {
          var _this$props$pageIndex, _this$props;
          this._currentState = state;
          var newValue = value2();
          null === (_this$props$pageIndex = (_this$props = this.props).pageIndexChange) || void 0 === _this$props$pageIndex ? void 0 : _this$props$pageIndex.call(_this$props, newValue);
          this._currentState = null;
          return {
            pageIndex: newValue
          };
        });
      }
      get slidingWindowState() {
        var slidingWindowState = this.slidingWindowStateHolder;
        if (!slidingWindowState) {
          return {
            indexesForReuse: [],
            slidingWindowIndexes: []
          };
        }
        return slidingWindowState;
      }
      canReuseSlidingWindow(currentPageCount, pageIndex) {
        var {
          indexesForReuse
        } = this.slidingWindowState;
        var lastIndexForReuse = indexesForReuse[indexesForReuse.length - 1];
        var lastPageIsFartherThanWindow = lastIndexForReuse < currentPageCount - 1;
        var pageIndexExistInIndexes = -1 !== indexesForReuse.indexOf(pageIndex);
        return lastPageIsFartherThanWindow && pageIndexExistInIndexes;
      }
      generatePageIndexes() {
        var {
          pageCount
        } = this.props;
        var startIndex = 0;
        var {
          slidingWindowIndexes
        } = this.slidingWindowState;
        if (this.__state_pageIndex === slidingWindowIndexes[0]) {
          startIndex = this.__state_pageIndex - 1;
        } else if (this.__state_pageIndex === slidingWindowIndexes[slidingWindowIndexes.length - 1]) {
          startIndex = this.__state_pageIndex + 2 - PAGES_LIMITER;
        } else if (this.__state_pageIndex < PAGES_LIMITER) {
          startIndex = 1;
        } else if (this.__state_pageIndex >= pageCount - PAGES_LIMITER) {
          startIndex = pageCount - PAGES_LIMITER - 1;
        } else {
          startIndex = this.__state_pageIndex - 1;
        }
        var slidingWindowSize = PAGES_LIMITER;
        var delimiter = getDelimiterType(startIndex, slidingWindowSize, pageCount);
        var _createPageIndexes = createPageIndexes(startIndex, slidingWindowSize, pageCount, delimiter), {
          pageIndexes
        } = _createPageIndexes, slidingWindowState = _objectWithoutPropertiesLoose(_createPageIndexes, _excluded7);
        this.slidingWindowStateHolder = slidingWindowState;
        return pageIndexes;
      }
      isSlidingWindowMode() {
        var {
          maxPagesCount,
          pageCount
        } = this.props;
        return pageCount <= PAGES_LIMITER || pageCount <= maxPagesCount;
      }
      onPageClick(pageIndex) {
        var _this$props$pageIndex2, _this$props2;
        null === (_this$props$pageIndex2 = (_this$props2 = this.props).pageIndexChange) || void 0 === _this$props$pageIndex2 ? void 0 : _this$props$pageIndex2.call(_this$props2, pageIndex);
      }
      get pageIndexes() {
        var {
          pageCount
        } = this.props;
        if (this.isSlidingWindowMode()) {
          return createPageIndexes(0, pageCount, pageCount, "none").pageIndexes;
        }
        if (this.canReuseSlidingWindow(pageCount, this.__state_pageIndex)) {
          var {
            slidingWindowIndexes
          } = this.slidingWindowState;
          var delimiter = getDelimiterType(slidingWindowIndexes[0], PAGES_LIMITER, pageCount);
          return createPageIndexesBySlidingWindowIndexes(slidingWindowIndexes, pageCount, delimiter).pageIndexes;
        }
        return this.generatePageIndexes();
      }
      get pages() {
        var _this$config;
        var createPage = (index2) => {
          var pagerProps = "low" === index2 || "high" === index2 ? null : {
            index: index2,
            onClick: () => this.onPageClick(index2),
            selected: this.__state_pageIndex === index2
          };
          return {
            key: index2.toString(),
            pageProps: pagerProps
          };
        };
        var rtlPageIndexes = null !== (_this$config = this.config) && void 0 !== _this$config && _this$config.rtlEnabled ? [...this.pageIndexes].reverse() : this.pageIndexes;
        return rtlPageIndexes.map((index2) => createPage(index2));
      }
      get restAttributes() {
        var _this$props$pageIndex3 = _extends({}, this.props, {
          pageIndex: this.__state_pageIndex
        }), restProps = _objectWithoutPropertiesLoose(_this$props$pageIndex3, _excluded22);
        return restProps;
      }
      render() {
        var props = this.props;
        return viewFunction5({
          props: _extends({}, props, {
            pageIndex: this.__state_pageIndex
          }),
          config: this.config,
          pageIndexes: this.pageIndexes,
          pages: this.pages,
          restAttributes: this.restAttributes
        });
      }
    };
    PagesLarge.defaultProps = _extends({}, PagesLargePropsType);
  }
});

// node_modules/devextreme/esm/renovation/ui/common/base_props.js
var BaseWidgetProps;
var init_base_props = __esm({
  "node_modules/devextreme/esm/renovation/ui/common/base_props.js"() {
    BaseWidgetProps = {
      activeStateEnabled: false,
      disabled: false,
      focusStateEnabled: false,
      hoverStateEnabled: false,
      tabIndex: 0,
      visible: true
    };
  }
});

// node_modules/devextreme/esm/renovation/common/config_provider.js
var _excluded8, viewFunction6, ConfigProviderProps, ConfigProvider;
var init_config_provider = __esm({
  "node_modules/devextreme/esm/renovation/common/config_provider.js"() {
    init_objectWithoutPropertiesLoose();
    init_extends();
    init_esm();
    _excluded8 = ["children", "rtlEnabled"];
    viewFunction6 = (viewModel) => viewModel.props.children;
    ConfigProviderProps = {};
    ConfigProvider = class extends BaseInfernoComponent {
      constructor(props) {
        super(props);
        this.state = {};
      }
      getChildContext() {
        return _extends({}, this.context, {
          ConfigContext: this.config
        });
      }
      get config() {
        return {
          rtlEnabled: this.props.rtlEnabled
        };
      }
      get restAttributes() {
        var _this$props = this.props, restProps = _objectWithoutPropertiesLoose(_this$props, _excluded8);
        return restProps;
      }
      render() {
        var props = this.props;
        return viewFunction6({
          props: _extends({}, props),
          config: this.config,
          restAttributes: this.restAttributes
        });
      }
    };
    ConfigProvider.defaultProps = _extends({}, ConfigProviderProps);
  }
});

// node_modules/devextreme/esm/renovation/utils/resolve_rtl.js
function resolveRtlEnabled(rtlProp, config2) {
  if (void 0 !== rtlProp) {
    return rtlProp;
  }
  if (void 0 !== (null === config2 || void 0 === config2 ? void 0 : config2.rtlEnabled)) {
    return config2.rtlEnabled;
  }
  return config_default().rtlEnabled;
}
function resolveRtlEnabledDefinition(rtlProp, config2) {
  var isPropDefined = isDefined(rtlProp);
  var onlyGlobalDefined = isDefined(config_default().rtlEnabled) && !isPropDefined && !isDefined(null === config2 || void 0 === config2 ? void 0 : config2.rtlEnabled);
  return isPropDefined && rtlProp !== (null === config2 || void 0 === config2 ? void 0 : config2.rtlEnabled) || onlyGlobalDefined;
}
var init_resolve_rtl = __esm({
  "node_modules/devextreme/esm/renovation/utils/resolve_rtl.js"() {
    init_type();
    init_config();
  }
});

// node_modules/devextreme/esm/renovation/ui/common/widget.js
var _excluded9, getAria, getCssClasses2, viewFunction7, WidgetProps, Widget2;
var init_widget = __esm({
  "node_modules/devextreme/esm/renovation/ui/common/widget.js"() {
    init_objectWithoutPropertiesLoose();
    init_extends();
    init_index_esm2();
    init_esm();
    init_click();
    init_hover();
    init_short();
    init_combine_classes();
    init_extend();
    init_selectors();
    init_style();
    init_base_props();
    init_config_context();
    init_config_provider();
    init_resolve_rtl();
    init_resize_callbacks();
    init_index_esm2();
    _excluded9 = ["_feedbackHideTimeout", "_feedbackShowTimeout", "accessKey", "activeStateEnabled", "activeStateUnit", "aria", "children", "className", "classes", "disabled", "focusStateEnabled", "height", "hint", "hoverStateEnabled", "name", "onActive", "onClick", "onContentReady", "onDimensionChanged", "onFocusIn", "onFocusOut", "onHoverEnd", "onHoverStart", "onInactive", "onKeyDown", "onKeyboardHandled", "onVisibilityChange", "rootElementRef", "rtlEnabled", "tabIndex", "visible", "width"];
    getAria = (args) => Object.keys(args).reduce((r, key) => {
      if (args[key]) {
        return _extends({}, r, {
          ["role" === key || "id" === key ? key : "aria-".concat(key)]: String(args[key])
        });
      }
      return r;
    }, {});
    getCssClasses2 = (model) => {
      var isFocusable = !!model.focusStateEnabled && !model.disabled;
      var isHoverable = !!model.hoverStateEnabled && !model.disabled;
      var canBeActive = !!model.activeStateEnabled && !model.disabled;
      var classesMap = {
        "dx-widget": true,
        [String(model.classes)]: !!model.classes,
        [String(model.className)]: !!model.className,
        "dx-state-disabled": !!model.disabled,
        "dx-state-invisible": !model.visible,
        "dx-state-focused": !!model.focused && isFocusable,
        "dx-state-active": !!model.active && canBeActive,
        "dx-state-hover": !!model.hovered && isHoverable && !model.active,
        "dx-rtl": !!model.rtlEnabled,
        "dx-visibility-change-handler": !!model.onVisibilityChange
      };
      return combineClasses(classesMap);
    };
    viewFunction7 = (viewModel) => {
      var widget = normalizeProps(createVNode(1, "div", viewModel.cssClasses, viewModel.props.children, 0, _extends({}, viewModel.attributes, {
        tabIndex: viewModel.tabIndex,
        title: viewModel.props.hint,
        style: normalizeStyles(viewModel.styles)
      }), null, viewModel.widgetRef));
      return viewModel.shouldRenderConfigProvider ? createComponentVNode(2, ConfigProvider, {
        rtlEnabled: viewModel.rtlEnabled,
        children: widget
      }) : widget;
    };
    WidgetProps = _extends({}, BaseWidgetProps, {
      _feedbackHideTimeout: 400,
      _feedbackShowTimeout: 30,
      aria: {},
      classes: "",
      className: "",
      name: ""
    });
    Widget2 = class extends InfernoWrapperComponent {
      constructor(props) {
        super(props);
        this._currentState = null;
        this.widgetRef = createRef();
        this.state = {
          active: false,
          focused: false,
          hovered: false
        };
        this.setRootElementRef = this.setRootElementRef.bind(this);
        this.activeEffect = this.activeEffect.bind(this);
        this.clickEffect = this.clickEffect.bind(this);
        this.focus = this.focus.bind(this);
        this.focusEffect = this.focusEffect.bind(this);
        this.hoverEffect = this.hoverEffect.bind(this);
        this.keyboardEffect = this.keyboardEffect.bind(this);
        this.resizeEffect = this.resizeEffect.bind(this);
        this.windowResizeEffect = this.windowResizeEffect.bind(this);
        this.visibilityEffect = this.visibilityEffect.bind(this);
      }
      get config() {
        if ("ConfigContext" in this.context) {
          return this.context.ConfigContext;
        }
        return ConfigContext;
      }
      createEffects() {
        return [new InfernoEffect(this.setRootElementRef, []), new InfernoEffect(this.activeEffect, [this.props._feedbackHideTimeout, this.props._feedbackShowTimeout, this.props.activeStateEnabled, this.props.activeStateUnit, this.props.disabled, this.props.onActive, this.props.onInactive]), new InfernoEffect(this.clickEffect, [this.props.disabled, this.props.name, this.props.onClick]), new InfernoEffect(this.focusEffect, [this.props.disabled, this.props.focusStateEnabled, this.props.name, this.props.onFocusIn, this.props.onFocusOut]), new InfernoEffect(this.hoverEffect, [this.props.activeStateUnit, this.props.disabled, this.props.hoverStateEnabled, this.props.onHoverEnd, this.props.onHoverStart, this.active]), new InfernoEffect(this.keyboardEffect, [this.props.onKeyDown]), new InfernoEffect(this.resizeEffect, [this.props.name, this.props.onDimensionChanged]), new InfernoEffect(this.windowResizeEffect, [this.props.onDimensionChanged]), new InfernoEffect(this.visibilityEffect, [this.props.name, this.props.onVisibilityChange])];
      }
      updateEffects() {
        var _this$_effects$, _this$_effects$2, _this$_effects$3, _this$_effects$4, _this$_effects$5, _this$_effects$6, _this$_effects$7, _this$_effects$8;
        null === (_this$_effects$ = this._effects[1]) || void 0 === _this$_effects$ ? void 0 : _this$_effects$.update([this.props._feedbackHideTimeout, this.props._feedbackShowTimeout, this.props.activeStateEnabled, this.props.activeStateUnit, this.props.disabled, this.props.onActive, this.props.onInactive]);
        null === (_this$_effects$2 = this._effects[2]) || void 0 === _this$_effects$2 ? void 0 : _this$_effects$2.update([this.props.disabled, this.props.name, this.props.onClick]);
        null === (_this$_effects$3 = this._effects[3]) || void 0 === _this$_effects$3 ? void 0 : _this$_effects$3.update([this.props.disabled, this.props.focusStateEnabled, this.props.name, this.props.onFocusIn, this.props.onFocusOut]);
        null === (_this$_effects$4 = this._effects[4]) || void 0 === _this$_effects$4 ? void 0 : _this$_effects$4.update([this.props.activeStateUnit, this.props.disabled, this.props.hoverStateEnabled, this.props.onHoverEnd, this.props.onHoverStart, this.active]);
        null === (_this$_effects$5 = this._effects[5]) || void 0 === _this$_effects$5 ? void 0 : _this$_effects$5.update([this.props.onKeyDown]);
        null === (_this$_effects$6 = this._effects[6]) || void 0 === _this$_effects$6 ? void 0 : _this$_effects$6.update([this.props.name, this.props.onDimensionChanged]);
        null === (_this$_effects$7 = this._effects[7]) || void 0 === _this$_effects$7 ? void 0 : _this$_effects$7.update([this.props.onDimensionChanged]);
        null === (_this$_effects$8 = this._effects[8]) || void 0 === _this$_effects$8 ? void 0 : _this$_effects$8.update([this.props.name, this.props.onVisibilityChange]);
      }
      get active() {
        var state = this._currentState || this.state;
        return state.active;
      }
      set_active(value2) {
        this.setState((state) => {
          this._currentState = state;
          var newValue = value2();
          this._currentState = null;
          return {
            active: newValue
          };
        });
      }
      get focused() {
        var state = this._currentState || this.state;
        return state.focused;
      }
      set_focused(value2) {
        this.setState((state) => {
          this._currentState = state;
          var newValue = value2();
          this._currentState = null;
          return {
            focused: newValue
          };
        });
      }
      get hovered() {
        var state = this._currentState || this.state;
        return state.hovered;
      }
      set_hovered(value2) {
        this.setState((state) => {
          this._currentState = state;
          var newValue = value2();
          this._currentState = null;
          return {
            hovered: newValue
          };
        });
      }
      setRootElementRef() {
        var {
          rootElementRef
        } = this.props;
        if (rootElementRef) {
          rootElementRef.current = this.widgetRef.current;
        }
      }
      activeEffect() {
        var {
          _feedbackHideTimeout,
          _feedbackShowTimeout,
          activeStateEnabled,
          activeStateUnit,
          disabled,
          onActive,
          onInactive
        } = this.props;
        var selector = activeStateUnit;
        if (activeStateEnabled && !disabled) {
          active.on(this.widgetRef.current, (_ref) => {
            var {
              event
            } = _ref;
            this.set_active(() => true);
            null === onActive || void 0 === onActive ? void 0 : onActive(event);
          }, (_ref2) => {
            var {
              event
            } = _ref2;
            this.set_active(() => false);
            null === onInactive || void 0 === onInactive ? void 0 : onInactive(event);
          }, {
            hideTimeout: _feedbackHideTimeout,
            namespace: "UIFeedback",
            selector,
            showTimeout: _feedbackShowTimeout
          });
          return () => active.off(this.widgetRef.current, {
            selector,
            namespace: "UIFeedback"
          });
        }
        return;
      }
      clickEffect() {
        var {
          disabled,
          name: name2,
          onClick
        } = this.props;
        var namespace = name2;
        if (onClick && !disabled) {
          dxClick.on(this.widgetRef.current, onClick, {
            namespace
          });
          return () => dxClick.off(this.widgetRef.current, {
            namespace
          });
        }
        return;
      }
      focusEffect() {
        var {
          disabled,
          focusStateEnabled,
          name: name2,
          onFocusIn,
          onFocusOut
        } = this.props;
        var namespace = "".concat(name2, "Focus");
        var isFocusable = focusStateEnabled && !disabled;
        if (isFocusable) {
          focus.on(this.widgetRef.current, (e) => {
            if (!e.isDefaultPrevented()) {
              this.set_focused(() => true);
              null === onFocusIn || void 0 === onFocusIn ? void 0 : onFocusIn(e);
            }
          }, (e) => {
            if (!e.isDefaultPrevented()) {
              this.set_focused(() => false);
              null === onFocusOut || void 0 === onFocusOut ? void 0 : onFocusOut(e);
            }
          }, {
            isFocusable: focusable,
            namespace
          });
          return () => focus.off(this.widgetRef.current, {
            namespace
          });
        }
        return;
      }
      hoverEffect() {
        var {
          activeStateUnit,
          disabled,
          hoverStateEnabled,
          onHoverEnd,
          onHoverStart
        } = this.props;
        var selector = activeStateUnit;
        var isHoverable = hoverStateEnabled && !disabled;
        if (isHoverable) {
          hover.on(this.widgetRef.current, (_ref3) => {
            var {
              event
            } = _ref3;
            !this.active && this.set_hovered(() => true);
            null === onHoverStart || void 0 === onHoverStart ? void 0 : onHoverStart(event);
          }, (_ref4) => {
            var {
              event
            } = _ref4;
            this.set_hovered(() => false);
            null === onHoverEnd || void 0 === onHoverEnd ? void 0 : onHoverEnd(event);
          }, {
            selector,
            namespace: "UIFeedback"
          });
          return () => hover.off(this.widgetRef.current, {
            selector,
            namespace: "UIFeedback"
          });
        }
        return;
      }
      keyboardEffect() {
        var {
          onKeyDown
        } = this.props;
        if (onKeyDown) {
          var id = keyboard.on(this.widgetRef.current, this.widgetRef.current, (e) => onKeyDown(e));
          return () => keyboard.off(id);
        }
        return;
      }
      resizeEffect() {
        var namespace = "".concat(this.props.name, "VisibilityChange");
        var {
          onDimensionChanged
        } = this.props;
        if (onDimensionChanged) {
          resize.on(this.widgetRef.current, onDimensionChanged, {
            namespace
          });
          return () => resize.off(this.widgetRef.current, {
            namespace
          });
        }
        return;
      }
      windowResizeEffect() {
        var {
          onDimensionChanged
        } = this.props;
        if (onDimensionChanged) {
          resize_callbacks_default.add(onDimensionChanged);
          return () => {
            resize_callbacks_default.remove(onDimensionChanged);
          };
        }
        return;
      }
      visibilityEffect() {
        var {
          name: name2,
          onVisibilityChange
        } = this.props;
        var namespace = "".concat(name2, "VisibilityChange");
        if (onVisibilityChange) {
          visibility.on(this.widgetRef.current, () => onVisibilityChange(true), () => onVisibilityChange(false), {
            namespace
          });
          return () => visibility.off(this.widgetRef.current, {
            namespace
          });
        }
        return;
      }
      get shouldRenderConfigProvider() {
        var {
          rtlEnabled
        } = this.props;
        return resolveRtlEnabledDefinition(rtlEnabled, this.config);
      }
      get rtlEnabled() {
        var {
          rtlEnabled
        } = this.props;
        return resolveRtlEnabled(rtlEnabled, this.config);
      }
      get attributes() {
        var {
          aria,
          disabled,
          focusStateEnabled,
          visible: visible2
        } = this.props;
        var accessKey = focusStateEnabled && !disabled && this.props.accessKey;
        return _extends({}, extend2({}, this.restAttributes, accessKey && {
          accessKey
        }), getAria(_extends({}, aria, {
          disabled,
          hidden: !visible2
        })));
      }
      get styles() {
        var {
          height,
          width
        } = this.props;
        var style = this.restAttributes.style || {};
        var computedWidth = normalizeStyleProp("width", "function" === typeof width ? width() : width);
        var computedHeight = normalizeStyleProp("height", "function" === typeof height ? height() : height);
        return _extends({}, style, {
          height: null !== computedHeight && void 0 !== computedHeight ? computedHeight : style.height,
          width: null !== computedWidth && void 0 !== computedWidth ? computedWidth : style.width
        });
      }
      get cssClasses() {
        var {
          activeStateEnabled,
          className,
          classes,
          disabled,
          focusStateEnabled,
          hoverStateEnabled,
          onVisibilityChange,
          visible: visible2
        } = this.props;
        return getCssClasses2({
          active: this.active,
          focused: this.focused,
          hovered: this.hovered,
          className,
          classes,
          disabled,
          activeStateEnabled,
          focusStateEnabled,
          hoverStateEnabled,
          onVisibilityChange,
          rtlEnabled: this.rtlEnabled,
          visible: visible2
        });
      }
      get tabIndex() {
        var {
          disabled,
          focusStateEnabled,
          tabIndex
        } = this.props;
        var isFocusable = focusStateEnabled && !disabled;
        return isFocusable ? tabIndex : void 0;
      }
      get restAttributes() {
        var _this$props = this.props, restProps = _objectWithoutPropertiesLoose(_this$props, _excluded9);
        return restProps;
      }
      focus() {
        focus.trigger(this.widgetRef.current);
      }
      render() {
        var props = this.props;
        return viewFunction7({
          props: _extends({}, props),
          active: this.active,
          focused: this.focused,
          hovered: this.hovered,
          widgetRef: this.widgetRef,
          config: this.config,
          shouldRenderConfigProvider: this.shouldRenderConfigProvider,
          rtlEnabled: this.rtlEnabled,
          attributes: this.attributes,
          styles: this.styles,
          cssClasses: this.cssClasses,
          tabIndex: this.tabIndex,
          restAttributes: this.restAttributes
        });
      }
    };
    Widget2.defaultProps = _extends({}, WidgetProps);
  }
});

// node_modules/devextreme/esm/renovation/utils/render_template.js
function renderTemplate(template, props, container) {
  setTimeout(() => {
    render2(createElement(template, props), null === container || void 0 === container ? void 0 : container.get(0));
  }, 0);
}
var init_render_template = __esm({
  "node_modules/devextreme/esm/renovation/utils/render_template.js"() {
    init_index_esm2();
    init_index_esm3();
  }
});

// node_modules/devextreme/esm/renovation/ui/common/dom_component_wrapper.js
var _excluded10, _excluded23, viewFunction8, DomComponentWrapperProps, DomComponentWrapper;
var init_dom_component_wrapper = __esm({
  "node_modules/devextreme/esm/renovation/ui/common/dom_component_wrapper.js"() {
    init_objectWithoutPropertiesLoose();
    init_extends();
    init_index_esm2();
    init_esm();
    init_config_context();
    init_render_template();
    init_index_esm2();
    _excluded10 = ["itemTemplate", "valueChange"];
    _excluded23 = ["componentProps", "componentType", "rootElementRef"];
    viewFunction8 = (_ref) => {
      var {
        props: {
          componentProps: {
            className
          }
        },
        restAttributes,
        widgetRef
      } = _ref;
      return normalizeProps(createVNode(1, "div", className, null, 1, _extends({}, restAttributes), null, widgetRef));
    };
    DomComponentWrapperProps = {};
    DomComponentWrapper = class extends InfernoComponent {
      constructor(props) {
        super(props);
        this.state = {};
        this.widgetRef = createRef();
        this.getInstance = this.getInstance.bind(this);
        this.setupWidget = this.setupWidget.bind(this);
        this.setRootElementRef = this.setRootElementRef.bind(this);
        this.updateWidget = this.updateWidget.bind(this);
      }
      get config() {
        if ("ConfigContext" in this.context) {
          return this.context.ConfigContext;
        }
        return ConfigContext;
      }
      createEffects() {
        return [new InfernoEffect(this.setupWidget, []), new InfernoEffect(this.setRootElementRef, []), new InfernoEffect(this.updateWidget, [this.props.componentProps, this.config])];
      }
      updateEffects() {
        var _this$_effects$;
        null === (_this$_effects$ = this._effects[2]) || void 0 === _this$_effects$ ? void 0 : _this$_effects$.update([this.props.componentProps, this.config]);
      }
      setupWidget() {
        var componentInstance = new this.props.componentType(this.widgetRef.current, this.properties);
        this.instance = componentInstance;
        return () => {
          componentInstance.dispose();
          this.instance = null;
        };
      }
      setRootElementRef() {
        var {
          rootElementRef
        } = this.props;
        if (rootElementRef) {
          rootElementRef.current = this.widgetRef.current;
        }
      }
      updateWidget() {
        var _this$getInstance;
        null === (_this$getInstance = this.getInstance()) || void 0 === _this$getInstance ? void 0 : _this$getInstance.option(this.properties);
      }
      get properties() {
        var _this$config;
        var _this$props$component = this.props.componentProps, {
          itemTemplate,
          valueChange
        } = _this$props$component, restProps = _objectWithoutPropertiesLoose(_this$props$component, _excluded10);
        var properties = _extends({
          rtlEnabled: (null === (_this$config = this.config) || void 0 === _this$config ? void 0 : _this$config.rtlEnabled) || false
        }, restProps);
        if (valueChange) {
          properties.onValueChanged = (_ref2) => {
            var {
              value: value2
            } = _ref2;
            return valueChange(value2);
          };
        }
        if (itemTemplate) {
          properties.itemTemplate = (item, index2, container) => {
            renderTemplate(itemTemplate, {
              item,
              index: index2,
              container
            }, container);
          };
        }
        return properties;
      }
      get restAttributes() {
        var _this$props = this.props, restProps = _objectWithoutPropertiesLoose(_this$props, _excluded23);
        return restProps;
      }
      getInstance() {
        return this.instance;
      }
      render() {
        var props = this.props;
        return viewFunction8({
          props: _extends({}, props),
          widgetRef: this.widgetRef,
          config: this.config,
          properties: this.properties,
          restAttributes: this.restAttributes
        });
      }
    };
    DomComponentWrapper.defaultProps = _extends({}, DomComponentWrapperProps);
  }
});

// node_modules/devextreme/esm/renovation/ui/number_box.js
var _excluded11, _excluded24, viewFunction9, NumberBoxProps, NumberBox;
var init_number_box3 = __esm({
  "node_modules/devextreme/esm/renovation/ui/number_box.js"() {
    init_extends();
    init_objectWithoutPropertiesLoose();
    init_index_esm2();
    init_esm();
    init_number_box2();
    init_widget();
    init_dom_component_wrapper();
    _excluded11 = ["rootElementRef"];
    _excluded24 = ["_feedbackHideTimeout", "_feedbackShowTimeout", "accessKey", "activeStateEnabled", "activeStateUnit", "aria", "children", "className", "classes", "defaultValue", "disabled", "focusStateEnabled", "height", "hint", "hoverStateEnabled", "invalidValueMessage", "max", "min", "mode", "name", "onActive", "onClick", "onContentReady", "onDimensionChanged", "onFocusIn", "onFocusOut", "onHoverEnd", "onHoverStart", "onInactive", "onKeyDown", "onKeyboardHandled", "onVisibilityChange", "rootElementRef", "rtlEnabled", "showSpinButtons", "step", "tabIndex", "useLargeSpinButtons", "value", "valueChange", "visible", "width"];
    viewFunction9 = (_ref) => {
      var {
        props: {
          rootElementRef
        },
        restAttributes
      } = _ref, componentProps = _objectWithoutPropertiesLoose(_ref.props, _excluded11);
      return normalizeProps(createComponentVNode(2, DomComponentWrapper, _extends({
        rootElementRef,
        componentType: number_box_default2,
        componentProps
      }, restAttributes)));
    };
    NumberBoxProps = _extends({}, WidgetProps, {
      focusStateEnabled: true,
      hoverStateEnabled: true,
      defaultValue: 0
    });
    NumberBox = class extends BaseInfernoComponent {
      constructor(props) {
        super(props);
        this._currentState = null;
        this.state = {
          value: void 0 !== this.props.value ? this.props.value : this.props.defaultValue
        };
      }
      get __state_value() {
        var state = this._currentState || this.state;
        return void 0 !== this.props.value ? this.props.value : state.value;
      }
      set_value(value2) {
        this.setState((state) => {
          var _this$props$valueChan, _this$props;
          this._currentState = state;
          var newValue = value2();
          null === (_this$props$valueChan = (_this$props = this.props).valueChange) || void 0 === _this$props$valueChan ? void 0 : _this$props$valueChan.call(_this$props, newValue);
          this._currentState = null;
          return {
            value: newValue
          };
        });
      }
      get restAttributes() {
        var _this$props$value = _extends({}, this.props, {
          value: this.__state_value
        }), restProps = _objectWithoutPropertiesLoose(_this$props$value, _excluded24);
        return restProps;
      }
      render() {
        var props = this.props;
        return viewFunction9({
          props: _extends({}, props, {
            value: this.__state_value
          }),
          restAttributes: this.restAttributes
        });
      }
    };
    NumberBox.defaultProps = _extends({}, NumberBoxProps);
  }
});

// node_modules/devextreme/esm/renovation/ui/pager/utils/calculate_values_fitted_width.js
function calculateValuesFittedWidth(minWidth, values) {
  return minWidth + oneDigitWidth * Math.max(...values).toString().length;
}
var oneDigitWidth;
var init_calculate_values_fitted_width = __esm({
  "node_modules/devextreme/esm/renovation/ui/pager/utils/calculate_values_fitted_width.js"() {
    oneDigitWidth = 10;
  }
});

// node_modules/devextreme/esm/renovation/ui/pager/pages/small.js
var _excluded12, PAGER_INFO_TEXT_CLASS, PAGER_PAGE_INDEX_CLASS, LIGHT_PAGES_CLASS, PAGER_PAGES_COUNT_CLASS, viewFunction10, PagerSmallProps, PagesSmall;
var init_small = __esm({
  "node_modules/devextreme/esm/renovation/ui/pager/pages/small.js"() {
    init_extends();
    init_objectWithoutPropertiesLoose();
    init_index_esm2();
    init_esm();
    init_page();
    init_info();
    init_number_box3();
    init_message();
    init_calculate_values_fitted_width();
    init_get_element_width();
    init_pager_props();
    init_index_esm2();
    _excluded12 = ["defaultPageIndex", "pageCount", "pageIndex", "pageIndexChange", "pagesCountText"];
    PAGER_INFO_TEXT_CLASS = "".concat(PAGER_INFO_CLASS, "  dx-info-text");
    PAGER_PAGE_INDEX_CLASS = "dx-page-index";
    LIGHT_PAGES_CLASS = "dx-light-pages";
    PAGER_PAGES_COUNT_CLASS = "dx-pages-count";
    viewFunction10 = (_ref) => {
      var {
        pageIndexRef,
        pagesCountText,
        props: {
          pageCount
        },
        selectLastPageIndex,
        value: value2,
        valueChange,
        width
      } = _ref;
      return createVNode(1, "div", LIGHT_PAGES_CLASS, [createComponentVNode(2, NumberBox, {
        rootElementRef: pageIndexRef,
        className: PAGER_PAGE_INDEX_CLASS,
        min: 1,
        max: pageCount,
        width,
        value: value2,
        valueChange
      }), createVNode(1, "span", PAGER_INFO_TEXT_CLASS, pagesCountText, 0), createComponentVNode(2, Page, {
        className: PAGER_PAGES_COUNT_CLASS,
        selected: false,
        index: pageCount - 1,
        onClick: selectLastPageIndex
      })], 4);
    };
    PagerSmallProps = {
      pageCount: PagerProps.pageCount,
      defaultPageIndex: PagerProps.pageIndex
    };
    PagesSmall = class extends InfernoComponent {
      constructor(props) {
        super(props);
        this._currentState = null;
        this.pageIndexRef = createRef();
        this.state = {
          minWidth: 10,
          pageIndex: void 0 !== this.props.pageIndex ? this.props.pageIndex : this.props.defaultPageIndex
        };
        this.updateWidth = this.updateWidth.bind(this);
        this.selectLastPageIndex = this.selectLastPageIndex.bind(this);
        this.valueChange = this.valueChange.bind(this);
      }
      createEffects() {
        return [new InfernoEffect(this.updateWidth, [this.minWidth])];
      }
      updateEffects() {
        var _this$_effects$;
        null === (_this$_effects$ = this._effects[0]) || void 0 === _this$_effects$ ? void 0 : _this$_effects$.update([this.minWidth]);
      }
      get minWidth() {
        var state = this._currentState || this.state;
        return state.minWidth;
      }
      set_minWidth(value2) {
        this.setState((state) => {
          this._currentState = state;
          var newValue = value2();
          this._currentState = null;
          return {
            minWidth: newValue
          };
        });
      }
      get __state_pageIndex() {
        var state = this._currentState || this.state;
        return void 0 !== this.props.pageIndex ? this.props.pageIndex : state.pageIndex;
      }
      set_pageIndex(value2) {
        this.setState((state) => {
          var _this$props$pageIndex, _this$props;
          this._currentState = state;
          var newValue = value2();
          null === (_this$props$pageIndex = (_this$props = this.props).pageIndexChange) || void 0 === _this$props$pageIndex ? void 0 : _this$props$pageIndex.call(_this$props, newValue);
          this._currentState = null;
          return {
            pageIndex: newValue
          };
        });
      }
      updateWidth() {
        this.set_minWidth(() => this.pageIndexRef.current && getElementMinWidth(this.pageIndexRef.current) || this.minWidth);
      }
      get value() {
        return this.__state_pageIndex + 1;
      }
      get width() {
        var pageCount = this.props.pageCount;
        return calculateValuesFittedWidth(this.minWidth, [pageCount]);
      }
      get pagesCountText() {
        return this.props.pagesCountText || message_default.getFormatter("dxPager-pagesCountText")();
      }
      selectLastPageIndex() {
        var _this$props$pageIndex2, _this$props2;
        var {
          pageCount
        } = this.props;
        null === (_this$props$pageIndex2 = (_this$props2 = this.props).pageIndexChange) || void 0 === _this$props$pageIndex2 ? void 0 : _this$props$pageIndex2.call(_this$props2, pageCount - 1);
      }
      valueChange(value2) {
        this.set_pageIndex(() => value2 - 1);
      }
      get restAttributes() {
        var _this$props$pageIndex3 = _extends({}, this.props, {
          pageIndex: this.__state_pageIndex
        }), restProps = _objectWithoutPropertiesLoose(_this$props$pageIndex3, _excluded12);
        return restProps;
      }
      render() {
        var props = this.props;
        return viewFunction10({
          props: _extends({}, props, {
            pageIndex: this.__state_pageIndex
          }),
          pageIndexRef: this.pageIndexRef,
          value: this.value,
          width: this.width,
          pagesCountText: this.pagesCountText,
          selectLastPageIndex: this.selectLastPageIndex,
          valueChange: this.valueChange,
          restAttributes: this.restAttributes
        });
      }
    };
    PagesSmall.defaultProps = _extends({}, PagerSmallProps);
  }
});

// node_modules/devextreme/esm/renovation/ui/pager/pages/page_index_selector.js
function getIncrement(direction) {
  return "next" === direction ? 1 : -1;
}
var _excluded13, PAGER_NAVIGATE_BUTTON, PAGER_PREV_BUTTON_CLASS, PAGER_NEXT_BUTTON_CLASS, PAGER_BUTTON_DISABLE_CLASS, nextButtonClassName, prevButtonClassName, nextButtonDisabledClassName, prevButtonDisabledClassName, viewFunction11, PageIndexSelectorProps, PageIndexSelectorPropsType, PageIndexSelector;
var init_page_index_selector = __esm({
  "node_modules/devextreme/esm/renovation/ui/pager/pages/page_index_selector.js"() {
    init_extends();
    init_objectWithoutPropertiesLoose();
    init_index_esm2();
    init_index_esm2();
    init_esm();
    init_light_button();
    init_large();
    init_small();
    init_pager_props();
    init_config_context();
    _excluded13 = ["defaultPageIndex", "hasKnownLastPage", "isLargeDisplayMode", "maxPagesCount", "pageCount", "pageIndex", "pageIndexChange", "pagesCountText", "showNavigationButtons", "totalCount"];
    PAGER_NAVIGATE_BUTTON = "dx-navigate-button";
    PAGER_PREV_BUTTON_CLASS = "dx-prev-button";
    PAGER_NEXT_BUTTON_CLASS = "dx-next-button";
    PAGER_BUTTON_DISABLE_CLASS = "dx-button-disable";
    nextButtonClassName = "".concat(PAGER_NAVIGATE_BUTTON, " ").concat(PAGER_NEXT_BUTTON_CLASS);
    prevButtonClassName = "".concat(PAGER_NAVIGATE_BUTTON, " ").concat(PAGER_PREV_BUTTON_CLASS);
    nextButtonDisabledClassName = "".concat(PAGER_BUTTON_DISABLE_CLASS, " ").concat(PAGER_NAVIGATE_BUTTON, " ").concat(PAGER_NEXT_BUTTON_CLASS);
    prevButtonDisabledClassName = "".concat(PAGER_BUTTON_DISABLE_CLASS, " ").concat(PAGER_NAVIGATE_BUTTON, " ").concat(PAGER_PREV_BUTTON_CLASS);
    viewFunction11 = (_ref) => {
      var {
        navigateToNextPage,
        navigateToPrevPage,
        nextClassName,
        pageIndexChange,
        prevClassName,
        props: {
          isLargeDisplayMode,
          maxPagesCount,
          pageCount,
          pageIndex,
          pagesCountText
        },
        renderNextButton,
        renderPrevButton
      } = _ref;
      return createFragment([renderPrevButton && createComponentVNode(2, LightButton, {
        className: prevClassName,
        label: "Previous page",
        onClick: navigateToPrevPage
      }), isLargeDisplayMode && createComponentVNode(2, PagesLarge, {
        maxPagesCount,
        pageCount,
        pageIndex,
        pageIndexChange
      }), !isLargeDisplayMode && createComponentVNode(2, PagesSmall, {
        pageCount,
        pageIndex,
        pageIndexChange,
        pagesCountText
      }), renderNextButton && createComponentVNode(2, LightButton, {
        className: nextClassName,
        label: "Next page",
        onClick: navigateToNextPage
      })], 0);
    };
    PageIndexSelectorProps = {
      isLargeDisplayMode: true
    };
    PageIndexSelectorPropsType = {
      maxPagesCount: PagerProps.maxPagesCount,
      pageCount: PagerProps.pageCount,
      hasKnownLastPage: PagerProps.hasKnownLastPage,
      showNavigationButtons: PagerProps.showNavigationButtons,
      totalCount: PagerProps.totalCount,
      isLargeDisplayMode: PageIndexSelectorProps.isLargeDisplayMode,
      defaultPageIndex: PagerProps.pageIndex
    };
    PageIndexSelector = class extends BaseInfernoComponent {
      constructor(props) {
        super(props);
        this._currentState = null;
        this.state = {
          pageIndex: void 0 !== this.props.pageIndex ? this.props.pageIndex : this.props.defaultPageIndex
        };
        this.getNextDirection = this.getNextDirection.bind(this);
        this.getPrevDirection = this.getPrevDirection.bind(this);
        this.canNavigateToPage = this.canNavigateToPage.bind(this);
        this.getNextPageIndex = this.getNextPageIndex.bind(this);
        this.canNavigateTo = this.canNavigateTo.bind(this);
        this.navigateToPage = this.navigateToPage.bind(this);
        this.pageIndexChange = this.pageIndexChange.bind(this);
        this.navigateToNextPage = this.navigateToNextPage.bind(this);
        this.navigateToPrevPage = this.navigateToPrevPage.bind(this);
      }
      get config() {
        if ("ConfigContext" in this.context) {
          return this.context.ConfigContext;
        }
        return ConfigContext;
      }
      get __state_pageIndex() {
        var state = this._currentState || this.state;
        return void 0 !== this.props.pageIndex ? this.props.pageIndex : state.pageIndex;
      }
      set_pageIndex(value2) {
        this.setState((state) => {
          var _this$props$pageIndex, _this$props;
          this._currentState = state;
          var newValue = value2();
          null === (_this$props$pageIndex = (_this$props = this.props).pageIndexChange) || void 0 === _this$props$pageIndex ? void 0 : _this$props$pageIndex.call(_this$props, newValue);
          this._currentState = null;
          return {
            pageIndex: newValue
          };
        });
      }
      getNextDirection() {
        var _this$config;
        return !(null !== (_this$config = this.config) && void 0 !== _this$config && _this$config.rtlEnabled) ? "next" : "prev";
      }
      getPrevDirection() {
        var _this$config2;
        return !(null !== (_this$config2 = this.config) && void 0 !== _this$config2 && _this$config2.rtlEnabled) ? "prev" : "next";
      }
      canNavigateToPage(pageIndex) {
        if (!this.props.hasKnownLastPage) {
          return pageIndex >= 0;
        }
        return pageIndex >= 0 && pageIndex <= this.props.pageCount - 1;
      }
      getNextPageIndex(direction) {
        return this.__state_pageIndex + getIncrement(direction);
      }
      canNavigateTo(direction) {
        return this.canNavigateToPage(this.getNextPageIndex(direction));
      }
      navigateToPage(direction) {
        this.pageIndexChange(this.getNextPageIndex(direction));
      }
      get renderPrevButton() {
        var {
          isLargeDisplayMode,
          showNavigationButtons
        } = this.props;
        return !isLargeDisplayMode || showNavigationButtons;
      }
      get renderNextButton() {
        return this.renderPrevButton || !this.props.hasKnownLastPage;
      }
      get nextClassName() {
        var direction = this.getNextDirection();
        var canNavigate = this.canNavigateTo(direction);
        return canNavigate ? nextButtonClassName : nextButtonDisabledClassName;
      }
      get prevClassName() {
        var direction = this.getPrevDirection();
        var canNavigate = this.canNavigateTo(direction);
        return canNavigate ? prevButtonClassName : prevButtonDisabledClassName;
      }
      pageIndexChange(pageIndex) {
        if (this.canNavigateToPage(pageIndex)) {
          this.set_pageIndex(() => pageIndex);
        }
      }
      navigateToNextPage() {
        this.navigateToPage(this.getNextDirection());
      }
      navigateToPrevPage() {
        this.navigateToPage(this.getPrevDirection());
      }
      get restAttributes() {
        var _this$props$pageIndex2 = _extends({}, this.props, {
          pageIndex: this.__state_pageIndex
        }), restProps = _objectWithoutPropertiesLoose(_this$props$pageIndex2, _excluded13);
        return restProps;
      }
      render() {
        var props = this.props;
        return viewFunction11({
          props: _extends({}, props, {
            pageIndex: this.__state_pageIndex
          }),
          config: this.config,
          renderPrevButton: this.renderPrevButton,
          renderNextButton: this.renderNextButton,
          nextClassName: this.nextClassName,
          prevClassName: this.prevClassName,
          pageIndexChange: this.pageIndexChange,
          navigateToNextPage: this.navigateToNextPage,
          navigateToPrevPage: this.navigateToPrevPage,
          restAttributes: this.restAttributes
        });
      }
    };
    PageIndexSelector.defaultProps = _extends({}, PageIndexSelectorPropsType);
  }
});

// node_modules/devextreme/esm/renovation/ui/select_box.js
var _excluded14, _excluded25, viewFunction12, SelectBoxProps, SelectBox2;
var init_select_box2 = __esm({
  "node_modules/devextreme/esm/renovation/ui/select_box.js"() {
    init_extends();
    init_objectWithoutPropertiesLoose();
    init_index_esm2();
    init_esm();
    init_widget();
    init_select_box();
    init_dom_component_wrapper();
    _excluded14 = ["rootElementRef"];
    _excluded25 = ["_feedbackHideTimeout", "_feedbackShowTimeout", "accessKey", "activeStateEnabled", "activeStateUnit", "aria", "children", "className", "classes", "dataSource", "defaultValue", "disabled", "displayExpr", "focusStateEnabled", "height", "hint", "hoverStateEnabled", "name", "onActive", "onClick", "onContentReady", "onDimensionChanged", "onFocusIn", "onFocusOut", "onHoverEnd", "onHoverStart", "onInactive", "onKeyDown", "onKeyboardHandled", "onVisibilityChange", "rootElementRef", "rtlEnabled", "tabIndex", "value", "valueChange", "valueExpr", "visible", "width"];
    viewFunction12 = (_ref) => {
      var {
        props: {
          rootElementRef
        },
        restAttributes
      } = _ref, componentProps = _objectWithoutPropertiesLoose(_ref.props, _excluded14);
      return normalizeProps(createComponentVNode(2, DomComponentWrapper, _extends({
        rootElementRef,
        componentType: select_box_default,
        componentProps
      }, restAttributes)));
    };
    SelectBoxProps = _extends({}, WidgetProps, {
      focusStateEnabled: true,
      hoverStateEnabled: true,
      defaultValue: null
    });
    SelectBox2 = class extends BaseInfernoComponent {
      constructor(props) {
        super(props);
        this._currentState = null;
        this.state = {
          value: void 0 !== this.props.value ? this.props.value : this.props.defaultValue
        };
      }
      get __state_value() {
        var state = this._currentState || this.state;
        return void 0 !== this.props.value ? this.props.value : state.value;
      }
      set_value(value2) {
        this.setState((state) => {
          var _this$props$valueChan, _this$props;
          this._currentState = state;
          var newValue = value2();
          null === (_this$props$valueChan = (_this$props = this.props).valueChange) || void 0 === _this$props$valueChan ? void 0 : _this$props$valueChan.call(_this$props, newValue);
          this._currentState = null;
          return {
            value: newValue
          };
        });
      }
      get restAttributes() {
        var _this$props$value = _extends({}, this.props, {
          value: this.__state_value
        }), restProps = _objectWithoutPropertiesLoose(_this$props$value, _excluded25);
        return restProps;
      }
      render() {
        var props = this.props;
        return viewFunction12({
          props: _extends({}, props, {
            value: this.__state_value
          }),
          restAttributes: this.restAttributes
        });
      }
    };
    SelectBox2.defaultProps = _extends({}, SelectBoxProps);
  }
});

// node_modules/devextreme/esm/renovation/ui/pager/page_size/small.js
var _excluded15, viewFunction13, PageSizeSmallPropsType, PageSizeSmall;
var init_small2 = __esm({
  "node_modules/devextreme/esm/renovation/ui/pager/page_size/small.js"() {
    init_extends();
    init_objectWithoutPropertiesLoose();
    init_index_esm2();
    init_esm();
    init_select_box2();
    init_calculate_values_fitted_width();
    init_get_element_width();
    init_pager_props();
    _excluded15 = ["defaultPageSize", "pageSize", "pageSizeChange", "pageSizes", "parentRef"];
    viewFunction13 = (_ref) => {
      var {
        props: {
          pageSize,
          pageSizeChange,
          pageSizes
        },
        width
      } = _ref;
      return createComponentVNode(2, SelectBox2, {
        displayExpr: "text",
        valueExpr: "value",
        dataSource: pageSizes,
        value: pageSize,
        valueChange: pageSizeChange,
        width
      });
    };
    PageSizeSmallPropsType = {
      defaultPageSize: PagerProps.pageSize
    };
    PageSizeSmall = class extends InfernoComponent {
      constructor(props) {
        super(props);
        this._currentState = null;
        this.state = {
          minWidth: 10,
          pageSize: void 0 !== this.props.pageSize ? this.props.pageSize : this.props.defaultPageSize
        };
        this.updateWidth = this.updateWidth.bind(this);
      }
      createEffects() {
        return [new InfernoEffect(this.updateWidth, [this.minWidth, this.__state_pageSize, this.props.pageSizeChange, this.props.pageSizes, this.props.defaultPageSize])];
      }
      updateEffects() {
        var _this$_effects$;
        null === (_this$_effects$ = this._effects[0]) || void 0 === _this$_effects$ ? void 0 : _this$_effects$.update([this.minWidth, this.__state_pageSize, this.props.pageSizeChange, this.props.pageSizes, this.props.defaultPageSize]);
      }
      get minWidth() {
        var state = this._currentState || this.state;
        return state.minWidth;
      }
      set_minWidth(value2) {
        this.setState((state) => {
          this._currentState = state;
          var newValue = value2();
          this._currentState = null;
          return {
            minWidth: newValue
          };
        });
      }
      get __state_pageSize() {
        var state = this._currentState || this.state;
        return void 0 !== this.props.pageSize ? this.props.pageSize : state.pageSize;
      }
      set_pageSize(value2) {
        this.setState((state) => {
          var _this$props$pageSizeC, _this$props;
          this._currentState = state;
          var newValue = value2();
          null === (_this$props$pageSizeC = (_this$props = this.props).pageSizeChange) || void 0 === _this$props$pageSizeC ? void 0 : _this$props$pageSizeC.call(_this$props, newValue);
          this._currentState = null;
          return {
            pageSize: newValue
          };
        });
      }
      updateWidth() {
        this.set_minWidth(() => getElementMinWidth(this.props.parentRef.current) || this.minWidth);
      }
      get width() {
        return calculateValuesFittedWidth(this.minWidth, this.props.pageSizes.map((p2) => p2.value));
      }
      get restAttributes() {
        var _this$props$pageSize = _extends({}, this.props, {
          pageSize: this.__state_pageSize
        }), restProps = _objectWithoutPropertiesLoose(_this$props$pageSize, _excluded15);
        return restProps;
      }
      render() {
        var props = this.props;
        return viewFunction13({
          props: _extends({}, props, {
            pageSize: this.__state_pageSize
          }),
          width: this.width,
          restAttributes: this.restAttributes
        });
      }
    };
    PageSizeSmall.defaultProps = _extends({}, PageSizeSmallPropsType);
  }
});

// node_modules/devextreme/esm/renovation/ui/pager/page_size/large.js
var _excluded16, viewFunction14, PageSizeLargePropsType, PageSizeLarge;
var init_large2 = __esm({
  "node_modules/devextreme/esm/renovation/ui/pager/page_size/large.js"() {
    init_extends();
    init_objectWithoutPropertiesLoose();
    init_index_esm2();
    init_index_esm2();
    init_esm();
    init_light_button();
    init_pager_props();
    init_consts2();
    _excluded16 = ["defaultPageSize", "pageSize", "pageSizeChange", "pageSizes"];
    viewFunction14 = (_ref) => {
      var {
        pageSizesText
      } = _ref;
      return createFragment(pageSizesText.map((_ref2) => {
        var {
          className,
          click: click2,
          label,
          text
        } = _ref2;
        return createComponentVNode(2, LightButton, {
          className,
          label,
          onClick: click2,
          children: text
        }, text);
      }), 0);
    };
    PageSizeLargePropsType = {
      defaultPageSize: PagerProps.pageSize
    };
    PageSizeLarge = class extends BaseInfernoComponent {
      constructor(props) {
        super(props);
        this._currentState = null;
        this.state = {
          pageSize: void 0 !== this.props.pageSize ? this.props.pageSize : this.props.defaultPageSize
        };
        this.onPageSizeChange = this.onPageSizeChange.bind(this);
      }
      get __state_pageSize() {
        var state = this._currentState || this.state;
        return void 0 !== this.props.pageSize ? this.props.pageSize : state.pageSize;
      }
      set_pageSize(value2) {
        this.setState((state) => {
          var _this$props$pageSizeC, _this$props;
          this._currentState = state;
          var newValue = value2();
          null === (_this$props$pageSizeC = (_this$props = this.props).pageSizeChange) || void 0 === _this$props$pageSizeC ? void 0 : _this$props$pageSizeC.call(_this$props, newValue);
          this._currentState = null;
          return {
            pageSize: newValue
          };
        });
      }
      get pageSizesText() {
        var {
          pageSizes
        } = this.props;
        return pageSizes.map((_ref3) => {
          var {
            text,
            value: processedPageSize
          } = _ref3;
          var selected = processedPageSize === this.__state_pageSize;
          var className = selected ? PAGER_SELECTED_PAGE_SIZE_CLASS : PAGER_PAGE_SIZE_CLASS;
          return {
            className,
            click: this.onPageSizeChange(processedPageSize),
            label: "Display ".concat(processedPageSize, " items on page"),
            text
          };
        });
      }
      onPageSizeChange(processedPageSize) {
        return () => {
          this.set_pageSize(() => processedPageSize);
        };
      }
      get restAttributes() {
        var _this$props$pageSize = _extends({}, this.props, {
          pageSize: this.__state_pageSize
        }), restProps = _objectWithoutPropertiesLoose(_this$props$pageSize, _excluded16);
        return restProps;
      }
      render() {
        var props = this.props;
        return viewFunction14({
          props: _extends({}, props, {
            pageSize: this.__state_pageSize
          }),
          pageSizesText: this.pageSizesText,
          restAttributes: this.restAttributes
        });
      }
    };
    PageSizeLarge.defaultProps = _extends({}, PageSizeLargePropsType);
  }
});

// node_modules/devextreme/esm/renovation/ui/pager/page_size/selector.js
function getAllText() {
  return message_default.getFormatter("dxPager-pageSizesAllText")();
}
var _excluded17, viewFunction15, PageSizeSelectorProps, PageSizeSelectorPropsType, PageSizeSelector;
var init_selector = __esm({
  "node_modules/devextreme/esm/renovation/ui/pager/page_size/selector.js"() {
    init_extends();
    init_objectWithoutPropertiesLoose();
    init_index_esm2();
    init_esm();
    init_small2();
    init_large2();
    init_pager_props();
    init_message();
    init_consts2();
    init_index_esm2();
    _excluded17 = ["defaultPageSize", "isLargeDisplayMode", "pageSize", "pageSizeChange", "pageSizes", "rootElementRef"];
    viewFunction15 = (_ref) => {
      var {
        htmlRef,
        normalizedPageSizes,
        props: {
          isLargeDisplayMode,
          pageSize,
          pageSizeChange
        }
      } = _ref;
      return createVNode(1, "div", PAGER_PAGE_SIZES_CLASS, [isLargeDisplayMode && createComponentVNode(2, PageSizeLarge, {
        pageSizes: normalizedPageSizes,
        pageSize,
        pageSizeChange
      }), !isLargeDisplayMode && createComponentVNode(2, PageSizeSmall, {
        parentRef: htmlRef,
        pageSizes: normalizedPageSizes,
        pageSize,
        pageSizeChange
      })], 0, null, null, htmlRef);
    };
    PageSizeSelectorProps = {
      isLargeDisplayMode: true
    };
    PageSizeSelectorPropsType = {
      pageSizes: PagerProps.pageSizes,
      isLargeDisplayMode: PageSizeSelectorProps.isLargeDisplayMode,
      defaultPageSize: PagerProps.pageSize
    };
    PageSizeSelector = class extends InfernoComponent {
      constructor(props) {
        super(props);
        this._currentState = null;
        this.htmlRef = createRef();
        this.state = {
          pageSize: void 0 !== this.props.pageSize ? this.props.pageSize : this.props.defaultPageSize
        };
        this.setRootElementRef = this.setRootElementRef.bind(this);
      }
      createEffects() {
        return [new InfernoEffect(this.setRootElementRef, [])];
      }
      updateEffects() {
      }
      get __state_pageSize() {
        var state = this._currentState || this.state;
        return void 0 !== this.props.pageSize ? this.props.pageSize : state.pageSize;
      }
      set_pageSize(value2) {
        this.setState((state) => {
          var _this$props$pageSizeC, _this$props;
          this._currentState = state;
          var newValue = value2();
          null === (_this$props$pageSizeC = (_this$props = this.props).pageSizeChange) || void 0 === _this$props$pageSizeC ? void 0 : _this$props$pageSizeC.call(_this$props, newValue);
          this._currentState = null;
          return {
            pageSize: newValue
          };
        });
      }
      setRootElementRef() {
        var {
          rootElementRef
        } = this.props;
        if (rootElementRef) {
          rootElementRef.current = this.htmlRef.current;
        }
      }
      get normalizedPageSizes() {
        var {
          pageSizes
        } = this.props;
        return pageSizes.map((p2) => "all" === p2 || 0 === p2 ? {
          text: getAllText(),
          value: 0
        } : {
          text: String(p2),
          value: p2
        });
      }
      get restAttributes() {
        var _this$props$pageSize = _extends({}, this.props, {
          pageSize: this.__state_pageSize
        }), restProps = _objectWithoutPropertiesLoose(_this$props$pageSize, _excluded17);
        return restProps;
      }
      render() {
        var props = this.props;
        return viewFunction15({
          props: _extends({}, props, {
            pageSize: this.__state_pageSize
          }),
          htmlRef: this.htmlRef,
          normalizedPageSizes: this.normalizedPageSizes,
          restAttributes: this.restAttributes
        });
      }
    };
    PageSizeSelector.defaultProps = _extends({}, PageSizeSelectorPropsType);
  }
});

// node_modules/devextreme/esm/renovation/ui/pager/content.js
var _excluded18, viewFunction16, PagerContentProps, PagerContent;
var init_content = __esm({
  "node_modules/devextreme/esm/renovation/ui/pager/content.js"() {
    init_objectWithoutPropertiesLoose();
    init_extends();
    init_index_esm2();
    init_esm();
    init_info();
    init_page_index_selector();
    init_selector();
    init_consts2();
    init_pager_props();
    init_combine_classes();
    init_widget();
    init_accessibility();
    init_index_esm2();
    _excluded18 = ["className", "defaultPageIndex", "defaultPageSize", "displayMode", "gridCompatibility", "hasKnownLastPage", "infoText", "infoTextRef", "infoTextVisible", "isLargeDisplayMode", "lightModeEnabled", "maxPagesCount", "onKeyDown", "pageCount", "pageIndex", "pageIndexChange", "pageSize", "pageSizeChange", "pageSizes", "pageSizesRef", "pagesCountText", "pagesNavigatorVisible", "pagesRef", "rootElementRef", "rtlEnabled", "showInfo", "showNavigationButtons", "showPageSizes", "totalCount", "visible"];
    viewFunction16 = (_ref) => {
      var {
        classes,
        infoVisible,
        isLargeDisplayMode,
        pageIndexSelectorVisible,
        pagesContainerVisibility,
        pagesContainerVisible,
        props: {
          hasKnownLastPage,
          infoText,
          infoTextRef,
          maxPagesCount,
          pageCount,
          pageIndex,
          pageIndexChange,
          pageSize,
          pageSizeChange,
          pageSizes,
          pageSizesRef,
          pagesCountText,
          pagesRef,
          rtlEnabled,
          showNavigationButtons,
          showPageSizes,
          totalCount,
          visible: visible2
        },
        restAttributes,
        widgetRootElementRef
      } = _ref;
      return normalizeProps(createComponentVNode(2, Widget2, _extends({
        rootElementRef: widgetRootElementRef,
        rtlEnabled,
        classes,
        visible: visible2
      }, restAttributes, {
        children: [showPageSizes && createComponentVNode(2, PageSizeSelector, {
          rootElementRef: pageSizesRef,
          isLargeDisplayMode,
          pageSize,
          pageSizeChange,
          pageSizes
        }), pagesContainerVisible && createVNode(1, "div", PAGER_PAGES_CLASS, [infoVisible && createComponentVNode(2, InfoText, {
          rootElementRef: infoTextRef,
          infoText,
          pageCount,
          pageIndex,
          totalCount
        }), pageIndexSelectorVisible && createVNode(1, "div", PAGER_PAGE_INDEXES_CLASS, createComponentVNode(2, PageIndexSelector, {
          hasKnownLastPage,
          isLargeDisplayMode,
          maxPagesCount,
          pageCount,
          pageIndex,
          pageIndexChange,
          pagesCountText,
          showNavigationButtons,
          totalCount
        }), 2, null, null, pagesRef)], 0, {
          style: normalizeStyles({
            visibility: pagesContainerVisibility
          })
        })]
      })));
    };
    PagerContentProps = _extends({}, PagerProps, {
      infoTextVisible: true,
      isLargeDisplayMode: true
    });
    PagerContent = class extends InfernoComponent {
      constructor(props) {
        super(props);
        this._currentState = null;
        this.widgetRootElementRef = createRef();
        this.state = {
          pageIndex: void 0 !== this.props.pageIndex ? this.props.pageIndex : this.props.defaultPageIndex,
          pageSize: void 0 !== this.props.pageSize ? this.props.pageSize : this.props.defaultPageSize
        };
        this.createFakeInstance = this.createFakeInstance.bind(this);
        this.setRootElementRef = this.setRootElementRef.bind(this);
      }
      createEffects() {
        return [new InfernoEffect(this.setRootElementRef, [])];
      }
      updateEffects() {
      }
      get __state_pageIndex() {
        var state = this._currentState || this.state;
        return void 0 !== this.props.pageIndex ? this.props.pageIndex : state.pageIndex;
      }
      set_pageIndex(value2) {
        this.setState((state) => {
          var _this$props$pageIndex, _this$props;
          this._currentState = state;
          var newValue = value2();
          null === (_this$props$pageIndex = (_this$props = this.props).pageIndexChange) || void 0 === _this$props$pageIndex ? void 0 : _this$props$pageIndex.call(_this$props, newValue);
          this._currentState = null;
          return {
            pageIndex: newValue
          };
        });
      }
      get __state_pageSize() {
        var state = this._currentState || this.state;
        return void 0 !== this.props.pageSize ? this.props.pageSize : state.pageSize;
      }
      set_pageSize(value2) {
        this.setState((state) => {
          var _this$props$pageSizeC, _this$props2;
          this._currentState = state;
          var newValue = value2();
          null === (_this$props$pageSizeC = (_this$props2 = this.props).pageSizeChange) || void 0 === _this$props$pageSizeC ? void 0 : _this$props$pageSizeC.call(_this$props2, newValue);
          this._currentState = null;
          return {
            pageSize: newValue
          };
        });
      }
      getChildContext() {
        return _extends({}, this.context, {
          KeyboardActionContext: this.keyboardAction
        });
      }
      setRootElementRef() {
        var {
          rootElementRef
        } = this.props;
        if (rootElementRef) {
          rootElementRef.current = this.widgetRootElementRef.current;
        }
      }
      createFakeInstance() {
        return {
          option: () => false,
          element: () => this.widgetRootElementRef.current,
          _createActionByOption: () => (e) => {
            var _this$props$onKeyDown, _this$props3;
            null === (_this$props$onKeyDown = (_this$props3 = this.props).onKeyDown) || void 0 === _this$props$onKeyDown ? void 0 : _this$props$onKeyDown.call(_this$props3, e);
          }
        };
      }
      get keyboardAction() {
        return {
          registerKeyboardAction: (element, action) => {
            var fakePagerInstance = this.createFakeInstance();
            return registerKeyboardAction("pager", fakePagerInstance, element, void 0, action);
          }
        };
      }
      get infoVisible() {
        var {
          infoTextVisible,
          showInfo
        } = this.props;
        return showInfo && infoTextVisible && this.isLargeDisplayMode;
      }
      get pageIndexSelectorVisible() {
        return 0 !== this.__state_pageSize;
      }
      get normalizedDisplayMode() {
        var {
          displayMode,
          lightModeEnabled
        } = this.props;
        if ("adaptive" === displayMode && void 0 !== lightModeEnabled) {
          return lightModeEnabled ? "compact" : "full";
        }
        return displayMode;
      }
      get pagesContainerVisible() {
        return !!this.props.pagesNavigatorVisible && this.props.pageCount > 0;
      }
      get pagesContainerVisibility() {
        if ("auto" === this.props.pagesNavigatorVisible && 1 === this.props.pageCount && this.props.hasKnownLastPage) {
          return "hidden";
        }
        return;
      }
      get isLargeDisplayMode() {
        var displayMode = this.normalizedDisplayMode;
        var result2 = false;
        if ("adaptive" === displayMode) {
          result2 = this.props.isLargeDisplayMode;
        } else {
          result2 = "full" === displayMode;
        }
        return result2;
      }
      get classes() {
        var classesMap = {
          ["".concat(this.props.className)]: !!this.props.className,
          [PAGER_CLASS]: true,
          [LIGHT_MODE_CLASS]: !this.isLargeDisplayMode
        };
        return combineClasses(classesMap);
      }
      get restAttributes() {
        var _this$props$pageIndex2 = _extends({}, this.props, {
          pageIndex: this.__state_pageIndex,
          pageSize: this.__state_pageSize
        }), restProps = _objectWithoutPropertiesLoose(_this$props$pageIndex2, _excluded18);
        return restProps;
      }
      render() {
        var props = this.props;
        return viewFunction16({
          props: _extends({}, props, {
            pageIndex: this.__state_pageIndex,
            pageSize: this.__state_pageSize
          }),
          widgetRootElementRef: this.widgetRootElementRef,
          keyboardAction: this.keyboardAction,
          infoVisible: this.infoVisible,
          pageIndexSelectorVisible: this.pageIndexSelectorVisible,
          pagesContainerVisible: this.pagesContainerVisible,
          pagesContainerVisibility: this.pagesContainerVisibility,
          isLargeDisplayMode: this.isLargeDisplayMode,
          classes: this.classes,
          restAttributes: this.restAttributes
        });
      }
    };
    PagerContent.defaultProps = _extends({}, PagerContentProps);
  }
});

// node_modules/devextreme/esm/renovation/ui/pager/pager.js
var _excluded19, viewFunction17, Pager;
var init_pager = __esm({
  "node_modules/devextreme/esm/renovation/ui/pager/pager.js"() {
    init_objectWithoutPropertiesLoose();
    init_extends();
    init_index_esm2();
    init_esm();
    init_resizable_container();
    init_pager_props();
    init_content();
    init_combine_classes();
    _excluded19 = ["className", "defaultPageIndex", "defaultPageSize", "displayMode", "gridCompatibility", "hasKnownLastPage", "infoText", "lightModeEnabled", "maxPagesCount", "onKeyDown", "pageCount", "pageIndex", "pageIndexChange", "pageSize", "pageSizeChange", "pageSizes", "pagesCountText", "pagesNavigatorVisible", "rtlEnabled", "showInfo", "showNavigationButtons", "showPageSizes", "totalCount", "visible"];
    viewFunction17 = (_ref) => {
      var {
        pagerProps,
        restAttributes
      } = _ref;
      return normalizeProps(createComponentVNode(2, ResizableContainer, _extends({
        contentTemplate: PagerContent,
        pagerProps
      }, restAttributes)));
    };
    Pager = class extends InfernoWrapperComponent {
      constructor(props) {
        super(props);
        this._currentState = null;
        this.state = {
          pageIndex: void 0 !== this.props.pageIndex ? this.props.pageIndex : this.props.defaultPageIndex,
          pageSize: void 0 !== this.props.pageSize ? this.props.pageSize : this.props.defaultPageSize
        };
        this.pageIndexChange = this.pageIndexChange.bind(this);
        this.pageSizeChange = this.pageSizeChange.bind(this);
      }
      get __state_pageIndex() {
        var state = this._currentState || this.state;
        return void 0 !== this.props.pageIndex ? this.props.pageIndex : state.pageIndex;
      }
      set_pageIndex(value2) {
        this.setState((state) => {
          var _this$props$pageIndex, _this$props;
          this._currentState = state;
          var newValue = value2();
          null === (_this$props$pageIndex = (_this$props = this.props).pageIndexChange) || void 0 === _this$props$pageIndex ? void 0 : _this$props$pageIndex.call(_this$props, newValue);
          this._currentState = null;
          return {
            pageIndex: newValue
          };
        });
      }
      get __state_pageSize() {
        var state = this._currentState || this.state;
        return void 0 !== this.props.pageSize ? this.props.pageSize : state.pageSize;
      }
      set_pageSize(value2) {
        this.setState((state) => {
          var _this$props$pageSizeC, _this$props2;
          this._currentState = state;
          var newValue = value2();
          null === (_this$props$pageSizeC = (_this$props2 = this.props).pageSizeChange) || void 0 === _this$props$pageSizeC ? void 0 : _this$props$pageSizeC.call(_this$props2, newValue);
          this._currentState = null;
          return {
            pageSize: newValue
          };
        });
      }
      pageIndexChange(newPageIndex) {
        if (this.props.gridCompatibility) {
          this.set_pageIndex(() => newPageIndex + 1);
        } else {
          this.set_pageIndex(() => newPageIndex);
        }
      }
      get pageIndex() {
        if (this.props.gridCompatibility) {
          return this.__state_pageIndex - 1;
        }
        return this.__state_pageIndex;
      }
      pageSizeChange(newPageSize) {
        this.set_pageSize(() => newPageSize);
      }
      get className() {
        if (this.props.gridCompatibility) {
          return combineClasses({
            "dx-datagrid-pager": true,
            ["".concat(this.props.className)]: !!this.props.className
          });
        }
        return this.props.className;
      }
      get pagerProps() {
        return _extends({}, _extends({}, this.props, {
          pageIndex: this.__state_pageIndex,
          pageSize: this.__state_pageSize
        }), {
          className: this.className,
          pageIndex: this.pageIndex,
          pageIndexChange: (pageIndex) => this.pageIndexChange(pageIndex),
          pageSizeChange: (pageSize) => this.pageSizeChange(pageSize)
        });
      }
      get restAttributes() {
        var _this$props$pageIndex2 = _extends({}, this.props, {
          pageIndex: this.__state_pageIndex,
          pageSize: this.__state_pageSize
        }), restProps = _objectWithoutPropertiesLoose(_this$props$pageIndex2, _excluded19);
        return restProps;
      }
      render() {
        var props = this.props;
        return viewFunction17({
          props: _extends({}, props, {
            pageIndex: this.__state_pageIndex,
            pageSize: this.__state_pageSize
          }),
          pageIndexChange: this.pageIndexChange,
          pageIndex: this.pageIndex,
          pageSizeChange: this.pageSizeChange,
          className: this.className,
          pagerProps: this.pagerProps,
          restAttributes: this.restAttributes
        });
      }
    };
    Pager.defaultProps = _extends({}, PagerProps);
  }
});

// node_modules/devextreme/esm/renovation/ui/pager/pager.j.js
var Pager2;
var init_pager_j = __esm({
  "node_modules/devextreme/esm/renovation/ui/pager/pager.j.js"() {
    init_component_registrator();
    init_grid_pager();
    init_pager();
    Pager2 = class extends GridPagerWrapper {
      getProps() {
        var props = super.getProps();
        props.onKeyDown = this._wrapKeyDownHandler(props.onKeyDown);
        return props;
      }
      get _propsInfo() {
        return {
          twoWay: [
            ["pageIndex", 1, "pageIndexChange"],
            ["pageSize", 5, "pageSizeChange"]
          ],
          allowNull: [],
          elements: [],
          templates: [],
          props: ["gridCompatibility", "className", "showInfo", "infoText", "lightModeEnabled", "displayMode", "maxPagesCount", "pageCount", "pagesCountText", "visible", "hasKnownLastPage", "pagesNavigatorVisible", "pageIndexChange", "pageSizeChange", "showPageSizes", "pageSizes", "rtlEnabled", "showNavigationButtons", "totalCount", "onKeyDown", "defaultPageIndex", "defaultPageSize", "pageIndex", "pageSize"]
        };
      }
      get _viewComponent() {
        return Pager;
      }
    };
    component_registrator_default("dxPager", Pager2);
  }
});

// node_modules/devextreme/esm/ui/pager.js
var pager_default;
var init_pager2 = __esm({
  "node_modules/devextreme/esm/ui/pager.js"() {
    init_pager_j();
    pager_default = Pager2;
  }
});

// node_modules/devextreme/esm/ui/grid_core/ui.grid_core.pager.js
var PAGER_CLASS2, MAX_PAGES_COUNT, getPageIndex, PagerView, pagerModule;
var init_ui_grid_core_pager = __esm({
  "node_modules/devextreme/esm/ui/grid_core/ui.grid_core.pager.js"() {
    init_ui_grid_core_modules();
    init_pager2();
    init_array();
    init_type();
    init_window();
    PAGER_CLASS2 = "pager";
    MAX_PAGES_COUNT = 10;
    getPageIndex = function(dataController) {
      return 1 + (parseInt(dataController.pageIndex()) || 0);
    };
    PagerView = ui_grid_core_modules_default.View.inherit({
      init: function() {
        var dataController = this.getController("data");
        dataController.changed.add((e) => {
          if (e && e.repaintChangesOnly) {
            var pager = this._pager;
            if (pager) {
              pager.option({
                pageIndex: getPageIndex(dataController),
                pageSize: dataController.pageSize(),
                pageCount: dataController.pageCount(),
                totalCount: dataController.totalCount(),
                hasKnownLastPage: dataController.hasKnownLastPage()
              });
            } else {
              this.render();
            }
          } else if (!e || "update" !== e.changeType && "updateSelection" !== e.changeType) {
            this._pager = null;
            this.render();
          }
        });
      },
      _renderCore: function() {
        var $element = this.element().addClass(this.addWidgetPrefix(PAGER_CLASS2));
        var pagerOptions = this.option("pager") || {};
        var dataController = this.getController("data");
        var keyboardController = this.getController("keyboardNavigation");
        var options2 = {
          maxPagesCount: MAX_PAGES_COUNT,
          pageIndex: getPageIndex(dataController),
          pageCount: dataController.pageCount(),
          pageSize: dataController.pageSize(),
          showPageSizes: pagerOptions.showPageSizeSelector,
          showInfo: pagerOptions.showInfo,
          displayMode: pagerOptions.displayMode,
          pagesNavigatorVisible: pagerOptions.visible,
          showNavigationButtons: pagerOptions.showNavigationButtons,
          pageSizes: this.getPageSizes(),
          totalCount: dataController.totalCount(),
          hasKnownLastPage: dataController.hasKnownLastPage(),
          pageIndexChanged: function(pageIndex) {
            if (dataController.pageIndex() !== pageIndex - 1) {
              dataController.pageIndex(pageIndex - 1);
            }
          },
          pageSizeChanged: function(pageSize) {
            dataController.pageSize(pageSize);
          },
          onKeyDown: (e) => keyboardController && keyboardController.executeAction("onKeyDown", e),
          useLegacyKeyboardNavigation: this.option("useLegacyKeyboardNavigation"),
          useKeyboard: this.option("keyboardNavigation.enabled")
        };
        if (isDefined(pagerOptions.infoText)) {
          options2.infoText = pagerOptions.infoText;
        }
        if (this._pager) {
          this._pager.repaint();
          return;
        }
        if (hasWindow()) {
          this._pager = this._createComponent($element, pager_default, options2);
        } else {
          $element.addClass("dx-pager").html('<div class="dx-pages"><div class="dx-page"></div></div>');
        }
      },
      getPager: function() {
        return this._pager;
      },
      getPageSizes: function() {
        var dataController = this.getController("data");
        var pagerOptions = this.option("pager");
        var allowedPageSizes = pagerOptions && pagerOptions.allowedPageSizes;
        var pageSize = dataController.pageSize();
        if (!isDefined(this._pageSizes) || -1 === inArray(pageSize, this._pageSizes)) {
          this._pageSizes = [];
          if (pagerOptions) {
            if (Array.isArray(allowedPageSizes)) {
              this._pageSizes = allowedPageSizes;
            } else if (allowedPageSizes && pageSize > 1) {
              this._pageSizes = [Math.floor(pageSize / 2), pageSize, 2 * pageSize];
            }
          }
        }
        return this._pageSizes;
      },
      isVisible: function() {
        var dataController = this.getController("data");
        var pagerOptions = this.option("pager");
        var pagerVisible = pagerOptions && pagerOptions.visible;
        var scrolling = this.option("scrolling");
        if ("auto" === pagerVisible) {
          if (scrolling && ("virtual" === scrolling.mode || "infinite" === scrolling.mode)) {
            pagerVisible = false;
          } else {
            pagerVisible = dataController.pageCount() > 1 || dataController.isLoaded() && !dataController.hasKnownLastPage();
          }
        }
        return pagerVisible;
      },
      getHeight: function() {
        return this.getElementHeight();
      },
      optionChanged: function(args) {
        var name2 = args.name;
        var isPager = "pager" === name2;
        var isPaging = "paging" === name2;
        var isDataSource = "dataSource" === name2;
        var isScrolling = "scrolling" === name2;
        var dataController = this.getController("data");
        if (isPager || isPaging || isScrolling || isDataSource) {
          args.handled = true;
          if (dataController.skipProcessingPagingChange(args.fullName)) {
            return;
          }
          if (isPager || isPaging) {
            this._pageSizes = null;
          }
          if (!isDataSource) {
            this._pager = null;
            this._invalidate();
            if (hasWindow() && isPager && this.component) {
              this.component.resize();
            }
          }
        }
      },
      dispose: function() {
        this._pager = null;
      }
    });
    pagerModule = {
      defaultOptions: function() {
        return {
          pager: {
            visible: "auto",
            showPageSizeSelector: false,
            allowedPageSizes: "auto"
          }
        };
      },
      views: {
        pagerView: PagerView
      }
    };
  }
});

// node_modules/devextreme/esm/ui/grid_core/ui.grid_core.columns_resizing_reordering.js
var COLUMNS_SEPARATOR_CLASS, COLUMNS_SEPARATOR_TRANSPARENT, DRAGGING_HEADER_CLASS, CELL_CONTENT_CLASS, HEADERS_DRAG_ACTION_CLASS, TRACKER_CLASS, HEADERS_DROP_HIGHLIGHT_CLASS, BLOCK_SEPARATOR_CLASS, HEADER_ROW_CLASS, WIDGET_CLASS5, DRAGGING_COMMAND_CELL_CLASS, MODULE_NAMESPACE, COLUMNS_SEPARATOR_TOUCH_TRACKER_WIDTH, DRAGGING_DELTA, COLUMN_OPACITY, allowResizing, allowReordering, TrackerView, SeparatorView, ColumnsSeparatorView, BlockSeparatorView, DraggingHeaderView, isNextColumnResizingMode, ColumnsResizerViewController, TablePositionViewController, DraggingHeaderViewController, columnsResizingReorderingModule;
var init_ui_grid_core_columns_resizing_reordering = __esm({
  "node_modules/devextreme/esm/ui/grid_core/ui.grid_core.columns_resizing_reordering.js"() {
    init_renderer();
    init_dom_adapter();
    init_events_engine();
    init_callbacks();
    init_type();
    init_iterator();
    init_extend();
    init_position();
    init_utils2();
    init_pointer();
    init_drag();
    init_ui_grid_core_modules();
    init_ui_grid_core_utils();
    init_fx();
    init_swatch_container();
    COLUMNS_SEPARATOR_CLASS = "columns-separator";
    COLUMNS_SEPARATOR_TRANSPARENT = "columns-separator-transparent";
    DRAGGING_HEADER_CLASS = "drag-header";
    CELL_CONTENT_CLASS = "text-content";
    HEADERS_DRAG_ACTION_CLASS = "drag-action";
    TRACKER_CLASS = "tracker";
    HEADERS_DROP_HIGHLIGHT_CLASS = "drop-highlight";
    BLOCK_SEPARATOR_CLASS = "dx-block-separator";
    HEADER_ROW_CLASS = "dx-header-row";
    WIDGET_CLASS5 = "dx-widget";
    DRAGGING_COMMAND_CELL_CLASS = "dx-drag-command-cell";
    MODULE_NAMESPACE = "dxDataGridResizingReordering";
    COLUMNS_SEPARATOR_TOUCH_TRACKER_WIDTH = 10;
    DRAGGING_DELTA = 5;
    COLUMN_OPACITY = 0.5;
    allowResizing = function(that) {
      return that.option("allowColumnResizing") || that.getController("columns").isColumnOptionUsed("allowResizing");
    };
    allowReordering = function(that) {
      return that.option("allowColumnReordering") || that.getController("columns").isColumnOptionUsed("allowReordering");
    };
    TrackerView = ui_grid_core_modules_default.View.inherit({
      _renderCore: function() {
        this.callBase();
        this.element().addClass(this.addWidgetPrefix(TRACKER_CLASS));
        this.hide();
      },
      _unsubscribeFromCallback: function() {
        if (this._positionChanged) {
          this._tablePositionController.positionChanged.remove(this._positionChanged);
        }
      },
      _subscribeToCallback: function() {
        var that = this;
        that._positionChanged = function(position3) {
          var $element = that.element();
          if ($element && $element.hasClass(that.addWidgetPrefix(TRACKER_CLASS))) {
            $element.css({
              top: position3.top
            });
            $element.height(position3.height);
          }
        };
        this._tablePositionController.positionChanged.add(that._positionChanged);
      },
      optionChanged: function(args) {
        if ("allowColumnResizing" === args.name) {
          this._unsubscribeFromCallback();
          if (args.value) {
            this._subscribeToCallback();
            this._invalidate();
          }
        }
        this.callBase(args);
      },
      init: function() {
        this.callBase();
        this._tablePositionController = this.getController("tablePosition");
        this._subscribeToCallback();
      },
      isVisible: function() {
        return allowResizing(this);
      },
      show: function() {
        this.element().show();
      },
      hide: function() {
        this.element() && this.element().hide();
      },
      setHeight: function(value2) {
        this.element().height(value2);
      },
      dispose: function() {
        this._unsubscribeFromCallback();
        this.callBase();
      }
    });
    SeparatorView = ui_grid_core_modules_default.View.inherit({
      _renderSeparator: function() {
      },
      _renderCore: function(options2) {
        this.callBase(options2);
        this._isShown = true;
        this._renderSeparator();
        this.hide();
      },
      show: function() {
        this._isShown = true;
      },
      hide: function() {
        this._isShown = false;
      },
      height: function(value2) {
        var $element = this.element();
        if ($element) {
          if (isDefined(value2)) {
            $element.height(value2);
          } else {
            return $element.height();
          }
        }
      },
      width: function(value2) {
        var $element = this.element();
        if ($element) {
          if (isDefined(value2)) {
            $element.width(value2);
          } else {
            return $element.width();
          }
        }
      }
    });
    ColumnsSeparatorView = SeparatorView.inherit({
      _renderSeparator: function() {
        this.callBase();
        var $element = this.element();
        $element.addClass(this.addWidgetPrefix(COLUMNS_SEPARATOR_CLASS));
      },
      _subscribeToCallback: function() {
        var that = this;
        var $element;
        that._positionChanged = function(position3) {
          $element = that.element();
          if ($element) {
            $element.css({
              top: position3.top
            });
            $element.height(position3.height);
          }
        };
        that._tablePositionController.positionChanged.add(that._positionChanged);
      },
      _unsubscribeFromCallback: function() {
        this._positionChanged && this._tablePositionController.positionChanged.remove(this._positionChanged);
      },
      _init: function() {
        this._isTransparent = allowResizing(this);
        if (this.isVisible()) {
          this._subscribeToCallback();
        }
      },
      isVisible: function() {
        return this.option("showColumnHeaders") && (allowReordering(this) || allowResizing(this));
      },
      optionChanged: function(args) {
        if ("allowColumnResizing" === args.name) {
          if (args.value) {
            this._init();
            this._invalidate();
            this.hide(true);
          } else {
            this._unsubscribeFromCallback();
            this._isTransparent = allowResizing(this);
            this.hide(true);
          }
        }
        this.callBase(args);
      },
      init: function() {
        this.callBase();
        this._tablePositionController = this.getController("tablePosition");
        this._init();
      },
      show: function() {
        var $element = this.element();
        if ($element && !this._isShown) {
          if (this._isTransparent) {
            $element.removeClass(this.addWidgetPrefix(COLUMNS_SEPARATOR_TRANSPARENT));
          } else {
            $element.show();
          }
        }
        this.callBase();
      },
      hide: function(force) {
        var $element = this.element();
        var columnsSeparatorTransparent = this.addWidgetPrefix(COLUMNS_SEPARATOR_TRANSPARENT);
        if ($element && (this._isShown || force)) {
          if (this._isTransparent) {
            $element.addClass(columnsSeparatorTransparent);
            $element.css("left", "");
            $element.show();
          } else {
            if ($element.hasClass(columnsSeparatorTransparent)) {
              $element.removeClass(columnsSeparatorTransparent);
            }
            $element.hide();
          }
        }
        this.callBase();
      },
      moveByX: function(outerX) {
        var $element = this.element();
        if ($element) {
          $element.css("left", null === outerX ? 0 : outerX - this._parentElement().offset().left);
        }
      },
      changeCursor: function(cursorName) {
        cursorName = isDefined(cursorName) ? cursorName : "";
        var $element = this.element();
        if ($element) {
          $element.css("cursor", cursorName);
        }
      },
      dispose: function() {
        this._unsubscribeFromCallback();
        this.callBase();
      }
    });
    BlockSeparatorView = SeparatorView.inherit({
      init: function() {
        var that = this;
        this.callBase();
        this.getController("data").loadingChanged.add(function(isLoading) {
          if (!isLoading) {
            that.hide();
          }
        });
      },
      _renderSeparator: function() {
        this.callBase();
        this.element().addClass(BLOCK_SEPARATOR_CLASS).html("&nbsp;");
      },
      hide: function() {
        var $parent = this._parentElement();
        var $element = this.element();
        if ($element && this._isShown) {
          $element.css("display", "none");
        }
        if ($parent && !$parent.children("." + BLOCK_SEPARATOR_CLASS).length) {
          $parent.prepend(this.element());
        }
        this.callBase();
      },
      isVisible: function() {
        var groupPanelOptions = this.option("groupPanel");
        var columnChooserOptions = this.option("columnChooser");
        return groupPanelOptions && groupPanelOptions.visible || columnChooserOptions && columnChooserOptions.enabled;
      },
      show: function(targetLocation) {
        var $element = this.element();
        var startAnimate = function(toOptions) {
          fx_default.stop($element, true);
          fx_default.animate($element, {
            type: "slide",
            from: {
              width: 0,
              display: toOptions.display
            },
            to: toOptions,
            duration: 300,
            easing: "swing"
          });
        };
        if ($element && !this._isShown) {
          switch (targetLocation) {
            case "group":
              startAnimate({
                width: "50px",
                display: "inline-block"
              });
              break;
            case "columnChooser":
              startAnimate({
                width: "100%",
                display: "block"
              });
              break;
            default:
              $element.css("display", "");
          }
        }
        this.callBase();
      }
    });
    DraggingHeaderView = ui_grid_core_modules_default.View.inherit({
      _isDragging: false,
      isDragging: function() {
        return this._isDragging;
      },
      _getDraggingPanelByPos: function(pos) {
        var result2;
        each(this._dragOptions.draggingPanels, function(index2, draggingPanel) {
          if (draggingPanel) {
            var boundingRect = draggingPanel.getBoundingRect();
            if (boundingRect && (void 0 === boundingRect.bottom || pos.y < boundingRect.bottom) && (void 0 === boundingRect.top || pos.y > boundingRect.top) && (void 0 === boundingRect.left || pos.x > boundingRect.left) && (void 0 === boundingRect.right || pos.x < boundingRect.right)) {
              result2 = draggingPanel;
              return false;
            }
          }
        });
        return result2;
      },
      _renderCore: function() {
        this.element().addClass(this.addWidgetPrefix(DRAGGING_HEADER_CLASS) + " " + this.addWidgetPrefix(CELL_CONTENT_CLASS) + " " + WIDGET_CLASS5).hide();
      },
      _resetTargetColumnOptions: function() {
        var params = this._dropOptions;
        params.targetColumnIndex = -1;
        delete params.targetColumnElement;
        delete params.isLast;
        delete params.posX;
        delete params.posY;
      },
      _getVisibleIndexObject: function(rowIndex, visibleIndex) {
        if (isDefined(rowIndex)) {
          return {
            columnIndex: visibleIndex,
            rowIndex
          };
        }
        return visibleIndex;
      },
      dispose: function() {
        var element = this.element();
        this._dragOptions = null;
        element && element.parent().find("." + this.addWidgetPrefix(DRAGGING_HEADER_CLASS)).remove();
      },
      isVisible: function() {
        var columnsController = this.getController("columns");
        var commonColumnSettings = columnsController.getCommonSettings();
        return this.option("showColumnHeaders") && (allowReordering(this) || commonColumnSettings.allowGrouping || commonColumnSettings.allowHiding);
      },
      init: function() {
        var that = this;
        this.callBase();
        this._controller = this.getController("draggingHeader");
        this._columnsResizerViewController = this.getController("columnsResizer");
        this.getController("data").loadingChanged.add(function(isLoading) {
          var element = that.element();
          if (!isLoading && element) {
            element.hide();
          }
        });
      },
      dragHeader: function(options2) {
        var columnElement = options2.columnElement;
        var isCommandColumn = !!options2.sourceColumn.type;
        this._isDragging = true;
        this._dragOptions = options2;
        this._dropOptions = {
          sourceIndex: options2.index,
          sourceColumnIndex: this._getVisibleIndexObject(options2.rowIndex, options2.columnIndex),
          sourceColumnElement: options2.columnElement,
          sourceLocation: options2.sourceLocation
        };
        var document2 = dom_adapter_default.getDocument();
        this._onSelectStart = document2.onselectstart;
        document2.onselectstart = function() {
          return false;
        };
        this._controller.drag(this._dropOptions);
        this.element().css({
          textAlign: columnElement && columnElement.css("textAlign"),
          height: columnElement && (isCommandColumn && columnElement.get(0).clientHeight || columnElement.height()),
          width: columnElement && (isCommandColumn && columnElement.get(0).clientWidth || columnElement.width()),
          whiteSpace: columnElement && columnElement.css("whiteSpace")
        }).addClass(this.addWidgetPrefix(HEADERS_DRAG_ACTION_CLASS)).toggleClass(DRAGGING_COMMAND_CELL_CLASS, isCommandColumn).text(isCommandColumn ? "" : options2.sourceColumn.caption);
        this.element().appendTo(swatch_container_default.getSwatchContainer(columnElement));
      },
      moveHeader: function(args) {
        var e = args.event;
        var that = e.data.that;
        var eventData2 = eventData(e);
        var isResizing = that._columnsResizerViewController ? that._columnsResizerViewController.isResizing() : false;
        var dragOptions = that._dragOptions;
        if (that._isDragging && !isResizing) {
          var $element = that.element();
          var moveDeltaX = Math.abs(eventData2.x - dragOptions.columnElement.offset().left - dragOptions.deltaX);
          var moveDeltaY = Math.abs(eventData2.y - dragOptions.columnElement.offset().top - dragOptions.deltaY);
          if ($element.is(":visible") || moveDeltaX > DRAGGING_DELTA || moveDeltaY > DRAGGING_DELTA) {
            $element.show();
            var newLeft = eventData2.x - dragOptions.deltaX;
            var newTop = eventData2.y - dragOptions.deltaY;
            $element.css({
              left: newLeft,
              top: newTop
            });
            that.dockHeader(eventData2);
          }
          e.preventDefault();
        }
      },
      dockHeader: function(eventData2) {
        var targetDraggingPanel = this._getDraggingPanelByPos(eventData2);
        var controller = this._controller;
        var params = this._dropOptions;
        var dragOptions = this._dragOptions;
        if (targetDraggingPanel) {
          var rtlEnabled = this.option("rtlEnabled");
          var isVerticalOrientation = "columnChooser" === targetDraggingPanel.getName();
          var axisName = isVerticalOrientation ? "y" : "x";
          var targetLocation = targetDraggingPanel.getName();
          var rowIndex = "headers" === targetLocation ? dragOptions.rowIndex : void 0;
          var sourceColumn = dragOptions.sourceColumn;
          var columnElements = targetDraggingPanel.getColumnElements(rowIndex, null === sourceColumn || void 0 === sourceColumn ? void 0 : sourceColumn.ownerBand) || [];
          var pointsByTarget = dragOptions.pointsByTarget = dragOptions.pointsByTarget || {};
          var pointsByColumns = "columnChooser" === targetLocation ? [] : pointsByTarget[targetLocation] || controller._generatePointsByColumns(extend2({}, dragOptions, {
            targetDraggingPanel,
            columns: targetDraggingPanel.getColumns(rowIndex),
            columnElements,
            isVerticalOrientation,
            startColumnIndex: "headers" === targetLocation && renderer_default(columnElements[0]).index()
          }));
          pointsByTarget[targetLocation] = pointsByColumns;
          params.targetLocation = targetLocation;
          if (pointsByColumns.length > 0) {
            for (var i = 0; i < pointsByColumns.length; i++) {
              var centerPosition = pointsByColumns[i + 1] && (pointsByColumns[i][axisName] + pointsByColumns[i + 1][axisName]) / 2;
              if (void 0 === centerPosition || (rtlEnabled && "x" === axisName ? eventData2[axisName] > centerPosition : eventData2[axisName] < centerPosition)) {
                params.targetColumnIndex = this._getVisibleIndexObject(rowIndex, pointsByColumns[i].columnIndex);
                if (columnElements[i]) {
                  params.targetColumnElement = columnElements.eq(i);
                  params.isLast = false;
                } else {
                  params.targetColumnElement = columnElements.last();
                  params.isLast = true;
                }
                params.posX = pointsByColumns[i].x;
                params.posY = pointsByColumns[i].y;
                controller.dock(params);
                break;
              }
            }
          } else {
            this._resetTargetColumnOptions();
            controller.dock(params);
          }
        }
      },
      dropHeader: function(args) {
        var e = args.event;
        var that = e.data.that;
        var controller = that._controller;
        that.element().hide();
        if (controller && that._isDragging) {
          controller.drop(that._dropOptions);
        }
        that.element().appendTo(that._parentElement());
        that._dragOptions = null;
        that._dropOptions = null;
        that._isDragging = false;
        dom_adapter_default.getDocument().onselectstart = that._onSelectStart || null;
      }
    });
    isNextColumnResizingMode = function(that) {
      return "widget" !== that.option("columnResizingMode");
    };
    ColumnsResizerViewController = ui_grid_core_modules_default.ViewController.inherit({
      _isHeadersRowArea: function(posY) {
        if (this._columnHeadersView) {
          var element = this._columnHeadersView.element();
          if (element) {
            var offsetTop = element.offset().top;
            var headersRowHeight = this._columnHeadersView.getHeadersRowHeight();
            return posY >= offsetTop && posY <= offsetTop + headersRowHeight;
          }
        }
        return false;
      },
      _isRtlParentStyle: function() {
        var _this$_$parentContain;
        return this.option("rtlEnabled") && "rtl" === (null === (_this$_$parentContain = this._$parentContainer) || void 0 === _this$_$parentContain ? void 0 : _this$_$parentContain.parent().css("direction"));
      },
      _pointCreated: function(point, cellsLength, columns) {
        var isNextColumnMode = isNextColumnResizingMode(this);
        var rtlEnabled = this.option("rtlEnabled");
        var isRtlParentStyle = this._isRtlParentStyle();
        var firstPointColumnIndex = !isNextColumnMode && rtlEnabled && !isRtlParentStyle ? 0 : 1;
        if (point.index >= firstPointColumnIndex && point.index < cellsLength + (!isNextColumnMode && (!rtlEnabled || isRtlParentStyle) ? 1 : 0)) {
          point.columnIndex -= firstPointColumnIndex;
          var currentColumn = columns[point.columnIndex] || {};
          var nextColumn = columns[point.columnIndex + 1] || {};
          return !(isNextColumnMode ? currentColumn.allowResizing && nextColumn.allowResizing : currentColumn.allowResizing);
        }
        return true;
      },
      _getTargetPoint: function(pointsByColumns, currentX, deltaX) {
        if (pointsByColumns) {
          for (var i = 0; i < pointsByColumns.length; i++) {
            if (pointsByColumns[i].x === pointsByColumns[0].x && pointsByColumns[i + 1] && pointsByColumns[i].x === pointsByColumns[i + 1].x) {
              continue;
            }
            if (pointsByColumns[i].x - deltaX <= currentX && currentX <= pointsByColumns[i].x + deltaX) {
              return pointsByColumns[i];
            }
          }
        }
        return null;
      },
      _moveSeparator: function(args) {
        var _that$_draggingHeader;
        var e = args.event;
        var that = e.data;
        var columnsSeparatorWidth = that._columnsSeparatorView.width();
        var isNextColumnMode = isNextColumnResizingMode(that);
        var deltaX = columnsSeparatorWidth / 2;
        var parentOffset = that._$parentContainer.offset();
        var parentOffsetLeft = parentOffset.left;
        var eventData2 = eventData(e);
        var rtlEnabled = that.option("rtlEnabled");
        var isRtlParentStyle = this._isRtlParentStyle();
        var isDragging = null === (_that$_draggingHeader = that._draggingHeaderView) || void 0 === _that$_draggingHeader ? void 0 : _that$_draggingHeader.isDragging();
        if (that._isResizing && that._resizingInfo) {
          if ((parentOffsetLeft <= eventData2.x || !isNextColumnMode && isRtlParentStyle) && (!isNextColumnMode || eventData2.x <= parentOffsetLeft + that._$parentContainer.width())) {
            if (that._updateColumnsWidthIfNeeded(eventData2.x)) {
              var $cell = that._columnHeadersView.getColumnElements().eq(that._resizingInfo.currentColumnIndex);
              var cell = $cell[0];
              if (cell) {
                var outerWidth = cell.getBoundingClientRect().width;
                that._columnsSeparatorView.moveByX($cell.offset().left + ((isNextColumnMode || isRtlParentStyle) && rtlEnabled ? 0 : outerWidth));
                that._tablePositionController.update(that._targetPoint.y);
                e.preventDefault();
              }
            }
          }
        } else if (!isDragging) {
          if (that._isHeadersRowArea(eventData2.y)) {
            if (that._previousParentOffset) {
              if (that._previousParentOffset.left !== parentOffset.left || that._previousParentOffset.top !== parentOffset.top) {
                that.pointsByColumns(null);
              }
            }
            that._targetPoint = that._getTargetPoint(that.pointsByColumns(), eventData2.x, columnsSeparatorWidth);
            that._previousParentOffset = parentOffset;
            that._isReadyResizing = false;
            if (that._targetPoint) {
              that._columnsSeparatorView.changeCursor("col-resize");
              that._columnsSeparatorView.moveByX(that._targetPoint.x - deltaX);
              that._tablePositionController.update(that._targetPoint.y);
              that._isReadyResizing = true;
              e.preventDefault();
            } else {
              that._columnsSeparatorView.changeCursor();
              that._columnsSeparatorView.moveByX(null);
            }
          } else {
            that.pointsByColumns(null);
            that._isReadyResizing = false;
            that._columnsSeparatorView.changeCursor();
            that._columnsSeparatorView.moveByX(null);
          }
        }
      },
      _endResizing: function(args) {
        var e = args.event;
        var that = e.data;
        if (that._isResizing) {
          that.pointsByColumns(null);
          that._resizingInfo = null;
          that._columnsSeparatorView.hide();
          that._columnsSeparatorView.changeCursor();
          that._trackerView.hide();
          that._isReadyResizing = false;
          that._isResizing = false;
        }
      },
      _getNextColumnIndex: function(currentColumnIndex) {
        return currentColumnIndex + 1;
      },
      _setupResizingInfo: function(posX) {
        var currentColumnIndex = this._targetPoint.columnIndex;
        var nextColumnIndex = this._getNextColumnIndex(currentColumnIndex);
        var currentHeader = this._columnHeadersView.getHeaderElement(currentColumnIndex);
        var nextHeader = this._columnHeadersView.getHeaderElement(nextColumnIndex);
        this._resizingInfo = {
          startPosX: posX,
          currentColumnIndex,
          currentColumnWidth: currentHeader && currentHeader.length > 0 ? getBoundingRect(currentHeader[0]).width : 0,
          nextColumnIndex,
          nextColumnWidth: nextHeader && nextHeader.length > 0 ? getBoundingRect(nextHeader[0]).width : 0
        };
      },
      _startResizing: function(args) {
        var e = args.event;
        var that = e.data;
        var eventData2 = eventData(e);
        if (isTouchEvent(e)) {
          if (that._isHeadersRowArea(eventData2.y)) {
            that._targetPoint = that._getTargetPoint(that.pointsByColumns(), eventData2.x, COLUMNS_SEPARATOR_TOUCH_TRACKER_WIDTH);
            if (that._targetPoint) {
              that._columnsSeparatorView.moveByX(that._targetPoint.x - that._columnsSeparatorView.width() / 2);
              that._isReadyResizing = true;
            }
          } else {
            that._isReadyResizing = false;
          }
        }
        if (that._isReadyResizing) {
          that._setupResizingInfo(eventData2.x);
          that._isResizing = true;
          that._tablePositionController.update(that._targetPoint.y);
          that._columnsSeparatorView.show();
          that._trackerView.show();
          var scrollable = that.component.getScrollable();
          if (scrollable && that._isRtlParentStyle()) {
            that._scrollRight = scrollable.$content().width() - renderer_default(scrollable.container()).width() - scrollable.scrollLeft();
          }
          e.preventDefault();
          e.stopPropagation();
        }
        if (this.isResizing()) {
          this.getController("editorFactory").loseFocus();
        }
      },
      _generatePointsByColumns: function() {
        var that = this;
        var columns = that._columnsController ? that._columnsController.getVisibleColumns() : [];
        var cells = that._columnHeadersView.getColumnElements();
        var pointsByColumns = [];
        if (cells && cells.length > 0) {
          pointsByColumns = ui_grid_core_utils_default.getPointsByColumns(cells, function(point) {
            return that._pointCreated(point, cells.length, columns);
          });
        }
        that._pointsByColumns = pointsByColumns;
      },
      _unsubscribeFromEvents: function() {
        this._moveSeparatorHandler && events_engine_default.off(dom_adapter_default.getDocument(), addNamespace2(pointer_default.move, MODULE_NAMESPACE), this._moveSeparatorHandler);
        this._startResizingHandler && events_engine_default.off(this._$parentContainer, addNamespace2(pointer_default.down, MODULE_NAMESPACE), this._startResizingHandler);
        if (this._endResizingHandler) {
          events_engine_default.off(this._columnsSeparatorView.element(), addNamespace2(pointer_default.up, MODULE_NAMESPACE), this._endResizingHandler);
          events_engine_default.off(dom_adapter_default.getDocument(), addNamespace2(pointer_default.up, MODULE_NAMESPACE), this._endResizingHandler);
        }
      },
      _subscribeToEvents: function() {
        this._moveSeparatorHandler = this.createAction(this._moveSeparator);
        this._startResizingHandler = this.createAction(this._startResizing);
        this._endResizingHandler = this.createAction(this._endResizing);
        events_engine_default.on(dom_adapter_default.getDocument(), addNamespace2(pointer_default.move, MODULE_NAMESPACE), this, this._moveSeparatorHandler);
        events_engine_default.on(this._$parentContainer, addNamespace2(pointer_default.down, MODULE_NAMESPACE), this, this._startResizingHandler);
        events_engine_default.on(this._columnsSeparatorView.element(), addNamespace2(pointer_default.up, MODULE_NAMESPACE), this, this._endResizingHandler);
        events_engine_default.on(dom_adapter_default.getDocument(), addNamespace2(pointer_default.up, MODULE_NAMESPACE), this, this._endResizingHandler);
      },
      _updateColumnsWidthIfNeeded: function(posX) {
        var deltaX;
        var needUpdate;
        var contentWidth = this._rowsView.contentWidth();
        var resizingInfo = this._resizingInfo;
        var columnsController = this._columnsController;
        var visibleColumns = columnsController.getVisibleColumns();
        var columnsSeparatorWidth = this._columnsSeparatorView.width();
        var isNextColumnMode = isNextColumnResizingMode(this);
        var adaptColumnWidthByRatio = isNextColumnMode && this.option("adaptColumnWidthByRatio") && !this.option("columnAutoWidth");
        var rtlEnabled = this.option("rtlEnabled");
        var isRtlParentStyle = this._isRtlParentStyle();
        var column = visibleColumns[resizingInfo.currentColumnIndex];
        var nextColumn = visibleColumns[resizingInfo.nextColumnIndex];
        function isPercentWidth2(width) {
          return isString2(width) && "%" === width.slice(-1);
        }
        function setColumnWidth(column2, columnWidth, contentWidth2, adaptColumnWidthByRatio2) {
          if (column2) {
            var oldColumnWidth = column2.width;
            if (oldColumnWidth) {
              adaptColumnWidthByRatio2 = isPercentWidth2(oldColumnWidth);
            }
            if (adaptColumnWidthByRatio2) {
              columnsController.columnOption(column2.index, "visibleWidth", columnWidth);
              columnsController.columnOption(column2.index, "width", (columnWidth / contentWidth2 * 100).toFixed(3) + "%");
            } else {
              columnsController.columnOption(column2.index, "visibleWidth", null);
              columnsController.columnOption(column2.index, "width", columnWidth);
            }
          }
        }
        deltaX = posX - resizingInfo.startPosX;
        if ((isNextColumnMode || isRtlParentStyle) && rtlEnabled) {
          deltaX = -deltaX;
        }
        var {
          cellWidth,
          nextCellWidth
        } = function(delta) {
          var nextMinWidth;
          var nextCellWidth2;
          var needCorrectionNextCellWidth;
          var cellWidth2 = resizingInfo.currentColumnWidth + delta;
          var minWidth = column && column.minWidth || columnsSeparatorWidth;
          var result2 = {};
          if (cellWidth2 >= minWidth) {
            result2.cellWidth = cellWidth2;
          } else {
            result2.cellWidth = minWidth;
            needCorrectionNextCellWidth = true;
          }
          if (isNextColumnMode) {
            nextCellWidth2 = resizingInfo.nextColumnWidth - delta;
            nextMinWidth = nextColumn && nextColumn.minWidth || columnsSeparatorWidth;
            if (nextCellWidth2 >= nextMinWidth) {
              if (needCorrectionNextCellWidth) {
                result2.nextCellWidth = resizingInfo.nextColumnWidth - (delta + minWidth - cellWidth2);
              } else {
                result2.nextCellWidth = nextCellWidth2;
              }
            } else {
              result2.nextCellWidth = nextMinWidth;
              result2.cellWidth = resizingInfo.currentColumnWidth + (delta - nextMinWidth + nextCellWidth2);
            }
          }
          return result2;
        }(deltaX);
        needUpdate = column.width !== cellWidth;
        if (needUpdate) {
          columnsController.beginUpdate();
          cellWidth = Math.floor(cellWidth);
          contentWidth = function(contentWidth2, visibleColumns2) {
            var allColumnsHaveWidth = visibleColumns2.every((column2) => column2.width);
            if (allColumnsHaveWidth) {
              var totalPercent = visibleColumns2.reduce((sum, column2) => {
                if (isPercentWidth2(column2.width)) {
                  sum += parseFloat(column2.width);
                }
                return sum;
              }, 0);
              if (totalPercent > 100) {
                contentWidth2 = contentWidth2 / totalPercent * 100;
              }
            }
            return contentWidth2;
          }(contentWidth, visibleColumns);
          setColumnWidth(column, cellWidth, contentWidth, adaptColumnWidthByRatio);
          if (isNextColumnMode) {
            nextCellWidth = Math.floor(nextCellWidth);
            setColumnWidth(nextColumn, nextCellWidth, contentWidth, adaptColumnWidthByRatio);
          } else {
            var columnWidths = this._columnHeadersView.getColumnWidths();
            columnWidths[resizingInfo.currentColumnIndex] = cellWidth;
            var hasScroll = columnWidths.reduce((totalWidth, width) => totalWidth + width, 0) > this._rowsView.contentWidth();
            if (!hasScroll) {
              var lastColumnIndex = ui_grid_core_utils_default.getLastResizableColumnIndex(visibleColumns);
              if (lastColumnIndex >= 0) {
                columnsController.columnOption(visibleColumns[lastColumnIndex].index, "visibleWidth", "auto");
              }
            }
            for (var i = 0; i < columnWidths.length; i++) {
              if (visibleColumns[i] && visibleColumns[i] !== column && void 0 === visibleColumns[i].width) {
                columnsController.columnOption(visibleColumns[i].index, "width", columnWidths[i]);
              }
            }
          }
          columnsController.endUpdate();
          if (!isNextColumnMode) {
            this.component.updateDimensions();
            var scrollable = this.component.getScrollable();
            if (scrollable && isRtlParentStyle) {
              var left = scrollable.$content().width() - renderer_default(scrollable.container()).width() - this._scrollRight;
              scrollable.scrollTo({
                left
              });
            }
          }
        }
        return needUpdate;
      },
      _subscribeToCallback: function(callback, handler) {
        callback.add(handler);
        this._subscribesToCallbacks.push({
          callback,
          handler
        });
      },
      _unsubscribeFromCallbacks: function() {
        for (var i = 0; i < this._subscribesToCallbacks.length; i++) {
          var subscribe = this._subscribesToCallbacks[i];
          subscribe.callback.remove(subscribe.handler);
        }
        this._subscribesToCallbacks = [];
      },
      _unsubscribes: function() {
        this._unsubscribeFromEvents();
        this._unsubscribeFromCallbacks();
      },
      _init: function() {
        var that = this;
        var generatePointsByColumnsHandler = function() {
          if (!that._isResizing) {
            that.pointsByColumns(null);
          }
        };
        var generatePointsByColumnsScrollHandler = function(offset2) {
          if (that._scrollLeft !== offset2.left) {
            that._scrollLeft = offset2.left;
            that.pointsByColumns(null);
          }
        };
        that._columnsSeparatorView = that.getView("columnsSeparatorView");
        that._columnHeadersView = that.getView("columnHeadersView");
        that._trackerView = that.getView("trackerView");
        that._rowsView = that.getView("rowsView");
        that._columnsController = that.getController("columns");
        that._tablePositionController = that.getController("tablePosition");
        that._$parentContainer = that.component.$element();
        that._draggingHeaderView = that.component.getView("draggingHeaderView");
        that._subscribeToCallback(that._columnHeadersView.renderCompleted, generatePointsByColumnsHandler);
        that._subscribeToCallback(that._columnHeadersView.resizeCompleted, generatePointsByColumnsHandler);
        that._subscribeToCallback(that._columnsSeparatorView.renderCompleted, function() {
          that._unsubscribeFromEvents();
          that._subscribeToEvents();
        });
        that._subscribeToCallback(that._rowsView.renderCompleted, function() {
          that._rowsView.scrollChanged.remove(generatePointsByColumnsScrollHandler);
          that._rowsView.scrollChanged.add(generatePointsByColumnsScrollHandler);
        });
        var previousScrollbarVisibility = 0 !== that._rowsView.getScrollbarWidth();
        var previousTableHeight = 0;
        that._subscribeToCallback(that.getController("tablePosition").positionChanged, function(e) {
          if (that._isResizing && !that._rowsView.isResizing) {
            var scrollbarVisibility = 0 !== that._rowsView.getScrollbarWidth();
            if (previousScrollbarVisibility !== scrollbarVisibility || previousTableHeight && previousTableHeight !== e.height) {
              previousScrollbarVisibility = scrollbarVisibility;
              previousTableHeight = e.height;
              that.component.updateDimensions();
            } else {
              that._rowsView.updateFreeSpaceRowHeight();
            }
          }
          previousTableHeight = e.height;
        });
      },
      optionChanged: function(args) {
        this.callBase(args);
        if ("allowColumnResizing" === args.name) {
          if (args.value) {
            this._init();
            this._subscribeToEvents();
          } else {
            this._unsubscribes();
          }
        }
      },
      isResizing: function() {
        return this._isResizing;
      },
      init: function() {
        this._subscribesToCallbacks = [];
        if (allowResizing(this)) {
          this._init();
        }
      },
      pointsByColumns: function(value2) {
        if (void 0 !== value2) {
          this._pointsByColumns = value2;
        } else {
          if (!this._pointsByColumns) {
            this._generatePointsByColumns();
          }
          return this._pointsByColumns;
        }
      },
      dispose: function() {
        this._unsubscribes();
        this.callBase();
      }
    });
    TablePositionViewController = ui_grid_core_modules_default.ViewController.inherit({
      update: function(top) {
        var params = {};
        var $element = this._columnHeadersView.element();
        var offset2 = $element && $element.offset();
        var offsetTop = offset2 && offset2.top || 0;
        var diffOffsetTop = isDefined(top) ? Math.abs(top - offsetTop) : 0;
        var columnsHeadersHeight = this._columnHeadersView ? this._columnHeadersView.getHeight() : 0;
        var scrollBarWidth = this._rowsView.getScrollbarWidth(true);
        var rowsHeight = this._rowsView ? this._rowsView.height() - scrollBarWidth : 0;
        var columnsResizerController = this.component.getController("columnsResizer");
        var draggingHeaderView = this.component.getView("draggingHeaderView");
        params.height = columnsHeadersHeight;
        var isDraggingOrResizing = false !== columnsResizerController.isResizing() || draggingHeaderView.isDragging();
        if (isDraggingOrResizing) {
          params.height += rowsHeight - diffOffsetTop;
        }
        if (null !== top && $element && $element.length) {
          params.top = $element[0].offsetTop + diffOffsetTop;
        }
        this.positionChanged.fire(params);
      },
      init: function() {
        var that = this;
        that.callBase();
        that._columnHeadersView = this.getView("columnHeadersView");
        that._rowsView = this.getView("rowsView");
        that._pagerView = this.getView("pagerView");
        that._rowsView.resizeCompleted.add(function() {
          if (that.option("allowColumnResizing")) {
            var targetPoint = that.getController("columnsResizer")._targetPoint;
            that.update(targetPoint ? targetPoint.y : null);
          }
        });
      },
      ctor: function(component) {
        this.callBase(component);
        this.positionChanged = callbacks_default();
      }
    });
    DraggingHeaderViewController = ui_grid_core_modules_default.ViewController.inherit({
      _generatePointsByColumns: function(options2) {
        var that = this;
        return ui_grid_core_utils_default.getPointsByColumns(options2.columnElements, function(point) {
          return that._pointCreated(point, options2.columns, options2.targetDraggingPanel.getName(), options2.sourceColumn);
        }, options2.isVerticalOrientation, options2.startColumnIndex);
      },
      _pointCreated: function(point, columns, location, sourceColumn) {
        var targetColumn = columns[point.columnIndex];
        var prevColumn = columns[point.columnIndex - 1];
        switch (location) {
          case "columnChooser":
            return true;
          case "headers":
            return sourceColumn && !sourceColumn.allowReordering || (!targetColumn || !targetColumn.allowReordering) && (!prevColumn || !prevColumn.allowReordering);
          default:
            return 0 === columns.length;
        }
      },
      _subscribeToEvents: function(draggingHeader, draggingPanels) {
        var that = this;
        each(draggingPanels, function(_2, draggingPanel) {
          if (draggingPanel) {
            var columns;
            var rowCount = draggingPanel.getRowCount ? draggingPanel.getRowCount() : 1;
            var nameDraggingPanel = draggingPanel.getName();
            var subscribeToEvents = function(index2, columnElement) {
              if (!columnElement) {
                return;
              }
              var $columnElement = renderer_default(columnElement);
              var column = columns[index2];
              if (draggingPanel.allowDragging(column, nameDraggingPanel, draggingPanels)) {
                $columnElement.addClass(that.addWidgetPrefix(HEADERS_DRAG_ACTION_CLASS));
                events_engine_default.on($columnElement, addNamespace2(DRAG_START_EVENT, MODULE_NAMESPACE), that.createAction(function(args) {
                  var e = args.event;
                  var eventData2 = eventData(e);
                  draggingHeader.dragHeader({
                    deltaX: eventData2.x - renderer_default(e.currentTarget).offset().left,
                    deltaY: eventData2.y - renderer_default(e.currentTarget).offset().top,
                    sourceColumn: column,
                    index: column.index,
                    columnIndex: index2,
                    columnElement: $columnElement,
                    sourceLocation: nameDraggingPanel,
                    draggingPanels,
                    rowIndex: that._columnsController.getRowIndex(column.index, true)
                  });
                }));
                events_engine_default.on($columnElement, addNamespace2(DRAG_EVENT, MODULE_NAMESPACE), {
                  that: draggingHeader
                }, that.createAction(draggingHeader.moveHeader));
                events_engine_default.on($columnElement, addNamespace2(DRAG_END_EVENT, MODULE_NAMESPACE), {
                  that: draggingHeader
                }, that.createAction(draggingHeader.dropHeader));
              }
            };
            for (var i = 0; i < rowCount; i++) {
              var columnElements = draggingPanel.getColumnElements(i) || [];
              if (columnElements.length) {
                columns = draggingPanel.getColumns(i) || [];
                each(columnElements, subscribeToEvents);
              }
            }
          }
        });
      },
      _unsubscribeFromEvents: function(draggingHeader, draggingPanels) {
        var that = this;
        each(draggingPanels, function(_2, draggingPanel) {
          if (draggingPanel) {
            var columnElements = draggingPanel.getColumnElements() || [];
            each(columnElements, function(index2, columnElement) {
              var $columnElement = renderer_default(columnElement);
              events_engine_default.off($columnElement, addNamespace2(DRAG_START_EVENT, MODULE_NAMESPACE));
              events_engine_default.off($columnElement, addNamespace2(DRAG_EVENT, MODULE_NAMESPACE));
              events_engine_default.off($columnElement, addNamespace2(DRAG_END_EVENT, MODULE_NAMESPACE));
              $columnElement.removeClass(that.addWidgetPrefix(HEADERS_DRAG_ACTION_CLASS));
            });
          }
        });
      },
      _getSeparator: function(targetLocation) {
        return "headers" === targetLocation ? this._columnsSeparatorView : this._blockSeparatorView;
      },
      hideSeparators: function(type2) {
        var blockSeparator = this._blockSeparatorView;
        var columnsSeparator = this._columnsSeparatorView;
        this._animationColumnIndex = null;
        blockSeparator && blockSeparator.hide();
        "block" !== type2 && columnsSeparator && columnsSeparator.hide();
      },
      init: function() {
        var that = this;
        that.callBase();
        that._columnsController = that.getController("columns");
        that._columnHeadersView = that.getView("columnHeadersView");
        that._columnsSeparatorView = that.getView("columnsSeparatorView");
        that._draggingHeaderView = that.getView("draggingHeaderView");
        that._rowsView = that.getView("rowsView");
        that._blockSeparatorView = that.getView("blockSeparatorView");
        that._headerPanelView = that.getView("headerPanel");
        that._columnChooserView = that.getView("columnChooserView");
        var subscribeToEvents = function() {
          if (that._draggingHeaderView) {
            var draggingPanels = [that._columnChooserView, that._columnHeadersView, that._headerPanelView];
            that._unsubscribeFromEvents(that._draggingHeaderView, draggingPanels);
            that._subscribeToEvents(that._draggingHeaderView, draggingPanels);
          }
        };
        that._columnHeadersView.renderCompleted.add(subscribeToEvents);
        that._headerPanelView && that._headerPanelView.renderCompleted.add(subscribeToEvents);
        that._columnChooserView && that._columnChooserView.renderCompleted.add(subscribeToEvents);
      },
      allowDrop: function(parameters) {
        return this._columnsController.allowMoveColumn(parameters.sourceColumnIndex, parameters.targetColumnIndex, parameters.sourceLocation, parameters.targetLocation);
      },
      drag: function(parameters) {
        var sourceIndex = parameters.sourceIndex;
        var sourceLocation = parameters.sourceLocation;
        var sourceColumnElement = parameters.sourceColumnElement;
        var headersView = this._columnHeadersView;
        var rowsView = this._rowsView;
        if (sourceColumnElement) {
          sourceColumnElement.css({
            opacity: COLUMN_OPACITY
          });
          if ("headers" === sourceLocation) {
            headersView && headersView.setRowsOpacity(sourceIndex, COLUMN_OPACITY);
            rowsView && rowsView.setRowsOpacity(sourceIndex, COLUMN_OPACITY);
          }
        }
      },
      dock: function(parameters) {
        var that = this;
        var targetColumnIndex = isObject2(parameters.targetColumnIndex) ? parameters.targetColumnIndex.columnIndex : parameters.targetColumnIndex;
        var sourceLocation = parameters.sourceLocation;
        var targetLocation = parameters.targetLocation;
        var separator = that._getSeparator(targetLocation);
        var hasTargetVisibleIndex = targetColumnIndex >= 0;
        that._columnHeadersView.element().find("." + HEADER_ROW_CLASS).toggleClass(that.addWidgetPrefix(HEADERS_DROP_HIGHLIGHT_CLASS), "headers" !== sourceLocation && "headers" === targetLocation && !hasTargetVisibleIndex);
        if (separator) {
          if (that.allowDrop(parameters) && hasTargetVisibleIndex) {
            if ("group" === targetLocation || "columnChooser" === targetLocation) {
              !function() {
                if (that._animationColumnIndex !== targetColumnIndex) {
                  that.hideSeparators();
                  separator.element()[parameters.isLast ? "insertAfter" : "insertBefore"](parameters.targetColumnElement);
                  that._animationColumnIndex = targetColumnIndex;
                  separator.show(targetLocation);
                }
              }();
            } else {
              that.hideSeparators("block");
              that.getController("tablePosition").update(parameters.posY);
              separator.moveByX(parameters.posX - separator.width());
              separator.show();
            }
          } else {
            that.hideSeparators();
          }
        }
      },
      drop: function(parameters) {
        var sourceColumnElement = parameters.sourceColumnElement;
        if (sourceColumnElement) {
          sourceColumnElement.css({
            opacity: ""
          });
          this._columnHeadersView.setRowsOpacity(parameters.sourceIndex, "");
          this._rowsView.setRowsOpacity(parameters.sourceIndex, "");
          this._columnHeadersView.element().find("." + HEADER_ROW_CLASS).removeClass(this.addWidgetPrefix(HEADERS_DROP_HIGHLIGHT_CLASS));
        }
        if (this.allowDrop(parameters)) {
          var separator = this._getSeparator(parameters.targetLocation);
          if (separator) {
            separator.hide();
          }
          this._columnsController.moveColumn(parameters.sourceColumnIndex, parameters.targetColumnIndex, parameters.sourceLocation, parameters.targetLocation);
        }
      },
      dispose: function() {
        if (this._draggingHeaderView) {
          this._unsubscribeFromEvents(this._draggingHeaderView, [this._columnChooserView, this._columnHeadersView, this._headerPanelView]);
        }
      }
    });
    columnsResizingReorderingModule = {
      views: {
        columnsSeparatorView: ColumnsSeparatorView,
        blockSeparatorView: BlockSeparatorView,
        draggingHeaderView: DraggingHeaderView,
        trackerView: TrackerView
      },
      controllers: {
        draggingHeader: DraggingHeaderViewController,
        tablePosition: TablePositionViewController,
        columnsResizer: ColumnsResizerViewController
      },
      extenders: {
        views: {
          rowsView: {
            _needUpdateRowHeight: function(itemCount) {
              var wordWrapEnabled = this.option("wordWrapEnabled");
              var columnsResizerController = this.getController("columnsResizer");
              var isResizing = columnsResizerController.isResizing();
              return this.callBase.apply(this, arguments) || itemCount > 0 && wordWrapEnabled && isResizing;
            }
          }
        },
        controllers: {
          editorFactory: {
            renderFocusOverlay: function() {
              if (this.getController("columnsResizer").isResizing()) {
                return;
              }
              return this.callBase.apply(this, arguments);
            }
          }
        }
      }
    };
  }
});

// node_modules/devextreme/esm/ui/grid_core/ui.grid_core.keyboard_navigation.js
function isGroupRow($row) {
  return $row && $row.hasClass(GROUP_ROW_CLASS2);
}
function isDetailRow($row) {
  return $row && $row.hasClass(MASTER_DETAIL_ROW_CLASS2);
}
function isDataRow($row) {
  return $row && !isGroupRow($row) && !isDetailRow($row);
}
function isNotFocusedRow($row) {
  return !$row || $row.hasClass(FREESPACE_ROW_CLASS) || $row.hasClass(VIRTUAL_ROW_CLASS2);
}
function isCellElement($element) {
  return $element.length && "TD" === $element[0].tagName;
}
function isEditorCell(that, $cell) {
  return !that._isRowEditMode() && $cell && !$cell.hasClass(COMMAND_SELECT_CLASS2) && $cell.hasClass(EDITOR_CELL_CLASS5);
}
function isElementDefined($element) {
  return isDefined($element) && $element.length > 0;
}
function isMobile() {
  return "desktop" !== devices_default.current().deviceType;
}
function isCellInHeaderRow($cell) {
  return !!$cell.parent(".".concat(HEADER_ROW_CLASS2)).length;
}
function isFixedColumnIndexOffsetRequired(that, column) {
  var rtlEnabled = that.option("rtlEnabled");
  var result2 = false;
  if (rtlEnabled) {
    result2 = !("right" === column.fixedPosition || isDefined(column.command) && !isDefined(column.fixedPosition));
  } else {
    result2 = !(!isDefined(column.fixedPosition) || "left" === column.fixedPosition);
  }
  return result2;
}
function shouldPreventScroll(that) {
  var keyboardController = that.getController("keyboardNavigation");
  return keyboardController._isVirtualScrolling() ? that.option("focusedRowIndex") === keyboardController.getRowIndex() : false;
}
var ROWS_VIEW_CLASS2, EDIT_FORM_CLASS2, GROUP_FOOTER_CLASS, ROW_CLASS6, DATA_ROW_CLASS3, GROUP_ROW_CLASS2, HEADER_ROW_CLASS2, EDIT_FORM_ITEM_CLASS2, MASTER_DETAIL_ROW_CLASS2, FREESPACE_ROW_CLASS, VIRTUAL_ROW_CLASS2, MASTER_DETAIL_CELL_CLASS2, EDITOR_CELL_CLASS5, DROPDOWN_EDITOR_OVERLAY_CLASS2, COMMAND_EXPAND_CLASS, COMMAND_SELECT_CLASS2, COMMAND_EDIT_CLASS2, COMMAND_CELL_SELECTOR, CELL_FOCUS_DISABLED_CLASS4, DATEBOX_WIDGET_NAME, FOCUS_STATE_CLASS2, WIDGET_CLASS6, REVERT_BUTTON_CLASS2, FAST_EDITING_DELETE_KEY, INTERACTIVE_ELEMENTS_SELECTOR, NON_FOCUSABLE_ELEMENTS_SELECTOR, EDIT_MODE_ROW3, EDIT_MODE_FORM3, EDIT_MODE_BATCH3, EDIT_MODE_CELL3, FOCUS_TYPE_ROW, FOCUS_TYPE_CELL, COLUMN_HEADERS_VIEW, FUNCTIONAL_KEYS, KeyboardNavigationController, keyboardNavigationModule;
var init_ui_grid_core_keyboard_navigation = __esm({
  "node_modules/devextreme/esm/ui/grid_core/ui.grid_core.keyboard_navigation.js"() {
    init_renderer();
    init_dom_adapter();
    init_events_engine();
    init_ui_grid_core_modules();
    init_ui_grid_core_utils();
    init_type();
    init_array();
    init_selectors();
    init_utils2();
    init_pointer();
    init_click();
    init_common();
    init_accessibility();
    init_browser();
    init_short();
    init_devices();
    ROWS_VIEW_CLASS2 = "rowsview";
    EDIT_FORM_CLASS2 = "edit-form";
    GROUP_FOOTER_CLASS = "group-footer";
    ROW_CLASS6 = "dx-row";
    DATA_ROW_CLASS3 = "dx-data-row";
    GROUP_ROW_CLASS2 = "dx-group-row";
    HEADER_ROW_CLASS2 = "dx-header-row";
    EDIT_FORM_ITEM_CLASS2 = "edit-form-item";
    MASTER_DETAIL_ROW_CLASS2 = "dx-master-detail-row";
    FREESPACE_ROW_CLASS = "dx-freespace-row";
    VIRTUAL_ROW_CLASS2 = "dx-virtual-row";
    MASTER_DETAIL_CELL_CLASS2 = "dx-master-detail-cell";
    EDITOR_CELL_CLASS5 = "dx-editor-cell";
    DROPDOWN_EDITOR_OVERLAY_CLASS2 = "dx-dropdowneditor-overlay";
    COMMAND_EXPAND_CLASS = "dx-command-expand";
    COMMAND_SELECT_CLASS2 = "dx-command-select";
    COMMAND_EDIT_CLASS2 = "dx-command-edit";
    COMMAND_CELL_SELECTOR = "[class^=dx-command]";
    CELL_FOCUS_DISABLED_CLASS4 = "dx-cell-focus-disabled";
    DATEBOX_WIDGET_NAME = "dxDateBox";
    FOCUS_STATE_CLASS2 = "dx-state-focused";
    WIDGET_CLASS6 = "dx-widget";
    REVERT_BUTTON_CLASS2 = "dx-revert-button";
    FAST_EDITING_DELETE_KEY = "delete";
    INTERACTIVE_ELEMENTS_SELECTOR = "input:not([type='hidden']), textarea, a, select, button, [tabindex], .dx-checkbox";
    NON_FOCUSABLE_ELEMENTS_SELECTOR = "".concat(INTERACTIVE_ELEMENTS_SELECTOR, ", .dx-dropdowneditor-icon");
    EDIT_MODE_ROW3 = "row";
    EDIT_MODE_FORM3 = "form";
    EDIT_MODE_BATCH3 = "batch";
    EDIT_MODE_CELL3 = "cell";
    FOCUS_TYPE_ROW = "row";
    FOCUS_TYPE_CELL = "cell";
    COLUMN_HEADERS_VIEW = "columnHeadersView";
    FUNCTIONAL_KEYS = ["shift", "control", "alt"];
    KeyboardNavigationController = ui_grid_core_modules_default.ViewController.inherit({
      init: function() {
        this._dataController = this.getController("data");
        this._selectionController = this.getController("selection");
        this._editingController = this.getController("editing");
        this._headerPanel = this.getView("headerPanel");
        this._columnsController = this.getController("columns");
        this._editorFactory = this.getController("editorFactory");
        if (this.isKeyboardEnabled()) {
          subscribeVisibilityChange();
          this._updateFocusTimeout = null;
          this._fastEditingStarted = false;
          this._focusedCellPosition = {};
          this._canceledCellPosition = null;
          this._editorFactory.focused.add(($element) => {
            this.setupFocusedView();
            if (this._isNeedScroll) {
              if ($element.is(":visible") && this._focusedView && this._focusedView.getScrollable) {
                this._focusedView._scrollToElement($element);
                this._isNeedScroll = false;
              }
            }
          });
          this._initViewHandlers();
          this._initDocumentHandlers();
          this.createAction("onKeyDown");
        }
      },
      _initViewHandlers: function() {
        var rowsView = this.getView("rowsView");
        var rowsViewFocusHandler = (event) => {
          var $element = renderer_default(event.target);
          var isRelatedTargetInRowsView = renderer_default(event.relatedTarget).closest(rowsView.element()).length;
          var isCommandButton = $element.hasClass("dx-link");
          if (isCommandButton && !isRelatedTargetInRowsView && this._isEventInCurrentGrid(event)) {
            var $focusedCell = this._getFocusedCell();
            $focusedCell = !isElementDefined($focusedCell) ? rowsView.getCellElements(0).filter("[tabindex]").eq(0) : $focusedCell;
            if (!$element.closest($focusedCell).length) {
              event.preventDefault();
              events_engine_default.trigger($focusedCell, "focus");
            }
          }
        };
        rowsView.renderCompleted.add((e) => {
          var $rowsView = rowsView.element();
          var isFullUpdate = !e || "refresh" === e.changeType;
          var isFocusedViewCorrect = this._focusedView && this._focusedView.name === rowsView.name;
          var needUpdateFocus = false;
          var isAppend = e && ("append" === e.changeType || "prepend" === e.changeType);
          var $focusedElement = renderer_default(":focus");
          var isFocusedElementCorrect = !$focusedElement.length || $focusedElement.closest($rowsView).length || browser_default.msie && $focusedElement.is("body");
          events_engine_default.off($rowsView, "focusin", rowsViewFocusHandler);
          events_engine_default.on($rowsView, "focusin", rowsViewFocusHandler);
          this._initPointerEventHandler();
          this._initKeyDownHandler();
          this._setRowsViewAttributes();
          if (isFocusedViewCorrect && isFocusedElementCorrect) {
            needUpdateFocus = this._isNeedFocus ? !isAppend : this._isHiddenFocus && isFullUpdate && !(null !== e && void 0 !== e && e.virtualColumnsScrolling);
            needUpdateFocus && this._updateFocus(true);
          }
        });
      },
      _initDocumentHandlers: function() {
        var document2 = dom_adapter_default.getDocument();
        this._documentClickHandler = this.createAction((e) => {
          var $target = renderer_default(e.event.target);
          var isCurrentRowsViewClick = this._isEventInCurrentGrid(e.event) && $target.closest(".".concat(this.addWidgetPrefix(ROWS_VIEW_CLASS2))).length;
          var isEditorOverlay = $target.closest(".".concat(DROPDOWN_EDITOR_OVERLAY_CLASS2)).length;
          var columnsResizerController = this.getController("columnsResizer");
          var isColumnResizing = !!columnsResizerController && columnsResizerController.isResizing();
          if (!isCurrentRowsViewClick && !isEditorOverlay && !isColumnResizing) {
            var targetInsideFocusedView = this._focusedView ? $target.parents().filter(this._focusedView.element()).length > 0 : false;
            !targetInsideFocusedView && this._resetFocusedCell(true);
            this._resetFocusedView();
          }
        });
        events_engine_default.on(document2, addNamespace2(pointer_default.down, "dxDataGridKeyboardNavigation"), this._documentClickHandler);
      },
      _setRowsViewAttributes: function() {
        var $rowsView = this._getRowsViewElement();
        var isGridEmpty = !this._dataController.getVisibleRows().length;
        if (isGridEmpty) {
          this._applyTabIndexToElement($rowsView);
        }
      },
      _initPointerEventHandler: function() {
        var pointerEventName = !isMobile() ? pointer_default.down : CLICK_EVENT_NAME;
        var clickSelector = ".".concat(ROW_CLASS6, " > td, .").concat(ROW_CLASS6);
        var $rowsView = this._getRowsViewElement();
        if (!isDefined(this._pointerEventAction)) {
          this._pointerEventAction = this.createAction(this._pointerEventHandler);
        }
        events_engine_default.off($rowsView, addNamespace2(pointerEventName, "dxDataGridKeyboardNavigation"), this._pointerEventAction);
        events_engine_default.on($rowsView, addNamespace2(pointerEventName, "dxDataGridKeyboardNavigation"), clickSelector, this._pointerEventAction);
      },
      _initKeyDownHandler: function() {
        var $rowsView = this._getRowsViewElement();
        keyboard.off(this._keyDownListener);
        this._keyDownListener = keyboard.on($rowsView, null, (e) => this._keyDownHandler(e));
      },
      dispose: function() {
        this.callBase();
        this._resetFocusedView();
        keyboard.off(this._keyDownListener);
        events_engine_default.off(dom_adapter_default.getDocument(), addNamespace2(pointer_default.down, "dxDataGridKeyboardNavigation"), this._documentClickHandler);
        clearTimeout(this._updateFocusTimeout);
        unsubscribeVisibilityChange();
      },
      optionChanged: function(args) {
        switch (args.name) {
          case "keyboardNavigation":
          case "useLegacyKeyboardNavigation":
            args.handled = true;
            break;
          default:
            this.callBase(args);
        }
      },
      isRowFocusType: function() {
        return this.focusType === FOCUS_TYPE_ROW;
      },
      isCellFocusType: function() {
        return this.focusType === FOCUS_TYPE_CELL;
      },
      setRowFocusType: function() {
        if (this.option("focusedRowEnabled")) {
          this.focusType = FOCUS_TYPE_ROW;
        }
      },
      setCellFocusType: function() {
        this.focusType = FOCUS_TYPE_CELL;
      },
      _keyDownHandler: function(e) {
        var needStopPropagation = true;
        this._isNeedFocus = true;
        this._isNeedScroll = true;
        var isHandled = this._processOnKeyDown(e);
        var isEditing = this._editingController.isEditing();
        var originalEvent = e.originalEvent;
        if (originalEvent.isDefaultPrevented()) {
          this._isNeedFocus = false;
          this._isNeedScroll = false;
          return;
        }
        FUNCTIONAL_KEYS.indexOf(e.keyName) < 0 && this._updateFocusedCellPositionByTarget(originalEvent.target);
        if (!isHandled) {
          switch (e.keyName) {
            case "leftArrow":
            case "rightArrow":
              this._leftRightKeysHandler(e, isEditing);
              isHandled = true;
              break;
            case "upArrow":
            case "downArrow":
              if (e.ctrl) {
                selectView("rowsView", this, originalEvent);
              } else {
                this._upDownKeysHandler(e, isEditing);
              }
              isHandled = true;
              break;
            case "pageUp":
            case "pageDown":
              this._pageUpDownKeyHandler(e);
              isHandled = true;
              break;
            case "space":
              isHandled = this._spaceKeyHandler(e, isEditing);
              break;
            case "A":
              if (isCommandKeyPressed(e.originalEvent)) {
                this._ctrlAKeyHandler(e, isEditing);
                isHandled = true;
              } else {
                isHandled = this._beginFastEditing(e.originalEvent);
              }
              break;
            case "tab":
              this._tabKeyHandler(e, isEditing);
              isHandled = true;
              break;
            case "enter":
              this._enterKeyHandler(e, isEditing);
              isHandled = true;
              break;
            case "escape":
              this._escapeKeyHandler(e, isEditing);
              isHandled = true;
              break;
            case "F":
              if (isCommandKeyPressed(e.originalEvent)) {
                this._ctrlFKeyHandler(e);
                isHandled = true;
              } else {
                isHandled = this._beginFastEditing(e.originalEvent);
              }
              break;
            case "F2":
              this._f2KeyHandler();
              isHandled = true;
              break;
            case "del":
            case "backspace":
              if (this._isFastEditingAllowed() && !this._isFastEditingStarted()) {
                isHandled = this._beginFastEditing(originalEvent, true);
              }
          }
          if (!isHandled && !this._beginFastEditing(originalEvent)) {
            this._isNeedFocus = false;
            this._isNeedScroll = false;
            needStopPropagation = false;
          }
          if (needStopPropagation) {
            originalEvent.stopPropagation();
          }
        }
      },
      _processOnKeyDown: function(eventArgs) {
        var originalEvent = eventArgs.originalEvent;
        var args = {
          handled: false,
          event: originalEvent
        };
        this.executeAction("onKeyDown", args);
        eventArgs.ctrl = originalEvent.ctrlKey;
        eventArgs.alt = originalEvent.altKey;
        eventArgs.shift = originalEvent.shiftKey;
        return !!args.handled;
      },
      _closeEditCell: function() {
        setTimeout(() => {
          this._editingController.closeEditCell();
        });
      },
      _leftRightKeysHandler: function(eventArgs, isEditing) {
        var rowIndex = this.getVisibleRowIndex();
        var $event = eventArgs.originalEvent;
        var $row = this._focusedView && this._focusedView.getRow(rowIndex);
        var directionCode = this._getDirectionCodeByKey(eventArgs.keyName);
        var isEditingNavigationMode = this._isFastEditingStarted();
        var allowNavigate = (!isEditing || isEditingNavigationMode) && isDataRow($row);
        if (allowNavigate) {
          this.setCellFocusType();
          isEditingNavigationMode && this._closeEditCell();
          if (this._isVirtualColumnRender()) {
            this._processVirtualHorizontalPosition(directionCode);
          }
          var $cell = this._getNextCell(directionCode);
          if (isElementDefined($cell)) {
            this._arrowKeysHandlerFocusCell($event, $cell, directionCode);
          }
          $event && $event.preventDefault();
        }
      },
      _upDownKeysHandler: function(eventArgs, isEditing) {
        var _this$_editingControl, _this$_editingControl2;
        var rowIndex = this._focusedCellPosition.rowIndex;
        var visibleRowIndex = this.getVisibleRowIndex();
        var $row = this._focusedView && this._focusedView.getRow(visibleRowIndex);
        var $event = eventArgs.originalEvent;
        var isUpArrow = "upArrow" === eventArgs.keyName;
        var dataSource = this._dataController.dataSource();
        var isRowEditingInCurrentRow = null === (_this$_editingControl = this._editingController) || void 0 === _this$_editingControl ? void 0 : null === (_this$_editingControl2 = _this$_editingControl.isEditRowByIndex) || void 0 === _this$_editingControl2 ? void 0 : _this$_editingControl2.call(_this$_editingControl, visibleRowIndex);
        var isEditingNavigationMode = this._isFastEditingStarted();
        var allowNavigate = (!isRowEditingInCurrentRow || !isEditing || isEditingNavigationMode) && $row && !isDetailRow($row);
        if (allowNavigate) {
          isEditingNavigationMode && this._closeEditCell();
          if (!this._navigateNextCell($event, eventArgs.keyName)) {
            if (this._isVirtualRowRender() && isUpArrow && dataSource && !dataSource.isLoading()) {
              var rowHeight = $row.outerHeight();
              rowIndex = this._focusedCellPosition.rowIndex - 1;
              this._scrollBy(0, -rowHeight, rowIndex, $event);
            }
          }
          $event && $event.preventDefault();
        }
      },
      _pageUpDownKeyHandler: function(eventArgs) {
        var pageIndex = this._dataController.pageIndex();
        var pageCount = this._dataController.pageCount();
        var pagingEnabled = this.option("paging.enabled");
        var isPageUp = "pageUp" === eventArgs.keyName;
        var pageStep = isPageUp ? -1 : 1;
        var scrollable = this.getView("rowsView").getScrollable();
        if (pagingEnabled && !this._isVirtualScrolling()) {
          if ((isPageUp ? pageIndex > 0 : pageIndex < pageCount - 1) && !this._isVirtualScrolling()) {
            this._dataController.pageIndex(pageIndex + pageStep);
            eventArgs.originalEvent.preventDefault();
          }
        } else if (scrollable && renderer_default(scrollable.container()).height() < scrollable.$content().height()) {
          this._scrollBy(0, renderer_default(scrollable.container()).height() * pageStep);
          eventArgs.originalEvent.preventDefault();
        }
      },
      _spaceKeyHandler: function(eventArgs, isEditing) {
        var rowIndex = this.getVisibleRowIndex();
        var $target = renderer_default(eventArgs.originalEvent && eventArgs.originalEvent.target);
        if (this.option("selection") && "none" !== this.option("selection").mode && !isEditing) {
          var isFocusedRowElement = "row" === this._getElementType($target) && this.isRowFocusType() && isDataRow($target);
          var isFocusedSelectionCell = $target.hasClass(COMMAND_SELECT_CLASS2);
          if (isFocusedSelectionCell && "onClick" === this.option("selection.showCheckBoxesMode")) {
            this._selectionController.startSelectionWithCheckboxes();
          }
          if (isFocusedRowElement || $target.parent().hasClass(DATA_ROW_CLASS3) || $target.hasClass(this.addWidgetPrefix(ROWS_VIEW_CLASS2))) {
            this._selectionController.changeItemSelection(rowIndex, {
              shift: eventArgs.shift,
              control: eventArgs.ctrl
            });
            eventArgs.originalEvent.preventDefault();
            return true;
          }
          return false;
        } else {
          return this._beginFastEditing(eventArgs.originalEvent);
        }
      },
      _ctrlAKeyHandler: function(eventArgs, isEditing) {
        if (!isEditing && !eventArgs.alt && "multiple" === this.option("selection.mode") && this.option("selection.allowSelectAll")) {
          this._selectionController.selectAll();
          eventArgs.originalEvent.preventDefault();
        }
      },
      _tabKeyHandler: function(eventArgs, isEditing) {
        var editingOptions = this.option("editing");
        var direction = eventArgs.shift ? "previous" : "next";
        var isCellPositionDefined = isDefined(this._focusedCellPosition) && !isEmptyObject(this._focusedCellPosition);
        var isOriginalHandlerRequired = !isCellPositionDefined || !eventArgs.shift && this._isLastValidCell(this._focusedCellPosition) || eventArgs.shift && this._isFirstValidCell(this._focusedCellPosition);
        var eventTarget = eventArgs.originalEvent.target;
        var focusedViewElement = this._focusedView && this._focusedView.element();
        if (this._handleTabKeyOnMasterDetailCell(eventTarget, direction)) {
          return;
        }
        renderer_default(focusedViewElement).addClass(FOCUS_STATE_CLASS2);
        if (editingOptions && eventTarget && !isOriginalHandlerRequired) {
          if (renderer_default(eventTarget).hasClass(this.addWidgetPrefix(ROWS_VIEW_CLASS2))) {
            this._resetFocusedCell();
          }
          if (this._isVirtualColumnRender()) {
            this._processVirtualHorizontalPosition(direction);
          }
          if (isEditing) {
            if (!this._editingCellTabHandler(eventArgs, direction)) {
              return;
            }
          } else if (this._targetCellTabHandler(eventArgs, direction)) {
            isOriginalHandlerRequired = true;
          }
        }
        if (isOriginalHandlerRequired) {
          this._editorFactory.loseFocus();
          if (this._editingController.isEditing() && !this._isRowEditMode()) {
            this._resetFocusedCell(true);
            this._resetFocusedView();
            this._closeEditCell();
          }
        } else {
          eventArgs.originalEvent.preventDefault();
        }
      },
      _getMaxHorizontalOffset: function() {
        var scrollable = this.component.getScrollable();
        var rowsView = this.getView("rowsView");
        var offset2 = scrollable ? scrollable.scrollWidth() - renderer_default(rowsView.element()).width() : 0;
        return offset2;
      },
      _isColumnRendered: function(columnIndex) {
        var allVisibleColumns = this._columnsController.getVisibleColumns(null, true);
        var renderedVisibleColumns = this._columnsController.getVisibleColumns();
        var column = allVisibleColumns[columnIndex];
        var result2 = false;
        if (column) {
          result2 = renderedVisibleColumns.indexOf(column) >= 0;
        }
        return result2;
      },
      _isFixedColumn: function(columnIndex) {
        var allVisibleColumns = this._columnsController.getVisibleColumns(null, true);
        var column = allVisibleColumns[columnIndex];
        return !!column && !!column.fixed;
      },
      _isColumnVirtual: function(columnIndex) {
        var localColumnIndex = columnIndex - this._columnsController.getColumnIndexOffset();
        var visibleColumns = this._columnsController.getVisibleColumns();
        var column = visibleColumns[localColumnIndex];
        return !!column && "virtual" === column.command;
      },
      _processVirtualHorizontalPosition: function(direction) {
        var scrollable = this.component.getScrollable();
        var columnIndex = this.getColumnIndex();
        var nextColumnIndex;
        var horizontalScrollPosition = 0;
        var needToScroll = false;
        switch (direction) {
          case "next":
          case "nextInRow":
            var columnsCount = this._getVisibleColumnCount();
            nextColumnIndex = columnIndex + 1;
            horizontalScrollPosition = this.option("rtlEnabled") ? this._getMaxHorizontalOffset() : 0;
            if ("next" === direction) {
              needToScroll = columnsCount === nextColumnIndex || this._isFixedColumn(columnIndex) && !this._isColumnRendered(nextColumnIndex);
            } else {
              needToScroll = columnsCount > nextColumnIndex && this._isFixedColumn(columnIndex) && !this._isColumnRendered(nextColumnIndex);
            }
            break;
          case "previous":
          case "previousInRow":
            nextColumnIndex = columnIndex - 1;
            horizontalScrollPosition = this.option("rtlEnabled") ? 0 : this._getMaxHorizontalOffset();
            if ("previous" === direction) {
              var columnIndexOffset = this._columnsController.getColumnIndexOffset();
              var leftEdgePosition = nextColumnIndex < 0 && 0 === columnIndexOffset;
              needToScroll = leftEdgePosition || this._isFixedColumn(columnIndex) && !this._isColumnRendered(nextColumnIndex);
            } else {
              needToScroll = nextColumnIndex >= 0 && this._isFixedColumn(columnIndex) && !this._isColumnRendered(nextColumnIndex);
            }
        }
        if (needToScroll) {
          scrollable.scrollTo({
            left: horizontalScrollPosition
          });
        } else if (isDefined(nextColumnIndex) && isDefined(direction) && this._isColumnVirtual(nextColumnIndex)) {
          horizontalScrollPosition = this._getHorizontalScrollPositionOffset(direction);
          0 !== horizontalScrollPosition && scrollable.scrollBy({
            left: horizontalScrollPosition,
            top: 0
          });
        }
      },
      _getHorizontalScrollPositionOffset: function(direction) {
        var positionOffset = 0;
        var $currentCell = this._getCell(this._focusedCellPosition);
        var currentCellWidth = $currentCell && $currentCell.outerWidth();
        if (currentCellWidth > 0) {
          var rtlMultiplier = this.option("rtlEnabled") ? -1 : 1;
          positionOffset = "nextInRow" === direction || "next" === direction ? currentCellWidth * rtlMultiplier : currentCellWidth * rtlMultiplier * -1;
        }
        return positionOffset;
      },
      _editingCellTabHandler: function(eventArgs, direction) {
        var eventTarget = eventArgs.originalEvent.target;
        var $cell = this._getCellElementFromTarget(eventTarget);
        var isEditingAllowed;
        var $event = eventArgs.originalEvent;
        var elementType = this._getElementType(eventTarget);
        if ($cell.is(COMMAND_CELL_SELECTOR)) {
          return !this._targetCellTabHandler(eventArgs, direction);
        }
        this._updateFocusedCellPosition($cell);
        var nextCellInfo = this._getNextCellByTabKey($event, direction, elementType);
        $cell = nextCellInfo.$cell;
        if (!$cell || this._handleTabKeyOnMasterDetailCell($cell, direction)) {
          return false;
        }
        var columnsController = this._columnsController;
        var cellIndex = this.getView("rowsView").getCellIndex($cell);
        var columnIndex = cellIndex + columnsController.getColumnIndexOffset();
        var column = columnsController.getVisibleColumns(null, true)[columnIndex];
        var $row = $cell.parent();
        var rowIndex = this._getRowIndex($row);
        var row = this._dataController.items()[rowIndex];
        var editingController = this._editingController;
        if (column && column.allowEditing) {
          var _isDataRow = !row || "data" === row.rowType;
          isEditingAllowed = editingController.allowUpdating({
            row
          }) ? _isDataRow : row && row.isNewRow;
        }
        if (!isEditingAllowed) {
          this._closeEditCell();
        }
        if (this._focusCell($cell, !nextCellInfo.isHighlighted)) {
          if (!this._isRowEditMode() && isEditingAllowed) {
            this._editFocusedCell();
          } else {
            this._focusInteractiveElement($cell, eventArgs.shift);
          }
        }
        return true;
      },
      _targetCellTabHandler: function(eventArgs, direction) {
        var $event = eventArgs.originalEvent;
        var eventTarget = $event.target;
        var $cell = this._getCellElementFromTarget(eventTarget);
        var $lastInteractiveElement = this._getInteractiveElement($cell, !eventArgs.shift);
        var isOriginalHandlerRequired = false;
        var elementType;
        if (!isEditorCell(this, $cell) && $lastInteractiveElement.length && eventTarget !== $lastInteractiveElement.get(0)) {
          isOriginalHandlerRequired = true;
        } else {
          if (void 0 === this._focusedCellPosition.rowIndex && renderer_default(eventTarget).hasClass(ROW_CLASS6)) {
            this._updateFocusedCellPosition($cell);
          }
          elementType = this._getElementType(eventTarget);
          if (this.isRowFocusType()) {
            this.setCellFocusType();
            if ("row" === elementType && isDataRow(renderer_default(eventTarget))) {
              eventTarget = this.getFirstValidCellInRow(renderer_default(eventTarget));
              elementType = this._getElementType(eventTarget);
            }
          }
          var nextCellInfo = this._getNextCellByTabKey($event, direction, elementType);
          $cell = nextCellInfo.$cell;
          if (!$cell) {
            return false;
          }
          $cell = this._checkNewLineTransition($event, $cell);
          if (!$cell) {
            return false;
          }
          this._focusCell($cell, !nextCellInfo.isHighlighted);
          if (!isEditorCell(this, $cell)) {
            this._focusInteractiveElement($cell, eventArgs.shift);
          }
        }
        return isOriginalHandlerRequired;
      },
      _getNextCellByTabKey: function($event, direction, elementType) {
        var $cell = this._getNextCell(direction, elementType);
        var args = $cell && this._fireFocusedCellChanging($event, $cell, true);
        if (!args || args.cancel) {
          return {};
        }
        if (args.$newCellElement) {
          $cell = args.$newCellElement;
        }
        return {
          $cell,
          isHighlighted: args.isHighlighted
        };
      },
      _checkNewLineTransition: function($event, $cell) {
        var rowIndex = this.getVisibleRowIndex();
        var $row = $cell.parent();
        if (rowIndex !== this._getRowIndex($row)) {
          var cellPosition = this._getCellPosition($cell);
          var args = this._fireFocusedRowChanging($event, $row);
          if (args.cancel) {
            return;
          }
          if (args.rowIndexChanged) {
            this.setFocusedColumnIndex(cellPosition.columnIndex);
            $cell = this._getFocusedCell();
          }
        }
        return $cell;
      },
      _enterKeyHandler: function(eventArgs, isEditing) {
        var $cell = this._getFocusedCell();
        var rowIndex = this.getVisibleRowIndex();
        var $row = this._focusedView && this._focusedView.getRow(rowIndex);
        if (this.option("grouping.allowCollapsing") && isGroupRow($row) || this.option("masterDetail.enabled") && $cell && $cell.hasClass(COMMAND_EXPAND_CLASS)) {
          var key = this._dataController.getKeyByRowIndex(rowIndex);
          var item = this._dataController.items()[rowIndex];
          if (void 0 !== key && item && item.data && !item.data.isContinuation) {
            this._dataController.changeRowExpand(key);
          }
        } else {
          this._processEnterKeyForDataCell(eventArgs, isEditing);
        }
      },
      _processEnterKeyForDataCell: function(eventArgs, isEditing) {
        var direction = this._getEnterKeyDirection(eventArgs);
        var allowEditingOnEnterKey = this._allowEditingOnEnterKey();
        if (isEditing || !allowEditingOnEnterKey && direction) {
          this._handleEnterKeyEditingCell(eventArgs.originalEvent);
          if ("next" === direction || "previous" === direction) {
            this._targetCellTabHandler(eventArgs, direction);
          } else if ("upArrow" === direction || "downArrow" === direction) {
            this._navigateNextCell(eventArgs.originalEvent, direction);
          }
        } else if (allowEditingOnEnterKey) {
          this._startEditing(eventArgs);
        }
      },
      _getEnterKeyDirection: function(eventArgs) {
        var enterKeyDirection = this.option("keyboardNavigation.enterKeyDirection");
        var isShift = eventArgs.shift;
        if ("column" === enterKeyDirection) {
          return isShift ? "upArrow" : "downArrow";
        }
        if ("row" === enterKeyDirection) {
          return isShift ? "previous" : "next";
        }
      },
      _handleEnterKeyEditingCell: function(event) {
        var target = event.target;
        var $cell = this._getCellElementFromTarget(target);
        var isRowEditMode = this._isRowEditMode();
        this._updateFocusedCellPosition($cell);
        if (isRowEditMode) {
          this._focusEditFormCell($cell);
          setTimeout(this._editingController.saveEditData.bind(this._editingController));
        } else {
          events_engine_default.trigger(renderer_default(target), "change");
          this._closeEditCell();
          event.preventDefault();
        }
      },
      _escapeKeyHandler: function(eventArgs, isEditing) {
        var $cell = this._getCellElementFromTarget(eventArgs.originalEvent.target);
        if (isEditing) {
          this._updateFocusedCellPosition($cell);
          if (!this._isRowEditMode()) {
            if ("cell" === this._editingController.getEditMode()) {
              this._editingController.cancelEditData();
            } else {
              this._closeEditCell();
            }
          } else {
            this._focusEditFormCell($cell);
            this._editingController.cancelEditData();
            if (0 === this._dataController.items().length) {
              this._resetFocusedCell();
              this._editorFactory.loseFocus();
            }
          }
          eventArgs.originalEvent.preventDefault();
        }
      },
      _ctrlFKeyHandler: function(eventArgs) {
        if (this.option("searchPanel.visible")) {
          var searchTextEditor = this._headerPanel.getSearchTextEditor();
          if (searchTextEditor) {
            searchTextEditor.focus();
            eventArgs.originalEvent.preventDefault();
          }
        }
      },
      _f2KeyHandler: function() {
        var isEditing = this._editingController.isEditing();
        var rowIndex = this.getVisibleRowIndex();
        var $row = this._focusedView && this._focusedView.getRow(rowIndex);
        if (!isEditing && isDataRow($row)) {
          this._startEditing();
        }
      },
      _navigateNextCell: function($event, keyCode) {
        var $cell = this._getNextCell(keyCode);
        var directionCode = this._getDirectionCodeByKey(keyCode);
        var isCellValid = $cell && this._isCellValid($cell);
        var result2 = isCellValid ? this._arrowKeysHandlerFocusCell($event, $cell, directionCode) : false;
        return result2;
      },
      _arrowKeysHandlerFocusCell: function($event, $nextCell, direction) {
        var isVerticalDirection = "prevRow" === direction || "nextRow" === direction;
        var args = this._fireFocusChangingEvents($event, $nextCell, isVerticalDirection, true);
        $nextCell = args.$newCellElement;
        if (!args.cancel && this._isCellValid($nextCell)) {
          this._focus($nextCell, !args.isHighlighted);
          return true;
        }
        return false;
      },
      _beginFastEditing: function(originalEvent, isDeleting) {
        if (!this._isFastEditingAllowed() || originalEvent.altKey || originalEvent.ctrlKey || this._editingController.isEditing()) {
          return false;
        }
        if (isDeleting) {
          this._startEditing(originalEvent, FAST_EDITING_DELETE_KEY);
        } else {
          var key = originalEvent.key;
          var keyCode = originalEvent.keyCode || originalEvent.which;
          var fastEditingKey = key || keyCode && String.fromCharCode(keyCode);
          if (fastEditingKey && (1 === fastEditingKey.length || fastEditingKey === FAST_EDITING_DELETE_KEY)) {
            this._startEditing(originalEvent, fastEditingKey);
          }
        }
        return true;
      },
      _pointerEventHandler: function(e) {
        var event = e.event || e;
        var $target = renderer_default(event.currentTarget);
        var rowsView = this.getView("rowsView");
        var focusedViewElement = rowsView && rowsView.element();
        var $parent = $target.parent();
        var isInteractiveElement = renderer_default(event.target).is(INTERACTIVE_ELEMENTS_SELECTOR);
        var isRevertButton = !!renderer_default(event.target).closest(".".concat(REVERT_BUTTON_CLASS2)).length;
        var isExpandCommandCell = $target.hasClass(COMMAND_EXPAND_CLASS);
        if (!this._isEventInCurrentGrid(event)) {
          return;
        }
        if (!isRevertButton && (this._isCellValid($target, !isInteractiveElement) || isExpandCommandCell)) {
          $target = this._isInsideEditForm($target) ? renderer_default(event.target) : $target;
          this._focusView();
          renderer_default(focusedViewElement).removeClass(FOCUS_STATE_CLASS2);
          if ($parent.hasClass(FREESPACE_ROW_CLASS)) {
            this._updateFocusedCellPosition($target);
            this._applyTabIndexToElement(this._focusedView.element());
            this._focusedView.focus();
          } else if (!this._isMasterDetailCell($target)) {
            this._clickTargetCellHandler(event, $target);
          } else {
            this._updateFocusedCellPosition($target);
          }
        } else if ($target.is("td")) {
          this._resetFocusedCell();
        }
      },
      _clickTargetCellHandler: function(event, $cell) {
        var columnIndex = this.getView("rowsView").getCellIndex($cell);
        var column = this._columnsController.getVisibleColumns()[columnIndex];
        var isCellEditMode = this._isCellEditMode();
        this.setCellFocusType();
        var args = this._fireFocusChangingEvents(event, $cell, true);
        $cell = args.$newCellElement;
        if (!args.cancel) {
          if (args.resetFocusedRow) {
            this.getController("focus")._resetFocusedRow();
            return;
          }
          if (args.rowIndexChanged) {
            $cell = this._getFocusedCell();
          }
          if (!args.isHighlighted && !isCellEditMode) {
            this.setRowFocusType();
          }
          this._updateFocusedCellPosition($cell);
          if (this._allowRowUpdating() && isCellEditMode && column && column.allowEditing) {
            this._isNeedFocus = false;
            this._isHiddenFocus = false;
          } else {
            var $target = event && renderer_default(event.target).closest(NON_FOCUSABLE_ELEMENTS_SELECTOR + ", td");
            var skipFocusEvent = $target && $target.not($cell).is(NON_FOCUSABLE_ELEMENTS_SELECTOR);
            var isEditor = !!column && !column.command && $cell.hasClass(EDITOR_CELL_CLASS5);
            var isDisabled = !isEditor && (!args.isHighlighted || skipFocusEvent);
            this._focus($cell, isDisabled, skipFocusEvent);
          }
        } else {
          this.setRowFocusType();
          this.setFocusedRowIndex(args.prevRowIndex);
          $cell = this._getFocusedCell();
          if (this._editingController.isEditing() && isCellEditMode) {
            this._closeEditCell();
          }
        }
      },
      _allowRowUpdating: function() {
        var rowIndex = this.getVisibleRowIndex();
        var row = this._dataController.items()[rowIndex];
        return this._editingController.allowUpdating({
          row
        }, "click");
      },
      focus: function(element) {
        var activeElementSelector;
        var focusedRowEnabled = this.option("focusedRowEnabled");
        var isHighlighted = isCellElement(renderer_default(element));
        if (!element) {
          activeElementSelector = ".dx-datagrid-rowsview .dx-row[tabindex]";
          if (!focusedRowEnabled) {
            activeElementSelector += ", .dx-datagrid-rowsview .dx-row > td[tabindex]";
          }
          element = this.component.$element().find(activeElementSelector).first();
        }
        element && this._focusElement(renderer_default(element), isHighlighted);
      },
      getFocusedView: function() {
        return this._focusedView;
      },
      setupFocusedView: function() {
        if (this.isKeyboardEnabled() && !isDefined(this._focusedView)) {
          this._focusView();
        }
      },
      _focusElement: function($element, isHighlighted) {
        var rowsViewElement = renderer_default(this._getRowsViewElement());
        var $focusedView = $element.closest(rowsViewElement);
        var isRowFocusType = this.isRowFocusType();
        var args = {};
        if (!$focusedView.length || isCellElement($element) && !this._isCellValid($element)) {
          return;
        }
        this._focusView();
        this._isNeedFocus = true;
        this._isNeedScroll = true;
        if (isCellElement($element) || isGroupRow($element)) {
          this.setCellFocusType();
          args = this._fireFocusChangingEvents(null, $element, false, isHighlighted);
          $element = args.$newCellElement;
          if (isRowFocusType && !args.isHighlighted) {
            this.setRowFocusType();
          }
        }
        if (!args.cancel) {
          this._focus($element, !args.isHighlighted);
          this._focusInteractiveElement($element);
        }
      },
      _getFocusedViewByElement: function($element) {
        var view = this.getFocusedView();
        var $view = view && renderer_default(view.element());
        return $element && 0 !== $element.closest($view).length;
      },
      _focusView: function() {
        this._focusedView = this.getView("rowsView");
      },
      _resetFocusedView: function() {
        this.setRowFocusType();
        this._focusedView = null;
      },
      _focusInteractiveElement: function($cell, isLast) {
        if (!$cell) {
          return;
        }
        var $focusedElement = this._getInteractiveElement($cell, isLast);
        ui_grid_core_utils_default.focusAndSelectElement(this, $focusedElement);
      },
      _focus: function($cell, disableFocus, skipFocusEvent) {
        var $row = $cell && !$cell.hasClass(ROW_CLASS6) ? $cell.closest(".".concat(ROW_CLASS6)) : $cell;
        if ($row && isNotFocusedRow($row)) {
          return;
        }
        var focusedView = this._focusedView;
        var $focusViewElement = focusedView && focusedView.element();
        var $focusElement;
        this._isHiddenFocus = disableFocus;
        var isRowFocus = isGroupRow($row) || this.isRowFocusType();
        if (isRowFocus) {
          $focusElement = $row;
          if (focusedView) {
            this.setFocusedRowIndex(this._getRowIndex($row));
          }
        } else if (isCellElement($cell)) {
          $focusElement = $cell;
          this._updateFocusedCellPosition($cell);
        }
        if ($focusElement) {
          if ($focusViewElement) {
            $focusViewElement.find(".dx-row[tabindex], .dx-row > td[tabindex]").not($focusElement).removeClass(CELL_FOCUS_DISABLED_CLASS4).removeAttr("tabindex");
          }
          events_engine_default.one($focusElement, "blur", (e) => {
            if (e.relatedTarget) {
              $focusElement.removeClass(CELL_FOCUS_DISABLED_CLASS4);
            }
          });
          if (!skipFocusEvent) {
            this._applyTabIndexToElement($focusElement);
            events_engine_default.trigger($focusElement, "focus");
          }
          if (disableFocus) {
            $focusElement.addClass(CELL_FOCUS_DISABLED_CLASS4);
            if (isRowFocus) {
              $cell.addClass(CELL_FOCUS_DISABLED_CLASS4);
            }
          } else {
            this._editorFactory.focus($focusElement);
          }
        }
      },
      _updateFocus: function(isRenderView) {
        this._updateFocusTimeout = setTimeout(() => {
          var editingController = this._editingController;
          var isCellEditMode = editingController.getEditMode() === EDIT_MODE_CELL3;
          var isBatchEditMode = editingController.getEditMode() === EDIT_MODE_BATCH3;
          if (isCellEditMode && editingController.hasChanges() || isBatchEditMode && editingController.isNewRowInEditMode()) {
            editingController._focusEditingCell();
            return;
          }
          var $cell = this._getFocusedCell();
          var isEditing = editingController.isEditing();
          if ($cell && !(this._isMasterDetailCell($cell) && !this._isRowEditMode())) {
            if (this._hasSkipRow($cell.parent())) {
              var direction = this._focusedCellPosition && this._focusedCellPosition.rowIndex > 0 ? "upArrow" : "downArrow";
              $cell = this._getNextCell(direction);
            }
            if (isElementDefined($cell)) {
              if ($cell.is("td") || $cell.hasClass(this.addWidgetPrefix(EDIT_FORM_ITEM_CLASS2))) {
                var isCommandCell = $cell.is(COMMAND_CELL_SELECTOR);
                var $focusedElementInsideCell = $cell.find(":focus");
                var isFocusedElementDefined = isElementDefined($focusedElementInsideCell);
                if ((isRenderView || !isCommandCell) && this._editorFactory.focus()) {
                  if (isCommandCell && isFocusedElementDefined) {
                    ui_grid_core_utils_default.focusAndSelectElement(this, $focusedElementInsideCell);
                    return;
                  }
                  !isFocusedElementDefined && this._focus($cell);
                } else if (!isFocusedElementDefined && (this._isNeedFocus || this._isHiddenFocus)) {
                  this._focus($cell, this._isHiddenFocus);
                }
                if (isEditing) {
                  this._focusInteractiveElement.bind(this)($cell);
                }
              } else {
                events_engine_default.trigger($cell, "focus");
              }
            }
          }
        });
      },
      _getFocusedCell: function() {
        return renderer_default(this._getCell(this._focusedCellPosition));
      },
      _updateFocusedCellPositionByTarget: function(target) {
        var _this$_focusedCellPos;
        var elementType = this._getElementType(target);
        if ("row" === elementType && isDefined(null === (_this$_focusedCellPos = this._focusedCellPosition) || void 0 === _this$_focusedCellPos ? void 0 : _this$_focusedCellPos.columnIndex)) {
          var $row = renderer_default(target);
          this._focusedView && isGroupRow($row) && this.setFocusedRowIndex(this._getRowIndex($row));
        } else {
          this._updateFocusedCellPosition(this._getCellElementFromTarget(target));
        }
      },
      _updateFocusedCellPosition: function($cell, direction) {
        var position3 = this._getCellPosition($cell, direction);
        if (position3) {
          if (!$cell.length || position3.rowIndex >= 0 && position3.columnIndex >= 0) {
            this.setFocusedCellPosition(position3.rowIndex, position3.columnIndex);
          }
        }
        return position3;
      },
      _getFocusedColumnIndexOffset: function(columnIndex) {
        var offset2 = 0;
        var column = this._columnsController.getVisibleColumns()[columnIndex];
        if (column && column.fixed) {
          offset2 = this._getFixedColumnIndexOffset(column);
        } else if (columnIndex >= 0) {
          offset2 = this._columnsController.getColumnIndexOffset();
        }
        return offset2;
      },
      _getFixedColumnIndexOffset: function(column) {
        var offset2 = isFixedColumnIndexOffsetRequired(this, column) ? this._getVisibleColumnCount() - this._columnsController.getVisibleColumns().length : 0;
        return offset2;
      },
      _getCellPosition: function($cell, direction) {
        var columnIndex;
        var $row = isElementDefined($cell) && $cell.closest("tr");
        var rowsView = this.getView("rowsView");
        if (isElementDefined($row)) {
          var rowIndex = this._getRowIndex($row);
          columnIndex = rowsView.getCellIndex($cell, rowIndex);
          columnIndex += this._getFocusedColumnIndexOffset(columnIndex);
          if (direction) {
            columnIndex = "previous" === direction ? columnIndex - 1 : columnIndex + 1;
            columnIndex = this._applyColumnIndexBoundaries(columnIndex);
          }
          return {
            rowIndex,
            columnIndex
          };
        }
      },
      _focusCell: function($cell, isDisabled) {
        if (this._isCellValid($cell)) {
          this._focus($cell, isDisabled);
          return true;
        }
      },
      _focusEditFormCell: function($cell) {
        if ($cell.hasClass(MASTER_DETAIL_CELL_CLASS2)) {
          this._editorFactory.focus($cell, true);
        }
      },
      _resetFocusedCell: function(preventScroll) {
        var _this$_focusedView;
        var $cell = this._getFocusedCell();
        isElementDefined($cell) && $cell.removeAttr("tabindex");
        this._isNeedFocus = false;
        this._isNeedScroll = false;
        this._focusedCellPosition = {};
        clearTimeout(this._updateFocusTimeout);
        null === (_this$_focusedView = this._focusedView) || void 0 === _this$_focusedView ? void 0 : _this$_focusedView.renderFocusState(preventScroll);
      },
      restoreFocusableElement: function(rowIndex, $event) {
        var args;
        var $rowElement;
        var isUpArrow = isDefined(rowIndex);
        var rowsView = this.getView("rowsView");
        var $rowsViewElement = rowsView.element();
        var columnIndex = this._focusedCellPosition.columnIndex;
        var rowIndexOffset = this._dataController.getRowIndexOffset();
        rowIndex = isUpArrow ? rowIndex : rowsView.getTopVisibleItemIndex() + rowIndexOffset;
        if (!isUpArrow) {
          this._editorFactory.loseFocus();
          this._applyTabIndexToElement($rowsViewElement);
          events_engine_default.trigger($rowsViewElement, "focus");
        } else {
          $rowElement = rowsView.getRow(rowIndex - rowIndexOffset);
          args = this._fireFocusedRowChanging($event, $rowElement);
          if (!args.cancel && args.rowIndexChanged) {
            rowIndex = args.newRowIndex;
          }
        }
        if (!isUpArrow || !args.cancel) {
          this.setFocusedCellPosition(rowIndex, columnIndex);
        }
        isUpArrow && this._updateFocus();
      },
      _getNewPositionByCode: function(cellPosition, elementType, code) {
        var columnIndex = cellPosition.columnIndex;
        var rowIndex = cellPosition.rowIndex;
        var visibleColumnsCount;
        if (void 0 === cellPosition.rowIndex && "next" === code) {
          return {
            columnIndex: 0,
            rowIndex: 0
          };
        }
        switch (code) {
          case "nextInRow":
          case "next":
            visibleColumnsCount = this._getVisibleColumnCount();
            if (columnIndex < visibleColumnsCount - 1 && "row" !== elementType && this._hasValidCellAfterPosition({
              columnIndex,
              rowIndex
            })) {
              columnIndex++;
            } else if (!this._isLastRow(rowIndex) && "next" === code) {
              columnIndex = 0;
              rowIndex++;
            }
            break;
          case "previousInRow":
          case "previous":
            if (columnIndex > 0 && "row" !== elementType && this._hasValidCellBeforePosition({
              columnIndex,
              rowIndex
            })) {
              columnIndex--;
            } else if (rowIndex > 0 && "previous" === code) {
              rowIndex--;
              visibleColumnsCount = this._getVisibleColumnCount();
              columnIndex = visibleColumnsCount - 1;
            }
            break;
          case "upArrow":
            rowIndex = rowIndex > 0 ? rowIndex - 1 : rowIndex;
            break;
          case "downArrow":
            rowIndex = !this._isLastRow(rowIndex) ? rowIndex + 1 : rowIndex;
        }
        return {
          columnIndex,
          rowIndex
        };
      },
      setFocusedCellPosition: function(rowIndex, columnIndex) {
        this.setFocusedRowIndex(rowIndex);
        this.setFocusedColumnIndex(columnIndex);
      },
      setFocusedRowIndex: function(rowIndex) {
        if (!this._focusedCellPosition) {
          this._focusedCellPosition = {};
        }
        this._focusedCellPosition.rowIndex = rowIndex;
      },
      setFocusedColumnIndex: function(columnIndex) {
        if (!this._focusedCellPosition) {
          this._focusedCellPosition = {};
        }
        this._focusedCellPosition.columnIndex = columnIndex;
      },
      getRowIndex: function() {
        return this._focusedCellPosition ? this._focusedCellPosition.rowIndex : -1;
      },
      getColumnIndex: function() {
        return this._focusedCellPosition ? this._focusedCellPosition.columnIndex : -1;
      },
      getVisibleRowIndex: function() {
        var rowIndex = this._focusedCellPosition && this._focusedCellPosition.rowIndex;
        if (!isDefined(rowIndex)) {
          return -1;
        }
        return rowIndex - this._dataController.getRowIndexOffset();
      },
      getVisibleColumnIndex: function() {
        var columnIndex = this._focusedCellPosition && this._focusedCellPosition.columnIndex;
        if (!isDefined(columnIndex)) {
          return -1;
        }
        return columnIndex - this._columnsController.getColumnIndexOffset();
      },
      _applyColumnIndexBoundaries: function(columnIndex) {
        var visibleColumnsCount = this._getVisibleColumnCount();
        if (columnIndex < 0) {
          columnIndex = 0;
        } else if (columnIndex >= visibleColumnsCount) {
          columnIndex = visibleColumnsCount - 1;
        }
        return columnIndex;
      },
      _isCellByPositionValid: function(cellPosition) {
        var $cell = renderer_default(this._getCell(cellPosition));
        return this._isCellValid($cell);
      },
      _isLastRow: function(rowIndex) {
        var dataController = this._dataController;
        if (this._isVirtualRowRender()) {
          return rowIndex >= dataController.getMaxRowIndex();
        }
        return rowIndex === dataController.items().length - 1;
      },
      _isFirstValidCell: function(cellPosition) {
        var isFirstValidCell = false;
        if (0 === cellPosition.rowIndex && cellPosition.columnIndex >= 0) {
          isFirstValidCell = isFirstValidCell || !this._hasValidCellBeforePosition(cellPosition);
        }
        return isFirstValidCell;
      },
      _hasValidCellBeforePosition: function(cellPosition) {
        var columnIndex = cellPosition.columnIndex;
        var hasValidCells = false;
        while (columnIndex > 0 && !hasValidCells) {
          var checkingPosition = {
            columnIndex: --columnIndex,
            rowIndex: cellPosition.rowIndex
          };
          hasValidCells = this._isCellByPositionValid(checkingPosition);
        }
        return hasValidCells;
      },
      _hasValidCellAfterPosition: function(cellPosition) {
        var columnIndex = cellPosition.columnIndex;
        var hasValidCells = false;
        var visibleColumnCount = this._getVisibleColumnCount();
        while (columnIndex < visibleColumnCount - 1 && !hasValidCells) {
          var checkingPosition = {
            columnIndex: ++columnIndex,
            rowIndex: cellPosition.rowIndex
          };
          hasValidCells = this._isCellByPositionValid(checkingPosition);
        }
        return hasValidCells;
      },
      _isLastValidCell: function(cellPosition) {
        var nextColumnIndex = cellPosition.columnIndex >= 0 ? cellPosition.columnIndex + 1 : 0;
        var rowIndex = cellPosition.rowIndex;
        var checkingPosition = {
          columnIndex: nextColumnIndex,
          rowIndex
        };
        var visibleRows = this._dataController.getVisibleRows();
        var row = visibleRows && visibleRows[rowIndex];
        var isLastRow = this._isLastRow(rowIndex);
        if (!isLastRow) {
          return false;
        }
        if (row && "group" === row.rowType && cellPosition.columnIndex > 0) {
          return true;
        }
        if (cellPosition.columnIndex === this._getVisibleColumnCount() - 1) {
          return true;
        }
        if (this._isCellByPositionValid(checkingPosition)) {
          return false;
        }
        return this._isLastValidCell(checkingPosition);
      },
      _isCellValid: function($cell, isClick) {
        if (isElementDefined($cell)) {
          var rowsView = this.getView("rowsView");
          var $row = $cell.parent();
          var columnsController = this._columnsController;
          var columnIndex = rowsView.getCellIndex($cell) + columnsController.getColumnIndexOffset();
          var column = columnsController.getVisibleColumns(null, true)[columnIndex];
          var visibleColumnCount = this._getVisibleColumnCount();
          var editingController = this._editingController;
          var isMasterDetailRow = isDetailRow($row);
          var isShowWhenGrouped = column && column.showWhenGrouped;
          var isDataCell = column && !$cell.hasClass(COMMAND_EXPAND_CLASS) && isDataRow($row);
          if (this._isMasterDetailCell($cell)) {
            return true;
          }
          if (visibleColumnCount > columnIndex && (!isMasterDetailRow && column && (!isDefined(column.groupIndex) || isShowWhenGrouped && isDataCell) || parseInt($cell.attr("colspan")) > 1)) {
            var rowItems = this._dataController.items();
            var visibleRowIndex = rowsView.getRowIndex($row);
            var row = rowItems[visibleRowIndex];
            var isCellEditing = editingController && this._isCellEditMode() && editingController.isEditing();
            var isRowEditingInCurrentRow = editingController && editingController.isEditRow(visibleRowIndex);
            var isEditing = isRowEditingInCurrentRow || isCellEditing;
            if (column.command) {
              if (this._isLegacyNavigation()) {
                return !isEditing && "expand" === column.command;
              }
              if (isCellEditing) {
                return false;
              }
              if (isRowEditingInCurrentRow) {
                return "select" !== column.command;
              }
              return !isEditing;
            }
            if (isCellEditing && row && "data" !== row.rowType) {
              return false;
            }
            return !isEditing || column.allowEditing || isClick;
          }
        }
      },
      getFirstValidCellInRow: function($row, columnIndex) {
        var $cells = $row.find("> td");
        var $cell;
        var $result;
        columnIndex = columnIndex || 0;
        for (var i = columnIndex; i < $cells.length; ++i) {
          $cell = $cells.eq(i);
          if (this._isCellValid($cell)) {
            $result = $cell;
            break;
          }
        }
        return $result;
      },
      _getNextCell: function(keyCode, elementType, cellPosition) {
        var focusedCellPosition = cellPosition || this._focusedCellPosition;
        var isRowFocusType = this.isRowFocusType();
        var includeCommandCells = isRowFocusType || inArray(keyCode, ["next", "previous"]) > -1;
        var $cell;
        var $row;
        if (this._focusedView && focusedCellPosition) {
          var newFocusedCellPosition = this._getNewPositionByCode(focusedCellPosition, elementType, keyCode);
          $cell = renderer_default(this._getCell(newFocusedCellPosition));
          var isLastCellOnDirection = "previous" === keyCode ? this._isFirstValidCell(newFocusedCellPosition) : this._isLastValidCell(newFocusedCellPosition);
          if (isElementDefined($cell) && !this._isCellValid($cell) && this._isCellInRow(newFocusedCellPosition, includeCommandCells) && !isLastCellOnDirection) {
            if (isRowFocusType) {
              $cell = this.getFirstValidCellInRow($cell.parent(), newFocusedCellPosition.columnIndex);
            } else {
              $cell = this._getNextCell(keyCode, "cell", newFocusedCellPosition);
            }
          }
          $row = isElementDefined($cell) && $cell.parent();
          if (this._hasSkipRow($row)) {
            var rowIndex = this._getRowIndex($row);
            if (!this._isLastRow(rowIndex)) {
              $cell = this._getNextCell(keyCode, "row", {
                columnIndex: focusedCellPosition.columnIndex,
                rowIndex
              });
            } else {
              return null;
            }
          }
          return isElementDefined($cell) ? $cell : null;
        }
        return null;
      },
      _startEditing: function(eventArgs, fastEditingKey) {
        var focusedCellPosition = this._focusedCellPosition;
        var visibleRowIndex = this.getVisibleRowIndex();
        var visibleColumnIndex = this.getVisibleColumnIndex();
        var row = this._dataController.items()[visibleRowIndex];
        var column = this._columnsController.getVisibleColumns()[visibleColumnIndex];
        if (this._isAllowEditing(row, column)) {
          if (this._isRowEditMode()) {
            this._editingController.editRow(visibleRowIndex);
          } else if (focusedCellPosition) {
            this._startEditCell(eventArgs, fastEditingKey);
          }
        }
      },
      _isAllowEditing: function(row, column) {
        return this._editingController.allowUpdating({
          row
        }) && column && column.allowEditing;
      },
      _editFocusedCell: function() {
        var rowIndex = this.getVisibleRowIndex();
        var colIndex = this.getVisibleColumnIndex();
        return this._editingController.editCell(rowIndex, colIndex);
      },
      _startEditCell: function(eventArgs, fastEditingKey) {
        this._fastEditingStarted = isDefined(fastEditingKey);
        var editResult = this._editFocusedCell();
        if (this._isFastEditingStarted()) {
          if (true === editResult) {
            this._editingCellHandler(eventArgs, fastEditingKey);
          } else if (editResult && editResult.done) {
            var editorValue = fastEditingKey !== FAST_EDITING_DELETE_KEY ? fastEditingKey : "";
            editResult.done(() => this._editingCellHandler(eventArgs, editorValue));
          }
        }
      },
      _editingCellHandler: function(eventArgs, editorValue) {
        var _$input$get$select, _$input$get;
        var $input = this._getFocusedCell().find(INTERACTIVE_ELEMENTS_SELECTOR).eq(0);
        var keyDownEvent = createEvent(eventArgs, {
          type: "keydown",
          target: $input.get(0)
        });
        var keyPressEvent = createEvent(eventArgs, {
          type: "keypress",
          target: $input.get(0)
        });
        var inputEvent = createEvent(eventArgs, {
          type: "input",
          target: $input.get(0)
        });
        null === (_$input$get$select = (_$input$get = $input.get(0)).select) || void 0 === _$input$get$select ? void 0 : _$input$get$select.call(_$input$get);
        events_engine_default.trigger($input, keyDownEvent);
        if (!keyDownEvent.isDefaultPrevented()) {
          events_engine_default.trigger($input, keyPressEvent);
          if (!keyPressEvent.isDefaultPrevented()) {
            var timeout = browser_default.mozilla ? 25 : 0;
            setTimeout(() => {
              $input.val(editorValue);
              if (browser_default.msie) {
                ui_grid_core_utils_default.setSelectionRange($input.get(0), {
                  selectionStart: editorValue.length,
                  selectionEnd: editorValue.length
                });
              }
              var $widgetContainer = $input.closest(".".concat(WIDGET_CLASS6));
              events_engine_default.off($widgetContainer, "focusout");
              events_engine_default.one($widgetContainer, "focusout", function() {
                events_engine_default.trigger($input, "change");
              });
              events_engine_default.trigger($input, inputEvent);
            }, timeout);
          }
        }
      },
      _fireFocusChangingEvents: function($event, $cell, fireRowEvent, isHighlighted) {
        var args = {};
        var cellPosition = this._getCellPosition($cell) || {};
        if (this.isCellFocusType()) {
          args = this._fireFocusedCellChanging($event, $cell, isHighlighted);
          if (!args.cancel) {
            cellPosition.columnIndex = args.newColumnIndex;
            cellPosition.rowIndex = args.newRowIndex;
            isHighlighted = args.isHighlighted;
            $cell = renderer_default(this._getCell(cellPosition));
          }
        }
        if (!args.cancel && fireRowEvent && $cell) {
          args = this._fireFocusedRowChanging($event, $cell.parent());
          if (!args.cancel) {
            cellPosition.rowIndex = args.newRowIndex;
            args.isHighlighted = isHighlighted;
          }
        }
        args.$newCellElement = renderer_default(this._getCell(cellPosition));
        if (!args.$newCellElement.length) {
          args.$newCellElement = $cell;
        }
        return args;
      },
      _fireFocusedCellChanging: function($event, $cellElement, isHighlighted) {
        var prevCellIndex = this.option("focusedColumnIndex");
        var prevRowIndex = this.option("focusedRowIndex");
        var cellPosition = this._getCellPosition($cellElement);
        var columnIndex = cellPosition ? cellPosition.columnIndex : -1;
        var rowIndex = cellPosition ? cellPosition.rowIndex : -1;
        var args = {
          cellElement: $cellElement,
          prevColumnIndex: prevCellIndex,
          prevRowIndex,
          newColumnIndex: columnIndex,
          newRowIndex: rowIndex,
          rows: this._dataController.getVisibleRows(),
          columns: this._columnsController.getVisibleColumns(),
          event: $event,
          isHighlighted: isHighlighted || false,
          cancel: false
        };
        this._canceledCellPosition = null;
        this.executeAction("onFocusedCellChanging", args);
        if (args.newColumnIndex !== columnIndex || args.newRowIndex !== rowIndex) {
          args.$newCellElement = renderer_default(this._getCell({
            columnIndex: args.newColumnIndex,
            rowIndex: args.newRowIndex
          }));
        }
        if (args.cancel) {
          this._canceledCellPosition = {
            rowIndex,
            columnIndex
          };
        }
        return args;
      },
      _fireFocusedCellChanged: function($cellElement, prevCellIndex, prevRowIndex) {
        var dataController = this._dataController;
        var columnIndex = this.getView("rowsView").getCellIndex($cellElement);
        var rowIndex = this._getRowIndex($cellElement && $cellElement.parent());
        var localRowIndex = Math.min(rowIndex - dataController.getRowIndexOffset(), dataController.items().length - 1);
        var isEditingCell2 = this._editingController.isEditCell(localRowIndex, columnIndex);
        var row = dataController.items()[localRowIndex];
        if (!isEditingCell2 && (prevCellIndex !== columnIndex || prevRowIndex !== rowIndex)) {
          this.executeAction("onFocusedCellChanged", {
            cellElement: $cellElement,
            columnIndex,
            rowIndex,
            row,
            column: this._columnsController.getVisibleColumns()[columnIndex]
          });
        }
      },
      _fireFocusedRowChanging: function(eventArgs, $newFocusedRow) {
        var newRowIndex = this._getRowIndex($newFocusedRow);
        var dataController = this._dataController;
        var prevFocusedRowIndex = this.option("focusedRowIndex");
        var loadingOperationTypes = dataController.loadingOperationTypes();
        var args = {
          rowElement: $newFocusedRow,
          prevRowIndex: prevFocusedRowIndex,
          newRowIndex,
          event: eventArgs,
          rows: dataController.getVisibleRows(),
          cancel: false
        };
        if (!dataController || dataController.isLoading() && (loadingOperationTypes.reload || loadingOperationTypes.paging)) {
          args.cancel = true;
          return args;
        }
        if (this.option("focusedRowEnabled")) {
          this.executeAction("onFocusedRowChanging", args);
          if (!args.cancel && args.newRowIndex !== newRowIndex) {
            args.resetFocusedRow = args.newRowIndex < 0;
            if (!args.resetFocusedRow) {
              this.setFocusedRowIndex(args.newRowIndex);
            }
            args.rowIndexChanged = true;
          }
        }
        return args;
      },
      _fireFocusedRowChanged: function($rowElement) {
        var row;
        var focusedRowKey = this.option("focusedRowKey");
        var focusController = this.getController("focus");
        var focusedRowIndex = null === focusController || void 0 === focusController ? void 0 : focusController.getFocusedRowIndexByKey(focusedRowKey);
        if (this.option("focusedRowEnabled")) {
          if (focusedRowIndex >= 0) {
            var dataController = this._dataController;
            row = focusedRowIndex >= 0 && dataController.getVisibleRows()[focusedRowIndex - dataController.getRowIndexOffset()];
          }
          this.executeAction("onFocusedRowChanged", {
            rowElement: $rowElement,
            rowIndex: focusedRowIndex,
            row
          });
        }
      },
      _isEventInCurrentGrid: function(event) {
        return ui_grid_core_utils_default.isElementInCurrentGrid(this, renderer_default(event.target));
      },
      _isRowEditMode: function() {
        var editMode = this._editingController.getEditMode();
        return editMode === EDIT_MODE_ROW3 || editMode === EDIT_MODE_FORM3;
      },
      _isCellEditMode: function() {
        var editMode = this._editingController.getEditMode();
        return editMode === EDIT_MODE_CELL3 || editMode === EDIT_MODE_BATCH3;
      },
      _isFastEditingAllowed: function() {
        return this._isCellEditMode() && this.option("keyboardNavigation.editOnKeyPress");
      },
      _getInteractiveElement: function($cell, isLast) {
        var $focusedElement = $cell.find(INTERACTIVE_ELEMENTS_SELECTOR).filter(":visible");
        return isLast ? $focusedElement.last() : $focusedElement.first();
      },
      _applyTabIndexToElement: function($element) {
        var tabIndex = this.option("tabIndex") || 0;
        $element.attr("tabindex", isDefined(tabIndex) ? tabIndex : 0);
      },
      _getCell: function(cellPosition) {
        if (this._focusedView && cellPosition) {
          var rowIndexOffset = this._dataController.getRowIndexOffset();
          var column = this._columnsController.getVisibleColumns(null, true)[cellPosition.columnIndex];
          var columnIndexOffset = column && column.fixed ? this._getFixedColumnIndexOffset(column) : this._columnsController.getColumnIndexOffset();
          var rowIndex = cellPosition.rowIndex >= 0 ? cellPosition.rowIndex - rowIndexOffset : -1;
          var columnIndex = cellPosition.columnIndex >= 0 ? cellPosition.columnIndex - columnIndexOffset : -1;
          return this._focusedView.getCell({
            rowIndex,
            columnIndex
          });
        }
      },
      _getRowIndex: function($row) {
        var rowsView = this.getView("rowsView");
        var rowIndex = rowsView.getRowIndex($row);
        if (rowIndex >= 0) {
          rowIndex += this._dataController.getRowIndexOffset();
        }
        return rowIndex;
      },
      _hasSkipRow: function($row) {
        var row = $row && $row.get(0);
        return row && ("none" === row.style.display || $row.hasClass(this.addWidgetPrefix(GROUP_FOOTER_CLASS)) || isDetailRow($row) && !$row.hasClass(this.addWidgetPrefix(EDIT_FORM_CLASS2)));
      },
      _allowEditingOnEnterKey: function() {
        return "startEdit" === this.option("keyboardNavigation.enterKeyAction");
      },
      _isLegacyNavigation: function() {
        return this.option("useLegacyKeyboardNavigation");
      },
      _getDirectionCodeByKey: function(key) {
        var directionCode;
        switch (key) {
          case "upArrow":
            directionCode = "prevRow";
            break;
          case "downArrow":
            directionCode = "nextRow";
            break;
          case "leftArrow":
            directionCode = this.option("rtlEnabled") ? "nextInRow" : "previousInRow";
            break;
          case "rightArrow":
            directionCode = this.option("rtlEnabled") ? "previousInRow" : "nextInRow";
        }
        return directionCode;
      },
      _isVirtualScrolling: function() {
        var scrollingMode = this.option("scrolling.mode");
        return "virtual" === scrollingMode || "infinite" === scrollingMode;
      },
      _isVirtualRowRender: function() {
        return this._isVirtualScrolling() || "virtual" === this.option("scrolling.rowRenderingMode");
      },
      _isVirtualColumnRender: function() {
        return "virtual" === this.option("scrolling.columnRenderingMode");
      },
      _scrollBy: function(left, top, rowIndex, $event) {
        var that = this;
        var scrollable = this.getView("rowsView").getScrollable();
        if (that._focusedCellPosition) {
          scrollable.on("scroll", function scrollHandler() {
            scrollable.off("scroll", scrollHandler);
            setTimeout(that.restoreFocusableElement.bind(that, rowIndex, $event));
          });
        }
        return scrollable.scrollBy({
          left,
          top
        });
      },
      _isInsideEditForm: function(element) {
        var $editForm = renderer_default(element).closest("." + this.addWidgetPrefix(EDIT_FORM_CLASS2));
        return $editForm.length && this.elementIsInsideGrid($editForm);
      },
      _isMasterDetailCell: function(element) {
        var $masterDetailCell = renderer_default(element).closest("." + MASTER_DETAIL_CELL_CLASS2);
        return $masterDetailCell.length && this.elementIsInsideGrid($masterDetailCell);
      },
      _processNextCellInMasterDetail: function($nextCell) {
        if (!this._isInsideEditForm($nextCell) && $nextCell) {
          this._applyTabIndexToElement($nextCell);
        }
      },
      _handleTabKeyOnMasterDetailCell: function(target, direction) {
        if (this._isMasterDetailCell(target)) {
          this._updateFocusedCellPosition(renderer_default(target), direction);
          var $nextCell = this._getNextCell(direction, "row");
          this._processNextCellInMasterDetail($nextCell);
          return true;
        }
        return false;
      },
      _getElementType: function(target) {
        return renderer_default(target).is("tr") ? "row" : "cell";
      },
      _isFastEditingStarted: function() {
        return this._isFastEditingAllowed() && this._fastEditingStarted;
      },
      _getVisibleColumnCount: function() {
        return this._columnsController.getVisibleColumns(null, true).length;
      },
      _isCellInRow: function(cellPosition, includeCommandCells) {
        var columnIndex = cellPosition.columnIndex;
        var visibleColumnsCount = this._getVisibleColumnCount();
        return includeCommandCells ? columnIndex >= 0 && columnIndex <= visibleColumnsCount - 1 : columnIndex > 0 && columnIndex < visibleColumnsCount - 1;
      },
      _getCellElementFromTarget: function(target) {
        var elementType = this._getElementType(target);
        var $targetElement = renderer_default(target);
        var $cell;
        if ("cell" === elementType) {
          $cell = $targetElement.closest(".".concat(ROW_CLASS6, " > td"));
        } else {
          $cell = $targetElement.children().not("." + COMMAND_EXPAND_CLASS).first();
        }
        return $cell;
      },
      _getRowsViewElement: function() {
        var rowsView = this.getView("rowsView");
        return rowsView && rowsView.element();
      },
      isKeyboardEnabled: function() {
        return this.option("keyboardNavigation.enabled");
      },
      _processCanceledEditCellPosition: function(rowIndex, columnIndex) {
        if (this._canceledCellPosition) {
          var isCanceled = this._canceledCellPosition.rowIndex === rowIndex && this._canceledCellPosition.columnIndex === columnIndex;
          this._canceledCellPosition = null;
          return isCanceled;
        }
      }
    });
    keyboardNavigationModule = {
      defaultOptions: function() {
        return {
          useLegacyKeyboardNavigation: false,
          keyboardNavigation: {
            enabled: true,
            enterKeyAction: "startEdit",
            enterKeyDirection: "none",
            editOnKeyPress: false
          }
        };
      },
      controllers: {
        keyboardNavigation: KeyboardNavigationController
      },
      extenders: {
        views: {
          rowsView: {
            _rowClick: function(e) {
              var editRowIndex = this.getController("editing").getEditRowIndex();
              var keyboardController = this.getController("keyboardNavigation");
              if (editRowIndex === e.rowIndex) {
                keyboardController.setCellFocusType();
              }
              var needTriggerPointerEventHandler = isMobile() && this.option("focusedRowEnabled");
              if (needTriggerPointerEventHandler) {
                this._triggerPointerDownEventHandler(e);
              }
              this.callBase.apply(this, arguments);
            },
            _triggerPointerDownEventHandler: function(e) {
              var originalEvent = e.event.originalEvent;
              if (originalEvent) {
                var keyboardController = this.getController("keyboardNavigation");
                var $cell = renderer_default(originalEvent.target);
                var columnIndex = this.getCellIndex($cell);
                var column = this.getController("columns").getVisibleColumns()[columnIndex];
                var row = this.getController("data").items()[e.rowIndex];
                if (keyboardController._isAllowEditing(row, column)) {
                  var eventArgs = createEvent(originalEvent, {
                    currentTarget: originalEvent.target
                  });
                  keyboardController._pointerEventHandler(eventArgs);
                }
              }
            },
            renderFocusState: function(preventScroll) {
              var keyboardController = this.getController("keyboardNavigation");
              var $rowsViewElement = this.element();
              if ($rowsViewElement && !focused($rowsViewElement)) {
                $rowsViewElement.attr("tabindex", null);
              }
              var rowIndex = keyboardController.getVisibleRowIndex();
              if (!isDefined(rowIndex) || rowIndex < 0) {
                rowIndex = 0;
              }
              var cellElements = this.getCellElements(rowIndex);
              if (keyboardController.isKeyboardEnabled() && cellElements.length) {
                this.updateFocusElementTabIndex(cellElements, preventScroll);
              }
            },
            updateFocusElementTabIndex: function(cellElements) {
              var keyboardController = this.getController("keyboardNavigation");
              var $row = cellElements.eq(0).parent();
              if (isGroupRow($row)) {
                keyboardController._applyTabIndexToElement($row);
              } else {
                var columnIndex = keyboardController.getColumnIndex();
                if (!isDefined(columnIndex) || columnIndex < 0) {
                  columnIndex = 0;
                }
                this._updateFocusedCellTabIndex(cellElements, columnIndex);
              }
            },
            _updateFocusedCellTabIndex: function(cellElements, columnIndex) {
              var keyboardController = this.getController("keyboardNavigation");
              var cellElementsLength = cellElements ? cellElements.length : -1;
              var updateCellTabIndex = function($cell2) {
                var isMasterDetailCell = keyboardController._isMasterDetailCell($cell2);
                var isValidCell = keyboardController._isCellValid($cell2);
                if (!isMasterDetailCell && isValidCell && isCellElement($cell2)) {
                  keyboardController._applyTabIndexToElement($cell2);
                  keyboardController.setCellFocusType();
                  return true;
                }
              };
              var $cell = cellElements.filter("[aria-colindex='".concat(columnIndex + 1, "']"));
              if ($cell.length) {
                updateCellTabIndex($cell);
              } else {
                if (cellElementsLength <= columnIndex) {
                  columnIndex = cellElementsLength - 1;
                }
                for (var i = columnIndex; i < cellElementsLength; ++i) {
                  if (updateCellTabIndex(renderer_default(cellElements[i]))) {
                    break;
                  }
                }
              }
            },
            renderDelayedTemplates: function(change) {
              this.callBase.apply(this, arguments);
              this._renderFocusByChange(change);
            },
            _renderFocusByChange(change) {
              if (!change || !change.repaintChangesOnly) {
                var preventScroll = shouldPreventScroll(this);
                this.renderFocusState(preventScroll);
              }
            },
            _renderCore: function(change) {
              this.callBase.apply(this, arguments);
              this._renderFocusByChange(change);
            },
            _editCellPrepared: function($cell) {
              var editorInstance = this._getEditorInstance($cell);
              var keyboardController = this.getController("keyboardNavigation");
              var isEditingNavigationMode = keyboardController && keyboardController._isFastEditingStarted();
              if (editorInstance && isEditingNavigationMode) {
                this._handleEditingNavigationMode(editorInstance);
              }
              this.callBase.apply(this, arguments);
            },
            _handleEditingNavigationMode: function(editorInstance) {
              ["downArrow", "upArrow"].forEach(function(keyName) {
                var originalKeyHandler = editorInstance._supportedKeys()[keyName];
                editorInstance.registerKeyHandler(keyName, (e) => {
                  var isDropDownOpened = "true" === editorInstance._input().attr("aria-expanded");
                  if (isDropDownOpened) {
                    return originalKeyHandler && originalKeyHandler.call(editorInstance, e);
                  }
                });
              });
              editorInstance.registerKeyHandler("leftArrow", noop2);
              editorInstance.registerKeyHandler("rightArrow", noop2);
              var isDateBoxWithMask = editorInstance.NAME === DATEBOX_WIDGET_NAME && editorInstance.option("useMaskBehavior");
              if (isDateBoxWithMask) {
                editorInstance.registerKeyHandler("enter", noop2);
              }
            },
            _getEditorInstance: function($cell) {
              var $editor = $cell.find(".dx-texteditor").eq(0);
              return ui_grid_core_utils_default.getWidgetInstance($editor);
            }
          }
        },
        controllers: {
          editing: {
            editCell: function(rowIndex, columnIndex) {
              var keyboardController = this.getController("keyboardNavigation");
              if (keyboardController._processCanceledEditCellPosition(rowIndex, columnIndex)) {
                return false;
              }
              var isCellEditing = this.callBase(rowIndex, columnIndex);
              if (isCellEditing) {
                keyboardController.setupFocusedView();
              }
              return isCellEditing;
            },
            editRow: function(rowIndex) {
              var keyboardController = this.getController("keyboardNavigation");
              var visibleColumnIndex = keyboardController.getVisibleColumnIndex();
              var column = this._columnsController.getVisibleColumns()[visibleColumnIndex];
              if (column && column.type || this.option("editing.mode") === EDIT_MODE_FORM3) {
                keyboardController._resetFocusedCell();
              }
              this.callBase(rowIndex);
            },
            addRow: function(parentKey) {
              var keyboardController = this.getController("keyboardNavigation");
              keyboardController.setupFocusedView();
              keyboardController.setCellFocusType();
              return this.callBase.apply(this, arguments);
            },
            getFocusedCellInRow: function(rowIndex) {
              var keyboardNavigationController = this.getController("keyboardNavigation");
              var $cell = this.callBase(rowIndex);
              if (keyboardNavigationController.isKeyboardEnabled() && keyboardNavigationController._focusedCellPosition.rowIndex === rowIndex) {
                var $focusedCell = keyboardNavigationController._getFocusedCell();
                if (isElementDefined($focusedCell) && !$focusedCell.hasClass(COMMAND_EDIT_CLASS2)) {
                  $cell = $focusedCell;
                }
              }
              return $cell;
            },
            _processCanceledEditingCell: function() {
              this.closeEditCell().done(() => {
                var keyboardNavigation = this.getController("keyboardNavigation");
                keyboardNavigation._updateFocus();
              });
            },
            init: function() {
              this.callBase();
              this._keyboardNavigationController = this.getController("keyboardNavigation");
            },
            closeEditCell: function() {
              var keyboardNavigation = this._keyboardNavigationController;
              keyboardNavigation._fastEditingStarted = false;
              var result2 = this.callBase.apply(this, arguments);
              keyboardNavigation._updateFocus();
              return result2;
            },
            _delayedInputFocus: function() {
              this._keyboardNavigationController._isNeedScroll = true;
              this.callBase.apply(this, arguments);
            },
            _isEditingStart: function() {
              var keyboardNavigation = this.getController("keyboardNavigation");
              var cancel2 = this.callBase.apply(this, arguments);
              if (cancel2 && !keyboardNavigation._isNeedFocus) {
                var $cell = keyboardNavigation._getFocusedCell();
                keyboardNavigation._focus($cell, true);
              }
              return cancel2;
            }
          },
          data: {
            _correctRowIndices: function(getRowIndexCorrection) {
              var that = this;
              var keyboardNavigationController = that.getController("keyboardNavigation");
              var editorFactory = that.getController("editorFactory");
              var focusedCellPosition = keyboardNavigationController._focusedCellPosition;
              that.callBase.apply(that, arguments);
              if (focusedCellPosition && focusedCellPosition.rowIndex >= 0) {
                var focusedRowIndexCorrection = getRowIndexCorrection(focusedCellPosition.rowIndex);
                if (focusedRowIndexCorrection) {
                  focusedCellPosition.rowIndex += focusedRowIndexCorrection;
                  editorFactory.refocus();
                }
              }
            },
            getMaxRowIndex: function() {
              var result2 = this.items().length - 1;
              var virtualItemsCount = this.virtualItemsCount();
              if (virtualItemsCount) {
                result2 += virtualItemsCount.begin + virtualItemsCount.end;
              }
              return result2;
            }
          },
          adaptiveColumns: {
            _showHiddenCellsInView: function(_ref) {
              var {
                viewName: viewName2,
                $cells,
                isCommandColumn
              } = _ref;
              this.callBase.apply(this, arguments);
              viewName2 === COLUMN_HEADERS_VIEW && !isCommandColumn && $cells.each((_2, cellElement) => {
                var $cell = renderer_default(cellElement);
                isCellInHeaderRow($cell) && $cell.attr("tabindex", 0);
              });
            },
            _hideVisibleCellInView: function(_ref2) {
              var {
                viewName: viewName2,
                $cell,
                isCommandColumn
              } = _ref2;
              this.callBase.apply(this, arguments);
              if (viewName2 === COLUMN_HEADERS_VIEW && !isCommandColumn && isCellInHeaderRow($cell)) {
                $cell.removeAttr("tabindex");
              }
            }
          }
        }
      }
    };
  }
});

// node_modules/devextreme/esm/ui/grid_core/ui.grid_core.column_fixing.js
var CONTENT_CLASS4, CONTENT_FIXED_CLASS2, MASTER_DETAIL_CELL_CLASS3, FIRST_CELL_CLASS, LAST_CELL_CLASS, HOVER_STATE_CLASS, FIXED_COL_CLASS, FIXED_COLUMNS_CLASS, POINTER_EVENTS_NONE_CLASS, COMMAND_TRANSPARENT2, GROUP_ROW_CLASS3, getTransparentColumnIndex, normalizeColumnWidths, baseFixedColumns, ColumnHeadersViewFixedColumnsExtender, RowsViewFixedColumnsExtender, FooterViewFixedColumnsExtender, columnFixingModule;
var init_ui_grid_core_column_fixing = __esm({
  "node_modules/devextreme/esm/ui/grid_core/ui.grid_core.column_fixing.js"() {
    init_renderer();
    init_events_engine();
    init_wheel();
    init_message();
    init_ui_grid_core_utils();
    init_type();
    init_extend();
    init_iterator();
    init_browser();
    init_position();
    init_translator();
    init_ui_scrollable();
    CONTENT_CLASS4 = "content";
    CONTENT_FIXED_CLASS2 = "content-fixed";
    MASTER_DETAIL_CELL_CLASS3 = "dx-master-detail-cell";
    FIRST_CELL_CLASS = "dx-first-cell";
    LAST_CELL_CLASS = "dx-last-cell";
    HOVER_STATE_CLASS = "dx-state-hover";
    FIXED_COL_CLASS = "dx-col-fixed";
    FIXED_COLUMNS_CLASS = "dx-fixed-columns";
    POINTER_EVENTS_NONE_CLASS = "dx-pointer-events-none";
    COMMAND_TRANSPARENT2 = "transparent";
    GROUP_ROW_CLASS3 = "dx-group-row";
    getTransparentColumnIndex = function(fixedColumns) {
      var transparentColumnIndex = -1;
      each(fixedColumns, function(index2, column) {
        if (column.command === COMMAND_TRANSPARENT2) {
          transparentColumnIndex = index2;
          return false;
        }
      });
      return transparentColumnIndex;
    };
    normalizeColumnWidths = function(fixedColumns, widths, fixedWidths) {
      var fixedColumnIndex = 0;
      if (fixedColumns && widths && fixedWidths) {
        for (var i = 0; i < fixedColumns.length; i++) {
          if (fixedColumns[i].command === COMMAND_TRANSPARENT2) {
            fixedColumnIndex += fixedColumns[i].colspan;
          } else {
            if (widths[fixedColumnIndex] < fixedWidths[i]) {
              widths[fixedColumnIndex] = fixedWidths[i];
            }
            fixedColumnIndex++;
          }
        }
      }
      return widths;
    };
    baseFixedColumns = {
      init: function() {
        this.callBase();
        this._isFixedTableRendering = false;
        this._isFixedColumns = false;
      },
      _createCol: function(column) {
        return this.callBase(column).toggleClass(FIXED_COL_CLASS, !!(this._isFixedTableRendering && (column.fixed || column.command && column.command !== COMMAND_TRANSPARENT2)));
      },
      _correctColumnIndicesForFixedColumns: function(fixedColumns, change) {
        var transparentColumnIndex = getTransparentColumnIndex(fixedColumns);
        var transparentColspan = fixedColumns[transparentColumnIndex].colspan;
        var columnIndices = change && change.columnIndices;
        if (columnIndices) {
          change.columnIndices = columnIndices.map(function(columnIndices2) {
            if (columnIndices2) {
              return columnIndices2.map(function(columnIndex) {
                if (columnIndex < transparentColumnIndex) {
                  return columnIndex;
                } else if (columnIndex >= transparentColumnIndex + transparentColspan) {
                  return columnIndex - transparentColspan + 1;
                }
                return -1;
              }).filter(function(columnIndex) {
                return columnIndex >= 0;
              });
            }
          });
        }
      },
      _renderTable: function(options2) {
        var $fixedTable;
        var fixedColumns = this.getFixedColumns();
        this._isFixedColumns = !!fixedColumns.length;
        var $table = this.callBase(options2);
        if (this._isFixedColumns) {
          this._isFixedTableRendering = true;
          var change = options2 && options2.change;
          var columnIndices = change && change.columnIndices;
          this._correctColumnIndicesForFixedColumns(fixedColumns, change);
          $fixedTable = this._createTable(fixedColumns);
          this._renderRows($fixedTable, extend2({}, options2, {
            columns: fixedColumns
          }));
          this._updateContent($fixedTable, change);
          if (columnIndices) {
            change.columnIndices = columnIndices;
          }
          this._isFixedTableRendering = false;
        } else {
          this._fixedTableElement && this._fixedTableElement.parent().remove();
          this._fixedTableElement = null;
        }
        return $table;
      },
      _renderRow: function($table, options2) {
        var fixedCorrection;
        var cells = options2.row.cells;
        this.callBase.apply(this, arguments);
        if (this._isFixedTableRendering && cells && cells.length) {
          fixedCorrection = 0;
          var fixedCells = options2.row.cells || [];
          cells = cells.slice();
          options2.row.cells = cells;
          for (var i = 0; i < fixedCells.length; i++) {
            if (fixedCells[i].column && fixedCells[i].column.command === COMMAND_TRANSPARENT2) {
              fixedCorrection = (fixedCells[i].column.colspan || 1) - 1;
              continue;
            }
            cells[i + fixedCorrection] = fixedCells[i];
          }
        }
      },
      _createCell: function(options2) {
        var that = this;
        var column = options2.column;
        var columnCommand = column && column.command;
        var rowType = options2.rowType;
        var $cell = that.callBase.apply(that, arguments);
        var fixedColumns;
        var prevFixedColumn;
        var transparentColumnIndex;
        if (that._isFixedTableRendering || "filter" === rowType) {
          fixedColumns = that.getFixedColumns();
          transparentColumnIndex = getTransparentColumnIndex(fixedColumns);
          prevFixedColumn = fixedColumns[transparentColumnIndex - 1];
        }
        if (that._isFixedTableRendering) {
          if (columnCommand === COMMAND_TRANSPARENT2) {
            $cell.addClass(POINTER_EVENTS_NONE_CLASS).toggleClass(FIRST_CELL_CLASS, 0 === transparentColumnIndex || prevFixedColumn && "expand" === prevFixedColumn.command).toggleClass(LAST_CELL_CLASS, fixedColumns.length && transparentColumnIndex === fixedColumns.length - 1);
            if ("freeSpace" !== rowType) {
              ui_grid_core_utils_default.setEmptyText($cell);
            }
          }
        } else if ("filter" === rowType) {
          $cell.toggleClass(FIRST_CELL_CLASS, options2.columnIndex === transparentColumnIndex);
        }
        var isRowAltStyle = that.option("rowAlternationEnabled") && options2.isAltRow;
        if (browser_default.mozilla && options2.column.fixed && "group" !== options2.rowType && !isRowAltStyle) {
          $cell.addClass(FIXED_COL_CLASS);
        }
        return $cell;
      },
      _wrapTableInScrollContainer: function() {
        var $scrollContainer = this.callBase.apply(this, arguments);
        if (this._isFixedTableRendering) {
          $scrollContainer.addClass(this.addWidgetPrefix(CONTENT_FIXED_CLASS2));
        }
        return $scrollContainer;
      },
      _renderCellContent: function($cell, options2) {
        var isEmptyCell;
        var column = options2.column;
        var isFixedTableRendering = this._isFixedTableRendering;
        var isGroupCell = "group" === options2.rowType && isDefined(column.groupIndex);
        if (isFixedTableRendering && isGroupCell && !column.command && !column.groupCellTemplate) {
          $cell.css("pointerEvents", "none");
        }
        if (!isFixedTableRendering && this._isFixedColumns) {
          isEmptyCell = column.fixed || column.command && false !== column.fixed;
          if (isGroupCell) {
            isEmptyCell = false;
            if (options2.row.summaryCells && options2.row.summaryCells.length) {
              var columns = this._columnsController.getVisibleColumns();
              var alignByFixedColumnCellCount = this._getAlignByColumnCellCount ? this._getAlignByColumnCellCount(column.colspan, {
                columns,
                row: options2.row,
                isFixed: true
              }) : 0;
              if (alignByFixedColumnCellCount > 0) {
                var transparentColumnIndex = getTransparentColumnIndex(this._columnsController.getFixedColumns());
                isEmptyCell = columns.length - alignByFixedColumnCellCount < transparentColumnIndex;
              }
            }
          }
          if (isEmptyCell) {
            if (column.command && "buttons" !== column.type || "group" === options2.rowType) {
              $cell.html("&nbsp;").addClass(column.cssClass);
              return;
            } else {
              $cell.addClass("dx-hidden-cell");
            }
          }
        }
        if (column.command !== COMMAND_TRANSPARENT2) {
          this.callBase($cell, options2);
        }
      },
      _getCellElementsCore: function(rowIndex) {
        var cellElements = this.callBase.apply(this, arguments);
        var isGroupRow2 = cellElements.parent().hasClass(GROUP_ROW_CLASS3);
        var headerRowIndex = "columnHeadersView" === this.name ? rowIndex : void 0;
        if (this._fixedTableElement && cellElements) {
          var fixedColumns = this.getFixedColumns(headerRowIndex);
          var fixedCellElements = this._getRowElements(this._fixedTableElement).eq(rowIndex).children("td");
          each(fixedCellElements, (columnIndex, cell) => {
            if (isGroupRow2) {
              if (cellElements[columnIndex] && "hidden" !== cell.style.visibility) {
                cellElements[columnIndex] = cell;
              }
            } else {
              var fixedColumn = fixedColumns[columnIndex];
              if (fixedColumn) {
                if (fixedColumn.command === COMMAND_TRANSPARENT2) {
                  if (fixedCellElements.eq(columnIndex).hasClass(MASTER_DETAIL_CELL_CLASS3)) {
                    cellElements[columnIndex] = cell || cellElements[columnIndex];
                  }
                } else {
                  var fixedColumnIndex = this._columnsController.getVisibleIndexByColumn(fixedColumn, headerRowIndex);
                  cellElements[fixedColumnIndex] = cell || cellElements[fixedColumnIndex];
                }
              }
            }
          });
        }
        return cellElements;
      },
      getColumnWidths: function() {
        var fixedWidths;
        var result2 = this.callBase();
        var fixedColumns = this.getFixedColumns();
        if (this._fixedTableElement && result2.length) {
          fixedWidths = this.callBase(this._fixedTableElement);
        }
        return normalizeColumnWidths(fixedColumns, result2, fixedWidths);
      },
      getTableElement: function() {
        var tableElement = this._isFixedTableRendering ? this._fixedTableElement : this.callBase();
        return tableElement;
      },
      setTableElement: function(tableElement) {
        if (this._isFixedTableRendering) {
          this._fixedTableElement = tableElement.addClass(POINTER_EVENTS_NONE_CLASS);
        } else {
          this.callBase(tableElement);
        }
      },
      getColumns: function(rowIndex, $tableElement) {
        $tableElement = $tableElement || this.getTableElement();
        if (this._isFixedTableRendering || $tableElement && $tableElement.closest("table").parent("." + this.addWidgetPrefix(CONTENT_FIXED_CLASS2)).length) {
          return this.getFixedColumns(rowIndex);
        }
        return this.callBase(rowIndex, $tableElement);
      },
      getRowIndex: function($row) {
        var $fixedTable = this._fixedTableElement;
        if ($fixedTable && $fixedTable.find($row).length) {
          return this._getRowElements($fixedTable).index($row);
        }
        return this.callBase($row);
      },
      getTableElements: function() {
        var result2 = this.callBase.apply(this, arguments);
        if (this._fixedTableElement) {
          result2 = renderer_default([result2.get(0), this._fixedTableElement.get(0)]);
        }
        return result2;
      },
      getFixedColumns: function(rowIndex) {
        return this._columnsController.getFixedColumns(rowIndex);
      },
      getFixedColumnsOffset: function() {
        var offset2 = {
          left: 0,
          right: 0
        };
        var $transparentColumn;
        if (this._fixedTableElement) {
          $transparentColumn = this.getTransparentColumnElement();
          var positionTransparentColumn = $transparentColumn.position();
          offset2 = {
            left: positionTransparentColumn.left,
            right: this.element().outerWidth(true) - ($transparentColumn.outerWidth(true) + positionTransparentColumn.left)
          };
        }
        return offset2;
      },
      getTransparentColumnElement: function() {
        return this._fixedTableElement && this._fixedTableElement.find("." + POINTER_EVENTS_NONE_CLASS).first();
      },
      getFixedTableElement: function() {
        return this._fixedTableElement;
      },
      isFixedColumns: function() {
        return this._isFixedColumns;
      },
      _resizeCore: function() {
        this.callBase();
        this.synchronizeRows();
      },
      setColumnWidths: function(options2) {
        var columns;
        var visibleColumns = this._columnsController.getVisibleColumns();
        var widths = options2.widths;
        var isWidthsSynchronized = widths && widths.length && isDefined(visibleColumns[0].visibleWidth);
        var optionNames = options2.optionNames;
        var isColumnWidthChanged = optionNames && optionNames.width;
        var useVisibleColumns = false;
        this.callBase.apply(this, arguments);
        if (this._fixedTableElement) {
          var hasAutoWidth = widths && widths.some(function(width) {
            return "auto" === width;
          });
          useVisibleColumns = hasAutoWidth && (!isWidthsSynchronized || !this.isScrollbarVisible(true));
          if (useVisibleColumns) {
            columns = visibleColumns;
          }
          this.callBase(extend2({}, options2, {
            $tableElement: this._fixedTableElement,
            columns,
            fixed: true
          }));
        }
        if (isWidthsSynchronized || isColumnWidthChanged && this.option("wordWrapEnabled")) {
          this.synchronizeRows();
        }
      },
      _createColGroup: function(columns) {
        if (this._isFixedTableRendering && !this.option("columnAutoWidth")) {
          var visibleColumns = this._columnsController.getVisibleColumns();
          var useVisibleColumns = visibleColumns.filter(function(column) {
            return !column.width;
          }).length;
          if (useVisibleColumns) {
            columns = visibleColumns;
          }
        }
        return this.callBase(columns);
      },
      _getClientHeight: function(element) {
        var boundingClientRectElement = element.getBoundingClientRect && getBoundingRect(element);
        return boundingClientRectElement && boundingClientRectElement.height ? boundingClientRectElement.height : element.clientHeight;
      },
      synchronizeRows: function() {
        var rowHeights = [];
        var fixedRowHeights = [];
        var rowIndex;
        var $rowElements;
        var $fixedRowElements;
        var $contentElement;
        if (this._isFixedColumns && this._tableElement && this._fixedTableElement) {
          var heightTable = this._getClientHeight(this._tableElement.get(0));
          var heightFixedTable = this._getClientHeight(this._fixedTableElement.get(0));
          $rowElements = this._getRowElements(this._tableElement);
          $fixedRowElements = this._getRowElements(this._fixedTableElement);
          $contentElement = this._findContentElement();
          if (heightTable !== heightFixedTable) {
            $contentElement && $contentElement.css("height", heightTable);
            $rowElements.css("height", "");
            $fixedRowElements.css("height", "");
            for (rowIndex = 0; rowIndex < $rowElements.length; rowIndex++) {
              rowHeights.push(this._getClientHeight($rowElements.get(rowIndex)));
              fixedRowHeights.push(this._getClientHeight($fixedRowElements.get(rowIndex)));
            }
            for (rowIndex = 0; rowIndex < $rowElements.length; rowIndex++) {
              var rowHeight = rowHeights[rowIndex];
              var fixedRowHeight = fixedRowHeights[rowIndex];
              if (rowHeight > fixedRowHeight) {
                $fixedRowElements.eq(rowIndex).css("height", rowHeight);
              } else if (rowHeight < fixedRowHeight) {
                $rowElements.eq(rowIndex).css("height", fixedRowHeight);
              }
            }
            $contentElement && $contentElement.css("height", "");
          }
        }
      },
      setScrollerSpacing: function(width) {
        var rtlEnabled = this.option("rtlEnabled");
        this.callBase(width);
        this.element().children("." + this.addWidgetPrefix(CONTENT_FIXED_CLASS2)).css({
          paddingLeft: rtlEnabled ? width : "",
          paddingRight: !rtlEnabled ? width : ""
        });
      }
    };
    ColumnHeadersViewFixedColumnsExtender = extend2({}, baseFixedColumns, {
      _getRowVisibleColumns: function(rowIndex) {
        if (this._isFixedTableRendering) {
          return this.getFixedColumns(rowIndex);
        }
        return this.callBase(rowIndex);
      },
      getContextMenuItems: function(options2) {
        var column = options2.column;
        var columnFixingOptions = this.option("columnFixing");
        var items = this.callBase(options2);
        if (options2.row && "header" === options2.row.rowType) {
          if (true === columnFixingOptions.enabled && column && column.allowFixing) {
            var onItemClick = (params) => {
              switch (params.itemData.value) {
                case "none":
                  this._columnsController.columnOption(column.index, "fixed", false);
                  break;
                case "left":
                  this._columnsController.columnOption(column.index, {
                    fixed: true,
                    fixedPosition: "left"
                  });
                  break;
                case "right":
                  this._columnsController.columnOption(column.index, {
                    fixed: true,
                    fixedPosition: "right"
                  });
              }
            };
            items = items || [];
            items.push({
              text: columnFixingOptions.texts.fix,
              beginGroup: true,
              items: [{
                text: columnFixingOptions.texts.leftPosition,
                value: "left",
                disabled: column.fixed && (!column.fixedPosition || "left" === column.fixedPosition),
                onItemClick
              }, {
                text: columnFixingOptions.texts.rightPosition,
                value: "right",
                disabled: column.fixed && "right" === column.fixedPosition,
                onItemClick
              }]
            }, {
              text: columnFixingOptions.texts.unfix,
              value: "none",
              disabled: !column.fixed,
              onItemClick
            });
          }
        }
        return items;
      },
      getFixedColumnElements: function(rowIndex) {
        if (isDefined(rowIndex)) {
          return this._fixedTableElement && this._getRowElements(this._fixedTableElement).eq(rowIndex).children();
        }
        var columnElements = this.getColumnElements();
        var $transparentColumnElement = this.getTransparentColumnElement();
        if (columnElements && $transparentColumnElement && $transparentColumnElement.length) {
          var transparentColumnIndex = getTransparentColumnIndex(this.getFixedColumns());
          columnElements.splice(transparentColumnIndex, $transparentColumnElement.get(0).colSpan, $transparentColumnElement.get(0));
        }
        return columnElements;
      },
      getColumnWidths: function() {
        var fixedWidths;
        var result2 = this.callBase();
        var $fixedColumnElements = this.getFixedColumnElements();
        var fixedColumns = this.getFixedColumns();
        if (this._fixedTableElement) {
          if ($fixedColumnElements && $fixedColumnElements.length) {
            fixedWidths = this._getWidths($fixedColumnElements);
          } else {
            fixedWidths = this.callBase(this._fixedTableElement);
          }
        }
        return normalizeColumnWidths(fixedColumns, result2, fixedWidths);
      }
    });
    RowsViewFixedColumnsExtender = extend2({}, baseFixedColumns, {
      _detachHoverEvents: function() {
        this._fixedTableElement && events_engine_default.off(this._fixedTableElement, "mouseover mouseout", ".dx-data-row");
        this._tableElement && events_engine_default.off(this._tableElement, "mouseover mouseout", ".dx-data-row");
      },
      _attachHoverEvents: function() {
        var that = this;
        var attachHoverEvent = function($table) {
          events_engine_default.on($table, "mouseover mouseout", ".dx-data-row", that.createAction(function(args) {
            var event = args.event;
            var rowIndex = that.getRowIndex(renderer_default(event.target).closest(".dx-row"));
            var isHover = "mouseover" === event.type;
            if (rowIndex >= 0) {
              that._tableElement && that._getRowElements(that._tableElement).eq(rowIndex).toggleClass(HOVER_STATE_CLASS, isHover);
              that._fixedTableElement && that._getRowElements(that._fixedTableElement).eq(rowIndex).toggleClass(HOVER_STATE_CLASS, isHover);
            }
          }));
        };
        if (that._fixedTableElement && that._tableElement) {
          attachHoverEvent(that._fixedTableElement);
          attachHoverEvent(that._tableElement);
        }
      },
      _findContentElement: function() {
        var that = this;
        var $content;
        var scrollTop;
        var contentClass = that.addWidgetPrefix(CONTENT_CLASS4);
        var element = that.element();
        var scrollDelay = browser_default.mozilla ? 60 : 0;
        if (element && that._isFixedTableRendering) {
          $content = element.children("." + contentClass);
          var scrollable = that.getScrollable();
          if (!$content.length && scrollable) {
            $content = renderer_default("<div>").addClass(contentClass);
            events_engine_default.on($content, "scroll", function(e) {
              clearTimeout(that._fixedScrollTimeout);
              that._fixedScrollTimeout = setTimeout(function() {
                scrollTop = renderer_default(e.target).scrollTop();
                scrollable.scrollTo({
                  y: scrollTop
                });
              }, scrollDelay);
            });
            events_engine_default.on($content, EVENT_NAME, function(e) {
              var $nearestScrollable = renderer_default(e.target).closest(".dx-scrollable");
              var shouldScroll = false;
              if (scrollable && scrollable.$element().is($nearestScrollable)) {
                shouldScroll = true;
              } else {
                var nearestScrollableInstance = $nearestScrollable.length && ui_scrollable_default.getInstance($nearestScrollable.get(0));
                var nearestScrollableHasVerticalScrollbar = nearestScrollableInstance && nearestScrollableInstance.scrollHeight() - nearestScrollableInstance.clientHeight() > 0;
                shouldScroll = nearestScrollableInstance && !nearestScrollableHasVerticalScrollbar;
              }
              if (shouldScroll) {
                scrollTop = scrollable.scrollTop();
                scrollable.scrollTo({
                  y: scrollTop - e.delta
                });
                if (scrollable.scrollTop() > 0 && scrollable.scrollTop() + scrollable.clientHeight() < scrollable.scrollHeight() + that.getScrollbarWidth()) {
                  return false;
                }
              }
            });
            $content.appendTo(element);
          }
          return $content;
        }
        return that.callBase();
      },
      _updateScrollable: function() {
        this.callBase();
        var scrollable = this.getScrollable();
        var scrollTop = scrollable && scrollable.scrollOffset().top;
        this._updateFixedTablePosition(scrollTop);
      },
      _renderContent: function(contentElement, tableElement) {
        if (this._isFixedTableRendering) {
          return contentElement.empty().addClass(this.addWidgetPrefix(CONTENT_CLASS4) + " " + this.addWidgetPrefix(CONTENT_FIXED_CLASS2)).append(tableElement);
        }
        return this.callBase(contentElement, tableElement);
      },
      _getGroupCellOptions: function(options2) {
        if (this._isFixedTableRendering) {
          return this.callBase(extend2({}, options2, {
            columns: this._columnsController.getVisibleColumns()
          }));
        }
        return this.callBase(options2);
      },
      _renderGroupedCells: function($row, options2) {
        return this.callBase($row, extend2({}, options2, {
          columns: this._columnsController.getVisibleColumns()
        }));
      },
      _renderGroupSummaryCells: function($row, options2) {
        if (this._isFixedTableRendering) {
          this.callBase($row, extend2({}, options2, {
            columns: this._columnsController.getVisibleColumns()
          }));
        } else {
          this.callBase($row, options2);
        }
      },
      _hasAlignByColumnSummaryItems: function(columnIndex, options2) {
        var result2 = this.callBase.apply(this, arguments);
        var column = options2.columns[columnIndex];
        if (options2.isFixed) {
          return column.fixed && (result2 || "right" === column.fixedPosition);
        }
        return result2 && (!this._isFixedColumns || !column.fixed);
      },
      _renderGroupSummaryCellsCore: function($groupCell, options2, groupCellColSpan, alignByColumnCellCount) {
        var alignByFixedColumnCellCount;
        if (this._isFixedTableRendering) {
          options2.isFixed = true;
          alignByFixedColumnCellCount = this._getAlignByColumnCellCount(groupCellColSpan, options2);
          options2.isFixed = false;
          var startColumnIndex = options2.columns.length - alignByFixedColumnCellCount;
          options2 = extend2({}, options2, {
            columns: this.getFixedColumns()
          });
          var transparentColumnIndex = getTransparentColumnIndex(options2.columns);
          if (startColumnIndex < transparentColumnIndex) {
            alignByFixedColumnCellCount -= options2.columns[transparentColumnIndex].colspan - 1 || 0;
            groupCellColSpan -= options2.columns[transparentColumnIndex].colspan - 1 || 0;
          } else if (alignByColumnCellCount > 0) {
            $groupCell.css("visibility", "hidden");
          }
          alignByColumnCellCount = alignByFixedColumnCellCount;
        }
        this.callBase($groupCell, options2, groupCellColSpan, alignByColumnCellCount);
      },
      _getSummaryCellIndex: function(columnIndex, columns) {
        if (this._isFixedTableRendering) {
          var transparentColumnIndex = getTransparentColumnIndex(columns);
          if (columnIndex > transparentColumnIndex) {
            columnIndex += columns[transparentColumnIndex].colspan - 1;
          }
          return columnIndex;
        }
        return this.callBase.apply(this, arguments);
      },
      _renderCore: function(change) {
        this._detachHoverEvents();
        this.callBase(change);
        var isFixedColumns = this._isFixedColumns;
        this.element().toggleClass(FIXED_COLUMNS_CLASS, isFixedColumns);
        if (this.option("hoverStateEnabled") && isFixedColumns) {
          this._attachHoverEvents();
        }
      },
      setRowsOpacity: function(columnIndex, value2) {
        this.callBase(columnIndex, value2);
        var $rows = this._getRowElements(this._fixedTableElement);
        this._setRowsOpacityCore($rows, this.getFixedColumns(), columnIndex, value2);
      },
      optionChanged: function(args) {
        this.callBase(args);
        if ("hoverStateEnabled" === args.name && this._isFixedColumns) {
          args.value ? this._attachHoverEvents() : this._detachHoverEvents();
        }
      },
      getCellIndex: function($cell) {
        var $fixedTable = this._fixedTableElement;
        var cellIndex = 0;
        if ($fixedTable && $cell.is("td") && $cell.closest($fixedTable).length) {
          var columns = this.getFixedColumns();
          each(columns, function(index2, column) {
            if (index2 === $cell[0].cellIndex) {
              return false;
            }
            if (column.colspan) {
              cellIndex += column.colspan;
              return;
            }
            cellIndex++;
          });
          return cellIndex;
        }
        return this.callBase.apply(this, arguments);
      },
      _updateFixedTablePosition: function(scrollTop, needFocus) {
        if (this._fixedTableElement && this._tableElement) {
          var $focusedElement;
          var editorFactory = this.getController("editorFactory");
          this._fixedTableElement.parent().scrollTop(scrollTop);
          if (needFocus && editorFactory) {
            $focusedElement = editorFactory.focus();
            $focusedElement && editorFactory.focus($focusedElement);
          }
        }
      },
      setScrollerSpacing: function(vWidth, hWidth) {
        var styles = {
          marginBottom: 0
        };
        var $fixedContent = this.element().children("." + this.addWidgetPrefix(CONTENT_FIXED_CLASS2));
        if ($fixedContent.length && this._fixedTableElement) {
          $fixedContent.css(styles);
          this._fixedTableElement.css(styles);
          styles[this.option("rtlEnabled") ? "marginLeft" : "marginRight"] = vWidth;
          styles.marginBottom = hWidth;
          var useNativeScrolling = this._scrollable && this._scrollable.option("useNative");
          (useNativeScrolling ? $fixedContent : this._fixedTableElement).css(styles);
        }
      },
      _getElasticScrollTop: function(e) {
        var elasticScrollTop = 0;
        if (e.scrollOffset.top < 0) {
          elasticScrollTop = -e.scrollOffset.top;
        } else if (e.reachedBottom) {
          var $scrollableContent = renderer_default(this._findContentElement());
          var $scrollableContainer = renderer_default(e.component.container());
          var maxScrollTop = Math.max($scrollableContent.get(0).clientHeight - $scrollableContainer.get(0).clientHeight, 0);
          elasticScrollTop = maxScrollTop - e.scrollOffset.top;
        }
        return Math.floor(elasticScrollTop);
      },
      _applyElasticScrolling: function(e) {
        if (this._fixedTableElement) {
          var elasticScrollTop = this._getElasticScrollTop(e);
          if (0 !== Math.ceil(elasticScrollTop)) {
            move(this._fixedTableElement, {
              top: elasticScrollTop
            });
          } else {
            this._fixedTableElement.css("transform", "");
          }
        }
      },
      _handleScroll: function(e) {
        this._updateFixedTablePosition(e.scrollOffset.top, true);
        this._applyElasticScrolling(e);
        this.callBase(e);
      },
      _updateContentPosition: function(isRender) {
        this.callBase.apply(this, arguments);
        if (!isRender) {
          this._updateFixedTablePosition(this._scrollTop);
        }
      },
      _afterRowPrepared: function(e) {
        if (this._isFixedTableRendering) {
          return;
        }
        this.callBase(e);
      },
      _scrollToElement: function($element) {
        this.callBase($element, this.getFixedColumnsOffset());
      },
      dispose: function() {
        this.callBase.apply(this, arguments);
        clearTimeout(this._fixedScrollTimeout);
      }
    });
    FooterViewFixedColumnsExtender = baseFixedColumns;
    columnFixingModule = {
      defaultOptions: function() {
        return {
          columnFixing: {
            enabled: false,
            texts: {
              fix: message_default.format("dxDataGrid-columnFixingFix"),
              unfix: message_default.format("dxDataGrid-columnFixingUnfix"),
              leftPosition: message_default.format("dxDataGrid-columnFixingLeftPosition"),
              rightPosition: message_default.format("dxDataGrid-columnFixingRightPosition")
            }
          }
        };
      },
      extenders: {
        views: {
          columnHeadersView: ColumnHeadersViewFixedColumnsExtender,
          rowsView: RowsViewFixedColumnsExtender,
          footerView: FooterViewFixedColumnsExtender
        },
        controllers: /* @__PURE__ */ function() {
          var normalizeColumnIndicesByPoints = function(columns, fixedColumns, pointsByColumns) {
            var transparentColumnIndex = getTransparentColumnIndex(fixedColumns);
            var correctIndex = columns.length - fixedColumns.length;
            each(pointsByColumns, function(_2, point) {
              if (point.index > transparentColumnIndex) {
                point.columnIndex += correctIndex;
                point.index += correctIndex;
              }
            });
            return pointsByColumns;
          };
          return {
            draggingHeader: {
              _generatePointsByColumns: function(options2) {
                var visibleColumns = options2.columns;
                var targetDraggingPanel = options2.targetDraggingPanel;
                if (targetDraggingPanel && "headers" === targetDraggingPanel.getName() && targetDraggingPanel.isFixedColumns()) {
                  if (options2.sourceColumn.fixed) {
                    if (!options2.rowIndex) {
                      options2.columnElements = targetDraggingPanel.getFixedColumnElements(0);
                    }
                    options2.columns = targetDraggingPanel.getFixedColumns(options2.rowIndex);
                    var pointsByColumns = this.callBase(options2);
                    normalizeColumnIndicesByPoints(visibleColumns, options2.columns, pointsByColumns);
                    return pointsByColumns;
                  }
                }
                return this.callBase(options2);
              },
              _pointCreated: function(point, columns, location, sourceColumn) {
                var result2 = this.callBase.apply(this, arguments);
                var targetColumn = columns[point.columnIndex];
                var $transparentColumn = this._columnHeadersView.getTransparentColumnElement();
                if (!result2 && "headers" === location && $transparentColumn && $transparentColumn.length) {
                  var boundingRect = getBoundingRect($transparentColumn.get(0));
                  if (sourceColumn && sourceColumn.fixed) {
                    return "right" === sourceColumn.fixedPosition ? point.x < boundingRect.right : point.x > boundingRect.left;
                  } else {
                    if (targetColumn && targetColumn.fixed && "right" !== targetColumn.fixedPosition) {
                      return true;
                    }
                    return point.x < boundingRect.left || point.x > boundingRect.right;
                  }
                }
                return result2;
              }
            },
            columnsResizer: {
              _generatePointsByColumns: function() {
                var that = this;
                var columnsController = that._columnsController;
                var columns = columnsController && that._columnsController.getVisibleColumns();
                var fixedColumns = columnsController && that._columnsController.getFixedColumns();
                var cells = that._columnHeadersView.getFixedColumnElements();
                var pointsByFixedColumns = [];
                that.callBase();
                if (cells && cells.length > 0) {
                  pointsByFixedColumns = ui_grid_core_utils_default.getPointsByColumns(cells, function(point) {
                    return that._pointCreated(point, cells.length, fixedColumns);
                  });
                  that._pointsByFixedColumns = normalizeColumnIndicesByPoints(columns, fixedColumns, pointsByFixedColumns);
                }
              },
              _pointCreated: function(point, cellsLength, columns) {
                var isWidgetResizingMode = "widget" === this.option("columnResizingMode");
                if (point.index > 0 && point.index < cellsLength) {
                  var currentColumn = columns[point.columnIndex - 1] || {};
                  var nextColumn = columns[point.columnIndex] || {};
                  if (currentColumn.fixed || nextColumn.fixed) {
                    point.columnIndex -= 1;
                    return !((currentColumn.allowResizing || currentColumn.command === COMMAND_TRANSPARENT2) && (isWidgetResizingMode || nextColumn.allowResizing || nextColumn.command === COMMAND_TRANSPARENT2));
                  }
                }
                return this.callBase.apply(this, arguments);
              },
              _getTargetPoint: function(pointsByColumns, currentX, deltaX) {
                var $transparentColumn = this._columnHeadersView.getTransparentColumnElement();
                if ($transparentColumn && $transparentColumn.length) {
                  var boundingRect = getBoundingRect($transparentColumn.get(0));
                  if (currentX <= boundingRect.left || currentX >= boundingRect.right) {
                    return this.callBase(this._pointsByFixedColumns, currentX, deltaX);
                  }
                }
                return this.callBase(pointsByColumns, currentX, deltaX);
              }
            }
          };
        }()
      }
    };
  }
});

// node_modules/devextreme/esm/ui/grid_core/ui.grid_core.adaptivity.js
function getColumnId(that, column) {
  return that._columnsController.getColumnId(column);
}
function getDataCellElements($row) {
  return $row.find("td:not(.dx-datagrid-hidden-column):not([class*='dx-command-'])");
}
function adaptiveCellTemplate(container, options2) {
  var $adaptiveColumnButton;
  var $container = renderer_default(container);
  var adaptiveColumnsController = options2.component.getController("adaptiveColumns");
  if ("data" === options2.rowType) {
    $adaptiveColumnButton = renderer_default("<span>").addClass(adaptiveColumnsController.addWidgetPrefix(ADAPTIVE_COLUMN_BUTTON_CLASS));
    events_engine_default.on($adaptiveColumnButton, addNamespace2(CLICK_EVENT_NAME, ADAPTIVE_NAMESPACE), adaptiveColumnsController.createAction(function() {
      adaptiveColumnsController.toggleExpandAdaptiveDetailRow(options2.key);
    }));
    $adaptiveColumnButton.appendTo($container);
  } else {
    ui_grid_core_utils_default.setEmptyText($container);
  }
}
var COLUMN_HEADERS_VIEW2, ROWS_VIEW, FOOTER_VIEW, COLUMN_VIEWS, ADAPTIVE_NAMESPACE, HIDDEN_COLUMNS_WIDTH2, ADAPTIVE_ROW_TYPE, FORM_ITEM_CONTENT_CLASS, FORM_ITEM_MODIFIED, HIDDEN_COLUMN_CLASS, ADAPTIVE_COLUMN_BUTTON_CLASS, ADAPTIVE_COLUMN_NAME_CLASS, COMMAND_ADAPTIVE_HIDDEN_CLASS, ADAPTIVE_DETAIL_ROW_CLASS, ADAPTIVE_ITEM_TEXT_CLASS, MASTER_DETAIL_CELL_CLASS4, LAST_DATA_CELL_CLASS, ADAPTIVE_COLUMN_NAME, EDIT_MODE_BATCH4, EDIT_MODE_ROW4, EDIT_MODE_FORM4, EDIT_MODE_POPUP3, REVERT_TOOLTIP_CLASS2, GROUP_CELL_CLASS3, GROUP_ROW_CLASS4, EXPAND_ARIA_NAME, COLLAPSE_ARIA_NAME, AdaptiveColumnsController, adaptivityModule;
var init_ui_grid_core_adaptivity = __esm({
  "node_modules/devextreme/esm/ui/grid_core/ui.grid_core.adaptivity.js"() {
    init_renderer();
    init_events_engine();
    init_utils2();
    init_click();
    init_type();
    init_browser();
    init_guid();
    init_ui_grid_core_modules();
    init_form();
    init_ui_grid_core_utils();
    init_themes();
    init_window();
    init_common();
    init_iterator();
    init_extend();
    init_deferred();
    init_message();
    COLUMN_HEADERS_VIEW2 = "columnHeadersView";
    ROWS_VIEW = "rowsView";
    FOOTER_VIEW = "footerView";
    COLUMN_VIEWS = [COLUMN_HEADERS_VIEW2, ROWS_VIEW, FOOTER_VIEW];
    ADAPTIVE_NAMESPACE = "dxDataGridAdaptivity";
    HIDDEN_COLUMNS_WIDTH2 = "adaptiveHidden";
    ADAPTIVE_ROW_TYPE = "detailAdaptive";
    FORM_ITEM_CONTENT_CLASS = "dx-field-item-content";
    FORM_ITEM_MODIFIED = "dx-item-modified";
    HIDDEN_COLUMN_CLASS = "hidden-column";
    ADAPTIVE_COLUMN_BUTTON_CLASS = "adaptive-more";
    ADAPTIVE_COLUMN_NAME_CLASS = "dx-command-adaptive";
    COMMAND_ADAPTIVE_HIDDEN_CLASS = "dx-command-adaptive-hidden";
    ADAPTIVE_DETAIL_ROW_CLASS = "dx-adaptive-detail-row";
    ADAPTIVE_ITEM_TEXT_CLASS = "dx-adaptive-item-text";
    MASTER_DETAIL_CELL_CLASS4 = "dx-master-detail-cell";
    LAST_DATA_CELL_CLASS = "dx-last-data-cell";
    ADAPTIVE_COLUMN_NAME = "adaptive";
    EDIT_MODE_BATCH4 = "batch";
    EDIT_MODE_ROW4 = "row";
    EDIT_MODE_FORM4 = "form";
    EDIT_MODE_POPUP3 = "popup";
    REVERT_TOOLTIP_CLASS2 = "revert-tooltip";
    GROUP_CELL_CLASS3 = "dx-group-cell";
    GROUP_ROW_CLASS4 = "dx-group-row";
    EXPAND_ARIA_NAME = "dxDataGrid-ariaAdaptiveExpand";
    COLLAPSE_ARIA_NAME = "dxDataGrid-ariaAdaptiveCollapse";
    AdaptiveColumnsController = ui_grid_core_modules_default.ViewController.inherit({
      _isRowEditMode: function() {
        var editMode = this._getEditMode();
        return editMode === EDIT_MODE_ROW4;
      },
      _isItemModified: function(item, cellOptions) {
        var columnIndex = this._columnsController.getVisibleIndex(item.column.index);
        var rowIndex = this._dataController.getRowIndexByKey(cellOptions.key);
        var row = this._dataController.items()[rowIndex + 1];
        return row && row.modifiedValues && isDefined(row.modifiedValues[columnIndex]);
      },
      _renderFormViewTemplate: function(item, cellOptions, $container) {
        var column = item.column;
        var focusAction = this.createAction(function() {
          events_engine_default.trigger($container, CLICK_EVENT_NAME);
        });
        var rowData = cellOptions.row.data;
        var value2 = column.calculateCellValue(rowData);
        var displayValue = ui_grid_core_utils_default.getDisplayValue(column, value2, rowData, cellOptions.rowType);
        var text = ui_grid_core_utils_default.formatValue(displayValue, column);
        var isCellOrBatchEditMode = this._editingController.isCellOrBatchEditMode();
        var rowsView = this._rowsView;
        if (column.allowEditing && this.getController("keyboardNavigation").isKeyboardEnabled()) {
          $container.attr("tabIndex", this.option("tabIndex"));
          if (isCellOrBatchEditMode) {
            events_engine_default.off($container, "focus", focusAction);
            events_engine_default.on($container, "focus", focusAction);
          }
        }
        if (column.cellTemplate) {
          var templateOptions = extend2({}, cellOptions, {
            value: value2,
            displayValue,
            text,
            column
          });
          var isDomElement = !!$container.closest(getWindow().document).length;
          rowsView.renderTemplate($container, column.cellTemplate, templateOptions, isDomElement).done(() => {
            rowsView._cellPrepared($container, cellOptions);
          });
        } else {
          var container = $container.get(0);
          if (column.encodeHtml) {
            container.textContent = text;
          } else {
            container.innerHTML = text;
          }
          $container.addClass(ADAPTIVE_ITEM_TEXT_CLASS);
          if (!isDefined(text) || "" === text) {
            $container.html("&nbsp;");
          }
          if (!this._isRowEditMode()) {
            if (this._isItemModified(item, cellOptions)) {
              $container.addClass(FORM_ITEM_MODIFIED);
            }
          }
          rowsView._cellPrepared($container, cellOptions);
        }
      },
      _getTemplate: function(item, cellOptions) {
        var that = this;
        var column = item.column;
        var editingController = this.getController("editing");
        return function(options2, container) {
          var $container = renderer_default(container);
          var columnIndex = that._columnsController.getVisibleIndex(column.index);
          var templateOptions = extend2({}, cellOptions);
          var renderFormTemplate = function() {
            var isItemEdited = that._isItemEdited(item);
            templateOptions.value = cellOptions.row.values[columnIndex];
            if (isItemEdited || column.showEditorAlways) {
              editingController.renderFormEditTemplate(templateOptions, item, options2.component, $container, !isItemEdited);
            } else {
              templateOptions.column = column;
              templateOptions.columnIndex = columnIndex;
              that._renderFormViewTemplate(item, templateOptions, $container);
            }
          };
          renderFormTemplate();
          templateOptions.watch && templateOptions.watch(function() {
            return {
              isItemEdited: that._isItemEdited(item),
              value: cellOptions.row.values[columnIndex]
            };
          }, function() {
            $container.contents().remove();
            $container.removeClass(ADAPTIVE_ITEM_TEXT_CLASS);
            renderFormTemplate();
          });
        };
      },
      _isVisibleColumnsValid: function(visibleColumns) {
        if (visibleColumns < 2) {
          return false;
        }
        if (visibleColumns.length - function() {
          var result2 = 0;
          for (var j = 0; j < visibleColumns.length; j++) {
            var visibleColumn = visibleColumns[j];
            if (visibleColumn.command) {
              result2++;
            }
          }
          return result2;
        }() <= 1) {
          return false;
        }
        return true;
      },
      _calculatePercentWidths: function(widths, visibleColumns) {
        var that = this;
        var percentWidths = 0;
        visibleColumns.forEach(function(item, index2) {
          if (widths[index2] !== HIDDEN_COLUMNS_WIDTH2) {
            percentWidths += that._getItemPercentWidth(item);
          }
        });
        return percentWidths;
      },
      _isPercentWidth: function(width) {
        return isString2(width) && "%" === width.slice(-1);
      },
      _isColumnHidden: function(column) {
        return this._hiddenColumns.filter(function(hiddenColumn) {
          return hiddenColumn.index === column.index;
        }).length > 0;
      },
      _getAverageColumnsWidth: function(containerWidth, columns, columnsCanFit) {
        var that = this;
        var fixedColumnsWidth = 0;
        var columnsWithoutFixedWidthCount = 0;
        columns.forEach(function(column) {
          if (!that._isColumnHidden(column)) {
            var width = column.width;
            if (isDefined(width) && !isNaN(parseFloat(width))) {
              fixedColumnsWidth += that._isPercentWidth(width) ? that._calculatePercentWidth({
                visibleIndex: column.visibleIndex,
                columnsCount: columns.length,
                columnsCanFit,
                bestFitWidth: column.bestFitWidth,
                columnWidth: width,
                containerWidth
              }) : parseFloat(width);
            } else {
              columnsWithoutFixedWidthCount++;
            }
          }
        });
        return (containerWidth - fixedColumnsWidth) / columnsWithoutFixedWidthCount;
      },
      _calculateColumnWidth: function(column, containerWidth, contentColumns, columnsCanFit) {
        var columnId = getColumnId(this, column);
        var widthOption = this._columnsController.columnOption(columnId, "width");
        var bestFitWidth = this._columnsController.columnOption(columnId, "bestFitWidth");
        var columnsCount = contentColumns.length;
        var colWidth;
        if (widthOption && "auto" !== widthOption) {
          if (this._isPercentWidth(widthOption)) {
            colWidth = this._calculatePercentWidth({
              visibleIndex: column.visibleIndex,
              columnsCount,
              columnsCanFit,
              bestFitWidth,
              columnWidth: widthOption,
              containerWidth
            });
          } else {
            return parseFloat(widthOption);
          }
        } else {
          var columnAutoWidth = this.option("columnAutoWidth");
          colWidth = columnAutoWidth || !!column.command ? bestFitWidth : this._getAverageColumnsWidth(containerWidth, contentColumns, columnsCanFit);
        }
        return colWidth;
      },
      _calculatePercentWidth: function(options2) {
        var columnFitted = options2.visibleIndex < options2.columnsCount - 1 && options2.columnsCanFit;
        var partialWidth = options2.containerWidth * parseFloat(options2.columnWidth) / 100;
        var resultWidth = options2.columnsCanFit && partialWidth < options2.bestFitWidth ? options2.bestFitWidth : partialWidth;
        return columnFitted ? options2.containerWidth * parseFloat(options2.columnWidth) / 100 : resultWidth;
      },
      _getNotTruncatedColumnWidth: function(column, containerWidth, contentColumns, columnsCanFit) {
        var columnId = getColumnId(this, column);
        var widthOption = this._columnsController.columnOption(columnId, "width");
        var bestFitWidth = this._columnsController.columnOption(columnId, "bestFitWidth");
        if (widthOption && "auto" !== widthOption && !this._isPercentWidth(widthOption)) {
          return parseFloat(widthOption);
        }
        var colWidth = this._calculateColumnWidth(column, containerWidth, contentColumns, columnsCanFit);
        return colWidth < bestFitWidth ? null : colWidth;
      },
      _getItemPercentWidth: function(item) {
        var result2 = 0;
        if (item.width && this._isPercentWidth(item.width)) {
          result2 = parseFloat(item.width);
        }
        return result2;
      },
      _getCommandColumnsWidth: function() {
        var that = this;
        var columns = that._columnsController.getVisibleColumns();
        var colWidth = 0;
        each(columns, function(index2, column) {
          if (column.index < 0 || column.command) {
            colWidth += that._columnsController.columnOption(getColumnId(that, column), "bestFitWidth") || 0;
          }
        });
        return colWidth;
      },
      _isItemEdited: function(item) {
        if (this.isFormOrPopupEditMode()) {
          return false;
        }
        if (this._isRowEditMode()) {
          var editRowKey = this.option("editing.editRowKey");
          if (equalByValue(editRowKey, this._dataController.adaptiveExpandedKey())) {
            return true;
          }
        } else {
          var rowIndex = this._dataController.getRowIndexByKey(this._dataController.adaptiveExpandedKey()) + 1;
          var columnIndex = this._columnsController.getVisibleIndex(item.column.index);
          return this._editingController.isEditCell(rowIndex, columnIndex);
        }
      },
      _getFormItemsByHiddenColumns: function(hiddenColumns) {
        var items = [];
        each(hiddenColumns, function(_2, column) {
          items.push({
            column,
            name: column.name,
            dataField: column.dataField,
            visibleIndex: column.visibleIndex
          });
        });
        return items;
      },
      _getAdaptiveColumnVisibleIndex: function(visibleColumns) {
        for (var i = 0; i < visibleColumns.length; i++) {
          var column = visibleColumns[i];
          if (column.command === ADAPTIVE_COLUMN_NAME) {
            return i;
          }
        }
      },
      _hideAdaptiveColumn: function(resultWidths, visibleColumns) {
        var visibleIndex = this._getAdaptiveColumnVisibleIndex(visibleColumns);
        if (isDefined(visibleIndex)) {
          resultWidths[visibleIndex] = HIDDEN_COLUMNS_WIDTH2;
          this._hideVisibleColumn({
            isCommandColumn: true,
            visibleIndex
          });
        }
      },
      _showHiddenCellsInView: function(_ref) {
        var {
          $cells,
          isCommandColumn
        } = _ref;
        var cssClassNameToRemove = isCommandColumn ? COMMAND_ADAPTIVE_HIDDEN_CLASS : this.addWidgetPrefix(HIDDEN_COLUMN_CLASS);
        $cells.removeClass(cssClassNameToRemove);
      },
      _showHiddenColumns: function() {
        for (var i = 0; i < COLUMN_VIEWS.length; i++) {
          var view = this.getView(COLUMN_VIEWS[i]);
          if (view && view.isVisible() && view.element()) {
            var viewName2 = view.name;
            var $hiddenCommandCells = view.element().find("." + COMMAND_ADAPTIVE_HIDDEN_CLASS);
            this._showHiddenCellsInView({
              viewName: viewName2,
              $cells: $hiddenCommandCells,
              isCommandColumn: true
            });
            var $hiddenCells = view.element().find("." + this.addWidgetPrefix(HIDDEN_COLUMN_CLASS));
            this._showHiddenCellsInView({
              viewName: viewName2,
              $cells: $hiddenCells
            });
          }
        }
      },
      _isCellValid: function($cell) {
        return $cell && $cell.length && !$cell.hasClass(MASTER_DETAIL_CELL_CLASS4) && !$cell.hasClass(GROUP_CELL_CLASS3);
      },
      _hideVisibleColumn: function(_ref2) {
        var {
          isCommandColumn,
          visibleIndex
        } = _ref2;
        var that = this;
        COLUMN_VIEWS.forEach(function(viewName2) {
          var view = that.getView(viewName2);
          view && that._hideVisibleColumnInView({
            view,
            isCommandColumn,
            visibleIndex
          });
        });
      },
      _hideVisibleColumnInView: function(_ref3) {
        var {
          view,
          isCommandColumn,
          visibleIndex
        } = _ref3;
        var viewName2 = view.name;
        var $cellElement;
        var column = this._columnsController.getVisibleColumns()[visibleIndex];
        var editFormRowIndex = this._editingController && this._editingController.getEditFormRowIndex();
        if (view && view.isVisible() && column) {
          var rowsCount = view.getRowsCount();
          var $rowElements = view._getRowElements();
          for (var rowIndex = 0; rowIndex < rowsCount; rowIndex++) {
            var cancelClassAdding = rowIndex === editFormRowIndex && viewName2 === ROWS_VIEW && "popup" !== this.option("editing.mode");
            if (!cancelClassAdding) {
              var currentVisibleIndex = viewName2 === COLUMN_HEADERS_VIEW2 ? this._columnsController.getVisibleIndex(column.index, rowIndex) : visibleIndex;
              if (currentVisibleIndex >= 0) {
                var $rowElement = $rowElements.eq(rowIndex);
                $cellElement = this._findCellElementInRow($rowElement, currentVisibleIndex);
                this._isCellValid($cellElement) && this._hideVisibleCellInView({
                  viewName: viewName2,
                  isCommandColumn,
                  $cell: $cellElement
                });
              }
            }
          }
        }
      },
      _findCellElementInRow($rowElement, visibleColumnIndex) {
        var $rowCells = $rowElement.children();
        var visibleIndex = visibleColumnIndex;
        var cellIsInsideGroup = false;
        if ($rowElement.hasClass(GROUP_ROW_CLASS4)) {
          var $groupCell = $rowElement.find(".".concat(GROUP_CELL_CLASS3));
          var colSpan = $groupCell.attr("colspan");
          if ($groupCell.length && isDefined(colSpan)) {
            var groupCellLength = parseInt(colSpan);
            var endGroupIndex = $groupCell.index() + groupCellLength - 1;
            if (visibleColumnIndex > endGroupIndex) {
              visibleIndex = visibleColumnIndex - groupCellLength + 1;
            } else {
              cellIsInsideGroup = true;
            }
          }
        }
        var $cellElement = !cellIsInsideGroup ? $rowCells.eq(visibleIndex) : void 0;
        return $cellElement;
      },
      _hideVisibleCellInView: function(_ref4) {
        var {
          $cell,
          isCommandColumn
        } = _ref4;
        var cssClassNameToAdd = isCommandColumn ? COMMAND_ADAPTIVE_HIDDEN_CLASS : this.addWidgetPrefix(HIDDEN_COLUMN_CLASS);
        $cell.addClass(cssClassNameToAdd);
      },
      _getEditMode: function() {
        return this._editingController.getEditMode();
      },
      isFormOrPopupEditMode: function() {
        var editMode = this._getEditMode();
        return editMode === EDIT_MODE_FORM4 || editMode === EDIT_MODE_POPUP3;
      },
      hideRedundantColumns: function(resultWidths, visibleColumns, hiddenQueue) {
        this._hiddenColumns = [];
        if (this._isVisibleColumnsValid(visibleColumns) && hiddenQueue.length) {
          var totalWidth = 0;
          var $rootElement = this.component.$element();
          var rootElementWidth = $rootElement.width() - this._getCommandColumnsWidth();
          var getVisibleContentColumns = (function() {
            return visibleColumns.filter((item) => !item.command && 0 === this._hiddenColumns.filter((i2) => i2.index === item.index).length);
          }).bind(this);
          var visibleContentColumns = getVisibleContentColumns();
          var contentColumnsCount = visibleContentColumns.length;
          var i;
          var hasHiddenColumns;
          var needHideColumn;
          do {
            needHideColumn = false;
            totalWidth = 0;
            var percentWidths = this._calculatePercentWidths(resultWidths, visibleColumns);
            var columnsCanFit = percentWidths < 100 && 0 !== percentWidths;
            for (i = 0; i < visibleColumns.length; i++) {
              var visibleColumn = visibleColumns[i];
              var columnWidth = this._getNotTruncatedColumnWidth(visibleColumn, rootElementWidth, visibleContentColumns, columnsCanFit);
              var columnId = getColumnId(this, visibleColumn);
              var widthOption = this._columnsController.columnOption(columnId, "width");
              var minWidth = this._columnsController.columnOption(columnId, "minWidth");
              var columnBestFitWidth = this._columnsController.columnOption(columnId, "bestFitWidth");
              if (resultWidths[i] === HIDDEN_COLUMNS_WIDTH2) {
                hasHiddenColumns = true;
                continue;
              }
              if (!columnWidth && !visibleColumn.command && !visibleColumn.fixed) {
                needHideColumn = true;
                break;
              }
              if (!widthOption || "auto" === widthOption) {
                columnWidth = Math.max(columnBestFitWidth || 0, minWidth || 0);
              }
              if (visibleColumn.command !== ADAPTIVE_COLUMN_NAME || hasHiddenColumns) {
                totalWidth += columnWidth;
              }
            }
            needHideColumn = needHideColumn || totalWidth > $rootElement.width();
            if (needHideColumn) {
              var column = hiddenQueue.pop();
              var visibleIndex = this._columnsController.getVisibleIndex(column.index);
              rootElementWidth += this._calculateColumnWidth(column, rootElementWidth, visibleContentColumns, columnsCanFit);
              this._hideVisibleColumn({
                visibleIndex
              });
              resultWidths[visibleIndex] = HIDDEN_COLUMNS_WIDTH2;
              this._hiddenColumns.push(column);
              visibleContentColumns = getVisibleContentColumns();
            }
          } while (needHideColumn && visibleContentColumns.length > 1 && hiddenQueue.length);
          if (contentColumnsCount === visibleContentColumns.length) {
            this._hideAdaptiveColumn(resultWidths, visibleColumns);
          }
        } else {
          this._hideAdaptiveColumn(resultWidths, visibleColumns);
        }
      },
      getItemContentByColumnIndex: function(visibleColumnIndex) {
        var $itemContent;
        for (var i = 0; i < this._$itemContents.length; i++) {
          $itemContent = this._$itemContents.eq(i);
          var item = $itemContent.data("dx-form-item");
          if (item && item.column && this._columnsController.getVisibleIndex(item.column.index) === visibleColumnIndex) {
            return $itemContent;
          }
        }
      },
      toggleExpandAdaptiveDetailRow: function(key, alwaysExpanded) {
        if (!(this.isFormOrPopupEditMode() && this._editingController.isEditing())) {
          this.getController("data").toggleExpandAdaptiveDetailRow(key, alwaysExpanded);
        }
      },
      createFormByHiddenColumns: function(container, options2) {
        var that = this;
        var $container = renderer_default(container);
        var userFormOptions = {
          items: that._getFormItemsByHiddenColumns(that._hiddenColumns),
          formID: "dx-" + new guid_default()
        };
        var defaultFormOptions = isMaterial() ? {
          colCount: 2
        } : {};
        this.executeAction("onAdaptiveDetailRowPreparing", {
          formOptions: userFormOptions
        });
        that._$itemContents = null;
        that._form = that._createComponent(renderer_default("<div>").appendTo($container), form_default, extend2(defaultFormOptions, userFormOptions, {
          customizeItem: function(item) {
            var column = item.column || that._columnsController.columnOption(item.name || item.dataField);
            if (column) {
              item.label = item.label || {};
              item.label.text = item.label.text || column.caption;
              item.column = column;
              item.template = that._getTemplate(item, options2, that.updateForm.bind(that));
            }
            userFormOptions.customizeItem && userFormOptions.customizeItem.call(this, item);
          },
          onContentReady: function(e) {
            userFormOptions.onContentReady && userFormOptions.onContentReady.call(this, e);
            that._$itemContents = $container.find("." + FORM_ITEM_CONTENT_CLASS);
          }
        }));
      },
      hasAdaptiveDetailRowExpanded: function() {
        return isDefined(this._dataController.adaptiveExpandedKey());
      },
      updateForm: function(hiddenColumns) {
        if (this.hasAdaptiveDetailRowExpanded()) {
          if (this._form && isDefined(this._form._contentReadyAction)) {
            if (hiddenColumns && hiddenColumns.length) {
              this._form.option("items", this._getFormItemsByHiddenColumns(hiddenColumns));
            } else {
              this._form.repaint();
            }
          }
        }
      },
      updateHidingQueue: function(columns) {
        var hideableColumns = columns.filter(function(column) {
          return column.visible && !column.type && !column.fixed && !(isDefined(column.groupIndex) && column.groupIndex >= 0);
        });
        var columnsHasHidingPriority;
        var i;
        this._hidingColumnsQueue = [];
        if (this.option("allowColumnResizing") && "widget" === this.option("columnResizingMode")) {
          return this._hidingColumnsQueue;
        }
        for (i = 0; i < hideableColumns.length; i++) {
          if (isDefined(hideableColumns[i].hidingPriority) && hideableColumns[i].hidingPriority >= 0) {
            columnsHasHidingPriority = true;
            this._hidingColumnsQueue[hideableColumns[i].hidingPriority] = hideableColumns[i];
          }
        }
        if (columnsHasHidingPriority) {
          this._hidingColumnsQueue.reverse();
        } else if (this.option("columnHidingEnabled")) {
          for (i = 0; i < hideableColumns.length; i++) {
            var visibleIndex = this._columnsController.getVisibleIndex(hideableColumns[i].index);
            this._hidingColumnsQueue[visibleIndex] = hideableColumns[i];
          }
        }
        this._hidingColumnsQueue = this._hidingColumnsQueue.filter(Object);
        return this._hidingColumnsQueue;
      },
      getHiddenColumns: function() {
        return this._hiddenColumns;
      },
      hasHiddenColumns: function() {
        return this._hiddenColumns.length > 0;
      },
      getHidingColumnsQueue: function() {
        return this._hidingColumnsQueue;
      },
      init: function() {
        var that = this;
        that._columnsController = that.getController("columns");
        that._dataController = that.getController("data");
        that._rowsView = that.getView("rowsView");
        that._columnsController.addCommandColumn({
          type: ADAPTIVE_COLUMN_NAME,
          command: ADAPTIVE_COLUMN_NAME,
          visible: true,
          adaptiveHidden: true,
          cssClass: ADAPTIVE_COLUMN_NAME_CLASS,
          alignment: "center",
          width: "auto",
          cellTemplate: adaptiveCellTemplate,
          fixedPosition: "right"
        });
        that._columnsController.columnsChanged.add(function() {
          var isAdaptiveVisible = !!that.updateHidingQueue(that._columnsController.getColumns()).length;
          that._columnsController.columnOption("command:adaptive", "adaptiveHidden", !isAdaptiveVisible, true);
        });
        that._editingController = that.getController("editing");
        that._hidingColumnsQueue = [];
        that._hiddenColumns = [];
        that.createAction("onAdaptiveDetailRowPreparing");
        that.callBase();
      },
      optionChanged: function(args) {
        if ("columnHidingEnabled" === args.name) {
          this._columnsController.columnOption("command:adaptive", "adaptiveHidden", !args.value);
        }
        this.callBase(args);
      },
      publicMethods: function() {
        return ["isAdaptiveDetailRowExpanded", "expandAdaptiveDetailRow", "collapseAdaptiveDetailRow"];
      },
      isAdaptiveDetailRowExpanded: function(key) {
        return this._dataController.adaptiveExpandedKey() && equalByValue(this._dataController.adaptiveExpandedKey(), key);
      },
      expandAdaptiveDetailRow: function(key) {
        if (!this.hasAdaptiveDetailRowExpanded()) {
          this.toggleExpandAdaptiveDetailRow(key);
        }
      },
      collapseAdaptiveDetailRow: function() {
        if (this.hasAdaptiveDetailRowExpanded()) {
          this.toggleExpandAdaptiveDetailRow();
        }
      },
      updateCommandAdaptiveAriaLabel: function(key, label) {
        var rowIndex = this._dataController.getRowIndexByKey(key);
        if (-1 === rowIndex) {
          return;
        }
        var $row = renderer_default(this.component.getRowElement(rowIndex));
        this.setCommandAdaptiveAriaLabel($row, label);
      },
      setCommandAdaptiveAriaLabel: function($row, labelName) {
        var $adaptiveCommand = $row.find(".dx-command-adaptive");
        $adaptiveCommand.attr("aria-label", message_default.format(labelName));
      }
    });
    adaptivityModule = {
      defaultOptions: function() {
        return {
          columnHidingEnabled: false,
          onAdaptiveDetailRowPreparing: null
        };
      },
      controllers: {
        adaptiveColumns: AdaptiveColumnsController
      },
      extenders: {
        views: {
          rowsView: {
            _getCellTemplate: function(options2) {
              var that = this;
              var column = options2.column;
              if (options2.rowType === ADAPTIVE_ROW_TYPE && "detail" === column.command) {
                return function(container, options3) {
                  that._adaptiveColumnsController.createFormByHiddenColumns(renderer_default(container), options3);
                };
              }
              return that.callBase(options2);
            },
            _createRow: function(row) {
              var $row = this.callBase(row);
              if (row && row.rowType === ADAPTIVE_ROW_TYPE && row.key === this._dataController.adaptiveExpandedKey()) {
                $row.addClass(ADAPTIVE_DETAIL_ROW_CLASS);
              }
              return $row;
            },
            _renderCells: function($row, options2) {
              this.callBase($row, options2);
              var adaptiveColumnsController = this._adaptiveColumnsController;
              var hidingColumnsQueueLength = adaptiveColumnsController.getHidingColumnsQueue().length;
              var hiddenColumnsLength = adaptiveColumnsController.getHiddenColumns().length;
              if (hidingColumnsQueueLength && !hiddenColumnsLength) {
                getDataCellElements($row).last().addClass(LAST_DATA_CELL_CLASS);
              }
              if ("data" === options2.row.rowType) {
                adaptiveColumnsController.setCommandAdaptiveAriaLabel($row, EXPAND_ARIA_NAME);
              }
            },
            _getColumnIndexByElementCore: function($element) {
              var $itemContent = $element.closest("." + FORM_ITEM_CONTENT_CLASS);
              if ($itemContent.length && $itemContent.closest(this.component.$element()).length) {
                var formItem = $itemContent.length ? $itemContent.first().data("dx-form-item") : null;
                return formItem && formItem.column && this._columnsController.getVisibleIndex(formItem.column.index);
              } else {
                return this.callBase($element);
              }
            },
            _cellPrepared: function($cell, options2) {
              this.callBase.apply(this, arguments);
              if (options2.row.rowType !== ADAPTIVE_ROW_TYPE && options2.column.visibleWidth === HIDDEN_COLUMNS_WIDTH2) {
                $cell.addClass(this.addWidgetPrefix(HIDDEN_COLUMN_CLASS));
              }
            },
            _getCellElement: function(rowIndex, columnIdentifier) {
              var item = this._dataController.items()[rowIndex];
              if (item && item.rowType === ADAPTIVE_ROW_TYPE) {
                return this._adaptiveColumnsController.getItemContentByColumnIndex(columnIdentifier);
              } else {
                return this.callBase.apply(this, arguments);
              }
            },
            getContextMenuItems: function(options2) {
              if (options2.row && "detailAdaptive" === options2.row.rowType) {
                var view = this.component.getView("columnHeadersView");
                var formItem = renderer_default(options2.targetElement).closest(".dx-field-item-label").next().data("dx-form-item");
                options2.column = formItem ? formItem.column : options2.column;
                return view.getContextMenuItems && view.getContextMenuItems(options2);
              }
              return this.callBase && this.callBase(options2);
            },
            isClickableElement: function($target) {
              var isClickable = this.callBase ? this.callBase($target) : false;
              return isClickable || !!$target.closest("." + ADAPTIVE_COLUMN_NAME_CLASS).length;
            },
            init: function() {
              this.callBase();
              this._adaptiveColumnsController = this.getController("adaptiveColumns");
            }
          }
        },
        controllers: {
          export: {
            _updateColumnWidth: function(column, width) {
              this.callBase(column, column.visibleWidth === HIDDEN_COLUMNS_WIDTH2 ? column.bestFitWidth : width);
            }
          },
          columnsResizer: {
            _pointCreated: function(point, cellsLength, columns) {
              var result2 = this.callBase(point, cellsLength, columns);
              var currentColumn = columns[point.columnIndex] || {};
              var nextColumnIndex = this._getNextColumnIndex(point.columnIndex);
              var nextColumn = columns[nextColumnIndex] || {};
              var hasHiddenColumnsOnly = nextColumnIndex !== point.columnIndex + 1 && nextColumn.command;
              var hasAdaptiveHiddenWidth = currentColumn.visibleWidth === HIDDEN_COLUMNS_WIDTH2 || hasHiddenColumnsOnly;
              return result2 || hasAdaptiveHiddenWidth;
            },
            _getNextColumnIndex: function(currentColumnIndex) {
              var visibleColumns = this._columnsController.getVisibleColumns();
              var index2 = this.callBase(currentColumnIndex);
              while (visibleColumns[index2] && visibleColumns[index2].visibleWidth === HIDDEN_COLUMNS_WIDTH2) {
                index2++;
              }
              return index2;
            }
          },
          draggingHeader: {
            _pointCreated: function(point, columns, location, sourceColumn) {
              var result2 = this.callBase(point, columns, location, sourceColumn);
              var column = columns[point.columnIndex - 1] || {};
              var hasAdaptiveHiddenWidth = column.visibleWidth === HIDDEN_COLUMNS_WIDTH2;
              return result2 || hasAdaptiveHiddenWidth;
            }
          },
          editing: {
            _isRowEditMode: function() {
              return this.getEditMode() === EDIT_MODE_ROW4;
            },
            _getFormEditItemTemplate: function(cellOptions, column) {
              if (this.getEditMode() !== EDIT_MODE_ROW4 && "detailAdaptive" === cellOptions.rowType) {
                cellOptions.columnIndex = this._columnsController.getVisibleIndex(column.index);
                return this.getColumnTemplate(cellOptions);
              }
              return this.callBase(cellOptions, column);
            },
            _closeEditItem: function($targetElement) {
              var $itemContents = $targetElement.closest("." + FORM_ITEM_CONTENT_CLASS);
              var rowIndex = this._dataController.getRowIndexByKey(this._dataController.adaptiveExpandedKey()) + 1;
              var formItem = $itemContents.length ? $itemContents.first().data("dx-form-item") : null;
              var columnIndex = formItem && formItem.column && this._columnsController.getVisibleIndex(formItem.column.index);
              if (!this.isEditCell(rowIndex, columnIndex)) {
                this.callBase($targetElement);
              }
            },
            _beforeUpdateItems: function(rowIndices, rowIndex) {
              if (!this._adaptiveController.isFormOrPopupEditMode() && this._adaptiveController.hasHiddenColumns()) {
                var items = this._dataController.items();
                var item = items[rowIndex];
                var oldExpandRowIndex = ui_grid_core_utils_default.getIndexByKey(this._dataController.adaptiveExpandedKey(), items);
                this._isForceRowAdaptiveExpand = !this._adaptiveController.hasAdaptiveDetailRowExpanded();
                if (oldExpandRowIndex >= 0) {
                  rowIndices.push(oldExpandRowIndex + 1);
                }
                rowIndices.push(rowIndex + 1);
                this._dataController.adaptiveExpandedKey(item.key);
              }
            },
            _afterInsertRow: function(options2) {
              this.callBase(options2);
              if (this._adaptiveController.hasHiddenColumns()) {
                this._adaptiveController.toggleExpandAdaptiveDetailRow(options2.key, this.isRowEditMode());
                this._isForceRowAdaptiveExpand = true;
              }
            },
            _collapseAdaptiveDetailRow: function() {
              if (this._isRowEditMode() && this._isForceRowAdaptiveExpand) {
                this._adaptiveController.collapseAdaptiveDetailRow();
                this._isForceRowAdaptiveExpand = false;
              }
            },
            _cancelEditAdaptiveDetailRow: function() {
              if (this._adaptiveController.hasHiddenColumns()) {
                this._collapseAdaptiveDetailRow();
              }
            },
            _afterSaveEditData: function() {
              this.callBase.apply(this, arguments);
              var deferred = new Deferred();
              if (this._isRowEditMode() && this._adaptiveController.hasHiddenColumns()) {
                when(this.getController("validating").validate(true)).done((isValid) => {
                  if (isValid) {
                    this._cancelEditAdaptiveDetailRow();
                  }
                  deferred.resolve();
                });
              } else {
                deferred.resolve();
              }
              return deferred.promise();
            },
            _beforeCancelEditData: function() {
              this.callBase();
              this._cancelEditAdaptiveDetailRow();
            },
            _getRowIndicesForCascadeUpdating: function(row) {
              var rowIndices = this.callBase.apply(this, arguments);
              if (this._adaptiveController.isAdaptiveDetailRowExpanded(row.key)) {
                rowIndices.push(row.rowType === ADAPTIVE_ROW_TYPE ? row.rowIndex - 1 : row.rowIndex + 1);
              }
              return rowIndices;
            },
            _beforeCloseEditCellInBatchMode: function(rowIndices) {
              var expandedKey = this._dataController._adaptiveExpandedKey;
              if (expandedKey) {
                var rowIndex = ui_grid_core_utils_default.getIndexByKey(expandedKey, this._dataController.items());
                if (rowIndex > -1) {
                  rowIndices.unshift(rowIndex);
                }
              }
            },
            editRow: function(rowIndex) {
              if (this._adaptiveController.isFormOrPopupEditMode()) {
                this._adaptiveController.collapseAdaptiveDetailRow();
              }
              this.callBase(rowIndex);
            },
            deleteRow: function(rowIndex) {
              var rowKey = this._dataController.getKeyByRowIndex(rowIndex);
              if (this.getEditMode() === EDIT_MODE_BATCH4 && this._adaptiveController.isAdaptiveDetailRowExpanded(rowKey)) {
                this._adaptiveController.collapseAdaptiveDetailRow();
              }
              this.callBase(rowIndex);
            },
            init: function() {
              this.callBase();
              this._adaptiveController = this.getController("adaptiveColumns");
            }
          },
          resizing: {
            _needBestFit: function() {
              return this.callBase() || !!this._adaptiveColumnsController.getHidingColumnsQueue().length;
            },
            _updateScrollableForIE: function() {
              var that = this;
              if (browser_default.msie && parseInt(browser_default.version) <= 11) {
                this._updateScrollableTimeoutID = setTimeout(function() {
                  that.getView("rowsView")._updateScrollable();
                });
              }
            },
            _correctColumnWidths: function(resultWidths, visibleColumns) {
              var adaptiveController = this._adaptiveColumnsController;
              var columnAutoWidth = this.option("columnAutoWidth");
              var oldHiddenColumns = adaptiveController.getHiddenColumns();
              var hidingColumnsQueue = adaptiveController.updateHidingQueue(this._columnsController.getColumns());
              adaptiveController.hideRedundantColumns(resultWidths, visibleColumns, hidingColumnsQueue);
              var hiddenColumns = adaptiveController.getHiddenColumns();
              if (adaptiveController.hasAdaptiveDetailRowExpanded()) {
                if (oldHiddenColumns.length !== hiddenColumns.length) {
                  adaptiveController.updateForm(hiddenColumns);
                }
              }
              !hiddenColumns.length && adaptiveController.collapseAdaptiveDetailRow();
              if (columnAutoWidth && hidingColumnsQueue.length && !hiddenColumns.length) {
                this._updateScrollableForIE();
              }
              return this.callBase.apply(this, arguments);
            },
            _toggleBestFitMode: function(isBestFit) {
              isBestFit && this._adaptiveColumnsController._showHiddenColumns();
              this.callBase(isBestFit);
            },
            _needStretch: function() {
              var adaptiveColumnsController = this._adaptiveColumnsController;
              return this.callBase.apply(this, arguments) || adaptiveColumnsController.getHidingColumnsQueue().length || adaptiveColumnsController.hasHiddenColumns();
            },
            init: function() {
              this._adaptiveColumnsController = this.getController("adaptiveColumns");
              this.callBase();
            },
            dispose: function() {
              this.callBase.apply(this, arguments);
              clearTimeout(this._updateScrollableTimeoutID);
            }
          },
          data: {
            _processItems: function(items, change) {
              var that = this;
              var changeType = change.changeType;
              items = that.callBase.apply(that, arguments);
              if ("loadingAll" === changeType || !isDefined(that._adaptiveExpandedKey)) {
                return items;
              }
              var expandRowIndex = ui_grid_core_utils_default.getIndexByKey(that._adaptiveExpandedKey, items);
              if (expandRowIndex >= 0) {
                var item = items[expandRowIndex];
                items.splice(expandRowIndex + 1, 0, {
                  visible: true,
                  rowType: ADAPTIVE_ROW_TYPE,
                  key: item.key,
                  data: item.data,
                  node: item.node,
                  modifiedValues: item.modifiedValues,
                  isNewRow: item.isNewRow,
                  values: item.values
                });
              } else if ("refresh" === changeType) {
                that._adaptiveExpandedKey = void 0;
              }
              return items;
            },
            _getRowIndicesForExpand: function(key) {
              var rowIndices = this.callBase.apply(this, arguments);
              if (this.getController("adaptiveColumns").isAdaptiveDetailRowExpanded(key)) {
                var lastRowIndex = rowIndices[rowIndices.length - 1];
                rowIndices.push(lastRowIndex + 1);
              }
              return rowIndices;
            },
            adaptiveExpandedKey: function(value2) {
              if (isDefined(value2)) {
                this._adaptiveExpandedKey = value2;
              } else {
                return this._adaptiveExpandedKey;
              }
            },
            toggleExpandAdaptiveDetailRow: function(key, alwaysExpanded) {
              var oldExpandLoadedRowIndex = ui_grid_core_utils_default.getIndexByKey(this._adaptiveExpandedKey, this._items);
              var newExpandLoadedRowIndex = ui_grid_core_utils_default.getIndexByKey(key, this._items);
              if (oldExpandLoadedRowIndex >= 0 && oldExpandLoadedRowIndex === newExpandLoadedRowIndex && !alwaysExpanded) {
                key = void 0;
                newExpandLoadedRowIndex = -1;
              }
              var oldKey = this._adaptiveExpandedKey;
              this._adaptiveExpandedKey = key;
              if (oldExpandLoadedRowIndex >= 0) {
                oldExpandLoadedRowIndex++;
              }
              if (newExpandLoadedRowIndex >= 0) {
                newExpandLoadedRowIndex++;
              }
              var rowIndexDelta = this.getRowIndexDelta();
              this.updateItems({
                allowInvisibleRowIndices: true,
                changeType: "update",
                rowIndices: [oldExpandLoadedRowIndex - rowIndexDelta, newExpandLoadedRowIndex - rowIndexDelta]
              });
              var adaptiveColumnsController = this.getController("adaptiveColumns");
              adaptiveColumnsController.updateCommandAdaptiveAriaLabel(key, COLLAPSE_ARIA_NAME);
              adaptiveColumnsController.updateCommandAdaptiveAriaLabel(oldKey, EXPAND_ARIA_NAME);
            },
            init: function() {
              this.callBase();
              this._adaptiveExpandedKey = void 0;
            }
          },
          editorFactory: {
            _getFocusCellSelector: function() {
              return this.callBase() + ", .dx-adaptive-detail-row .dx-field-item > .dx-field-item-content";
            },
            _getTooltipsSelector: function() {
              return this.callBase() + ", .dx-field-item-content ." + this.addWidgetPrefix(REVERT_TOOLTIP_CLASS2);
            }
          },
          columns: {
            _isColumnVisible: function(column) {
              return this.callBase(column) && !column.adaptiveHidden;
            }
          },
          keyboardNavigation: {
            _isCellValid: function($cell) {
              return this.callBase.apply(this, arguments) && !$cell.hasClass(this.addWidgetPrefix(HIDDEN_COLUMN_CLASS));
            },
            _processNextCellInMasterDetail: function($nextCell) {
              this.callBase($nextCell);
              var isCellOrBatchMode = this._editingController.isCellOrBatchEditMode();
              if (!this._isInsideEditForm($nextCell) && $nextCell && isCellOrBatchMode) {
                events_engine_default.on($nextCell, "focus", function focusHandler() {
                  events_engine_default.off($nextCell, "focus", focusHandler);
                  events_engine_default.trigger($nextCell, "dxclick");
                });
              }
            },
            _handleTabKeyOnMasterDetailCell: function(eventTarget, direction) {
              var result2 = this.callBase(eventTarget, direction);
              var $currentCell = this._getFocusedCell();
              var $row = $currentCell && $currentCell.parent();
              if (!result2 && $row && $row.length) {
                var $dataCells = getDataCellElements($row);
                var $targetCell = "next" === direction ? $dataCells.last() : $dataCells.first();
                var rowIndex = $row.get(0).rowIndex;
                var adaptiveController = this._adaptiveController;
                var key = this._dataController.getKeyByRowIndex("next" === direction ? rowIndex : rowIndex - 1);
                var isCellElementsEquals = $currentCell && $targetCell && $currentCell.get(0) === $targetCell.get(0);
                return adaptiveController.isAdaptiveDetailRowExpanded(key) && isCellElementsEquals;
              }
              return result2;
            },
            init: function() {
              this.callBase();
              this._adaptiveController = this.getController("adaptiveColumns");
            }
          }
        }
      }
    };
  }
});

// node_modules/devextreme/esm/ui/grid_core/ui.grid_core.virtual_columns_core.js
function foreachColumnInfo(info, callback, rowIndex, offsets, columnCount, lastProcessedIndexes) {
  rowIndex = rowIndex || 0;
  offsets = offsets || [];
  lastProcessedIndexes = lastProcessedIndexes || [];
  offsets[rowIndex] = offsets[rowIndex] || 0;
  var row = info[rowIndex];
  var startIndex = lastProcessedIndexes[rowIndex] + 1 || 0;
  var processedColumnCount = 0;
  var colIndex;
  if (!row) {
    return;
  }
  for (colIndex = startIndex; colIndex < row.length; colIndex++) {
    var cell = row[colIndex];
    var visibleIndex = colIndex + offsets[rowIndex];
    var colspan = cell.colspan || 1;
    foreachColumnInfo(info, callback, rowIndex + (cell.rowspan || 1), offsets, colspan, lastProcessedIndexes);
    offsets[rowIndex] += colspan - 1;
    processedColumnCount += colspan;
    if (cell.rowspan) {
      for (var i = rowIndex + 1; i < rowIndex + cell.rowspan; i++) {
        offsets[i] = offsets[i] || 0;
        offsets[i] += cell.colspan || 1;
      }
    }
    if (false === callback(cell, visibleIndex, rowIndex, colIndex)) {
      break;
    }
    if (void 0 !== columnCount && processedColumnCount >= columnCount) {
      break;
    }
  }
  lastProcessedIndexes[rowIndex] = colIndex;
}
function createColumnsInfo(info, startIndex, endIndex) {
  var newInfo = [];
  foreachColumnInfo(info, function(columnInfo, visibleIndex, rowIndex) {
    var cell = columnInfo;
    var colspan;
    var cellColspan = cell.colspan || 1;
    var isVisible2 = visibleIndex + cellColspan - 1 >= startIndex && visibleIndex < endIndex;
    newInfo[rowIndex] = newInfo[rowIndex] || [];
    if (isVisible2) {
      if (visibleIndex < startIndex) {
        colspan = cellColspan - (startIndex - visibleIndex);
        visibleIndex = startIndex;
      } else {
        colspan = cellColspan;
      }
      if (visibleIndex + colspan > endIndex) {
        colspan = endIndex - visibleIndex;
      }
      if (colspan !== cellColspan) {
        cell = extend2({}, cell, {
          colspan
        });
      }
      newInfo[rowIndex].push(cell);
    } else if (visibleIndex > endIndex) {
      return false;
    }
  });
  for (var i = 0; i < newInfo.length; i++) {
    newInfo[i] = newInfo[i] || [];
  }
  return newInfo;
}
var init_ui_grid_core_virtual_columns_core = __esm({
  "node_modules/devextreme/esm/ui/grid_core/ui.grid_core.virtual_columns_core.js"() {
    init_extend();
  }
});

// node_modules/devextreme/esm/ui/grid_core/ui.grid_core.virtual_columns.js
var DEFAULT_COLUMN_WIDTH, VirtualScrollingRowsViewExtender2, HeaderViewExtender, ColumnsControllerExtender, virtualColumnsModule;
var init_ui_grid_core_virtual_columns = __esm({
  "node_modules/devextreme/esm/ui/grid_core/ui.grid_core.virtual_columns.js"() {
    init_window();
    init_ui_grid_core_virtual_columns_core();
    init_type();
    DEFAULT_COLUMN_WIDTH = 50;
    VirtualScrollingRowsViewExtender2 = {
      _resizeCore: function() {
        this.callBase.apply(this, arguments);
        this._columnsController.resize();
      },
      _handleScroll: function(e) {
        var that = this;
        var scrollable = this.getScrollable();
        var left = e.scrollOffset.left;
        that.callBase.apply(that, arguments);
        if (that.option("rtlEnabled") && scrollable) {
          left = scrollable.$content().width() - scrollable.$element().width() - left;
        }
        that._columnsController.setScrollPosition(left);
      }
    };
    HeaderViewExtender = {
      _renderCore: function() {
        this.callBase.apply(this, arguments);
        if (this._columnsController.isVirtualMode()) {
          this._updateScrollLeftPosition();
        }
      }
    };
    ColumnsControllerExtender = /* @__PURE__ */ function() {
      var getWidths = function(columns) {
        return columns.map((column) => column.visibleWidth || parseFloat(column.width) || DEFAULT_COLUMN_WIDTH);
      };
      var members = {
        init: function() {
          this.callBase();
          this._beginPageIndex = null;
          this._endPageIndex = null;
          this._position = 0;
          this._virtualVisibleColumns = {};
        },
        resetColumnsCache: function() {
          this.callBase();
          this._virtualVisibleColumns = {};
        },
        getBeginPageIndex: function(position3) {
          var visibleColumns = this.getVisibleColumns(void 0, true);
          var widths = getWidths(visibleColumns);
          var currentPosition = 0;
          for (var index2 = 0; index2 < widths.length; index2++) {
            if (currentPosition >= position3) {
              return Math.floor(index2 / this.getColumnPageSize());
            }
            currentPosition += widths[index2];
          }
          return 0;
        },
        getTotalWidth: function() {
          var width = this.option("width");
          if ("number" === typeof width) {
            return width;
          }
          return this.getController("resizing")._lastWidth || this.component.$element().outerWidth();
        },
        getEndPageIndex: function(position3) {
          var visibleColumns = this.getVisibleColumns(void 0, true);
          var widths = getWidths(visibleColumns);
          var currentPosition = 0;
          position3 += this.getTotalWidth();
          for (var index2 = 0; index2 < widths.length; index2++) {
            if (currentPosition >= position3) {
              return Math.ceil(index2 / this.getColumnPageSize());
            }
            currentPosition += widths[index2];
          }
          return Math.ceil(widths.length / this.getColumnPageSize());
        },
        getColumnPageSize: function() {
          return this.option("scrolling.columnPageSize");
        },
        _fireColumnsChanged: function() {
          var date = /* @__PURE__ */ new Date();
          this.columnsChanged.fire({
            optionNames: {
              all: true,
              length: 1
            },
            changeTypes: {
              columns: true,
              virtualColumnsScrolling: true,
              length: 2
            }
          });
          this._renderTime = /* @__PURE__ */ new Date() - date;
        },
        setScrollPosition: function(position3) {
          var that = this;
          var renderingThreshold = that.option("scrolling.columnRenderingThreshold");
          if (that._renderTime > renderingThreshold) {
            clearTimeout(that._changedTimeout);
            that._changedTimeout = setTimeout(function() {
              that._setScrollPositionCore(position3);
            }, that.option("scrolling.timeout"));
          } else {
            that._setScrollPositionCore(position3);
          }
        },
        isVirtualMode: function() {
          return hasWindow() && "virtual" === this.option("scrolling.columnRenderingMode");
        },
        resize: function() {
          this._setScrollPositionCore(this._position);
        },
        _setScrollPositionCore: function(position3) {
          if (this.isVirtualMode()) {
            var beginPageIndex = this.getBeginPageIndex(position3);
            var endPageIndex = this.getEndPageIndex(position3);
            var needColumnsChanged = position3 < this._position ? this._beginPageIndex > beginPageIndex : this._endPageIndex < endPageIndex;
            this._position = position3;
            if (needColumnsChanged) {
              this._beginPageIndex = beginPageIndex;
              this._endPageIndex = endPageIndex;
              this._fireColumnsChanged();
            }
          }
        },
        getFixedColumns: function(rowIndex, isBase) {
          var fixedColumns = this.callBase(rowIndex);
          if (this.isVirtualMode() && !isBase && fixedColumns.length) {
            var transparentColumnIndex = fixedColumns.map((c) => c.command).indexOf("transparent");
            fixedColumns[transparentColumnIndex].colspan = this.getVisibleColumns().length - this.callBase().length + 1;
            return fixedColumns;
          }
          return fixedColumns;
        },
        getVisibleColumns: function(rowIndex, isBase) {
          var _this$_columns;
          if (isBase || !this.isVirtualMode()) {
            return this.callBase(rowIndex);
          }
          if (null !== (_this$_columns = this._columns) && void 0 !== _this$_columns && _this$_columns.length && !isDefined(this._beginPageIndex) && !isDefined(this._endPageIndex)) {
            this._beginPageIndex = this.getBeginPageIndex(this._position);
            this._endPageIndex = this.getEndPageIndex(this._position);
          }
          var beginPageIndex = this._beginPageIndex;
          var endPageIndex = this._endPageIndex;
          var visibleColumnsHash = rowIndex + "-" + beginPageIndex + "-" + endPageIndex;
          if (this._virtualVisibleColumns[visibleColumnsHash]) {
            return this._virtualVisibleColumns[visibleColumnsHash];
          }
          var visibleColumns = this.callBase();
          var rowCount = this.getRowCount();
          var pageSize = this.getColumnPageSize();
          var startIndex = beginPageIndex * pageSize;
          var endIndex = endPageIndex * pageSize;
          var fixedColumns = this.getFixedColumns(void 0, true);
          var transparentColumnIndex = fixedColumns.map((c) => c.command).indexOf("transparent");
          var beginFixedColumnCount = fixedColumns.length ? transparentColumnIndex : 0;
          var beginFixedColumns = visibleColumns.slice(0, beginFixedColumnCount);
          var beginColumns = visibleColumns.slice(beginFixedColumnCount, startIndex);
          var beginWidth = getWidths(beginColumns).reduce((a, b) => a + b, 0);
          if (!beginWidth) {
            startIndex = 0;
          }
          var endFixedColumnCount = fixedColumns.length ? fixedColumns.length - transparentColumnIndex - 1 : 0;
          var endFixedColumns = visibleColumns.slice(visibleColumns.length - endFixedColumnCount);
          var endColumns = visibleColumns.slice(endIndex, visibleColumns.length - endFixedColumnCount);
          var endWidth = getWidths(endColumns).reduce((a, b) => a + b, 0);
          if (!endWidth) {
            endIndex = visibleColumns.length;
          }
          if (rowCount > 1 && "number" === typeof rowIndex) {
            var columnsInfo = [];
            for (var i = 0; i < rowCount; i++) {
              columnsInfo.push(this.callBase(i));
            }
            beginFixedColumns = createColumnsInfo(columnsInfo, 0, beginFixedColumns.length)[rowIndex] || [];
            endFixedColumns = createColumnsInfo(columnsInfo, visibleColumns.length - endFixedColumns.length, visibleColumns.length)[rowIndex] || [];
            visibleColumns = createColumnsInfo(columnsInfo, startIndex, endIndex)[rowIndex] || [];
          } else {
            visibleColumns = visibleColumns.slice(startIndex, endIndex);
          }
          if (beginWidth) {
            visibleColumns.unshift({
              command: "virtual",
              width: beginWidth
            });
            visibleColumns = beginFixedColumns.concat(visibleColumns);
          }
          if (endWidth) {
            visibleColumns.push({
              command: "virtual",
              width: endWidth
            });
            visibleColumns = visibleColumns.concat(endFixedColumns);
          }
          this._virtualVisibleColumns[visibleColumnsHash] = visibleColumns;
          return visibleColumns;
        },
        getColumnIndexOffset: function() {
          var offset2 = 0;
          if (this._beginPageIndex > 0) {
            var fixedColumns = this.getFixedColumns();
            var transparentColumnIndex = fixedColumns.map((c) => c.command).indexOf("transparent");
            var leftFixedColumnCount = transparentColumnIndex >= 0 ? transparentColumnIndex : 0;
            offset2 = this._beginPageIndex * this.getColumnPageSize() - leftFixedColumnCount - 1;
          }
          return offset2 > 0 ? offset2 : 0;
        },
        dispose: function() {
          clearTimeout(this._changedTimeout);
          this.callBase.apply(this, arguments);
        }
      };
      return members;
    }();
    virtualColumnsModule = {
      defaultOptions: function() {
        return {
          scrolling: {
            columnRenderingMode: "standard",
            columnPageSize: 5,
            columnRenderingThreshold: 300
          }
        };
      },
      extenders: {
        controllers: {
          columns: ColumnsControllerExtender
        },
        views: {
          columnHeadersView: HeaderViewExtender,
          rowsView: VirtualScrollingRowsViewExtender2
        }
      }
    };
  }
});

// node_modules/devextreme/esm/ui/grid_core/ui.grid_core.focus.js
var ROW_FOCUSED_CLASS, FOCUSED_ROW_SELECTOR2, TABLE_POSTFIX_CLASS, CELL_FOCUS_DISABLED_CLASS5, FocusController, focusModule;
var init_ui_grid_core_focus = __esm({
  "node_modules/devextreme/esm/ui/grid_core/ui.grid_core.focus.js"() {
    init_renderer();
    init_ui_grid_core_modules();
    init_iterator();
    init_ui_grid_core_utils();
    init_common();
    init_type();
    init_deferred();
    ROW_FOCUSED_CLASS = "dx-row-focused";
    FOCUSED_ROW_SELECTOR2 = ".dx-row." + ROW_FOCUSED_CLASS;
    TABLE_POSTFIX_CLASS = "table";
    CELL_FOCUS_DISABLED_CLASS5 = "dx-cell-focus-disabled";
    FocusController = ui_grid_core_modules_default.ViewController.inherit({
      init: function() {
        this._dataController = this.getController("data");
        this._keyboardController = this.getController("keyboardNavigation");
        this.component._optionsByReference.focusedRowKey = true;
      },
      optionChanged: function(args) {
        if ("focusedRowIndex" === args.name) {
          var focusedRowKey = this.option("focusedRowKey");
          this._focusRowByIndex(args.value);
          this._triggerFocusedRowChangedIfNeed(focusedRowKey, args.value);
          args.handled = true;
        } else if ("focusedRowKey" === args.name) {
          args.handled = true;
          if (Array.isArray(args.value) && JSON.stringify(args.value) === JSON.stringify(args.previousValue)) {
            return;
          }
          var focusedRowIndex = this.option("focusedRowIndex");
          this._focusRowByKey(args.value);
          this._triggerFocusedRowChangedIfNeed(args.value, focusedRowIndex);
        } else if ("focusedColumnIndex" === args.name) {
          args.handled = true;
        } else if ("focusedRowEnabled" === args.name) {
          args.handled = true;
        } else if ("autoNavigateToFocusedRow" === args.name) {
          args.handled = true;
        } else {
          this.callBase(args);
        }
      },
      _triggerFocusedRowChangedIfNeed: function(focusedRowKey, focusedRowIndex) {
        var focusedRowIndexByKey = this.getFocusedRowIndexByKey(focusedRowKey);
        if (focusedRowIndex === focusedRowIndexByKey) {
          var rowIndex = this._dataController.getRowIndexByKey(focusedRowKey);
          if (rowIndex >= 0) {
            var $rowElement = renderer_default(this.getView("rowsView").getRowElement(rowIndex));
            this.getController("keyboardNavigation")._fireFocusedRowChanged($rowElement, focusedRowIndex);
          }
        }
      },
      isAutoNavigateToFocusedRow: function() {
        return "infinite" !== this.option("scrolling.mode") && this.option("autoNavigateToFocusedRow");
      },
      _focusRowByIndex: function(index2, operationTypes) {
        if (!this.option("focusedRowEnabled")) {
          return;
        }
        index2 = void 0 !== index2 ? index2 : this.option("focusedRowIndex");
        if (index2 < 0) {
          if (this.isAutoNavigateToFocusedRow()) {
            this._resetFocusedRow();
          }
        } else {
          this._focusRowByIndexCore(index2, operationTypes);
        }
      },
      _focusRowByIndexCore: function(index2, operationTypes) {
        var dataController = this.getController("data");
        var pageSize = dataController.pageSize();
        var setKeyByIndex = () => {
          if (this._isValidFocusedRowIndex(index2)) {
            var rowIndex = index2 - dataController.getRowIndexOffset(true);
            if (!operationTypes || operationTypes.paging && !operationTypes.filtering) {
              var lastItemIndex = dataController._getLastItemIndex();
              rowIndex = Math.min(rowIndex, lastItemIndex);
            }
            var focusedRowKey = dataController.getKeyByRowIndex(rowIndex, true);
            if (isDefined(focusedRowKey) && !this.isRowFocused(focusedRowKey)) {
              this.option("focusedRowKey", focusedRowKey);
            }
          }
        };
        if (pageSize >= 0) {
          if (!this._isLocalRowIndex(index2)) {
            var pageIndex = Math.floor(index2 / dataController.pageSize());
            when(dataController.pageIndex(pageIndex), dataController.waitReady()).done(() => {
              setKeyByIndex();
            });
          } else {
            setKeyByIndex();
          }
        }
      },
      _isLocalRowIndex(index2) {
        var dataController = this.getController("data");
        var isVirtualScrolling = this.getController("keyboardNavigation")._isVirtualScrolling();
        if (isVirtualScrolling) {
          var pageIndex = Math.floor(index2 / dataController.pageSize());
          var virtualItems = dataController.virtualItemsCount();
          var virtualItemsBegin = virtualItems ? virtualItems.begin : -1;
          var visibleRowsCount = dataController.getVisibleRows().length + dataController.getRowIndexOffset();
          var visiblePagesCount = Math.ceil(visibleRowsCount / dataController.pageSize());
          return virtualItemsBegin <= index2 && visiblePagesCount > pageIndex;
        }
        return true;
      },
      _setFocusedRowKeyByIndex: function(index2) {
        var dataController = this.getController("data");
        if (this._isValidFocusedRowIndex(index2)) {
          var rowIndex = Math.min(index2 - dataController.getRowIndexOffset(), dataController.items().length - 1);
          var focusedRowKey = dataController.getKeyByRowIndex(rowIndex);
          if (isDefined(focusedRowKey) && !this.isRowFocused(focusedRowKey)) {
            this.option("focusedRowKey", focusedRowKey);
          }
        }
      },
      _focusRowByKey: function(key) {
        if (!isDefined(key)) {
          this._resetFocusedRow();
        } else {
          this._navigateToRow(key, true);
        }
      },
      _resetFocusedRow: function() {
        var focusedRowKey = this.option("focusedRowKey");
        var isFocusedRowKeyDefined = isDefined(focusedRowKey);
        if (!isFocusedRowKeyDefined && this.option("focusedRowIndex") < 0) {
          return;
        }
        var keyboardController = this.getController("keyboardNavigation");
        if (isFocusedRowKeyDefined) {
          this.option("focusedRowKey", void 0);
        }
        keyboardController.setFocusedRowIndex(-1);
        this.option("focusedRowIndex", -1);
        this.getController("data").updateItems({
          changeType: "updateFocusedRow",
          focusedRowKey: void 0
        });
        keyboardController._fireFocusedRowChanged(void 0, -1);
      },
      _isValidFocusedRowIndex: function(rowIndex) {
        var dataController = this.getController("data");
        var row = dataController.getVisibleRows()[rowIndex];
        return !row || "data" === row.rowType || "group" === row.rowType;
      },
      publicMethods: function() {
        return ["navigateToRow", "isRowFocused"];
      },
      navigateToRow: function(key) {
        if (!this.isAutoNavigateToFocusedRow()) {
          this.option("focusedRowIndex", -1);
        }
        this._navigateToRow(key);
      },
      _navigateToRow: function(key, needFocusRow) {
        var that = this;
        var dataController = that.getController("data");
        var isAutoNavigate = that.isAutoNavigateToFocusedRow();
        var d = new Deferred();
        if (void 0 === key || !dataController.dataSource()) {
          return d.reject().promise();
        }
        var rowIndexByKey = that.getFocusedRowIndexByKey(key);
        if (!isAutoNavigate && needFocusRow || rowIndexByKey >= 0) {
          that._navigateTo(key, d, needFocusRow);
        } else {
          dataController.getPageIndexByKey(key).done(function(pageIndex) {
            if (pageIndex < 0) {
              d.resolve(-1);
              return;
            }
            if (pageIndex === dataController.pageIndex()) {
              dataController.reload().done(function() {
                if (that.isRowFocused(key)) {
                  d.resolve(that.getFocusedRowIndexByKey(key));
                } else {
                  that._navigateTo(key, d, needFocusRow);
                }
              }).fail(d.reject);
            } else {
              dataController.pageIndex(pageIndex).done(function() {
                that._navigateTo(key, d, needFocusRow);
              }).fail(d.reject);
            }
          }).fail(d.reject);
        }
        return d.promise();
      },
      _navigateTo: function(key, deferred, needFocusRow) {
        var visibleRowIndex = this.getController("data").getRowIndexByKey(key);
        var isVirtualRowRenderingMode = "virtual" === this.option("scrolling.rowRenderingMode");
        var isAutoNavigate = this.isAutoNavigateToFocusedRow();
        if (isAutoNavigate && isVirtualRowRenderingMode && visibleRowIndex < 0) {
          this._navigateToVirtualRow(key, deferred, needFocusRow);
        } else {
          this._navigateToVisibleRow(key, deferred, needFocusRow);
        }
      },
      _navigateToVisibleRow: function(key, deferred, needFocusRow) {
        if (needFocusRow) {
          this._triggerUpdateFocusedRow(key, deferred);
        } else {
          this.getView("rowsView").scrollToRowElement(key);
        }
      },
      _navigateToVirtualRow: function(key, deferred, needFocusRow) {
        var that = this;
        var dataController = this.getController("data");
        var rowsScrollController = dataController._rowsScrollController;
        var rowIndex = ui_grid_core_utils_default.getIndexByKey(key, dataController.items(true));
        var scrollable = that.getView("rowsView").getScrollable();
        if (rowsScrollController && scrollable && rowIndex >= 0) {
          var focusedRowIndex = rowIndex + dataController.getRowIndexOffset(true);
          var offset2 = rowsScrollController.getItemOffset(focusedRowIndex);
          if (needFocusRow) {
            that.component.on("contentReady", function triggerUpdateFocusedRow() {
              that.component.off("contentReady", triggerUpdateFocusedRow);
              that._triggerUpdateFocusedRow(key, deferred);
            });
          }
          scrollable.scrollTo({
            y: offset2
          });
        }
      },
      _triggerUpdateFocusedRow: function(key, deferred) {
        var dataController = this.getController("data");
        var focusedRowIndex = this.getFocusedRowIndexByKey(key);
        if (this._isValidFocusedRowIndex(focusedRowIndex)) {
          if (this.option("focusedRowEnabled")) {
            dataController.updateItems({
              changeType: "updateFocusedRow",
              focusedRowKey: key
            });
          } else {
            this.getView("rowsView").scrollToRowElement(key);
          }
          this.getController("keyboardNavigation").setFocusedRowIndex(focusedRowIndex);
          deferred && deferred.resolve(focusedRowIndex);
        } else {
          deferred && deferred.resolve(-1);
        }
      },
      getFocusedRowIndexByKey: function(key) {
        var dataController = this.getController("data");
        var loadedRowIndex = dataController.getRowIndexByKey(key, true);
        return loadedRowIndex >= 0 ? loadedRowIndex + dataController.getRowIndexOffset(true) : -1;
      },
      _focusRowByKeyOrIndex: function() {
        var focusedRowKey = this.option("focusedRowKey");
        var currentFocusedRowIndex = this.option("focusedRowIndex");
        var keyboardController = this.getController("keyboardNavigation");
        var dataController = this.getController("data");
        if (isDefined(focusedRowKey)) {
          var visibleRowIndex = dataController.getRowIndexByKey(focusedRowKey);
          if (visibleRowIndex >= 0) {
            if (keyboardController._isVirtualScrolling()) {
              currentFocusedRowIndex = visibleRowIndex + dataController.getRowIndexOffset();
            }
            keyboardController.setFocusedRowIndex(currentFocusedRowIndex);
            this._triggerUpdateFocusedRow(focusedRowKey);
          } else {
            this._navigateToRow(focusedRowKey, true).done((focusedRowIndex) => {
              if (currentFocusedRowIndex >= 0 && focusedRowIndex < 0) {
                this._focusRowByIndex();
              } else if (currentFocusedRowIndex < 0 && focusedRowIndex >= 0) {
                keyboardController.setFocusedRowIndex(focusedRowIndex);
              }
            });
          }
        } else if (currentFocusedRowIndex >= 0) {
          this.getController("focus")._focusRowByIndex(currentFocusedRowIndex);
        }
      },
      isRowFocused: function(key) {
        var focusedRowKey = this.option("focusedRowKey");
        if (isDefined(focusedRowKey)) {
          return equalByValue(key, this.option("focusedRowKey"));
        }
      },
      updateFocusedRow: function(change) {
        var that = this;
        var focusedRowIndex = that._dataController.getRowIndexByKey(change.focusedRowKey);
        var rowsView = that.getView("rowsView");
        var $tableElement;
        var $mainRow;
        each(rowsView.getTableElements(), function(index2, element) {
          var _change$items;
          var isMainTable = 0 === index2;
          $tableElement = renderer_default(element);
          that._clearPreviousFocusedRow($tableElement, focusedRowIndex);
          var $row = that._prepareFocusedRow({
            changedItem: null === change || void 0 === change ? void 0 : null === (_change$items = change.items) || void 0 === _change$items ? void 0 : _change$items[focusedRowIndex],
            $tableElement,
            focusedRowIndex
          });
          if (isMainTable) {
            $mainRow = $row;
          }
        });
        $mainRow && rowsView.scrollToElementVertically($mainRow);
      },
      _clearPreviousFocusedRow: function($tableElement, focusedRowIndex) {
        var $prevRowFocusedElement = $tableElement.find(FOCUSED_ROW_SELECTOR2).filter((_2, focusedRow) => {
          var $focusedRowTable = renderer_default(focusedRow).closest(".".concat(this.addWidgetPrefix(TABLE_POSTFIX_CLASS)));
          return $tableElement.is($focusedRowTable);
        });
        $prevRowFocusedElement.removeClass(ROW_FOCUSED_CLASS).removeClass(CELL_FOCUS_DISABLED_CLASS5).removeAttr("tabindex");
        $prevRowFocusedElement.children("td").removeAttr("tabindex");
        if (0 !== focusedRowIndex) {
          var $firstRow = renderer_default(this.getView("rowsView").getRowElement(0));
          $firstRow.removeClass(CELL_FOCUS_DISABLED_CLASS5).removeAttr("tabIndex");
        }
      },
      _prepareFocusedRow: function(options2) {
        var $row;
        var changedItem = options2.changedItem;
        if (changedItem && ("data" === changedItem.rowType || "group" === changedItem.rowType)) {
          var focusedRowIndex = options2.focusedRowIndex;
          var $tableElement = options2.$tableElement;
          var tabIndex = this.option("tabindex") || 0;
          var rowsView = this.getView("rowsView");
          $row = renderer_default(rowsView._getRowElements($tableElement).eq(focusedRowIndex));
          $row.addClass(ROW_FOCUSED_CLASS).attr("tabindex", tabIndex);
        }
        return $row;
      }
    });
    focusModule = {
      defaultOptions: function() {
        return {
          focusedRowEnabled: false,
          autoNavigateToFocusedRow: true,
          focusedRowKey: void 0,
          focusedRowIndex: -1,
          focusedColumnIndex: -1
        };
      },
      controllers: {
        focus: FocusController
      },
      extenders: {
        controllers: {
          keyboardNavigation: {
            init: function() {
              var rowIndex = this.option("focusedRowIndex");
              var columnIndex = this.option("focusedColumnIndex");
              this.createAction("onFocusedRowChanging", {
                excludeValidators: ["disabled", "readOnly"]
              });
              this.createAction("onFocusedRowChanged", {
                excludeValidators: ["disabled", "readOnly"]
              });
              this.createAction("onFocusedCellChanging", {
                excludeValidators: ["disabled", "readOnly"]
              });
              this.createAction("onFocusedCellChanged", {
                excludeValidators: ["disabled", "readOnly"]
              });
              this.callBase();
              this.setRowFocusType();
              this._focusedCellPosition = {};
              if (isDefined(rowIndex)) {
                this._focusedCellPosition.rowIndex = this.option("focusedRowIndex");
              }
              if (isDefined(columnIndex)) {
                this._focusedCellPosition.columnIndex = this.option("focusedColumnIndex");
              }
            },
            setFocusedRowIndex: function(rowIndex) {
              var dataController = this.getController("data");
              this.callBase(rowIndex);
              var visibleRowIndex = rowIndex - dataController.getRowIndexOffset();
              var visibleRow = dataController.getVisibleRows()[visibleRowIndex];
              if (!visibleRow || !visibleRow.isNewRow) {
                this.option("focusedRowIndex", rowIndex);
              }
            },
            setFocusedColumnIndex: function(columnIndex) {
              this.callBase(columnIndex);
              this.option("focusedColumnIndex", columnIndex);
            },
            _escapeKeyHandler: function(eventArgs, isEditing) {
              if (isEditing || !this.option("focusedRowEnabled")) {
                this.callBase(eventArgs, isEditing);
                return;
              }
              if (this.isCellFocusType()) {
                this.setRowFocusType();
                this._focus(this._getCellElementFromTarget(eventArgs.originalEvent.target), true);
              }
            },
            _updateFocusedCellPosition: function($cell, direction) {
              var prevRowIndex = this.option("focusedRowIndex");
              var prevColumnIndex = this.option("focusedColumnIndex");
              var position3 = this.callBase($cell, direction);
              if (position3 && position3.columnIndex >= 0) {
                this._fireFocusedCellChanged($cell, prevColumnIndex, prevRowIndex);
              }
            }
          },
          editorFactory: {
            renderFocusOverlay: function($element, hideBorder) {
              var keyboardController = this.getController("keyboardNavigation");
              var focusedRowEnabled = this.option("focusedRowEnabled");
              var editingController = this.getController("editing");
              var isRowElement = "row" === keyboardController._getElementType($element);
              var $cell;
              if (!focusedRowEnabled || !keyboardController.isRowFocusType() || editingController.isEditing()) {
                this.callBase($element, hideBorder);
              } else if (focusedRowEnabled) {
                if (isRowElement && !$element.hasClass(ROW_FOCUSED_CLASS)) {
                  $cell = keyboardController.getFirstValidCellInRow($element);
                  keyboardController.focus($cell);
                }
              }
            }
          },
          columns: {
            getSortDataSourceParameters: function(_2, sortByKey) {
              var result2 = this.callBase.apply(this, arguments);
              var dataController = this.getController("data");
              var dataSource = dataController._dataSource;
              var store = dataController.store();
              var key = store && store.key();
              var remoteOperations = dataSource && dataSource.remoteOperations() || {};
              var isLocalOperations = Object.keys(remoteOperations).every((operationName) => !remoteOperations[operationName]);
              if (key && (this.option("focusedRowEnabled") && false !== this.getController("focus").isAutoNavigateToFocusedRow() || sortByKey)) {
                key = Array.isArray(key) ? key : [key];
                var notSortedKeys = key.filter((key2) => !this.columnOption(key2, "sortOrder"));
                if (notSortedKeys.length) {
                  result2 = result2 || [];
                  if (isLocalOperations) {
                    result2.push({
                      selector: dataSource.getDataIndexGetter(),
                      desc: false
                    });
                  } else {
                    notSortedKeys.forEach((notSortedKey) => result2.push({
                      selector: notSortedKey,
                      desc: false
                    }));
                  }
                }
              }
              return result2;
            }
          },
          data: {
            _applyChange: function(change) {
              if (change && "updateFocusedRow" === change.changeType) {
                return;
              }
              return this.callBase.apply(this, arguments);
            },
            _fireChanged: function(e) {
              this.callBase(e);
              if (this.option("focusedRowEnabled") && this._dataSource) {
                var isPartialUpdate = "update" === e.changeType && e.repaintChangesOnly;
                var isPartialUpdateWithDeleting = isPartialUpdate && e.changeTypes && e.changeTypes.indexOf("remove") >= 0;
                if ("refresh" === e.changeType && e.items.length || isPartialUpdateWithDeleting) {
                  this._updatePageIndexes();
                  this.processUpdateFocusedRow(e);
                } else if ("append" === e.changeType || "prepend" === e.changeType) {
                  this._updatePageIndexes();
                } else if ("update" === e.changeType && e.repaintChangesOnly) {
                  this.processUpdateFocusedRow(e);
                }
              }
            },
            _updatePageIndexes: function() {
              var prevRenderingPageIndex = this._lastRenderingPageIndex || 0;
              var renderingPageIndex = this._rowsScrollController ? this._rowsScrollController.pageIndex() : 0;
              this._lastRenderingPageIndex = renderingPageIndex;
              this._isPagingByRendering = renderingPageIndex !== prevRenderingPageIndex;
            },
            isPagingByRendering: function() {
              return this._isPagingByRendering;
            },
            processUpdateFocusedRow: function(e) {
              var operationTypes = e.operationTypes || {};
              var focusController = this.getController("focus");
              var {
                reload,
                fullReload
              } = operationTypes;
              var keyboardController = this.getController("keyboardNavigation");
              var isVirtualScrolling = keyboardController._isVirtualScrolling();
              var focusedRowKey = this.option("focusedRowKey");
              var isAutoNavigate = focusController.isAutoNavigateToFocusedRow();
              if (reload && !fullReload && isDefined(focusedRowKey)) {
                focusController._navigateToRow(focusedRowKey, true).done(function(focusedRowIndex2) {
                  if (focusedRowIndex2 < 0) {
                    focusController._focusRowByIndex(void 0, operationTypes);
                  }
                });
              } else if (operationTypes.paging && !isVirtualScrolling) {
                if (isAutoNavigate) {
                  var rowIndexByKey = this.getRowIndexByKey(focusedRowKey);
                  var isValidRowIndexByKey = rowIndexByKey >= 0;
                  var focusedRowIndex = this.option("focusedRowIndex");
                  var needFocusRowByIndex = focusedRowIndex >= 0 && (focusedRowIndex === rowIndexByKey || !isValidRowIndexByKey);
                  if (needFocusRowByIndex) {
                    focusController._focusRowByIndex(void 0, operationTypes);
                  }
                } else if (this.getRowIndexByKey(focusedRowKey) < 0) {
                  this.option("focusedRowIndex", -1);
                }
              } else if (operationTypes.fullReload) {
                focusController._focusRowByKeyOrIndex();
              }
            },
            getPageIndexByKey: function(key) {
              var that = this;
              var d = new Deferred();
              that.getGlobalRowIndexByKey(key).done(function(globalIndex) {
                d.resolve(globalIndex >= 0 ? Math.floor(globalIndex / that.pageSize()) : -1);
              }).fail(d.reject);
              return d.promise();
            },
            getGlobalRowIndexByKey: function(key) {
              if (this._dataSource.group()) {
                return this._calculateGlobalRowIndexByGroupedData(key);
              }
              return this._calculateGlobalRowIndexByFlatData(key);
            },
            _calculateGlobalRowIndexByFlatData: function(key, groupFilter, useGroup) {
              var that = this;
              var deferred = new Deferred();
              var dataSource = that._dataSource;
              if (Array.isArray(key)) {
                return deferred.resolve(-1).promise();
              }
              var filter = that._generateFilterByKey(key);
              dataSource.load({
                filter: that._concatWithCombinedFilter(filter),
                skip: 0,
                take: 1
              }).done(function(data2) {
                if (data2.length > 0) {
                  filter = that._generateOperationFilterByKey(key, data2[0], useGroup);
                  dataSource.load({
                    filter: that._concatWithCombinedFilter(filter, groupFilter),
                    skip: 0,
                    take: 1,
                    requireTotalCount: true
                  }).done(function(_2, extra) {
                    deferred.resolve(extra.totalCount);
                  });
                } else {
                  deferred.resolve(-1);
                }
              });
              return deferred.promise();
            },
            _concatWithCombinedFilter: function(filter, groupFilter) {
              var combinedFilter = this.getCombinedFilter();
              return ui_grid_core_utils_default.combineFilters([filter, combinedFilter, groupFilter]);
            },
            _generateBooleanFilter: function(selector, value2, sortInfo) {
              var result2;
              if (false === value2) {
                result2 = [selector, "=", sortInfo.desc ? true : null];
              } else if (true === value2 ? !sortInfo.desc : sortInfo.desc) {
                result2 = [selector, "<>", value2];
              }
              return result2;
            },
            _generateOperationFilterByKey: function(key, rowData, useGroup) {
              var that = this;
              var dataSource = that._dataSource;
              var filter = that._generateFilterByKey(key, "<");
              var sort = that._columnsController.getSortDataSourceParameters(!dataSource.remoteOperations().filtering, true);
              if (useGroup) {
                var group = that._columnsController.getGroupDataSourceParameters(!dataSource.remoteOperations().filtering);
                if (group) {
                  sort = sort ? group.concat(sort) : group;
                }
              }
              if (sort) {
                sort.slice().reverse().forEach(function(sortInfo) {
                  var selector = sortInfo.selector;
                  var getter;
                  if ("function" === typeof selector) {
                    getter = selector;
                  } else {
                    getter = that._columnsController.columnOption(selector, "selector");
                  }
                  var value2 = getter ? getter(rowData) : rowData[selector];
                  filter = [
                    [selector, "=", value2],
                    "and",
                    filter
                  ];
                  if (null === value2 || isBoolean(value2)) {
                    var booleanFilter = that._generateBooleanFilter(selector, value2, sortInfo);
                    if (booleanFilter) {
                      filter = [booleanFilter, "or", filter];
                    }
                  } else {
                    var filterOperation = sortInfo.desc ? ">" : "<";
                    var sortFilter = [selector, filterOperation, value2];
                    if (!sortInfo.desc) {
                      sortFilter = [sortFilter, "or", [selector, "=", null]];
                    }
                    filter = [sortFilter, "or", filter];
                  }
                });
              }
              return filter;
            },
            _generateFilterByKey: function(key, operation) {
              var dataSourceKey = this._dataSource.key();
              var filter = [];
              if (!operation) {
                operation = "=";
              }
              if (Array.isArray(dataSourceKey)) {
                for (var i = 0; i < dataSourceKey.length; ++i) {
                  var keyPart = key[dataSourceKey[i]];
                  if (keyPart) {
                    if (filter.length > 0) {
                      filter.push("and");
                    }
                    filter.push([dataSourceKey[i], operation, keyPart]);
                  }
                }
              } else {
                filter = [dataSourceKey, operation, key];
              }
              return filter;
            },
            _getLastItemIndex: function() {
              return this.items(true).length - 1;
            }
          },
          editing: {
            _deleteRowCore: function(rowIndex) {
              var deferred = this.callBase.apply(this, arguments);
              var dataController = this.getController("data");
              var rowKey = dataController.getKeyByRowIndex(rowIndex);
              deferred.done(() => {
                var rowIndex2 = dataController.getRowIndexByKey(rowKey);
                var visibleRows = dataController.getVisibleRows();
                if (-1 === rowIndex2 && !visibleRows.length) {
                  this.getController("focus")._resetFocusedRow();
                }
              });
            }
          }
        },
        views: {
          rowsView: {
            _createRow: function(row) {
              var $row = this.callBase(row);
              if (this.option("focusedRowEnabled") && row) {
                if (this.getController("focus").isRowFocused(row.key)) {
                  $row.addClass(ROW_FOCUSED_CLASS);
                }
              }
              return $row;
            },
            _checkRowKeys: function(options2) {
              this.callBase.apply(this, arguments);
              if (this.option("focusedRowEnabled") && this.option("dataSource")) {
                var store = this._dataController.store();
                if (store && !store.key()) {
                  this._dataController.fireError("E1042", "Row focusing");
                }
              }
            },
            _update: function(change) {
              if ("updateFocusedRow" === change.changeType) {
                if (this.option("focusedRowEnabled")) {
                  this.getController("focus").updateFocusedRow(change);
                }
              } else {
                this.callBase(change);
              }
            },
            updateFocusElementTabIndex: function($cellElements, preventScroll) {
              var rowIndex = this.getController("keyboardNavigation").getVisibleRowIndex();
              var row = this._dataController.getVisibleRows()[rowIndex];
              if (this.option("focusedRowEnabled") && !(null !== row && void 0 !== row && row.isNewRow)) {
                this._setFocusedRowElementTabIndex(preventScroll);
              } else {
                this.callBase($cellElements);
              }
            },
            _setFocusedRowElementTabIndex: function(preventScroll) {
              var focusedRowKey = this.option("focusedRowKey");
              var tabIndex = this.option("tabIndex") || 0;
              var dataController = this._dataController;
              var columnsController = this._columnsController;
              var rowIndex = dataController.getRowIndexByKey(focusedRowKey);
              var columnIndex = this.option("focusedColumnIndex");
              var $row = this._findRowElementForTabIndex();
              if (!isDefined(this._scrollToFocusOnResize)) {
                this._scrollToFocusOnResize = () => {
                  this.scrollToElementVertically(this._findRowElementForTabIndex());
                  this.resizeCompleted.remove(this._scrollToFocusOnResize);
                };
              }
              $row.attr("tabIndex", tabIndex);
              if (rowIndex >= 0 && !preventScroll) {
                if (columnIndex < 0) {
                  columnIndex = 0;
                }
                rowIndex += dataController.getRowIndexOffset();
                columnIndex += columnsController.getColumnIndexOffset();
                this.getController("keyboardNavigation").setFocusedCellPosition(rowIndex, columnIndex);
                if (this.getController("focus").isAutoNavigateToFocusedRow()) {
                  var dataSource = dataController.dataSource();
                  var operationTypes = dataSource && dataSource.operationTypes();
                  if (operationTypes && !operationTypes.paging && !dataController.isPagingByRendering()) {
                    this.resizeCompleted.remove(this._scrollToFocusOnResize);
                    this.resizeCompleted.add(this._scrollToFocusOnResize);
                  }
                }
              }
            },
            _findRowElementForTabIndex: function() {
              var focusedRowKey = this.option("focusedRowKey");
              var rowIndex = this._dataController.getRowIndexByKey(focusedRowKey);
              return renderer_default(this.getRowElement(rowIndex >= 0 ? rowIndex : 0));
            },
            scrollToRowElement: function(key) {
              var rowIndex = this.getController("data").getRowIndexByKey(key);
              var $row = renderer_default(this.getRow(rowIndex));
              this.scrollToElementVertically($row);
            },
            scrollToElementVertically: function($row) {
              var scrollable = this.getScrollable();
              if (scrollable && $row.length) {
                var position3 = scrollable.getScrollElementPosition($row, "vertical");
                this._dataController.resetFilterApplying();
                scrollable.scrollTo({
                  top: position3
                });
              }
            }
          }
        }
      }
    };
  }
});

// node_modules/devextreme/esm/ui/grid_core/ui.grid_core.row_dragging.js
var COMMAND_HANDLE_CLASS, CELL_FOCUS_DISABLED_CLASS6, HANDLE_ICON_CLASS, ROWS_VIEW2, SORTABLE_WITHOUT_HANDLE_CLASS, RowDraggingExtender, rowDraggingModule;
var init_ui_grid_core_row_dragging = __esm({
  "node_modules/devextreme/esm/ui/grid_core/ui.grid_core.row_dragging.js"() {
    init_renderer();
    init_extend();
    init_sortable();
    init_ui_grid_core_utils();
    init_browser();
    COMMAND_HANDLE_CLASS = "dx-command-drag";
    CELL_FOCUS_DISABLED_CLASS6 = "dx-cell-focus-disabled";
    HANDLE_ICON_CLASS = "drag-icon";
    ROWS_VIEW2 = "rowsview";
    SORTABLE_WITHOUT_HANDLE_CLASS = "dx-sortable-without-handle";
    RowDraggingExtender = {
      init: function() {
        this.callBase.apply(this, arguments);
        this._updateHandleColumn();
      },
      _allowReordering: function() {
        var rowDragging = this.option("rowDragging");
        return !!(rowDragging && (rowDragging.allowReordering || rowDragging.allowDropInsideItem || rowDragging.group));
      },
      _updateHandleColumn: function() {
        var rowDragging = this.option("rowDragging");
        var allowReordering2 = this._allowReordering();
        var columnsController = this._columnsController;
        var isHandleColumnVisible = allowReordering2 && rowDragging.showDragIcons;
        columnsController && columnsController.addCommandColumn({
          type: "drag",
          command: "drag",
          visibleIndex: -2,
          alignment: "center",
          cssClass: COMMAND_HANDLE_CLASS,
          width: "auto",
          cellTemplate: this._getHandleTemplate(),
          visible: isHandleColumnVisible
        });
        columnsController.columnOption("type:drag", "visible", isHandleColumnVisible);
      },
      _renderContent: function() {
        var rowDragging = this.option("rowDragging");
        var allowReordering2 = this._allowReordering();
        var $content = this.callBase.apply(this, arguments);
        var isFixedTableRendering = this._isFixedTableRendering;
        var sortableName = "_sortable";
        var sortableFixedName = "_sortableFixed";
        var currentSortableName = isFixedTableRendering ? sortableFixedName : sortableName;
        var anotherSortableName = isFixedTableRendering ? sortableName : sortableFixedName;
        var togglePointerEventsStyle = (toggle) => {
          var _this$sortableFixedNa;
          null === (_this$sortableFixedNa = this[sortableFixedName]) || void 0 === _this$sortableFixedNa ? void 0 : _this$sortableFixedNa.$element().css("pointerEvents", toggle ? "auto" : "");
        };
        if ((allowReordering2 || this[currentSortableName]) && $content.length) {
          this[currentSortableName] = this._createComponent($content, sortable_default, extend2({
            component: this.component,
            contentTemplate: null,
            cursorOffset: (options2) => {
              var event = options2.event;
              var rowsViewOffset = renderer_default(this.element()).offset();
              return {
                x: event.pageX - rowsViewOffset.left
              };
            },
            onDraggableElementShown: (e) => {
              if (rowDragging.dragTemplate) {
                return;
              }
              var $dragElement = renderer_default(e.dragElement);
              var gridInstance = $dragElement.children(".dx-widget").data(this.component.NAME);
              this._synchronizeScrollLeftPosition(gridInstance);
            },
            filter: "> table > tbody > .dx-row:not(.dx-freespace-row):not(.dx-virtual-row)",
            dragTemplate: this._getDraggableRowTemplate(),
            handle: rowDragging.showDragIcons && ".".concat(COMMAND_HANDLE_CLASS),
            dropFeedbackMode: "indicate"
          }, rowDragging, {
            onDragStart: (e) => {
              var _this$getController, _rowDragging$onDragSt;
              null === (_this$getController = this.getController("keyboardNavigation")) || void 0 === _this$getController ? void 0 : _this$getController._resetFocusedCell();
              var row = e.component.getVisibleRows()[e.fromIndex];
              e.itemData = row && row.data;
              var isDataRow2 = row && "data" === row.rowType;
              e.cancel = !allowReordering2 || !isDataRow2;
              null === (_rowDragging$onDragSt = rowDragging.onDragStart) || void 0 === _rowDragging$onDragSt ? void 0 : _rowDragging$onDragSt.call(rowDragging, e);
            },
            onDragEnter: () => {
              togglePointerEventsStyle(true);
            },
            onDragLeave: () => {
              togglePointerEventsStyle(false);
            },
            onDragEnd: (e) => {
              var _rowDragging$onDragEn;
              togglePointerEventsStyle(false);
              null === (_rowDragging$onDragEn = rowDragging.onDragEnd) || void 0 === _rowDragging$onDragEn ? void 0 : _rowDragging$onDragEn.call(rowDragging, e);
            },
            onAdd: (e) => {
              var _rowDragging$onAdd;
              togglePointerEventsStyle(false);
              null === (_rowDragging$onAdd = rowDragging.onAdd) || void 0 === _rowDragging$onAdd ? void 0 : _rowDragging$onAdd.call(rowDragging, e);
            },
            dropFeedbackMode: browser_default.msie ? "indicate" : rowDragging.dropFeedbackMode,
            onOptionChanged: (e) => {
              var hasFixedSortable = this[sortableFixedName];
              if (hasFixedSortable) {
                if ("fromIndex" === e.name || "toIndex" === e.name) {
                  this[anotherSortableName].option(e.name, e.value);
                }
              }
            }
          }));
          $content.toggleClass("dx-scrollable-container", isFixedTableRendering);
          $content.toggleClass(SORTABLE_WITHOUT_HANDLE_CLASS, allowReordering2 && !rowDragging.showDragIcons);
        }
        return $content;
      },
      _resizeCore: function() {
        this.callBase.apply(this, arguments);
        var offset2 = this._dataController.getRowIndexOffset();
        [this._sortable, this._sortableFixed].forEach((sortable) => {
          null === sortable || void 0 === sortable ? void 0 : sortable.option("offset", offset2);
          null === sortable || void 0 === sortable ? void 0 : sortable.update();
        });
      },
      _getDraggableGridOptions: function(options2) {
        var gridOptions = this.option();
        var columns = this.getColumns();
        var $rowElement = renderer_default(this.getRowElement(options2.rowIndex));
        return {
          dataSource: [{
            id: 1,
            parentId: 0
          }],
          showBorders: true,
          showColumnHeaders: false,
          scrolling: {
            useNative: false,
            showScrollbar: false
          },
          pager: {
            visible: false
          },
          loadingTimeout: void 0,
          columnFixing: gridOptions.columnFixing,
          columnAutoWidth: gridOptions.columnAutoWidth,
          showColumnLines: gridOptions.showColumnLines,
          columns: columns.map((column) => ({
            width: column.width || column.visibleWidth,
            fixed: column.fixed,
            fixedPosition: column.fixedPosition
          })),
          onRowPrepared: (e) => {
            var rowsView = e.component.getView("rowsView");
            renderer_default(e.rowElement).replaceWith($rowElement.eq(rowsView._isFixedTableRendering ? 1 : 0).clone());
          }
        };
      },
      _synchronizeScrollLeftPosition: function(gridInstance) {
        var scrollable = null === gridInstance || void 0 === gridInstance ? void 0 : gridInstance.getScrollable();
        null === scrollable || void 0 === scrollable ? void 0 : scrollable.scrollTo({
          x: this._scrollLeft
        });
      },
      _getDraggableRowTemplate: function() {
        return (options2) => {
          var $rootElement = this.component.$element();
          var $dataGridContainer = renderer_default("<div>").width($rootElement.width());
          var items = this._dataController.items();
          var row = items && items[options2.fromIndex];
          var gridOptions = this._getDraggableGridOptions(row);
          this._createComponent($dataGridContainer, this.component.NAME, gridOptions);
          $dataGridContainer.find(".dx-gridbase-container").children(":not(.".concat(this.addWidgetPrefix(ROWS_VIEW2), ")")).hide();
          return $dataGridContainer;
        };
      },
      _getHandleTemplate: function() {
        return (container, options2) => {
          if ("data" === options2.rowType) {
            renderer_default(container).addClass(CELL_FOCUS_DISABLED_CLASS6);
            return renderer_default("<span>").addClass(this.addWidgetPrefix(HANDLE_ICON_CLASS));
          } else {
            ui_grid_core_utils_default.setEmptyText(renderer_default(container));
          }
        };
      },
      optionChanged: function(args) {
        if ("rowDragging" === args.name) {
          this._updateHandleColumn();
          this._invalidate(true, true);
          args.handled = true;
        }
        this.callBase.apply(this, arguments);
      }
    };
    rowDraggingModule = {
      defaultOptions: function() {
        return {
          rowDragging: {
            showDragIcons: true,
            dropFeedbackMode: "indicate",
            allowReordering: false,
            allowDropInsideItem: false
          }
        };
      },
      extenders: {
        views: {
          rowsView: RowDraggingExtender
        }
      }
    };
  }
});

// node_modules/devextreme/esm/ui/grid_core/ui.grid_core.column_headers.js
var CELL_CONTENT_CLASS2, HEADERS_CLASS, NOWRAP_CLASS, ROW_CLASS_SELECTOR, HEADER_ROW_CLASS3, COLUMN_LINES_CLASS2, CONTEXT_MENU_SORT_ASC_ICON, CONTEXT_MENU_SORT_DESC_ICON, CONTEXT_MENU_SORT_NONE_ICON, CELL_FOCUS_DISABLED_CLASS7, VISIBILITY_HIDDEN_CLASS, TEXT_CONTENT_ALIGNMENT_CLASS_PREFIX, SORT_INDICATOR_CLASS, SORT_INDEX_INDICATOR_CLASS, HEADER_FILTER_CLASS_SELECTOR, HEADER_FILTER_INDICATOR_CLASS, MULTI_ROW_HEADER_CLASS, columnHeadersModule;
var init_ui_grid_core_column_headers = __esm({
  "node_modules/devextreme/esm/ui/grid_core/ui.grid_core.column_headers.js"() {
    init_renderer();
    init_events_engine();
    init_ui_grid_core_columns_view();
    init_message();
    init_type();
    init_iterator();
    init_extend();
    init_ui_grid_core_accessibility();
    CELL_CONTENT_CLASS2 = "text-content";
    HEADERS_CLASS = "headers";
    NOWRAP_CLASS = "nowrap";
    ROW_CLASS_SELECTOR = ".dx-row";
    HEADER_ROW_CLASS3 = "dx-header-row";
    COLUMN_LINES_CLASS2 = "dx-column-lines";
    CONTEXT_MENU_SORT_ASC_ICON = "context-menu-sort-asc";
    CONTEXT_MENU_SORT_DESC_ICON = "context-menu-sort-desc";
    CONTEXT_MENU_SORT_NONE_ICON = "context-menu-sort-none";
    CELL_FOCUS_DISABLED_CLASS7 = "dx-cell-focus-disabled";
    VISIBILITY_HIDDEN_CLASS = "dx-visibility-hidden";
    TEXT_CONTENT_ALIGNMENT_CLASS_PREFIX = "dx-text-content-alignment-";
    SORT_INDICATOR_CLASS = "dx-sort-indicator";
    SORT_INDEX_INDICATOR_CLASS = "dx-sort-index-indicator";
    HEADER_FILTER_CLASS_SELECTOR = ".dx-header-filter";
    HEADER_FILTER_INDICATOR_CLASS = "dx-header-filter-indicator";
    MULTI_ROW_HEADER_CLASS = "dx-header-multi-row";
    columnHeadersModule = {
      defaultOptions: function() {
        return {
          showColumnHeaders: true,
          cellHintEnabled: true
        };
      },
      views: {
        columnHeadersView: ColumnsView.inherit(/* @__PURE__ */ function() {
          var createCellContent = function(that, $cell, options2) {
            var $cellContent = renderer_default("<div>").addClass(that.addWidgetPrefix(CELL_CONTENT_CLASS2));
            that.setAria("role", "presentation", $cellContent);
            addCssClassesToCellContent(that, $cell, options2.column, $cellContent);
            var showColumnLines = that.option("showColumnLines");
            var contentAlignment = that.getController("columns").getHeaderContentAlignment(options2.column.alignment);
            return $cellContent[showColumnLines || "right" === contentAlignment ? "appendTo" : "prependTo"]($cell);
          };
          function addCssClassesToCellContent(that, $cell, column, $cellContent) {
            var $indicatorElements = that._getIndicatorElements($cell, true);
            var $visibleIndicatorElements = that._getIndicatorElements($cell);
            var indicatorCount = $indicatorElements && $indicatorElements.length;
            var columnAlignment = that._getColumnAlignment(column.alignment);
            var sortIndicatorClassName = ".".concat(that._getIndicatorClassName("sort"));
            var sortIndexIndicatorClassName = ".".concat(that._getIndicatorClassName("sortIndex"));
            var $sortIndicator = $visibleIndicatorElements.filter(sortIndicatorClassName);
            var $sortIndexIndicator = $visibleIndicatorElements.children().filter(sortIndexIndicatorClassName);
            $cellContent = $cellContent || $cell.children("." + that.addWidgetPrefix(CELL_CONTENT_CLASS2));
            $cellContent.toggleClass(TEXT_CONTENT_ALIGNMENT_CLASS_PREFIX + columnAlignment, indicatorCount > 0).toggleClass(TEXT_CONTENT_ALIGNMENT_CLASS_PREFIX + ("left" === columnAlignment ? "right" : "left"), indicatorCount > 0 && "center" === column.alignment).toggleClass(SORT_INDICATOR_CLASS, !!$sortIndicator.length).toggleClass(SORT_INDEX_INDICATOR_CLASS, !!$sortIndexIndicator.length).toggleClass(HEADER_FILTER_INDICATOR_CLASS, !!$visibleIndicatorElements.filter("." + that._getIndicatorClassName("headerFilter")).length);
          }
          return {
            _createTable: function() {
              var $table = this.callBase.apply(this, arguments);
              events_engine_default.on($table, "mousedown selectstart", this.createAction(function(e) {
                var event = e.event;
                if (event.shiftKey) {
                  event.preventDefault();
                }
              }));
              return $table;
            },
            _isLegacyKeyboardNavigation() {
              return this.option("useLegacyKeyboardNavigation");
            },
            _getDefaultTemplate: function(column) {
              var that = this;
              return function($container, options2) {
                var $content = column.command ? $container : createCellContent(that, $container, options2);
                var caption = "expand" !== column.command && column.caption;
                if (caption) {
                  $content.text(caption);
                } else if (column.command) {
                  $container.html("&nbsp;");
                }
              };
            },
            _getHeaderTemplate: function(column) {
              return column.headerCellTemplate || {
                allowRenderToDetachedContainer: true,
                render: this._getDefaultTemplate(column)
              };
            },
            _processTemplate: function(template, options2) {
              var that = this;
              var resultTemplate;
              var column = options2.column;
              var renderingTemplate = that.callBase(template);
              if ("header" === options2.rowType && renderingTemplate && column.headerCellTemplate && !column.command) {
                resultTemplate = {
                  render: function(options3) {
                    var $content = createCellContent(that, options3.container, options3.model);
                    renderingTemplate.render(extend2({}, options3, {
                      container: $content
                    }));
                  }
                };
              } else {
                resultTemplate = renderingTemplate;
              }
              return resultTemplate;
            },
            _handleDataChanged: function(e) {
              if ("refresh" !== e.changeType) {
                return;
              }
              if (this._isGroupingChanged || this._requireReady) {
                this._isGroupingChanged = false;
                this.render();
              }
            },
            _renderCell: function($row, options2) {
              var $cell = this.callBase($row, options2);
              if ("header" === options2.row.rowType) {
                $cell.addClass(CELL_FOCUS_DISABLED_CLASS7);
                if (!this._isLegacyKeyboardNavigation()) {
                  if (options2.column && !options2.column.type) {
                    $cell.attr("tabindex", this.option("tabindex") || 0);
                  }
                }
              }
              return $cell;
            },
            _setCellAriaAttributes: function($cell, cellOptions) {
              this.callBase($cell, cellOptions);
              if ("header" === cellOptions.rowType) {
                this.setAria("role", "columnheader", $cell);
                if (cellOptions.column && !cellOptions.column.command && !cellOptions.column.isBand) {
                  $cell.attr("id", cellOptions.column.headerId);
                  this.setAria("label", message_default.format("dxDataGrid-ariaColumn") + " " + cellOptions.column.caption, $cell);
                }
              }
            },
            _createRow: function(row) {
              var $row = this.callBase(row).toggleClass(COLUMN_LINES_CLASS2, this.option("showColumnLines"));
              if ("header" === row.rowType) {
                $row.addClass(HEADER_ROW_CLASS3);
                if (!this._isLegacyKeyboardNavigation()) {
                  registerKeyboardAction2("columnHeaders", this, $row, "td", this._handleActionKeyDown.bind(this));
                }
              }
              return $row;
            },
            _handleActionKeyDown: function(args) {
              var event = args.event;
              var $target = renderer_default(event.target);
              this._lastActionElement = event.target;
              if ($target.is(HEADER_FILTER_CLASS_SELECTOR)) {
                var headerFilterController = this.getController("headerFilter");
                var $column = $target.closest("td");
                var columnIndex = this.getColumnIndexByElement($column);
                if (columnIndex >= 0) {
                  headerFilterController.showHeaderFilterMenu(columnIndex, false);
                }
              } else {
                var $row = $target.closest(ROW_CLASS_SELECTOR);
                this._processHeaderAction(event, $row);
              }
              event.preventDefault();
            },
            _renderCore: function() {
              var that = this;
              var $container = that.element();
              if (that._tableElement && !that._dataController.isLoaded() && !that._hasRowElements) {
                return;
              }
              $container.addClass(that.addWidgetPrefix(HEADERS_CLASS)).toggleClass(that.addWidgetPrefix(NOWRAP_CLASS), !that.option("wordWrapEnabled")).empty();
              that.setAria("role", "presentation", $container);
              that._updateContent(that._renderTable());
              if (that.getRowCount() > 1) {
                $container.addClass(MULTI_ROW_HEADER_CLASS);
              }
              that.callBase.apply(that, arguments);
            },
            _renderRows: function() {
              var that = this;
              if (that._dataController.isLoaded() || that._hasRowElements) {
                that.callBase.apply(that, arguments);
                that._hasRowElements = true;
              }
            },
            _getRowVisibleColumns: function(rowIndex) {
              return this._columnsController.getVisibleColumns(rowIndex);
            },
            _renderRow: function($table, options2) {
              options2.columns = this._getRowVisibleColumns(options2.row.rowIndex);
              this.callBase($table, options2);
            },
            _createCell: function(options2) {
              var column = options2.column;
              var $cellElement = this.callBase.apply(this, arguments);
              column.rowspan > 1 && "header" === options2.rowType && $cellElement.attr("rowSpan", column.rowspan);
              return $cellElement;
            },
            _getRows: function() {
              var result2 = [];
              var rowCount = this.getRowCount();
              if (this.option("showColumnHeaders")) {
                for (var i = 0; i < rowCount; i++) {
                  result2.push({
                    rowType: "header",
                    rowIndex: i
                  });
                }
              }
              return result2;
            },
            _getCellTemplate: function(options2) {
              if ("header" === options2.rowType) {
                return this._getHeaderTemplate(options2.column);
              }
            },
            _columnOptionChanged: function(e) {
              var changeTypes = e.changeTypes;
              var optionNames = e.optionNames;
              if (changeTypes.grouping || changeTypes.groupExpanding) {
                if (changeTypes.grouping) {
                  this._isGroupingChanged = true;
                }
                return;
              }
              this.callBase(e);
              if (optionNames.width || optionNames.visible) {
                this.resizeCompleted.fire();
              }
            },
            _isElementVisible: function(elementOptions) {
              return elementOptions && elementOptions.visible;
            },
            _alignCaptionByCenter: function($cell) {
              var $indicatorsContainer = this._getIndicatorContainer($cell, true);
              if ($indicatorsContainer && $indicatorsContainer.length) {
                $indicatorsContainer.filter("." + VISIBILITY_HIDDEN_CLASS).remove();
                $indicatorsContainer = this._getIndicatorContainer($cell);
                $indicatorsContainer.clone().addClass(VISIBILITY_HIDDEN_CLASS).css("float", "").insertBefore($cell.children("." + this.addWidgetPrefix(CELL_CONTENT_CLASS2)));
              }
            },
            _updateCell: function($cell, options2) {
              if ("header" === options2.rowType && "center" === options2.column.alignment) {
                this._alignCaptionByCenter($cell);
              }
              this.callBase.apply(this, arguments);
            },
            _updateIndicator: function($cell, column, indicatorName) {
              var $indicatorElement = this.callBase.apply(this, arguments);
              if ("center" === column.alignment) {
                this._alignCaptionByCenter($cell);
              }
              addCssClassesToCellContent(this, $cell, column);
              return $indicatorElement;
            },
            _getIndicatorContainer: function($cell, returnAll) {
              var $indicatorsContainer = this.callBase($cell);
              return returnAll ? $indicatorsContainer : $indicatorsContainer.filter(":not(." + VISIBILITY_HIDDEN_CLASS + ")");
            },
            _isSortableElement: function() {
              return true;
            },
            getHeadersRowHeight: function() {
              var $tableElement = this.getTableElement();
              var $headerRows = $tableElement && $tableElement.find("." + HEADER_ROW_CLASS3);
              return $headerRows && $headerRows.toArray().reduce(function(sum, headerRow) {
                return sum + renderer_default(headerRow).height();
              }, 0) || 0;
            },
            getHeaderElement: function(index2) {
              var columnElements = this.getColumnElements();
              return columnElements && columnElements.eq(index2);
            },
            getColumnElements: function(index2, bandColumnIndex) {
              var that = this;
              var $cellElement;
              var columnsController = that._columnsController;
              var rowCount = that.getRowCount();
              if (that.option("showColumnHeaders")) {
                if (rowCount > 1 && (!isDefined(index2) || isDefined(bandColumnIndex))) {
                  var result2 = [];
                  var visibleColumns = isDefined(bandColumnIndex) ? columnsController.getChildrenByBandColumn(bandColumnIndex, true) : columnsController.getVisibleColumns();
                  each(visibleColumns, function(_2, column) {
                    var rowIndex = isDefined(index2) ? index2 : columnsController.getRowIndex(column.index);
                    $cellElement = that._getCellElement(rowIndex, columnsController.getVisibleIndex(column.index, rowIndex));
                    $cellElement && result2.push($cellElement.get(0));
                  });
                  return renderer_default(result2);
                } else if (!index2 || index2 < rowCount) {
                  return that.getCellElements(index2 || 0);
                }
              }
            },
            getColumnIndexByElement: function($cell) {
              var cellIndex = this.getCellIndex($cell);
              var $row = $cell.closest(".dx-row");
              var rowIndex = $row[0].rowIndex;
              var column = this.getColumns(rowIndex)[cellIndex];
              return column ? column.index : -1;
            },
            getVisibleColumnIndex: function(columnIndex, rowIndex) {
              var column = this.getColumns()[columnIndex];
              return column ? this._columnsController.getVisibleIndex(column.index, rowIndex) : -1;
            },
            getColumnWidths: function() {
              var $columnElements = this.getColumnElements();
              if ($columnElements && $columnElements.length) {
                return this._getWidths($columnElements);
              }
              return this.callBase.apply(this, arguments);
            },
            allowDragging: function(column, sourceLocation, draggingPanels) {
              var i;
              var draggableColumnCount = 0;
              var rowIndex = column && this._columnsController.getRowIndex(column.index);
              var columns = this.getColumns(0 === rowIndex ? 0 : null);
              var canHideColumn = (null === column || void 0 === column ? void 0 : column.allowHiding) && columns.length > 1;
              var allowDrag = function(column2) {
                return column2.allowReordering || column2.allowGrouping || column2.allowHiding;
              };
              for (i = 0; i < columns.length; i++) {
                if (allowDrag(columns[i])) {
                  draggableColumnCount++;
                }
              }
              if (draggableColumnCount <= 1 && !canHideColumn) {
                return false;
              } else if (!draggingPanels) {
                return (this.option("allowColumnReordering") || this._columnsController.isColumnOptionUsed("allowReordering")) && column && column.allowReordering;
              }
              for (i = 0; i < draggingPanels.length; i++) {
                var draggingPanel = draggingPanels[i];
                if (draggingPanel && draggingPanel.allowDragging(column, sourceLocation)) {
                  return true;
                }
              }
              return false;
            },
            getBoundingRect: function() {
              var $columnElements = this.getColumnElements();
              if ($columnElements && $columnElements.length) {
                var offset2 = this.getTableElement().offset();
                return {
                  top: offset2.top
                };
              }
              return null;
            },
            getName: function() {
              return "headers";
            },
            getColumnCount: function() {
              var $columnElements = this.getColumnElements();
              return $columnElements ? $columnElements.length : 0;
            },
            isVisible: function() {
              return this.option("showColumnHeaders");
            },
            optionChanged: function(args) {
              switch (args.name) {
                case "showColumnHeaders":
                case "wordWrapEnabled":
                case "showColumnLines":
                  this._invalidate(true, true);
                  args.handled = true;
                  break;
                default:
                  this.callBase(args);
              }
            },
            getHeight: function() {
              return this.getElementHeight();
            },
            getContextMenuItems: function(options2) {
              var that = this;
              var column = options2.column;
              if (options2.row && ("header" === options2.row.rowType || "detailAdaptive" === options2.row.rowType)) {
                var sortingOptions = that.option("sorting");
                if (sortingOptions && "none" !== sortingOptions.mode && column && column.allowSorting) {
                  var onItemClick = function(params) {
                    setTimeout(function() {
                      that._columnsController.changeSortOrder(column.index, params.itemData.value);
                    });
                  };
                  return [{
                    text: sortingOptions.ascendingText,
                    value: "asc",
                    disabled: "asc" === column.sortOrder,
                    icon: CONTEXT_MENU_SORT_ASC_ICON,
                    onItemClick
                  }, {
                    text: sortingOptions.descendingText,
                    value: "desc",
                    disabled: "desc" === column.sortOrder,
                    icon: CONTEXT_MENU_SORT_DESC_ICON,
                    onItemClick
                  }, {
                    text: sortingOptions.clearText,
                    value: "none",
                    disabled: !column.sortOrder,
                    icon: CONTEXT_MENU_SORT_NONE_ICON,
                    onItemClick
                  }];
                }
              }
            },
            getRowCount: function() {
              return this._columnsController && this._columnsController.getRowCount();
            },
            setRowsOpacity: function(columnIndex, value2, rowIndex) {
              var that = this;
              var i;
              var columnElements;
              var rowCount = that.getRowCount();
              var columns = that._columnsController.getColumns();
              var column = columns && columns[columnIndex];
              var columnID = column && column.isBand && column.index;
              var setColumnOpacity = function(index2, column2) {
                if (column2.ownerBand === columnID) {
                  columnElements.eq(index2).css({
                    opacity: value2
                  });
                  if (column2.isBand) {
                    that.setRowsOpacity(column2.index, value2, i + 1);
                  }
                }
              };
              if (isDefined(columnID)) {
                rowIndex = rowIndex || 0;
                for (i = rowIndex; i < rowCount; i++) {
                  columnElements = that.getCellElements(i);
                  each(that.getColumns(i), setColumnOpacity);
                }
              }
            }
          };
        }())
      }
    };
  }
});

// node_modules/devextreme/esm/ui/grid_core/ui.grid_core.columns_controller.js
var USER_STATE_FIELD_NAMES_15_1, USER_STATE_FIELD_NAMES, IGNORE_COLUMN_OPTION_NAMES, COMMAND_EXPAND_CLASS2, MAX_SAFE_INTEGER, GROUP_COMMAND_COLUMN_NAME, regExp, globalColumnId, columnsControllerModule;
var init_ui_grid_core_columns_controller = __esm({
  "node_modules/devextreme/esm/ui/grid_core/ui.grid_core.columns_controller.js"() {
    init_extends();
    init_renderer();
    init_callbacks();
    init_variable_wrapper();
    init_data();
    init_common();
    init_type();
    init_iterator();
    init_position();
    init_extend();
    init_array();
    init_config();
    init_object();
    init_ui_errors();
    init_ui_grid_core_modules();
    init_ui_grid_core_utils();
    init_inflector();
    init_date_serialization();
    init_number3();
    init_date3();
    init_message();
    init_deferred();
    init_abstract_store();
    init_data_source();
    init_utils5();
    init_filtering();
    USER_STATE_FIELD_NAMES_15_1 = ["filterValues", "filterType", "fixed", "fixedPosition"];
    USER_STATE_FIELD_NAMES = ["visibleIndex", "dataField", "name", "dataType", "width", "visible", "sortOrder", "lastSortOrder", "sortIndex", "groupIndex", "filterValue", "selectedFilterOperation", "added"].concat(USER_STATE_FIELD_NAMES_15_1);
    IGNORE_COLUMN_OPTION_NAMES = {
      visibleWidth: true,
      bestFitWidth: true,
      bufferedFilterValue: true
    };
    COMMAND_EXPAND_CLASS2 = "dx-command-expand";
    MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
    GROUP_COMMAND_COLUMN_NAME = "groupExpand";
    regExp = /columns\[(\d+)\]\.?/gi;
    globalColumnId = 1;
    columnsControllerModule = {
      defaultOptions: function() {
        return {
          commonColumnSettings: {
            allowFiltering: true,
            allowHiding: true,
            allowSorting: true,
            allowEditing: true,
            encodeHtml: true,
            trueText: message_default.format("dxDataGrid-trueText"),
            falseText: message_default.format("dxDataGrid-falseText")
          },
          allowColumnReordering: false,
          allowColumnResizing: false,
          columnResizingMode: "nextColumn",
          columnMinWidth: void 0,
          columnWidth: void 0,
          adaptColumnWidthByRatio: true,
          columns: void 0,
          regenerateColumnsByVisibleItems: false,
          customizeColumns: null,
          dateSerializationFormat: void 0
        };
      },
      controllers: {
        columns: ui_grid_core_modules_default.Controller.inherit(/* @__PURE__ */ function() {
          var DEFAULT_COLUMN_OPTIONS = {
            visible: true,
            showInColumnChooser: true
          };
          var DATATYPE_OPERATIONS2 = {
            number: ["=", "<>", "<", ">", "<=", ">=", "between"],
            string: ["contains", "notcontains", "startswith", "endswith", "=", "<>"],
            date: ["=", "<>", "<", ">", "<=", ">=", "between"],
            datetime: ["=", "<>", "<", ">", "<=", ">=", "between"]
          };
          var COLUMN_INDEX_OPTIONS = {
            visibleIndex: true,
            groupIndex: true,
            grouped: true,
            sortIndex: true,
            sortOrder: true
          };
          var setFilterOperationsAsDefaultValues = function(column) {
            column.filterOperations = column.defaultFilterOperations;
          };
          var createColumn = function(that, columnOptions, userStateColumnOptions, bandColumn) {
            var commonColumnOptions = {};
            if (columnOptions) {
              if (isString2(columnOptions)) {
                columnOptions = {
                  dataField: columnOptions
                };
              }
              that.setName(columnOptions);
              var result2 = {};
              if (columnOptions.command) {
                result2 = deepExtendArraySafe(commonColumnOptions, columnOptions);
              } else {
                commonColumnOptions = that.getCommonSettings(columnOptions);
                if (userStateColumnOptions && userStateColumnOptions.name && userStateColumnOptions.dataField) {
                  columnOptions = extend2({}, columnOptions, {
                    dataField: userStateColumnOptions.dataField
                  });
                }
                var calculatedColumnOptions = that._createCalculatedColumnOptions(columnOptions, bandColumn);
                if (!columnOptions.type) {
                  result2 = {
                    headerId: "dx-col-".concat(globalColumnId++)
                  };
                }
                result2 = deepExtendArraySafe(result2, DEFAULT_COLUMN_OPTIONS);
                deepExtendArraySafe(result2, commonColumnOptions);
                deepExtendArraySafe(result2, calculatedColumnOptions);
                deepExtendArraySafe(result2, columnOptions);
                deepExtendArraySafe(result2, {
                  selector: null
                });
              }
              if (columnOptions.filterOperations === columnOptions.defaultFilterOperations) {
                setFilterOperationsAsDefaultValues(result2);
              }
              return result2;
            }
          };
          var createColumnsFromOptions = function createColumnsFromOptions2(that, columnsOptions, bandColumn) {
            var result2 = [];
            if (columnsOptions) {
              each(columnsOptions, function(index2, columnOptions) {
                var userStateColumnOptions = that._columnsUserState && checkUserStateColumn(columnOptions, that._columnsUserState[index2]) && that._columnsUserState[index2];
                var column = createColumn(that, columnOptions, userStateColumnOptions, bandColumn);
                if (column) {
                  if (bandColumn) {
                    column.ownerBand = bandColumn;
                  }
                  result2.push(column);
                  if (column.columns) {
                    result2 = result2.concat(createColumnsFromOptions2(that, column.columns, column));
                    delete column.columns;
                    column.hasColumns = true;
                  }
                }
              });
            }
            return result2;
          };
          var getParentBandColumns = function(columnIndex, columnParentByIndex) {
            var result2 = [];
            var parent = columnParentByIndex[columnIndex];
            while (parent) {
              result2.unshift(parent);
              columnIndex = parent.index;
              parent = columnParentByIndex[columnIndex];
            }
            return result2;
          };
          var _getChildrenByBandColumn = function(columnIndex, columnChildrenByIndex, recursive) {
            var result2 = [];
            var children = columnChildrenByIndex[columnIndex];
            if (children) {
              for (var i = 0; i < children.length; i++) {
                var column = children[i];
                if (!isDefined(column.groupIndex) || column.showWhenGrouped) {
                  result2.push(column);
                  if (recursive && column.isBand) {
                    result2 = result2.concat(_getChildrenByBandColumn(column.index, columnChildrenByIndex, recursive));
                  }
                }
              }
            }
            return result2;
          };
          var getColumnFullPath = function(that, column) {
            var result2 = [];
            var columns;
            var bandColumnsCache = that.getBandColumnsCache();
            var callbackFilter = function(item) {
              return item.ownerBand === column.ownerBand;
            };
            if (bandColumnsCache.isPlain) {
              var columnIndex = that._columns.indexOf(column);
              if (columnIndex >= 0) {
                result2 = ["columns[".concat(columnIndex, "]")];
              }
            } else {
              columns = that._columns.filter(callbackFilter);
              while (columns.length && -1 !== columns.indexOf(column)) {
                result2.unshift("columns[".concat(columns.indexOf(column), "]"));
                column = bandColumnsCache.columnParentByIndex[column.index];
                columns = column ? that._columns.filter(callbackFilter) : [];
              }
            }
            return result2.join(".");
          };
          var calculateColspan = function calculateColspan2(that, columnID) {
            var colspan = 0;
            var columns = that.getChildrenByBandColumn(columnID, true);
            each(columns, function(_2, column) {
              if (column.isBand) {
                column.colspan = column.colspan || calculateColspan2(that, column.index);
                colspan += column.colspan || 1;
              } else {
                colspan += 1;
              }
            });
            return colspan;
          };
          var getValueDataType = function(value2) {
            var dataType = type(value2);
            if ("string" !== dataType && "boolean" !== dataType && "number" !== dataType && "date" !== dataType && "object" !== dataType) {
              dataType = void 0;
            }
            return dataType;
          };
          var getSerializationFormat = function(dataType, value2) {
            switch (dataType) {
              case "date":
              case "datetime":
                return date_serialization_default.getDateSerializationFormat(value2);
              case "number":
                if (isString2(value2)) {
                  return "string";
                }
                if (isNumeric(value2)) {
                  return null;
                }
            }
          };
          var updateSerializers = function(options2, dataType) {
            if (!options2.deserializeValue) {
              if (ui_grid_core_utils_default.isDateType(dataType)) {
                options2.deserializeValue = function(value2) {
                  return date_serialization_default.deserializeDate(value2);
                };
                options2.serializeValue = function(value2) {
                  return isString2(value2) ? value2 : date_serialization_default.serializeDate(value2, this.serializationFormat);
                };
              }
              if ("number" === dataType) {
                options2.deserializeValue = function(value2) {
                  var parsedValue = parseFloat(value2);
                  return isNaN(parsedValue) ? value2 : parsedValue;
                };
                options2.serializeValue = function(value2, target) {
                  if ("filter" === target) {
                    return value2;
                  }
                  return isDefined(value2) && "string" === this.serializationFormat ? value2.toString() : value2;
                };
              }
            }
          };
          var customizeTextForBooleanDataType = function(e) {
            if (true === e.value) {
              return this.trueText || "true";
            } else if (false === e.value) {
              return this.falseText || "false";
            } else {
              return e.valueText || "";
            }
          };
          var getCustomizeTextByDataType = function(dataType) {
            if ("boolean" === dataType) {
              return customizeTextForBooleanDataType;
            }
          };
          var updateColumnIndexes = function(that) {
            each(that._columns, function(index2, column) {
              column.index = index2;
            });
            each(that._columns, function(index2, column) {
              if (isObject2(column.ownerBand)) {
                column.ownerBand = column.ownerBand.index;
              }
            });
            each(that._commandColumns, function(index2, column) {
              column.index = -(index2 + 1);
            });
          };
          var updateColumnGroupIndexes = function(that, currentColumn) {
            normalizeIndexes(that._columns, "groupIndex", currentColumn, function(column) {
              var grouped = column.grouped;
              delete column.grouped;
              return grouped;
            });
          };
          var getColumnIndexByVisibleIndex = function(that, visibleIndex, location) {
            var rowIndex = isObject2(visibleIndex) ? visibleIndex.rowIndex : null;
            var columns = "group" === location ? that.getGroupColumns() : "columnChooser" === location ? that.getChooserColumns() : that.getVisibleColumns(rowIndex);
            var column;
            visibleIndex = isObject2(visibleIndex) ? visibleIndex.columnIndex : visibleIndex;
            column = columns[visibleIndex];
            if (column && column.type === GROUP_COMMAND_COLUMN_NAME) {
              column = that._columns.filter((col) => column.type === col.type)[0] || column;
            }
            return column && isDefined(column.index) ? column.index : -1;
          };
          function checkUserStateColumn(column, userStateColumn) {
            return column && userStateColumn && (userStateColumn.name === column.name || !column.name) && (userStateColumn.dataField === column.dataField || column.name);
          }
          var applyUserState = function(that) {
            var columnsUserState = that._columnsUserState;
            var ignoreColumnOptionNames = that._ignoreColumnOptionNames || [];
            var columns = that._columns;
            var columnCountById = {};
            var resultColumns = [];
            var allColumnsHaveState = true;
            var userStateColumnIndexes = [];
            var column;
            var userStateColumnIndex;
            var i;
            function applyFieldsState(column2, userStateColumn) {
              if (!userStateColumn) {
                return;
              }
              for (var index2 = 0; index2 < USER_STATE_FIELD_NAMES.length; index2++) {
                var fieldName = USER_STATE_FIELD_NAMES[index2];
                if (inArray(fieldName, ignoreColumnOptionNames) >= 0) {
                  continue;
                }
                if ("dataType" === fieldName) {
                  column2[fieldName] = column2[fieldName] || userStateColumn[fieldName];
                } else if (inArray(fieldName, USER_STATE_FIELD_NAMES_15_1) >= 0) {
                  if (fieldName in userStateColumn) {
                    column2[fieldName] = userStateColumn[fieldName];
                  }
                } else {
                  if ("selectedFilterOperation" === fieldName && userStateColumn[fieldName]) {
                    column2.defaultSelectedFilterOperation = column2[fieldName] || null;
                  }
                  column2[fieldName] = userStateColumn[fieldName];
                }
              }
            }
            function findUserStateColumn(columnsUserState2, column2) {
              var id = column2.name || column2.dataField;
              var count = columnCountById[id] || 0;
              for (var j = 0; j < columnsUserState2.length; j++) {
                if (checkUserStateColumn(column2, columnsUserState2[j])) {
                  if (count) {
                    count--;
                  } else {
                    columnCountById[id] = columnCountById[id] || 0;
                    columnCountById[id]++;
                    return j;
                  }
                }
              }
              return -1;
            }
            if (columnsUserState) {
              for (i = 0; i < columns.length; i++) {
                userStateColumnIndex = findUserStateColumn(columnsUserState, columns[i]);
                allColumnsHaveState = allColumnsHaveState && userStateColumnIndex >= 0;
                userStateColumnIndexes.push(userStateColumnIndex);
              }
              for (i = 0; i < columns.length; i++) {
                column = columns[i];
                userStateColumnIndex = userStateColumnIndexes[i];
                if (that._hasUserState || allColumnsHaveState) {
                  applyFieldsState(column, columnsUserState[userStateColumnIndex]);
                }
                if (userStateColumnIndex >= 0 && isDefined(columnsUserState[userStateColumnIndex].initialIndex)) {
                  resultColumns[userStateColumnIndex] = column;
                } else {
                  resultColumns.push(column);
                }
              }
              var hasAddedBands = false;
              for (i = 0; i < columnsUserState.length; i++) {
                var columnUserState = columnsUserState[i];
                if (columnUserState.added && findUserStateColumn(columns, columnUserState) < 0) {
                  column = createColumn(that, columnUserState.added);
                  applyFieldsState(column, columnUserState);
                  resultColumns.push(column);
                  if (columnUserState.added.columns) {
                    hasAddedBands = true;
                  }
                }
              }
              if (hasAddedBands) {
                updateColumnIndexes(that);
                resultColumns = createColumnsFromOptions(that, resultColumns);
              }
              assignColumns(that, resultColumns);
            }
          };
          var updateIndexes = function(that, column) {
            updateColumnIndexes(that);
            updateColumnGroupIndexes(that, column);
            !function(that2, currentColumn) {
              each(that2._columns, function(index2, column2) {
                if (isDefined(column2.sortIndex) && !isSortOrderValid(column2.sortOrder)) {
                  delete column2.sortIndex;
                }
              });
              normalizeIndexes(that2._columns, "sortIndex", currentColumn, function(column2) {
                return !isDefined(column2.groupIndex) && isSortOrderValid(column2.sortOrder);
              });
            }(that, column);
            resetBandColumnsCache(that);
            !function(that2, currentColumn) {
              var key;
              var column2;
              var bandColumns = {};
              var result2 = [];
              var bandColumnsCache = that2.getBandColumnsCache();
              var columns = that2._columns.filter((column3) => !column3.command);
              for (var i = 0; i < columns.length; i++) {
                column2 = columns[i];
                var parentBandColumns = getParentBandColumns(i, bandColumnsCache.columnParentByIndex);
                if (parentBandColumns.length) {
                  var bandColumnIndex = parentBandColumns[parentBandColumns.length - 1].index;
                  bandColumns[bandColumnIndex] = bandColumns[bandColumnIndex] || [];
                  bandColumns[bandColumnIndex].push(column2);
                } else {
                  result2.push(column2);
                }
              }
              for (key in bandColumns) {
                normalizeIndexes(bandColumns[key], "visibleIndex", currentColumn);
              }
              normalizeIndexes(result2, "visibleIndex", currentColumn);
            }(that, column);
          };
          var resetColumnsCache = function(that) {
            that.resetColumnsCache();
          };
          function assignColumns(that, columns) {
            that._columns = columns;
            resetColumnsCache(that);
            that.updateColumnDataTypes();
          }
          var updateColumnChanges = function(that, changeType, optionName, columnIndex) {
            var columnChanges = that._columnChanges || {
              optionNames: {
                length: 0
              },
              changeTypes: {
                length: 0
              },
              columnIndex
            };
            optionName = optionName || "all";
            optionName = optionName.split(".")[0];
            var changeTypes = columnChanges.changeTypes;
            if (changeType && !changeTypes[changeType]) {
              changeTypes[changeType] = true;
              changeTypes.length++;
            }
            var optionNames = columnChanges.optionNames;
            if (optionName && !optionNames[optionName]) {
              optionNames[optionName] = true;
              optionNames.length++;
            }
            if (void 0 === columnIndex || columnIndex !== columnChanges.columnIndex) {
              delete columnChanges.columnIndex;
            }
            that._columnChanges = columnChanges;
            resetColumnsCache(that);
          };
          var fireColumnsChanged = function(that) {
            var onColumnsChanging = that.option("onColumnsChanging");
            var columnChanges = that._columnChanges;
            var reinitOptionNames = ["dataField", "lookup", "dataType", "columns"];
            if (that.isInitialized() && !that._updateLockCount && columnChanges) {
              if (onColumnsChanging) {
                that._updateLockCount++;
                onColumnsChanging(extend2({
                  component: that.component
                }, columnChanges));
                that._updateLockCount--;
              }
              that._columnChanges = void 0;
              if (options2 = columnChanges.optionNames, options2 && reinitOptionNames.some((name2) => options2[name2])) {
                that.reinit();
              } else {
                that.columnsChanged.fire(columnChanges);
              }
            }
            var options2;
          };
          var updateSortOrderWhenGrouping = function(that, column, groupIndex, prevGroupIndex) {
            var columnWasGrouped = prevGroupIndex >= 0;
            if (groupIndex >= 0) {
              if (!columnWasGrouped) {
                column.lastSortOrder = column.sortOrder;
              }
            } else {
              var sortMode = that.option("sorting.mode");
              var sortOrder = column.lastSortOrder;
              if ("single" === sortMode) {
                var sortedByAnotherColumn = that._columns.some((col) => col !== column && isDefined(col.sortIndex));
                if (sortedByAnotherColumn) {
                  sortOrder = void 0;
                }
              }
              column.sortOrder = sortOrder;
            }
          };
          var fireOptionChanged = function(that, options2) {
            var value2 = options2.value;
            var optionName = options2.optionName;
            var prevValue = options2.prevValue;
            var fullOptionName = options2.fullOptionName;
            var fullOptionPath = "".concat(fullOptionName, ".").concat(optionName);
            if (!IGNORE_COLUMN_OPTION_NAMES[optionName] && that._skipProcessingColumnsChange !== fullOptionPath) {
              that._skipProcessingColumnsChange = fullOptionPath;
              that.component._notifyOptionChanged(fullOptionPath, value2, prevValue);
              that._skipProcessingColumnsChange = false;
            }
          };
          var columnOptionCore = function(that, column, optionName, value2, notFireEvent) {
            var optionGetter = compileGetter(optionName);
            var columnIndex = column.index;
            var columns;
            var changeType;
            var initialColumn;
            if (3 === arguments.length) {
              return optionGetter(column, {
                functionsAsIs: true
              });
            }
            var prevValue = optionGetter(column, {
              functionsAsIs: true
            });
            if (!equalByValue(prevValue, value2)) {
              if ("groupIndex" === optionName || "calculateGroupValue" === optionName) {
                changeType = "grouping";
                updateSortOrderWhenGrouping(that, column, value2, prevValue);
              } else if ("sortIndex" === optionName || "sortOrder" === optionName || "calculateSortValue" === optionName) {
                changeType = "sorting";
              } else {
                changeType = "columns";
              }
              var optionSetter = compileSetter(optionName);
              optionSetter(column, value2, {
                functionsAsIs: true
              });
              var fullOptionName = getColumnFullPath(that, column);
              if (COLUMN_INDEX_OPTIONS[optionName]) {
                updateIndexes(that, column);
                value2 = optionGetter(column);
              }
              if ("name" === optionName || "allowEditing" === optionName) {
                that._checkColumns();
              }
              if (!isDefined(prevValue) && !isDefined(value2) && 0 !== optionName.indexOf("buffer")) {
                notFireEvent = true;
              }
              if (!notFireEvent) {
                if (inArray(optionName, USER_STATE_FIELD_NAMES) < 0 && "visibleWidth" !== optionName) {
                  columns = that.option("columns");
                  initialColumn = that.getColumnByPath(fullOptionName, columns);
                  if (isString2(initialColumn)) {
                    initialColumn = columns[columnIndex] = {
                      dataField: initialColumn
                    };
                  }
                  if (initialColumn && checkUserStateColumn(initialColumn, column)) {
                    optionSetter(initialColumn, value2, {
                      functionsAsIs: true
                    });
                  }
                }
                updateColumnChanges(that, changeType, optionName, columnIndex);
              } else {
                resetColumnsCache(that);
              }
              fullOptionName && fireOptionChanged(that, {
                fullOptionName,
                optionName,
                value: value2,
                prevValue
              });
            }
          };
          function isSortOrderValid(sortOrder) {
            return "asc" === sortOrder || "desc" === sortOrder;
          }
          var defaultSetCellValue = function(data2, value2) {
            var path = this.dataField.split(".");
            var dotCount = path.length - 1;
            if (this.serializeValue) {
              value2 = this.serializeValue(value2);
            }
            for (var i = 0; i < dotCount; i++) {
              var name2 = path[i];
              data2 = data2[name2] = data2[name2] || {};
            }
            data2[path[dotCount]] = value2;
          };
          var isCustomCommandColumn = (that, commandColumn) => !!that._columns.filter((column) => column.type === commandColumn.type).length;
          var getFixedPosition = function(that, column) {
            var rtlEnabled = that.option("rtlEnabled");
            if (column.command && !isCustomCommandColumn(that, column) || !column.fixedPosition) {
              return rtlEnabled ? "right" : "left";
            }
            return column.fixedPosition;
          };
          var processExpandColumns = function(columns, expandColumns, type2, columnIndex) {
            var customColumnIndex;
            var rowCount = this.getRowCount();
            var rowspan = columns[columnIndex] && columns[columnIndex].rowspan;
            var expandColumnsByType = expandColumns.filter((column) => column.type === type2);
            columns.forEach((column, index2) => {
              if (column.type === type2) {
                customColumnIndex = index2;
                rowspan = columns[index2 + 1] ? columns[index2 + 1].rowspan : rowCount;
              }
            });
            if (rowspan > 1) {
              expandColumnsByType = map(expandColumnsByType, function(expandColumn) {
                return extend2({}, expandColumn, {
                  rowspan
                });
              });
            }
            expandColumnsByType.unshift.apply(expandColumnsByType, isDefined(customColumnIndex) ? [customColumnIndex, 1] : [columnIndex, 0]);
            columns.splice.apply(columns, expandColumnsByType);
            return rowspan || 1;
          };
          var numberToString = function(number2, digitsCount) {
            var str = number2 ? number2.toString() : "0";
            while (str.length < digitsCount) {
              str = "0" + str;
            }
            return str;
          };
          var mergeColumns = (that, columns, commandColumns, needToExtend) => {
            var column;
            var commandColumnIndex;
            var result2 = columns.slice().map((column2) => extend2({}, column2));
            var isColumnFixing = that._isColumnFixing();
            var defaultCommandColumns = commandColumns.slice().map((column2) => extend2({
              fixed: isColumnFixing
            }, column2));
            var getCommandColumnIndex = (column2) => commandColumns.reduce((result3, commandColumn, index2) => {
              var columnType = needToExtend && column2.type === GROUP_COMMAND_COLUMN_NAME ? "expand" : column2.type;
              return commandColumn.type === columnType || commandColumn.command === column2.command ? index2 : result3;
            }, -1);
            var callbackFilter = (commandColumn) => commandColumn.command !== commandColumns[commandColumnIndex].command;
            for (var i = 0; i < columns.length; i++) {
              column = columns[i];
              commandColumnIndex = column && (column.type || column.command) ? getCommandColumnIndex(column) : -1;
              if (commandColumnIndex >= 0) {
                if (needToExtend) {
                  result2[i] = extend2({
                    fixed: isColumnFixing
                  }, commandColumns[commandColumnIndex], column);
                  if (column.type !== GROUP_COMMAND_COLUMN_NAME) {
                    defaultCommandColumns = defaultCommandColumns.filter(callbackFilter);
                  }
                } else {
                  var columnOptions = {
                    visibleIndex: column.visibleIndex,
                    index: column.index,
                    headerId: column.headerId,
                    allowFixing: 0 === column.groupIndex,
                    allowReordering: 0 === column.groupIndex,
                    groupIndex: column.groupIndex
                  };
                  result2[i] = extend2({}, column, commandColumns[commandColumnIndex], column.type === GROUP_COMMAND_COLUMN_NAME && columnOptions);
                }
              }
            }
            if (columns.length && needToExtend && defaultCommandColumns.length) {
              result2 = result2.concat(defaultCommandColumns);
            }
            return result2;
          };
          var isColumnFixed = (that, column) => isDefined(column.fixed) || !column.type ? column.fixed : that._isColumnFixing();
          var resetBandColumnsCache = (that) => {
            that._bandColumnsCache = void 0;
          };
          var findColumn = (columns, identifier) => {
            var identifierOptionName = isString2(identifier) && identifier.substr(0, identifier.indexOf(":"));
            var column;
            if (void 0 === identifier) {
              return;
            }
            if (identifierOptionName) {
              identifier = identifier.substr(identifierOptionName.length + 1);
            }
            if (identifierOptionName) {
              column = columns.filter((column2) => "" + column2[identifierOptionName] === identifier)[0];
            } else {
              ["index", "name", "dataField", "caption"].some((optionName) => {
                column = columns.filter((column2) => column2[optionName] === identifier)[0];
                return !!column;
              });
            }
            return column;
          };
          return {
            _getExpandColumnOptions: function() {
              return {
                type: "expand",
                command: "expand",
                width: "auto",
                cssClass: COMMAND_EXPAND_CLASS2,
                allowEditing: false,
                allowGrouping: false,
                allowSorting: false,
                allowResizing: false,
                allowReordering: false,
                allowHiding: false
              };
            },
            _getFirstItems: function(dataSource) {
              var groupsCount;
              var items = [];
              if (dataSource && dataSource.items().length > 0) {
                groupsCount = ui_grid_core_utils_default.normalizeSortingInfo(dataSource.group()).length;
                items = function getFirstItemsCore(items2, groupsCount2) {
                  if (!items2 || !groupsCount2) {
                    return items2;
                  }
                  for (var i = 0; i < items2.length; i++) {
                    var childItems = getFirstItemsCore(items2[i].items || items2[i].collapsedItems, groupsCount2 - 1);
                    if (childItems && childItems.length) {
                      return childItems;
                    }
                  }
                }(dataSource.items(), groupsCount) || [];
              }
              return items;
            },
            _endUpdateCore: function() {
              !this._skipProcessingColumnsChange && fireColumnsChanged(this);
            },
            init: function() {
              var columns = this.option("columns");
              this._commandColumns = this._commandColumns || [];
              this._columns = this._columns || [];
              this._isColumnsFromOptions = !!columns;
              if (this._isColumnsFromOptions) {
                assignColumns(this, columns ? createColumnsFromOptions(this, columns) : []);
                applyUserState(this);
              } else {
                assignColumns(this, this._columnsUserState ? createColumnsFromOptions(this, this._columnsUserState) : this._columns);
              }
              !function(that) {
                var options2 = that._getExpandColumnOptions();
                that.addCommandColumn(options2);
              }(this);
              if (this._dataSourceApplied) {
                this.applyDataSource(this._dataSource, true);
              } else {
                updateIndexes(this);
              }
              this._checkColumns();
            },
            callbackNames: function() {
              return ["columnsChanged"];
            },
            getColumnByPath: function(path, columns) {
              var column;
              var columnIndexes = [];
              path.replace(regExp, function(_2, columnIndex) {
                columnIndexes.push(parseInt(columnIndex));
                return "";
              });
              if (columnIndexes.length) {
                if (columns) {
                  column = columnIndexes.reduce(function(column2, index2) {
                    return column2 && column2.columns && column2.columns[index2];
                  }, {
                    columns
                  });
                } else {
                  column = function(that, columnIndexes2) {
                    var result2;
                    var columns2;
                    var bandColumnsCache = that.getBandColumnsCache();
                    var callbackFilter = function(column2) {
                      var ownerBand = result2 ? result2.index : void 0;
                      return column2.ownerBand === ownerBand;
                    };
                    if (bandColumnsCache.isPlain) {
                      result2 = that._columns[columnIndexes2[0]];
                    } else {
                      columns2 = that._columns.filter(callbackFilter);
                      for (var i = 0; i < columnIndexes2.length; i++) {
                        result2 = columns2[columnIndexes2[i]];
                        if (result2) {
                          columns2 = that._columns.filter(callbackFilter);
                        }
                      }
                    }
                    return result2;
                  }(this, columnIndexes);
                }
              }
              return column;
            },
            optionChanged: function(args) {
              var needUpdateRequireResize;
              switch (args.name) {
                case "adaptColumnWidthByRatio":
                  args.handled = true;
                  break;
                case "dataSource":
                  if (args.value !== args.previousValue && !this.option("columns") && (!Array.isArray(args.value) || !Array.isArray(args.previousValue))) {
                    this._columns = [];
                  }
                  break;
                case "columns":
                  needUpdateRequireResize = this._skipProcessingColumnsChange;
                  args.handled = true;
                  if (!this._skipProcessingColumnsChange) {
                    if (args.name === args.fullName) {
                      this._columnsUserState = null;
                      this._ignoreColumnOptionNames = null;
                      this.init();
                    } else {
                      this._columnOptionChanged(args);
                      needUpdateRequireResize = true;
                    }
                  }
                  if (needUpdateRequireResize) {
                    this._updateRequireResize(args);
                  }
                  break;
                case "commonColumnSettings":
                case "columnAutoWidth":
                case "allowColumnResizing":
                case "allowColumnReordering":
                case "columnFixing":
                case "grouping":
                case "groupPanel":
                case "regenerateColumnsByVisibleItems":
                case "customizeColumns":
                case "columnHidingEnabled":
                case "dateSerializationFormat":
                case "columnResizingMode":
                case "columnMinWidth":
                case "columnWidth":
                  args.handled = true;
                  var ignoreColumnOptionNames = "columnWidth" === args.fullName && ["width"];
                  this.reinit(ignoreColumnOptionNames);
                  break;
                case "rtlEnabled":
                  this.reinit();
                  break;
                default:
                  this.callBase(args);
              }
            },
            _columnOptionChanged: function(args) {
              var columnOptionValue = {};
              var column = this.getColumnByPath(args.fullName);
              var columnOptionName = args.fullName.replace(regExp, "");
              if (column) {
                if (columnOptionName) {
                  columnOptionValue[columnOptionName] = args.value;
                } else {
                  columnOptionValue = args.value;
                }
                this._skipProcessingColumnsChange = args.fullName;
                this.columnOption(column.index, columnOptionValue);
                this._skipProcessingColumnsChange = false;
              }
            },
            _updateRequireResize: function(args) {
              var component = this.component;
              if ("width" === args.fullName.replace(regExp, "") && component._updateLockCount) {
                component._requireResize = true;
              }
            },
            publicMethods: function() {
              return ["addColumn", "deleteColumn", "columnOption", "columnCount", "clearSorting", "clearGrouping", "getVisibleColumns", "getVisibleColumnIndex"];
            },
            applyDataSource: function(dataSource, forceApplying) {
              var isDataSourceLoaded = dataSource && dataSource.isLoaded();
              this._dataSource = dataSource;
              if (!this._dataSourceApplied || 0 === this._dataSourceColumnsCount || forceApplying || this.option("regenerateColumnsByVisibleItems")) {
                if (isDataSourceLoaded) {
                  if (!this._isColumnsFromOptions) {
                    var columnsFromDataSource = function(that, dataSource2) {
                      var firstItems = that._getFirstItems(dataSource2);
                      var fieldName;
                      var processedFields = {};
                      var result2 = [];
                      for (var i = 0; i < firstItems.length; i++) {
                        if (firstItems[i]) {
                          for (fieldName in firstItems[i]) {
                            if (!isFunction(firstItems[i][fieldName]) || variable_wrapper_default.isWrapped(firstItems[i][fieldName])) {
                              processedFields[fieldName] = true;
                            }
                          }
                        }
                      }
                      for (fieldName in processedFields) {
                        if (0 !== fieldName.indexOf("__")) {
                          var column = createColumn(that, fieldName);
                          result2.push(column);
                        }
                      }
                      return result2;
                    }(this, dataSource);
                    if (columnsFromDataSource.length) {
                      assignColumns(this, columnsFromDataSource);
                      this._dataSourceColumnsCount = this._columns.length;
                      applyUserState(this);
                    }
                  }
                  return this.updateColumns(dataSource, forceApplying);
                } else {
                  this._dataSourceApplied = false;
                  updateIndexes(this);
                }
              } else if (isDataSourceLoaded && !this.isAllDataTypesDefined(true) && this.updateColumnDataTypes(dataSource)) {
                updateColumnChanges(this, "columns");
                fireColumnsChanged(this);
                return new Deferred().reject().promise();
              }
            },
            reset: function() {
              this._dataSourceApplied = false;
              this._dataSourceColumnsCount = void 0;
              this.reinit();
            },
            resetColumnsCache: function() {
              this._visibleColumns = void 0;
              this._fixedColumns = void 0;
              this._rowCount = void 0;
              resetBandColumnsCache(this);
            },
            reinit: function(ignoreColumnOptionNames) {
              this._columnsUserState = this.getUserState();
              this._ignoreColumnOptionNames = ignoreColumnOptionNames || null;
              this.init();
              if (ignoreColumnOptionNames) {
                this._ignoreColumnOptionNames = null;
              }
            },
            isInitialized: function() {
              return !!this._columns.length || !!this.option("columns");
            },
            isDataSourceApplied: function() {
              return this._dataSourceApplied;
            },
            getCommonSettings: function(column) {
              var commonColumnSettings = (!column || !column.type) && this.option("commonColumnSettings") || {};
              var groupingOptions = this.option("grouping") || {};
              var groupPanelOptions = this.option("groupPanel") || {};
              return extend2({
                allowFixing: this.option("columnFixing.enabled"),
                allowResizing: this.option("allowColumnResizing") || void 0,
                allowReordering: this.option("allowColumnReordering"),
                minWidth: this.option("columnMinWidth"),
                width: this.option("columnWidth"),
                autoExpandGroup: groupingOptions.autoExpandAll,
                allowCollapsing: groupingOptions.allowCollapsing,
                allowGrouping: groupPanelOptions.allowColumnDragging && groupPanelOptions.visible || groupingOptions.contextMenuEnabled
              }, commonColumnSettings);
            },
            isColumnOptionUsed: function(optionName) {
              for (var i = 0; i < this._columns.length; i++) {
                if (this._columns[i][optionName]) {
                  return true;
                }
              }
            },
            isAllDataTypesDefined: function(checkSerializers) {
              var columns = this._columns;
              if (!columns.length) {
                return false;
              }
              for (var i = 0; i < columns.length; i++) {
                if (!columns[i].dataField && columns[i].calculateCellValue === columns[i].defaultCalculateCellValue) {
                  continue;
                }
                if (!columns[i].dataType || checkSerializers && columns[i].deserializeValue && void 0 === columns[i].serializationFormat) {
                  return false;
                }
              }
              return true;
            },
            getColumns: function() {
              return this._columns;
            },
            isBandColumnsUsed: function() {
              return this.getColumns().some(function(column) {
                return column.isBand;
              });
            },
            getGroupColumns: function() {
              var result2 = [];
              each(this._columns, function() {
                if (isDefined(this.groupIndex)) {
                  result2[this.groupIndex] = this;
                }
              });
              return result2;
            },
            getVisibleColumns: function(rowIndex) {
              this._visibleColumns = this._visibleColumns || this._getVisibleColumnsCore();
              rowIndex = isDefined(rowIndex) ? rowIndex : this._visibleColumns.length - 1;
              return this._visibleColumns[rowIndex] || [];
            },
            getFixedColumns: function(rowIndex) {
              this._fixedColumns = this._fixedColumns || this._getFixedColumnsCore();
              rowIndex = isDefined(rowIndex) ? rowIndex : this._fixedColumns.length - 1;
              return this._fixedColumns[rowIndex] || [];
            },
            getFilteringColumns: function() {
              return this.getColumns().filter((item) => (item.dataField || item.name) && (item.allowFiltering || item.allowHeaderFiltering)).map((item) => {
                var field = extend2(true, {}, item);
                if (!isDefined(field.dataField)) {
                  field.dataField = field.name;
                }
                field.filterOperations = item.filterOperations !== item.defaultFilterOperations ? field.filterOperations : null;
                return field;
              });
            },
            getColumnIndexOffset: function() {
              return 0;
            },
            _getFixedColumnsCore: function() {
              var result2 = [];
              var rowCount = this.getRowCount();
              var isColumnFixing = this._isColumnFixing();
              var transparentColumn = {
                command: "transparent"
              };
              var transparentColspan = 0;
              var notFixedColumnCount;
              var transparentColumnIndex;
              var lastFixedPosition;
              if (isColumnFixing) {
                for (var i = 0; i <= rowCount; i++) {
                  notFixedColumnCount = 0;
                  lastFixedPosition = null;
                  transparentColumnIndex = null;
                  var visibleColumns = this.getVisibleColumns(i, true);
                  for (var j = 0; j < visibleColumns.length; j++) {
                    var prevColumn = visibleColumns[j - 1];
                    var column = visibleColumns[j];
                    if (!column.fixed) {
                      if (0 === i) {
                        if (column.isBand && column.colspan) {
                          transparentColspan += column.colspan;
                        } else {
                          transparentColspan++;
                        }
                      }
                      notFixedColumnCount++;
                      if (!isDefined(transparentColumnIndex)) {
                        transparentColumnIndex = j;
                      }
                    } else if (prevColumn && prevColumn.fixed && getFixedPosition(this, prevColumn) !== getFixedPosition(this, column)) {
                      if (!isDefined(transparentColumnIndex)) {
                        transparentColumnIndex = j;
                      }
                    } else {
                      lastFixedPosition = column.fixedPosition;
                    }
                  }
                  if (0 === i && (0 === notFixedColumnCount || notFixedColumnCount >= visibleColumns.length)) {
                    return [];
                  }
                  if (!isDefined(transparentColumnIndex)) {
                    transparentColumnIndex = "right" === lastFixedPosition ? 0 : visibleColumns.length;
                  }
                  result2[i] = visibleColumns.slice(0);
                  if (!transparentColumn.colspan) {
                    transparentColumn.colspan = transparentColspan;
                  }
                  result2[i].splice(transparentColumnIndex, notFixedColumnCount, transparentColumn);
                }
              }
              return result2.map((columns) => columns.map((column2) => {
                var newColumn = _extends({}, column2);
                if (newColumn.headerId) {
                  newColumn.headerId += "-fixed";
                }
                return newColumn;
              }));
            },
            _isColumnFixing: function() {
              var isColumnFixing = this.option("columnFixing.enabled");
              !isColumnFixing && each(this._columns, function(_2, column) {
                if (column.fixed) {
                  isColumnFixing = true;
                  return false;
                }
              });
              return isColumnFixing;
            },
            _getExpandColumnsCore: function() {
              return this.getGroupColumns();
            },
            getExpandColumns: function() {
              var expandColumns = this._getExpandColumnsCore();
              var expandColumn;
              var firstGroupColumn = expandColumns.filter((column) => 0 === column.groupIndex)[0];
              var isFixedFirstGroupColumn = firstGroupColumn && firstGroupColumn.fixed;
              var isColumnFixing = this._isColumnFixing();
              var rtlEnabled = this.option("rtlEnabled");
              if (expandColumns.length) {
                expandColumn = this.columnOption("command:expand");
              }
              expandColumns = map(expandColumns, (column) => extend2({}, column, {
                visibleWidth: null,
                minWidth: null,
                cellTemplate: !isDefined(column.groupIndex) ? column.cellTemplate : null,
                headerCellTemplate: null,
                fixed: !isDefined(column.groupIndex) || !isFixedFirstGroupColumn ? isColumnFixing : true,
                fixedPosition: rtlEnabled ? "right" : "left"
              }, expandColumn, {
                index: column.index,
                type: column.type || GROUP_COMMAND_COLUMN_NAME
              }));
              return expandColumns;
            },
            getBandColumnsCache: function() {
              if (!this._bandColumnsCache) {
                var columns = this._columns;
                var columnChildrenByIndex = {};
                var columnParentByIndex = {};
                var isPlain = true;
                columns.forEach(function(column) {
                  var ownerBand = column.ownerBand;
                  var parentIndex = isObject2(ownerBand) ? ownerBand.index : ownerBand;
                  var parent = columns[parentIndex];
                  if (column.hasColumns) {
                    isPlain = false;
                  }
                  if (column.colspan) {
                    column.colspan = void 0;
                  }
                  if (column.rowspan) {
                    column.rowspan = void 0;
                  }
                  if (parent) {
                    columnParentByIndex[column.index] = parent;
                  } else {
                    parentIndex = -1;
                  }
                  columnChildrenByIndex[parentIndex] = columnChildrenByIndex[parentIndex] || [];
                  columnChildrenByIndex[parentIndex].push(column);
                });
                this._bandColumnsCache = {
                  isPlain,
                  columnChildrenByIndex,
                  columnParentByIndex
                };
              }
              return this._bandColumnsCache;
            },
            _isColumnVisible: function(column) {
              return column.visible && this.isParentColumnVisible(column.index);
            },
            _getVisibleColumnsCore: function() {
              var that = this;
              var i;
              var result2 = [];
              var rowspanGroupColumns = 0;
              var rowspanExpandColumns = 0;
              var rowCount = that.getRowCount();
              var positiveIndexedColumns = [];
              var negativeIndexedColumns = [];
              var notGroupedColumnsCount = 0;
              var isFixedToEnd;
              var rtlEnabled = that.option("rtlEnabled");
              var bandColumnsCache = that.getBandColumnsCache();
              var expandColumns = mergeColumns(that, that.getExpandColumns(), that._columns);
              var columns = mergeColumns(that, that._columns, that._commandColumns, true);
              var columnDigitsCount = function(number2) {
                var i2;
                for (i2 = 0; number2 > 1; i2++) {
                  number2 /= 10;
                }
                return i2;
              }(columns.length);
              !function(that2, columns2, bandColumnsCache2) {
                var rowspan;
                for (var i2 = 0; i2 < columns2.length; i2++) {
                  var column = columns2[i2];
                  if (column.visible || column.command) {
                    if (column.isBand) {
                      column.colspan = column.colspan || calculateColspan(that2, column.index);
                    }
                    if (!column.isBand || !column.colspan) {
                      rowspan = that2.getRowCount();
                      if (!column.command && (!isDefined(column.groupIndex) || column.showWhenGrouped)) {
                        rowspan -= getParentBandColumns(column.index, bandColumnsCache2.columnParentByIndex).length;
                      }
                      if (rowspan > 1) {
                        column.rowspan = rowspan;
                      }
                    }
                  }
                }
              }(that, columns, bandColumnsCache);
              for (i = 0; i < rowCount; i++) {
                result2[i] = [];
                negativeIndexedColumns[i] = [{}];
                positiveIndexedColumns[i] = [{}, {}, {}];
              }
              each(columns, function() {
                var visibleIndex = this.visibleIndex;
                var indexedColumns;
                var parentBandColumns = getParentBandColumns(this.index, bandColumnsCache.columnParentByIndex);
                var visible2 = that._isColumnVisible(this);
                if (visible2 && (!isDefined(this.groupIndex) || this.showWhenGrouped)) {
                  var rowIndex = parentBandColumns.length;
                  if (visibleIndex < 0) {
                    visibleIndex = -visibleIndex;
                    indexedColumns = negativeIndexedColumns[rowIndex];
                  } else {
                    this.fixed = parentBandColumns.length ? parentBandColumns[0].fixed : this.fixed;
                    this.fixedPosition = parentBandColumns.length ? parentBandColumns[0].fixedPosition : this.fixedPosition;
                    if (this.fixed) {
                      isFixedToEnd = "right" === this.fixedPosition;
                      if (rtlEnabled && (!this.command || isCustomCommandColumn(that, this))) {
                        isFixedToEnd = !isFixedToEnd;
                      }
                      if (isFixedToEnd) {
                        indexedColumns = positiveIndexedColumns[rowIndex][2];
                      } else {
                        indexedColumns = positiveIndexedColumns[rowIndex][0];
                      }
                    } else {
                      indexedColumns = positiveIndexedColumns[rowIndex][1];
                    }
                  }
                  if (parentBandColumns.length) {
                    visibleIndex = numberToString(visibleIndex, columnDigitsCount);
                    for (i = parentBandColumns.length - 1; i >= 0; i--) {
                      visibleIndex = numberToString(parentBandColumns[i].visibleIndex, columnDigitsCount) + visibleIndex;
                    }
                  }
                  indexedColumns[visibleIndex] = indexedColumns[visibleIndex] || [];
                  indexedColumns[visibleIndex].push(this);
                  notGroupedColumnsCount++;
                }
              });
              each(result2, function(rowIndex) {
                orderEach(negativeIndexedColumns[rowIndex], function(_2, columns2) {
                  result2[rowIndex].unshift.apply(result2[rowIndex], columns2);
                });
                var firstPositiveIndexColumn = result2[rowIndex].length;
                each(positiveIndexedColumns[rowIndex], function(index2, columnsByFixing) {
                  orderEach(columnsByFixing, function(_2, columnsByVisibleIndex) {
                    result2[rowIndex].push.apply(result2[rowIndex], columnsByVisibleIndex);
                  });
                });
                if (rowspanExpandColumns < rowIndex + 1) {
                  rowspanExpandColumns += processExpandColumns.call(that, result2[rowIndex], expandColumns, "detailExpand", firstPositiveIndexColumn);
                }
                if (rowspanGroupColumns < rowIndex + 1) {
                  rowspanGroupColumns += processExpandColumns.call(that, result2[rowIndex], expandColumns, GROUP_COMMAND_COLUMN_NAME, firstPositiveIndexColumn);
                }
              });
              result2.push(function getDataColumns(columns2, rowIndex, bandColumnID) {
                var result3 = [];
                rowIndex = rowIndex || 0;
                columns2[rowIndex] && each(columns2[rowIndex], function(_2, column) {
                  if (column.ownerBand === bandColumnID || column.type === GROUP_COMMAND_COLUMN_NAME) {
                    if (!column.isBand || !column.colspan) {
                      if (!column.command || rowIndex < 1) {
                        result3.push(column);
                      }
                    } else {
                      result3.push.apply(result3, getDataColumns(columns2, rowIndex + 1, column.index));
                    }
                  }
                });
                return result3;
              }(result2));
              if (!notGroupedColumnsCount && that._columns.length) {
                result2[rowCount].push({
                  command: "empty"
                });
              }
              return result2;
            },
            getInvisibleColumns: function(columns, bandColumnIndex) {
              var that = this;
              var result2 = [];
              var hiddenColumnsByBand;
              columns = columns || that._columns;
              each(columns, function(_2, column) {
                if (column.ownerBand !== bandColumnIndex) {
                  return;
                }
                if (column.isBand) {
                  if (!column.visible) {
                    hiddenColumnsByBand = that.getChildrenByBandColumn(column.index);
                  } else {
                    hiddenColumnsByBand = that.getInvisibleColumns(that.getChildrenByBandColumn(column.index), column.index);
                  }
                  if (hiddenColumnsByBand.length) {
                    result2.push(column);
                    result2 = result2.concat(hiddenColumnsByBand);
                  }
                  return;
                }
                if (!column.visible) {
                  result2.push(column);
                }
              });
              return result2;
            },
            getChooserColumns: function(getAllColumns) {
              var columns = getAllColumns ? this.getColumns() : this.getInvisibleColumns();
              return grep(columns, function(column) {
                return column.showInColumnChooser;
              });
            },
            allowMoveColumn: function(fromVisibleIndex, toVisibleIndex, sourceLocation, targetLocation) {
              var columnIndex = getColumnIndexByVisibleIndex(this, fromVisibleIndex, sourceLocation);
              var sourceColumn = this._columns[columnIndex];
              if (sourceColumn && (sourceColumn.allowReordering || sourceColumn.allowGrouping || sourceColumn.allowHiding)) {
                if (sourceLocation === targetLocation) {
                  if ("columnChooser" === sourceLocation) {
                    return false;
                  }
                  fromVisibleIndex = isObject2(fromVisibleIndex) ? fromVisibleIndex.columnIndex : fromVisibleIndex;
                  toVisibleIndex = isObject2(toVisibleIndex) ? toVisibleIndex.columnIndex : toVisibleIndex;
                  return fromVisibleIndex !== toVisibleIndex && fromVisibleIndex + 1 !== toVisibleIndex;
                } else if ("group" === sourceLocation && "columnChooser" !== targetLocation || "group" === targetLocation) {
                  return sourceColumn && sourceColumn.allowGrouping;
                } else if ("columnChooser" === sourceLocation || "columnChooser" === targetLocation) {
                  return sourceColumn && sourceColumn.allowHiding;
                }
                return true;
              }
              return false;
            },
            moveColumn: function(fromVisibleIndex, toVisibleIndex, sourceLocation, targetLocation) {
              var options2 = {};
              var prevGroupIndex;
              var fromIndex = getColumnIndexByVisibleIndex(this, fromVisibleIndex, sourceLocation);
              var toIndex = getColumnIndexByVisibleIndex(this, toVisibleIndex, targetLocation);
              var targetGroupIndex;
              if (fromIndex >= 0) {
                var column = this._columns[fromIndex];
                toVisibleIndex = isObject2(toVisibleIndex) ? toVisibleIndex.columnIndex : toVisibleIndex;
                targetGroupIndex = toIndex >= 0 ? this._columns[toIndex].groupIndex : -1;
                if (isDefined(column.groupIndex) && "group" === sourceLocation) {
                  if (targetGroupIndex > column.groupIndex) {
                    targetGroupIndex--;
                  }
                  if ("group" !== targetLocation) {
                    options2.groupIndex = void 0;
                  } else {
                    prevGroupIndex = column.groupIndex;
                    delete column.groupIndex;
                    updateColumnGroupIndexes(this);
                  }
                }
                if ("group" === targetLocation) {
                  options2.groupIndex = function(that, column2, groupIndex) {
                    var groupColumns = that.getGroupColumns();
                    var i;
                    if (groupIndex >= 0) {
                      for (i = 0; i < groupColumns.length; i++) {
                        if (groupColumns[i].groupIndex >= groupIndex) {
                          groupColumns[i].groupIndex++;
                        }
                      }
                    } else {
                      groupIndex = 0;
                      for (i = 0; i < groupColumns.length; i++) {
                        groupIndex = Math.max(groupIndex, groupColumns[i].groupIndex + 1);
                      }
                    }
                    return groupIndex;
                  }(this, 0, targetGroupIndex);
                  column.groupIndex = prevGroupIndex;
                } else if (toVisibleIndex >= 0) {
                  var targetColumn = this._columns[toIndex];
                  if (!targetColumn || column.ownerBand !== targetColumn.ownerBand) {
                    options2.visibleIndex = MAX_SAFE_INTEGER;
                  } else if (isColumnFixed(this, column) ^ isColumnFixed(this, targetColumn)) {
                    options2.visibleIndex = MAX_SAFE_INTEGER;
                  } else {
                    options2.visibleIndex = targetColumn.visibleIndex;
                  }
                }
                var isVisible2 = "columnChooser" !== targetLocation;
                if (column.visible !== isVisible2) {
                  options2.visible = isVisible2;
                }
                this.columnOption(column.index, options2);
              }
            },
            changeSortOrder: function(columnIndex, sortOrder) {
              var options2 = {};
              var sortingOptions = this.option("sorting");
              var sortingMode = sortingOptions && sortingOptions.mode;
              var needResetSorting = "single" === sortingMode || !sortOrder;
              var allowSorting = "single" === sortingMode || "multiple" === sortingMode;
              var column = this._columns[columnIndex];
              if (allowSorting && column && column.allowSorting) {
                if (needResetSorting && !isDefined(column.groupIndex)) {
                  each(this._columns, function(index2) {
                    if (index2 !== columnIndex && this.sortOrder) {
                      if (!isDefined(this.groupIndex)) {
                        delete this.sortOrder;
                      }
                      delete this.sortIndex;
                    }
                  });
                }
                if (isSortOrderValid(sortOrder)) {
                  if (column.sortOrder !== sortOrder) {
                    options2.sortOrder = sortOrder;
                  }
                } else if ("none" === sortOrder) {
                  if (column.sortOrder) {
                    options2.sortIndex = void 0;
                    options2.sortOrder = void 0;
                  }
                } else {
                  !function(column2) {
                    if ("ctrl" === sortOrder) {
                      if (!("sortOrder" in column2 && "sortIndex" in column2)) {
                        return false;
                      }
                      options2.sortOrder = void 0;
                      options2.sortIndex = void 0;
                    } else if (isDefined(column2.groupIndex) || isDefined(column2.sortIndex)) {
                      options2.sortOrder = "desc" === column2.sortOrder ? "asc" : "desc";
                    } else {
                      options2.sortOrder = "asc";
                    }
                    return true;
                  }(column);
                }
              }
              this.columnOption(column.index, options2);
            },
            getSortDataSourceParameters: function(useLocalSelector) {
              var sortColumns = [];
              var sort = [];
              each(this._columns, function() {
                if ((this.dataField || this.selector || this.calculateCellValue) && isDefined(this.sortIndex) && !isDefined(this.groupIndex)) {
                  sortColumns[this.sortIndex] = this;
                }
              });
              each(sortColumns, function() {
                var sortOrder = this && this.sortOrder;
                if (isSortOrderValid(sortOrder)) {
                  var sortItem = {
                    selector: this.calculateSortValue || this.displayField || this.calculateDisplayValue || useLocalSelector && this.selector || this.dataField || this.calculateCellValue,
                    desc: "desc" === this.sortOrder
                  };
                  if (this.sortingMethod) {
                    sortItem.compare = this.sortingMethod.bind(this);
                  }
                  sort.push(sortItem);
                }
              });
              return sort.length > 0 ? sort : null;
            },
            getGroupDataSourceParameters: function(useLocalSelector) {
              var group = [];
              each(this.getGroupColumns(), function() {
                var selector = this.calculateGroupValue || this.displayField || this.calculateDisplayValue || useLocalSelector && this.selector || this.dataField || this.calculateCellValue;
                if (selector) {
                  var groupItem = {
                    selector,
                    desc: "desc" === this.sortOrder,
                    isExpanded: !!this.autoExpandGroup
                  };
                  if (this.sortingMethod) {
                    groupItem.compare = this.sortingMethod.bind(this);
                  }
                  group.push(groupItem);
                }
              });
              return group.length > 0 ? group : null;
            },
            refresh: function(updateNewLookupsOnly) {
              var deferreds = [];
              each(this._columns, function() {
                var lookup = this.lookup;
                if (lookup && !this.calculateDisplayValue) {
                  if (updateNewLookupsOnly && lookup.valueMap) {
                    return;
                  }
                  if (lookup.update) {
                    deferreds.push(lookup.update());
                  }
                }
              });
              return when.apply(renderer_default, deferreds).done(resetColumnsCache.bind(null, this));
            },
            _updateColumnOptions: function(column, columnIndex) {
              column.selector = column.selector || function(data2) {
                return column.calculateCellValue(data2);
              };
              each(["calculateSortValue", "calculateGroupValue", "calculateDisplayValue"], function(_2, calculateCallbackName) {
                var calculateCallback = column[calculateCallbackName];
                if (isFunction(calculateCallback)) {
                  if (!calculateCallback.originalCallback) {
                    var context2 = {
                      column
                    };
                    column[calculateCallbackName] = function(data2) {
                      return calculateCallback.call(context2.column, data2);
                    };
                    column[calculateCallbackName].originalCallback = calculateCallback;
                    column[calculateCallbackName].columnIndex = columnIndex;
                    column[calculateCallbackName].context = context2;
                  } else {
                    column[calculateCallbackName].context.column = column;
                  }
                }
              });
              if (isString2(column.calculateDisplayValue)) {
                column.displayField = column.calculateDisplayValue;
                column.calculateDisplayValue = compileGetter(column.displayField);
              }
              if (column.calculateDisplayValue) {
                column.displayValueMap = column.displayValueMap || {};
              }
              updateSerializers(column, column.dataType);
              var lookup = column.lookup;
              if (lookup) {
                updateSerializers(lookup, lookup.dataType);
              }
              var dataType = lookup ? lookup.dataType : column.dataType;
              if (dataType) {
                column.alignment = column.alignment || function(dataType2, isRTL) {
                  switch (dataType2) {
                    case "number":
                      return "right";
                    case "boolean":
                      return "center";
                    default:
                      return getDefaultAlignment(isRTL);
                  }
                }(dataType, this.option("rtlEnabled"));
                column.format = column.format || ui_grid_core_utils_default.getFormatByDataType(dataType);
                column.customizeText = column.customizeText || getCustomizeTextByDataType(dataType);
                column.defaultFilterOperations = column.defaultFilterOperations || !lookup && DATATYPE_OPERATIONS2[dataType] || [];
                if (!isDefined(column.filterOperations)) {
                  setFilterOperationsAsDefaultValues(column);
                }
                column.defaultFilterOperation = column.filterOperations && column.filterOperations[0] || "=";
                column.showEditorAlways = isDefined(column.showEditorAlways) ? column.showEditorAlways : "boolean" === dataType && !column.cellTemplate && !column.lookup;
              }
            },
            updateColumnDataTypes: function(dataSource) {
              var that = this;
              var dateSerializationFormat = that.option("dateSerializationFormat");
              var firstItems = that._getFirstItems(dataSource);
              var isColumnDataTypesUpdated = false;
              each(that._columns, function(index2, column) {
                var i;
                var value2;
                var dataType;
                var lookupDataType;
                var valueDataType;
                var lookup = column.lookup;
                if (ui_grid_core_utils_default.isDateType(column.dataType) && void 0 === column.serializationFormat) {
                  column.serializationFormat = dateSerializationFormat;
                }
                if (lookup && ui_grid_core_utils_default.isDateType(lookup.dataType) && void 0 === column.serializationFormat) {
                  lookup.serializationFormat = dateSerializationFormat;
                }
                if (column.calculateCellValue && firstItems.length) {
                  if (!column.dataType || lookup && !lookup.dataType) {
                    for (i = 0; i < firstItems.length; i++) {
                      value2 = column.calculateCellValue(firstItems[i]);
                      if (!column.dataType) {
                        valueDataType = getValueDataType(value2);
                        dataType = dataType || valueDataType;
                        if (dataType && valueDataType && dataType !== valueDataType) {
                          dataType = "string";
                        }
                      }
                      if (lookup && !lookup.dataType) {
                        valueDataType = getValueDataType(ui_grid_core_utils_default.getDisplayValue(column, value2, firstItems[i]));
                        lookupDataType = lookupDataType || valueDataType;
                        if (lookupDataType && valueDataType && lookupDataType !== valueDataType) {
                          lookupDataType = "string";
                        }
                      }
                    }
                    if (dataType || lookupDataType) {
                      if (dataType) {
                        column.dataType = dataType;
                      }
                      if (lookup && lookupDataType) {
                        lookup.dataType = lookupDataType;
                      }
                      isColumnDataTypesUpdated = true;
                    }
                  }
                  if (void 0 === column.serializationFormat || lookup && void 0 === lookup.serializationFormat) {
                    for (i = 0; i < firstItems.length; i++) {
                      value2 = column.calculateCellValue(firstItems[i], true);
                      if (void 0 === column.serializationFormat) {
                        column.serializationFormat = getSerializationFormat(column.dataType, value2);
                      }
                      if (lookup && void 0 === lookup.serializationFormat) {
                        lookup.serializationFormat = getSerializationFormat(lookup.dataType, lookup.calculateCellValue(value2, true));
                      }
                    }
                  }
                }
                that._updateColumnOptions(column, index2);
              });
              return isColumnDataTypesUpdated;
            },
            _customizeColumns: function(columns) {
              var customizeColumns = this.option("customizeColumns");
              if (customizeColumns) {
                var hasOwnerBand = columns.some(function(column) {
                  return isObject2(column.ownerBand);
                });
                if (hasOwnerBand) {
                  updateIndexes(this);
                }
                customizeColumns(columns);
                assignColumns(this, createColumnsFromOptions(this, columns));
              }
            },
            updateColumns: function(dataSource, forceApplying) {
              if (!forceApplying) {
                this.updateSortingGrouping(dataSource);
              }
              if (!dataSource || dataSource.isLoaded()) {
                var sortParameters = dataSource ? dataSource.sort() || [] : this.getSortDataSourceParameters();
                var groupParameters = dataSource ? dataSource.group() || [] : this.getGroupDataSourceParameters();
                var filterParameters = null === dataSource || void 0 === dataSource ? void 0 : dataSource.lastLoadOptions().filter;
                this._customizeColumns(this._columns);
                updateIndexes(this);
                var columns = this._columns;
                return when(this.refresh(true)).always(() => {
                  if (this._columns !== columns) {
                    return;
                  }
                  this._updateChanges(dataSource, {
                    sorting: sortParameters,
                    grouping: groupParameters,
                    filtering: filterParameters
                  });
                  fireColumnsChanged(this);
                });
              }
            },
            _updateChanges: function(dataSource, parameters) {
              if (dataSource) {
                this.updateColumnDataTypes(dataSource);
                this._dataSourceApplied = true;
              }
              if (!ui_grid_core_utils_default.equalSortParameters(parameters.sorting, this.getSortDataSourceParameters())) {
                updateColumnChanges(this, "sorting");
              }
              if (!ui_grid_core_utils_default.equalSortParameters(parameters.grouping, this.getGroupDataSourceParameters())) {
                updateColumnChanges(this, "grouping");
              }
              var dataController = this.getController("data");
              if (dataController && !ui_grid_core_utils_default.equalFilterParameters(parameters.filtering, dataController.getCombinedFilter())) {
                updateColumnChanges(this, "filtering");
              }
              updateColumnChanges(this, "columns");
            },
            updateSortingGrouping: function(dataSource, fromDataSource) {
              var that = this;
              var sortParameters;
              var isColumnsChanged;
              var updateSortGroupParameterIndexes = function(columns, sortParameters2, indexParameterName) {
                each(columns, function(index2, column) {
                  delete column[indexParameterName];
                  if (sortParameters2) {
                    for (var i = 0; i < sortParameters2.length; i++) {
                      var selector = sortParameters2[i].selector;
                      var isExpanded = sortParameters2[i].isExpanded;
                      if (selector === column.dataField || selector === column.name || selector === column.selector || selector === column.calculateCellValue || selector === column.calculateGroupValue || selector === column.calculateDisplayValue) {
                        column.sortOrder = column.sortOrder || (sortParameters2[i].desc ? "desc" : "asc");
                        if (void 0 !== isExpanded) {
                          column.autoExpandGroup = isExpanded;
                        }
                        column[indexParameterName] = i;
                        break;
                      }
                    }
                  }
                });
              };
              if (dataSource) {
                sortParameters = ui_grid_core_utils_default.normalizeSortingInfo(dataSource.sort());
                var groupParameters = ui_grid_core_utils_default.normalizeSortingInfo(dataSource.group());
                var columnsGroupParameters = that.getGroupDataSourceParameters();
                var columnsSortParameters = that.getSortDataSourceParameters();
                var groupingChanged = !ui_grid_core_utils_default.equalSortParameters(groupParameters, columnsGroupParameters, true);
                var groupExpandingChanged = !groupingChanged && !ui_grid_core_utils_default.equalSortParameters(groupParameters, columnsGroupParameters);
                if (!that._columns.length) {
                  each(groupParameters, function(index2, group) {
                    that._columns.push(group.selector);
                  });
                  each(sortParameters, function(index2, sort) {
                    if (!isFunction(sort.selector)) {
                      that._columns.push(sort.selector);
                    }
                  });
                  assignColumns(that, createColumnsFromOptions(that, that._columns));
                }
                if ((fromDataSource || !columnsGroupParameters && !that._hasUserState) && (groupingChanged || groupExpandingChanged)) {
                  updateSortGroupParameterIndexes(that._columns, groupParameters, "groupIndex");
                  if (fromDataSource) {
                    groupingChanged && updateColumnChanges(that, "grouping");
                    groupExpandingChanged && updateColumnChanges(that, "groupExpanding");
                    isColumnsChanged = true;
                  }
                }
                if ((fromDataSource || !columnsSortParameters && !that._hasUserState) && !ui_grid_core_utils_default.equalSortParameters(sortParameters, columnsSortParameters)) {
                  updateSortGroupParameterIndexes(that._columns, sortParameters, "sortIndex");
                  if (fromDataSource) {
                    updateColumnChanges(that, "sorting");
                    isColumnsChanged = true;
                  }
                }
                if (isColumnsChanged) {
                  fireColumnsChanged(that);
                }
              }
            },
            updateFilter: function(filter, remoteFiltering, columnIndex, filterValue) {
              if (!Array.isArray(filter)) {
                return filter;
              }
              filter = extend2([], filter);
              columnIndex = void 0 !== filter.columnIndex ? filter.columnIndex : columnIndex;
              filterValue = void 0 !== filter.filterValue ? filter.filterValue : filterValue;
              if (isString2(filter[0]) && "!" !== filter[0]) {
                var column = this.columnOption(filter[0]);
                if (remoteFiltering) {
                  if (config_default().forceIsoDateParsing && column && column.serializeValue && filter.length > 1) {
                    filter[filter.length - 1] = column.serializeValue(filter[filter.length - 1], "filter");
                  }
                } else if (column && column.selector) {
                  filter[0] = column.selector;
                  filter[0].columnIndex = column.index;
                }
              } else if (isFunction(filter[0])) {
                filter[0].columnIndex = columnIndex;
                filter[0].filterValue = filterValue;
              }
              for (var i = 0; i < filter.length; i++) {
                filter[i] = this.updateFilter(filter[i], remoteFiltering, columnIndex, filterValue);
              }
              return filter;
            },
            columnCount: function() {
              return this._columns ? this._columns.length : 0;
            },
            columnOption: function(identifier, option, value2, notFireEvent) {
              var that = this;
              var columns = that._columns.concat(that._commandColumns);
              var column = findColumn(columns, identifier);
              if (column) {
                if (1 === arguments.length) {
                  return extend2({}, column);
                }
                if (isString2(option)) {
                  if (2 === arguments.length) {
                    return columnOptionCore(that, column, option);
                  } else {
                    columnOptionCore(that, column, option, value2, notFireEvent);
                  }
                } else if (isObject2(option)) {
                  each(option, function(optionName, value3) {
                    columnOptionCore(that, column, optionName, value3, notFireEvent);
                  });
                }
                fireColumnsChanged(that);
              }
            },
            clearSorting: function() {
              var columnCount = this.columnCount();
              this.beginUpdate();
              for (var i = 0; i < columnCount; i++) {
                this.columnOption(i, "sortOrder", void 0);
              }
              this.endUpdate();
            },
            clearGrouping: function() {
              var columnCount = this.columnCount();
              this.beginUpdate();
              for (var i = 0; i < columnCount; i++) {
                this.columnOption(i, "groupIndex", void 0);
              }
              this.endUpdate();
            },
            getVisibleIndex: function(index2, rowIndex) {
              var columns = this.getVisibleColumns(rowIndex);
              for (var i = columns.length - 1; i >= 0; i--) {
                if (columns[i].index === index2) {
                  return i;
                }
              }
              return -1;
            },
            getVisibleIndexByColumn: function(column, rowIndex) {
              var visibleColumns = this.getVisibleColumns(rowIndex);
              var visibleColumn = visibleColumns.filter((col) => col.index === column.index && col.command === column.command)[0];
              return visibleColumns.indexOf(visibleColumn);
            },
            getVisibleColumnIndex: function(id, rowIndex) {
              var index2 = this.columnOption(id, "index");
              return this.getVisibleIndex(index2, rowIndex);
            },
            addColumn: function(options2) {
              var column = createColumn(this, options2);
              var index2 = this._columns.length;
              this._columns.push(column);
              if (column.isBand) {
                this._columns = createColumnsFromOptions(this, this._columns);
                column = this._columns[index2];
              }
              column.added = options2;
              updateIndexes(this, column);
              this.updateColumns(this._dataSource);
              this._checkColumns();
            },
            deleteColumn: function(id) {
              var column = this.columnOption(id);
              if (column && column.index >= 0) {
                columns = this._columns, void columns.forEach((column2) => {
                  if (isDefined(column2.ownerBand)) {
                    column2.ownerBand = columns[column2.ownerBand];
                  }
                });
                this._columns.splice(column.index, 1);
                if (column.isBand) {
                  var childIndexes = this.getChildrenByBandColumn(column.index).map((column2) => column2.index);
                  this._columns = this._columns.filter((column2) => childIndexes.indexOf(column2.index) < 0);
                }
                updateIndexes(this);
                this.updateColumns(this._dataSource);
              }
              var columns;
            },
            addCommandColumn: function(options2) {
              var commandColumn = this._commandColumns.filter((column) => column.command === options2.command)[0];
              if (!commandColumn) {
                commandColumn = options2;
                this._commandColumns.push(commandColumn);
              }
            },
            getUserState: function() {
              var columns = this._columns;
              var result2 = [];
              var i;
              function handleStateField(index2, value2) {
                if (void 0 !== columns[i][value2]) {
                  result2[i][value2] = columns[i][value2];
                }
              }
              for (i = 0; i < columns.length; i++) {
                result2[i] = {};
                each(USER_STATE_FIELD_NAMES, handleStateField);
              }
              return result2;
            },
            setName: function(column) {
              column.name = column.name || column.dataField || column.type;
            },
            setUserState: function(state) {
              var dataSource = this._dataSource;
              var ignoreColumnOptionNames = this.option("stateStoring.ignoreColumnOptionNames");
              null === state || void 0 === state ? void 0 : state.forEach(this.setName);
              if (!ignoreColumnOptionNames) {
                ignoreColumnOptionNames = [];
                var commonColumnSettings = this.getCommonSettings();
                if (!this.option("columnChooser.enabled")) {
                  ignoreColumnOptionNames.push("visible");
                }
                if ("none" === this.option("sorting.mode")) {
                  ignoreColumnOptionNames.push("sortIndex", "sortOrder");
                }
                if (!commonColumnSettings.allowGrouping) {
                  ignoreColumnOptionNames.push("groupIndex");
                }
                if (!commonColumnSettings.allowFixing) {
                  ignoreColumnOptionNames.push("fixed", "fixedPosition");
                }
                if (!commonColumnSettings.allowResizing) {
                  ignoreColumnOptionNames.push("width", "visibleWidth");
                }
                var isFilterPanelHidden = !this.option("filterPanel.visible");
                if (!this.option("filterRow.visible") && isFilterPanelHidden) {
                  ignoreColumnOptionNames.push("filterValue", "selectedFilterOperation");
                }
                if (!this.option("headerFilter.visible") && isFilterPanelHidden) {
                  ignoreColumnOptionNames.push("filterValues", "filterType");
                }
              }
              this._columnsUserState = state;
              this._ignoreColumnOptionNames = ignoreColumnOptionNames;
              this._hasUserState = !!state;
              updateColumnChanges(this, "filtering");
              this.init();
              if (dataSource) {
                dataSource.sort(this.getSortDataSourceParameters());
                dataSource.group(this.getGroupDataSourceParameters());
              }
            },
            _checkColumns: function() {
              var usedNames = {};
              var hasEditableColumnWithoutName = false;
              var duplicatedNames = [];
              this._columns.forEach((column) => {
                var _column$columns;
                var name2 = column.name;
                var isBand = null === (_column$columns = column.columns) || void 0 === _column$columns ? void 0 : _column$columns.length;
                var isEditable = column.allowEditing && (column.dataField || column.setCellValue) && !isBand;
                if (name2) {
                  if (usedNames[name2]) {
                    duplicatedNames.push('"'.concat(name2, '"'));
                  }
                  usedNames[name2] = true;
                } else if (isEditable) {
                  hasEditableColumnWithoutName = true;
                }
              });
              if (duplicatedNames.length) {
                ui_errors_default.log("E1059", duplicatedNames.join(", "));
              }
              if (hasEditableColumnWithoutName) {
                ui_errors_default.log("E1060");
              }
            },
            _createCalculatedColumnOptions: function(columnOptions, bandColumn) {
              var calculatedColumnOptions = {};
              var dataField = columnOptions.dataField;
              if (Array.isArray(columnOptions.columns) && columnOptions.columns.length || columnOptions.isBand) {
                calculatedColumnOptions.isBand = true;
                dataField = null;
              }
              if (dataField) {
                if (isString2(dataField)) {
                  var getter = compileGetter(dataField);
                  calculatedColumnOptions = {
                    caption: captionize(dataField),
                    calculateCellValue: function(data2, skipDeserialization) {
                      var value2 = getter(data2);
                      return this.deserializeValue && !skipDeserialization ? this.deserializeValue(value2) : value2;
                    },
                    setCellValue: defaultSetCellValue,
                    parseValue: function(text) {
                      var result2;
                      var parsedValue;
                      if ("number" === this.dataType) {
                        if (isString2(text) && this.format) {
                          parsedValue = number_default2.parse(text);
                          if (isNumeric(parsedValue)) {
                            result2 = parsedValue;
                          }
                        } else if (isDefined(text) && isNumeric(text)) {
                          result2 = Number(text);
                        }
                      } else if ("boolean" === this.dataType) {
                        if (text === this.trueText) {
                          result2 = true;
                        } else if (text === this.falseText) {
                          result2 = false;
                        }
                      } else if (ui_grid_core_utils_default.isDateType(this.dataType)) {
                        parsedValue = date_default3.parse(text, this.format);
                        if (parsedValue) {
                          result2 = parsedValue;
                        }
                      } else {
                        result2 = text;
                      }
                      return result2;
                    }
                  };
                }
                calculatedColumnOptions.allowFiltering = true;
              } else {
                calculatedColumnOptions.allowFiltering = !!columnOptions.calculateFilterExpression;
              }
              calculatedColumnOptions.calculateFilterExpression = function() {
                return filtering_default.defaultCalculateFilterExpression.apply(this, arguments);
              };
              calculatedColumnOptions.createFilterExpression = function(filterValue) {
                var result2;
                if (this.calculateFilterExpression) {
                  result2 = this.calculateFilterExpression.apply(this, arguments);
                }
                if (isFunction(result2)) {
                  result2 = [result2, "=", true];
                }
                if (result2) {
                  result2.columnIndex = this.index;
                  result2.filterValue = filterValue;
                }
                return result2;
              };
              if (!dataField || !isString2(dataField)) {
                extend2(true, calculatedColumnOptions, {
                  allowSorting: false,
                  allowGrouping: false,
                  calculateCellValue: function() {
                    return null;
                  }
                });
              }
              if (bandColumn) {
                calculatedColumnOptions.allowFixing = false;
              }
              if (columnOptions.dataType) {
                calculatedColumnOptions.userDataType = columnOptions.dataType;
              }
              if (columnOptions.selectedFilterOperation && !("defaultSelectedFilterOperation" in calculatedColumnOptions)) {
                calculatedColumnOptions.defaultSelectedFilterOperation = columnOptions.selectedFilterOperation;
              }
              if (columnOptions.lookup) {
                calculatedColumnOptions.lookup = {
                  calculateCellValue: function(value2, skipDeserialization) {
                    if (this.valueExpr) {
                      value2 = this.valueMap && this.valueMap[value2];
                    }
                    return this.deserializeValue && !skipDeserialization ? this.deserializeValue(value2) : value2;
                  },
                  updateValueMap: function() {
                    this.valueMap = {};
                    if (this.items) {
                      var calculateValue = compileGetter(this.valueExpr);
                      var calculateDisplayValue = compileGetter(this.displayExpr);
                      for (var i = 0; i < this.items.length; i++) {
                        var item = this.items[i];
                        var displayValue = calculateDisplayValue(item);
                        this.valueMap[calculateValue(item)] = displayValue;
                        this.dataType = this.dataType || getValueDataType(displayValue);
                      }
                    }
                  },
                  update: function() {
                    var that = this;
                    var dataSource = that.dataSource;
                    if (dataSource) {
                      if (isFunction(dataSource) && !variable_wrapper_default.isWrapped(dataSource)) {
                        dataSource = dataSource({});
                      }
                      if (isPlainObject(dataSource) || dataSource instanceof abstract_store_default || Array.isArray(dataSource)) {
                        if (that.valueExpr) {
                          var dataSourceOptions = normalizeDataSourceOptions(dataSource);
                          dataSourceOptions.paginate = false;
                          dataSource = new DataSource(dataSourceOptions);
                          return dataSource.load().done(function(data2) {
                            that.items = data2;
                            that.updateValueMap && that.updateValueMap();
                          });
                        }
                      } else {
                        ui_errors_default.log("E1016");
                      }
                    } else {
                      that.updateValueMap && that.updateValueMap();
                    }
                  }
                };
              }
              calculatedColumnOptions.resizedCallbacks = callbacks_default();
              if (columnOptions.resized) {
                calculatedColumnOptions.resizedCallbacks.add(columnOptions.resized.bind(columnOptions));
              }
              each(calculatedColumnOptions, function(optionName) {
                if (isFunction(calculatedColumnOptions[optionName]) && 0 !== optionName.indexOf("default")) {
                  var defaultOptionName = "default" + optionName.charAt(0).toUpperCase() + optionName.substr(1);
                  calculatedColumnOptions[defaultOptionName] = calculatedColumnOptions[optionName];
                }
              });
              return calculatedColumnOptions;
            },
            getRowCount: function() {
              this._rowCount = this._rowCount || function(that) {
                var rowCount = 1;
                var bandColumnsCache = that.getBandColumnsCache();
                var columnParentByIndex = bandColumnsCache.columnParentByIndex;
                that._columns.forEach(function(column) {
                  var parents = getParentBandColumns(column.index, columnParentByIndex);
                  var invisibleParents = parents.filter(function(column2) {
                    return !column2.visible;
                  });
                  if (column.visible && !invisibleParents.length) {
                    rowCount = Math.max(rowCount, parents.length + 1);
                  }
                });
                return rowCount;
              }(this);
              return this._rowCount;
            },
            getRowIndex: function(columnIndex, alwaysGetRowIndex) {
              var column = this._columns[columnIndex];
              var bandColumnsCache = this.getBandColumnsCache();
              return column && (alwaysGetRowIndex || column.visible && !(column.command || isDefined(column.groupIndex))) ? getParentBandColumns(columnIndex, bandColumnsCache.columnParentByIndex).length : 0;
            },
            getChildrenByBandColumn: function(bandColumnIndex, onlyVisibleDirectChildren) {
              var bandColumnsCache = this.getBandColumnsCache();
              var result2 = _getChildrenByBandColumn(bandColumnIndex, bandColumnsCache.columnChildrenByIndex, !onlyVisibleDirectChildren);
              if (onlyVisibleDirectChildren) {
                return result2.filter(function(column) {
                  return column.visible && !column.command;
                }).sort(function(column1, column2) {
                  return column1.visibleIndex - column2.visibleIndex;
                });
              }
              return result2;
            },
            isParentBandColumn: function(columnIndex, bandColumnIndex) {
              var result2 = false;
              var column = this._columns[columnIndex];
              var bandColumnsCache = this.getBandColumnsCache();
              var parentBandColumns = column && getParentBandColumns(columnIndex, bandColumnsCache.columnParentByIndex);
              if (parentBandColumns) {
                each(parentBandColumns, function(_2, bandColumn) {
                  if (bandColumn.index === bandColumnIndex) {
                    result2 = true;
                    return false;
                  }
                });
              }
              return result2;
            },
            isParentColumnVisible: function(columnIndex) {
              var result2 = true;
              var bandColumnsCache = this.getBandColumnsCache();
              var bandColumns = columnIndex >= 0 && getParentBandColumns(columnIndex, bandColumnsCache.columnParentByIndex);
              bandColumns && each(bandColumns, function(_2, bandColumn) {
                result2 = result2 && bandColumn.visible;
                return result2;
              });
              return result2;
            },
            getColumnId: function(column) {
              if (column.command && column.type === GROUP_COMMAND_COLUMN_NAME) {
                if (isCustomCommandColumn(this, column)) {
                  return "type:" + column.type;
                }
                return "command:" + column.command;
              }
              return column.index;
            },
            getCustomizeTextByDataType,
            getHeaderContentAlignment: function(columnAlignment) {
              var rtlEnabled = this.option("rtlEnabled");
              if (rtlEnabled) {
                return "left" === columnAlignment ? "right" : "left";
              }
              return columnAlignment;
            }
          };
        }())
      }
    };
  }
});

// node_modules/devextreme/esm/ui/grid_core/ui.grid_core.data_source_adapter.js
var ui_grid_core_data_source_adapter_default;
var init_ui_grid_core_data_source_adapter = __esm({
  "node_modules/devextreme/esm/ui/grid_core/ui.grid_core.data_source_adapter.js"() {
    init_callbacks();
    init_ui_data_grid_core();
    init_common();
    init_type();
    init_iterator();
    init_extend();
    init_array_store();
    init_array_utils();
    init_deferred();
    ui_grid_core_data_source_adapter_default = ui_data_grid_core_default.Controller.inherit(/* @__PURE__ */ function() {
      function cloneItems(items, groupCount) {
        if (items) {
          items = items.slice(0);
          if (groupCount) {
            for (var i = 0; i < items.length; i++) {
              items[i] = extend2({
                key: items[i].key
              }, items[i]);
              items[i].items = cloneItems(items[i].items, groupCount - 1);
            }
          }
        }
        return items;
      }
      function calculateOperationTypes(loadOptions, lastLoadOptions, isFullReload) {
        var operationTypes = {
          reload: true,
          fullReload: true
        };
        if (lastLoadOptions) {
          operationTypes = {
            sorting: !ui_data_grid_core_default.equalSortParameters(loadOptions.sort, lastLoadOptions.sort),
            grouping: !ui_data_grid_core_default.equalSortParameters(loadOptions.group, lastLoadOptions.group, true),
            groupExpanding: !ui_data_grid_core_default.equalSortParameters(loadOptions.group, lastLoadOptions.group) || lastLoadOptions.groupExpand,
            filtering: !ui_data_grid_core_default.equalFilterParameters(loadOptions.filter, lastLoadOptions.filter),
            pageIndex: loadOptions.pageIndex !== lastLoadOptions.pageIndex,
            skip: loadOptions.skip !== lastLoadOptions.skip,
            take: loadOptions.take !== lastLoadOptions.take,
            pageSize: loadOptions.pageSize !== lastLoadOptions.pageSize,
            fullReload: isFullReload
          };
          operationTypes.reload = isFullReload || operationTypes.sorting || operationTypes.grouping || operationTypes.filtering;
          operationTypes.paging = operationTypes.pageIndex || operationTypes.pageSize || operationTypes.take;
        }
        return operationTypes;
      }
      function getPageKey(pageIndex, loadPageCount) {
        return isDefined(loadPageCount) ? "".concat(pageIndex, ":").concat(loadPageCount) : pageIndex;
      }
      function getPageDataFromCache(options2) {
        var key = getPageKey(options2.pageIndex, options2.loadPageCount);
        return options2.cachedPagesData.pages[key];
      }
      return {
        init: function(dataSource, remoteOperations) {
          var that = this;
          that._dataSource = dataSource;
          that._remoteOperations = remoteOperations || {};
          that._isLastPage = !dataSource.isLastPage();
          that._hasLastPage = false;
          that._currentTotalCount = 0;
          that._cachedPagesData = {
            pages: {}
          };
          that._lastOperationTypes = {};
          that._eventsStrategy = dataSource._eventsStrategy;
          that._skipCorrection = 0;
          that._isLoadingAll = false;
          that.changed = callbacks_default();
          that.loadingChanged = callbacks_default();
          that.loadError = callbacks_default();
          that.customizeStoreLoadOptions = callbacks_default();
          that.changing = callbacks_default();
          that.pushed = callbacks_default();
          that._dataChangedHandler = that._handleDataChanged.bind(that);
          that._dataLoadingHandler = that._handleDataLoading.bind(that);
          that._dataLoadedHandler = that._handleDataLoaded.bind(that);
          that._loadingChangedHandler = that._handleLoadingChanged.bind(that);
          that._loadErrorHandler = that._handleLoadError.bind(that);
          that._pushHandler = that._handlePush.bind(that);
          that._changingHandler = that._handleChanging.bind(that);
          dataSource.on("changed", that._dataChangedHandler);
          dataSource.on("customizeStoreLoadOptions", that._dataLoadingHandler);
          dataSource.on("customizeLoadResult", that._dataLoadedHandler);
          dataSource.on("loadingChanged", that._loadingChangedHandler);
          dataSource.on("loadError", that._loadErrorHandler);
          dataSource.on("changing", that._changingHandler);
          dataSource.store().on("push", that._pushHandler);
          each(dataSource, function(memberName, member) {
            if (!that[memberName] && isFunction(member)) {
              that[memberName] = function() {
                return this._dataSource[memberName].apply(this._dataSource, arguments);
              };
            }
          });
        },
        remoteOperations: function() {
          return this._remoteOperations;
        },
        dispose: function(isSharedDataSource) {
          var dataSource = this._dataSource;
          var store = dataSource.store();
          dataSource.off("changed", this._dataChangedHandler);
          dataSource.off("customizeStoreLoadOptions", this._dataLoadingHandler);
          dataSource.off("customizeLoadResult", this._dataLoadedHandler);
          dataSource.off("loadingChanged", this._loadingChangedHandler);
          dataSource.off("loadError", this._loadErrorHandler);
          dataSource.off("changing", this._changingHandler);
          store && store.off("push", this._pushHandler);
          if (!isSharedDataSource) {
            dataSource.dispose();
          }
        },
        refresh: function(options2, operationTypes) {
          var dataSource = this._dataSource;
          if (operationTypes.reload) {
            this.resetCurrentTotalCount();
            this._isLastPage = !dataSource.paginate();
            this._hasLastPage = this._isLastPage;
          }
        },
        resetCurrentTotalCount: function() {
          this._currentTotalCount = 0;
          this._skipCorrection = 0;
        },
        resetCache: function() {
          this._cachedStoreData = void 0;
          this._cachedPagingData = void 0;
        },
        resetPagesCache: function() {
          this._cachedPagesData = {
            pages: {}
          };
        },
        _needClearStoreDataCache: function() {
          var remoteOperations = this.remoteOperations();
          var operationTypes = calculateOperationTypes(this._lastLoadOptions || {}, {});
          var isLocalOperations = Object.keys(remoteOperations).every((operationName) => !operationTypes[operationName] || !remoteOperations[operationName]);
          return !isLocalOperations;
        },
        push: function(changes, fromStore) {
          var store = this.store();
          if (this._needClearStoreDataCache()) {
            this._cachedStoreData = void 0;
          }
          this._cachedPagingData = void 0;
          this.resetPagesCache(true);
          if (this._cachedStoreData) {
            applyBatch({
              keyInfo: store,
              data: this._cachedStoreData,
              changes
            });
          }
          if (!fromStore) {
            this._applyBatch(changes);
          }
          this.pushed.fire(changes);
        },
        getDataIndexGetter: function() {
          if (!this._dataIndexGetter) {
            var indexByKey2;
            var storeData;
            var store = this.store();
            this._dataIndexGetter = (data2) => {
              var isCacheUpdated = storeData && storeData !== this._cachedStoreData;
              if (!indexByKey2 || isCacheUpdated) {
                storeData = this._cachedStoreData || [];
                indexByKey2 = {};
                for (var i = 0; i < storeData.length; i++) {
                  indexByKey2[getKeyHash(store.keyOf(storeData[i]))] = i;
                }
              }
              return indexByKey2[getKeyHash(store.keyOf(data2))];
            };
          }
          return this._dataIndexGetter;
        },
        _getKeyInfo: function() {
          return this.store();
        },
        _applyBatch: function(changes) {
          var keyInfo = this._getKeyInfo();
          var dataSource = this._dataSource;
          var groupCount = ui_data_grid_core_default.normalizeSortingInfo(this.group()).length;
          var totalCount = this.totalCount();
          var isReshapeMode = "reshape" === this.option("editing.refreshMode");
          var isVirtualMode2 = "virtual" === this.option("scrolling.mode");
          changes = changes.filter(function(change) {
            return !dataSource.paginate() || "insert" !== change.type || void 0 !== change.index;
          });
          var getItemCount = () => groupCount ? this.itemsCount() : this._items.length;
          var oldItemCount = getItemCount();
          applyBatch({
            keyInfo,
            data: this._items,
            changes,
            groupCount,
            useInsertIndex: true
          });
          applyBatch({
            keyInfo,
            data: dataSource.items(),
            changes,
            groupCount,
            useInsertIndex: true
          });
          if (this._currentTotalCount > 0 || !isReshapeMode && isVirtualMode2 && totalCount === oldItemCount) {
            this._skipCorrection += getItemCount() - oldItemCount;
          }
          changes.splice(0, changes.length);
        },
        _handlePush: function(changes) {
          this.push(changes, true);
        },
        _handleChanging: function(e) {
          this.changing.fire(e);
          this._applyBatch(e.changes);
        },
        _needCleanCacheByOperation: function(operationType, remoteOperations) {
          var operationTypesByOrder = ["filtering", "sorting", "paging"];
          var operationTypeIndex = operationTypesByOrder.indexOf(operationType);
          var currentOperationTypes = operationTypeIndex >= 0 ? operationTypesByOrder.slice(operationTypeIndex) : [operationType];
          return currentOperationTypes.some((operationType2) => remoteOperations[operationType2]);
        },
        _customizeRemoteOperations: function(options2, operationTypes) {
          var that = this;
          var cachedStoreData = that._cachedStoreData;
          var cachedPagingData = that._cachedPagingData;
          var cachedPagesData = that._cachedPagesData;
          if (options2.storeLoadOptions.filter && !options2.remoteOperations.filtering || options2.storeLoadOptions.sort && !options2.remoteOperations.sorting) {
            options2.remoteOperations = {
              filtering: options2.remoteOperations.filtering
            };
          }
          if (operationTypes.fullReload) {
            cachedStoreData = void 0;
            cachedPagingData = void 0;
            cachedPagesData = {
              pages: {}
            };
          } else {
            if (operationTypes.reload) {
              cachedPagingData = void 0;
              cachedPagesData = {
                pages: {}
              };
            } else if (operationTypes.pageSize || operationTypes.groupExpanding) {
              cachedPagesData = {
                pages: {}
              };
            }
            each(operationTypes, function(operationType, value2) {
              if (value2 && that._needCleanCacheByOperation(operationType, options2.remoteOperations)) {
                cachedStoreData = void 0;
                cachedPagingData = void 0;
              }
            });
          }
          if (cachedPagingData) {
            options2.remoteOperations.paging = false;
          }
          options2.cachedStoreData = cachedStoreData;
          options2.cachedPagingData = cachedPagingData;
          options2.cachedPagesData = cachedPagesData;
          if (!options2.isCustomLoading) {
            that._cachedStoreData = cachedStoreData;
            that._cachedPagingData = cachedPagingData;
            that._cachedPagesData = cachedPagesData;
          }
        },
        _handleDataLoading: function(options2) {
          var dataSource = this._dataSource;
          var lastLoadOptions = this._lastLoadOptions;
          this.customizeStoreLoadOptions.fire(options2);
          options2.delay = this.option("loadingTimeout");
          options2.originalStoreLoadOptions = options2.storeLoadOptions;
          options2.remoteOperations = extend2({}, this.remoteOperations());
          var isFullReload = !this.isLoaded() && !this._isRefreshing;
          if (this.option("integrationOptions.renderedOnServer") && !this.isLoaded()) {
            options2.delay = void 0;
          }
          var loadOptions = extend2({
            pageIndex: this.pageIndex(),
            pageSize: this.pageSize()
          }, options2.storeLoadOptions);
          var operationTypes = calculateOperationTypes(loadOptions, lastLoadOptions, isFullReload);
          this._customizeRemoteOperations(options2, operationTypes);
          if (!options2.isCustomLoading) {
            var isRefreshing = this._isRefreshing;
            options2.pageIndex = dataSource.pageIndex();
            options2.lastLoadOptions = loadOptions;
            options2.operationTypes = operationTypes;
            this._loadingOperationTypes = operationTypes;
            this._isRefreshing = true;
            when(isRefreshing || this._isRefreshed || this.refresh(options2, operationTypes)).done(() => {
              if (this._lastOperationId === options2.operationId) {
                this._isRefreshed = true;
                this.load().always(() => {
                  this._isRefreshed = false;
                });
              }
            }).fail(() => {
              dataSource.cancel(options2.operationId);
            }).always(() => {
              this._isRefreshing = false;
            });
            dataSource.cancel(this._lastOperationId);
            this._lastOperationId = options2.operationId;
            if (this._isRefreshing) {
              dataSource.cancel(this._lastOperationId);
            }
          }
          this._handleDataLoadingCore(options2);
        },
        _handleDataLoadingCore: function(options2) {
          var _options$data;
          var remoteOperations = options2.remoteOperations;
          options2.loadOptions = {};
          var cachedExtra = options2.cachedPagesData.extra;
          var localLoadOptionNames = {
            filter: !remoteOperations.filtering,
            sort: !remoteOperations.sorting,
            group: !remoteOperations.grouping,
            summary: !remoteOperations.summary,
            skip: !remoteOperations.paging,
            take: !remoteOperations.paging,
            requireTotalCount: cachedExtra && "totalCount" in cachedExtra || !remoteOperations.paging
          };
          each(options2.storeLoadOptions, function(optionName, optionValue) {
            if (localLoadOptionNames[optionName]) {
              options2.loadOptions[optionName] = optionValue;
              delete options2.storeLoadOptions[optionName];
            }
          });
          if (cachedExtra) {
            options2.extra = cachedExtra;
          }
          if (!(0 === (null === (_options$data = options2.data) || void 0 === _options$data ? void 0 : _options$data.length))) {
            options2.data = getPageDataFromCache(options2) || options2.cachedStoreData;
          }
        },
        _handleDataLoaded: function(options2) {
          var loadOptions = options2.loadOptions;
          var localPaging = options2.remoteOperations && !options2.remoteOperations.paging;
          var cachedPagesData = options2.cachedPagesData;
          var storeLoadOptions = options2.storeLoadOptions;
          var needCache = false !== this.option("cacheEnabled") && storeLoadOptions;
          var needPageCache = needCache && !options2.isCustomLoading && cachedPagesData && (!localPaging || storeLoadOptions.group);
          var needPagingCache = needCache && localPaging;
          var needStoreCache = needPagingCache && !options2.isCustomLoading;
          if (!loadOptions) {
            this._dataSource.cancel(options2.operationId);
            return;
          }
          if (options2.lastLoadOptions) {
            this._lastLoadOptions = options2.lastLoadOptions;
            Object.keys(options2.operationTypes).forEach((operationType) => {
              this._lastOperationTypes[operationType] = this._lastOperationTypes[operationType] || options2.operationTypes[operationType];
            });
          }
          if (localPaging) {
            options2.skip = loadOptions.skip;
            options2.take = loadOptions.take;
            delete loadOptions.skip;
            delete loadOptions.take;
          }
          if (loadOptions.group) {
            loadOptions.group = options2.group || loadOptions.group;
          }
          var groupCount = ui_data_grid_core_default.normalizeSortingInfo(storeLoadOptions.group || loadOptions.group).length;
          if (!needPageCache || !getPageDataFromCache(options2)) {
            if (needPagingCache && options2.cachedPagingData) {
              options2.data = cloneItems(options2.cachedPagingData, groupCount);
            } else {
              if (needStoreCache) {
                if (!this._cachedStoreData) {
                  this._cachedStoreData = cloneItems(options2.data, ui_data_grid_core_default.normalizeSortingInfo(storeLoadOptions.group).length);
                } else if (options2.mergeStoreLoadData) {
                  options2.data = this._cachedStoreData = this._cachedStoreData.concat(options2.data);
                }
              }
              new array_store_default(options2.data).load(loadOptions).done((data2) => {
                options2.data = data2;
                if (needStoreCache) {
                  this._cachedPagingData = cloneItems(options2.data, groupCount);
                }
              }).fail((error) => {
                options2.data = new Deferred().reject(error);
              });
            }
            if (loadOptions.requireTotalCount && localPaging) {
              options2.extra = isPlainObject(options2.extra) ? options2.extra : {};
              options2.extra.totalCount = options2.data.length;
            }
            if (options2.extra && options2.extra.totalCount >= 0 && (false === storeLoadOptions.requireTotalCount || false === loadOptions.requireTotalCount)) {
              options2.extra.totalCount = -1;
            }
            this._handleDataLoadedCore(options2);
            if (needPageCache) {
              cachedPagesData.extra = cachedPagesData.extra || extend2({}, options2.extra);
              when(options2.data).done((data2) => {
                !function(options3, data3) {
                  var pageIndex = options3.pageIndex;
                  if (void 0 !== pageIndex) {
                    var key = getPageKey(pageIndex, options3.loadPageCount);
                    options3.cachedPagesData.pages[key] = data3;
                  }
                }(options2, cloneItems(data2, groupCount));
              });
            }
          }
          options2.storeLoadOptions = options2.originalStoreLoadOptions;
        },
        _handleDataLoadedCore: function(options2) {
          if (options2.remoteOperations && !options2.remoteOperations.paging && Array.isArray(options2.data)) {
            if (void 0 !== options2.skip) {
              options2.data = options2.data.slice(options2.skip);
            }
            if (void 0 !== options2.take) {
              options2.data = options2.data.slice(0, options2.take);
            }
          }
        },
        _handleLoadingChanged: function(isLoading) {
          this.loadingChanged.fire(isLoading);
        },
        _handleLoadError: function(error) {
          this.loadError.fire(error);
          this.changed.fire({
            changeType: "loadError",
            error
          });
        },
        _loadPageSize: function() {
          return this.pageSize();
        },
        _handleDataChanged: function(args) {
          var currentTotalCount;
          var dataSource = this._dataSource;
          var isLoading = false;
          var isDataLoading = !args || isDefined(args.changeType);
          var itemsCount = this.itemsCount();
          if (isDataLoading) {
            this._isLastPage = !itemsCount || !this._loadPageSize() || itemsCount < this._loadPageSize();
            if (this._isLastPage) {
              this._hasLastPage = true;
            }
          }
          if (dataSource.totalCount() >= 0) {
            if (dataSource.pageIndex() >= this.pageCount()) {
              dataSource.pageIndex(this.pageCount() - 1);
              this.pageIndex(dataSource.pageIndex());
              this.resetPagesCache();
              dataSource.load();
              isLoading = true;
            }
          } else if (isDataLoading) {
            currentTotalCount = dataSource.pageIndex() * this.pageSize() + itemsCount;
            if (currentTotalCount > this._currentTotalCount) {
              this._currentTotalCount = currentTotalCount;
              if (0 === dataSource.pageIndex()) {
                this._skipCorrection = 0;
              }
            }
            if (0 === itemsCount && dataSource.pageIndex() >= this.pageCount()) {
              dataSource.pageIndex(this.pageCount() - 1);
              if ("infinite" !== this.option("scrolling.mode")) {
                dataSource.load();
                isLoading = true;
              }
            }
          }
          if (!isLoading) {
            this._operationTypes = this._lastOperationTypes;
            this._lastOperationTypes = {};
            this.component._optionCache = {};
            this.changed.fire(args);
            this.component._optionCache = void 0;
          }
        },
        _scheduleCustomLoadCallbacks: function(deferred) {
          var that = this;
          that._isCustomLoading = true;
          deferred.always(function() {
            that._isCustomLoading = false;
          });
        },
        loadingOperationTypes: function() {
          return this._loadingOperationTypes;
        },
        operationTypes: function() {
          return this._operationTypes;
        },
        lastLoadOptions: function() {
          return this._lastLoadOptions || {};
        },
        isLastPage: function() {
          return this._isLastPage;
        },
        totalCount: function() {
          return parseInt((this._currentTotalCount || this._dataSource.totalCount()) + this._skipCorrection);
        },
        itemsCount: function() {
          return this._dataSource.items().length;
        },
        totalItemsCount: function() {
          return this.totalCount();
        },
        pageSize: function() {
          var dataSource = this._dataSource;
          if (!arguments.length && !dataSource.paginate()) {
            return 0;
          }
          return dataSource.pageSize.apply(dataSource, arguments);
        },
        pageCount: function() {
          var count = this.totalItemsCount() - this._skipCorrection;
          var pageSize = this.pageSize();
          if (pageSize && count > 0) {
            return Math.max(1, Math.ceil(count / pageSize));
          }
          return 1;
        },
        hasKnownLastPage: function() {
          return this._hasLastPage || this._dataSource.totalCount() >= 0;
        },
        loadFromStore: function(loadOptions, store) {
          var dataSource = this._dataSource;
          var d = new Deferred();
          if (!dataSource) {
            return;
          }
          store = store || dataSource.store();
          store.load(loadOptions).done(function(data2, extra) {
            if (data2 && !Array.isArray(data2) && Array.isArray(data2.data)) {
              extra = data2;
              data2 = data2.data;
            }
            d.resolve(data2, extra);
          }).fail(d.reject);
          return d;
        },
        isCustomLoading: function() {
          return !!this._isCustomLoading;
        },
        load: function(options2) {
          var that = this;
          var dataSource = that._dataSource;
          var d = new Deferred();
          if (options2) {
            var store = dataSource.store();
            var dataSourceLoadOptions = dataSource.loadOptions();
            var loadResult = {
              storeLoadOptions: options2,
              isCustomLoading: true
            };
            each(store._customLoadOptions() || [], function(_2, optionName) {
              if (!(optionName in loadResult.storeLoadOptions)) {
                loadResult.storeLoadOptions[optionName] = dataSourceLoadOptions[optionName];
              }
            });
            this._isLoadingAll = options2.isLoadingAll;
            that._scheduleCustomLoadCallbacks(d);
            dataSource._scheduleLoadCallbacks(d);
            that._handleDataLoading(loadResult);
            !function(action, timeout) {
              if (isDefined(timeout)) {
                executeAsync(action, timeout);
              } else {
                action();
              }
            }(function() {
              if (!dataSource.store()) {
                return d.reject("canceled");
              }
              when(loadResult.data || that.loadFromStore(loadResult.storeLoadOptions)).done(function(data2, extra) {
                loadResult.data = data2;
                loadResult.extra = extra || {};
                that._handleDataLoaded(loadResult);
                if (options2.requireTotalCount && void 0 === loadResult.extra.totalCount) {
                  loadResult.extra.totalCount = store.totalCount(loadResult.storeLoadOptions);
                }
                when(loadResult.data, loadResult.extra.totalCount).done(function(data3, totalCount) {
                  loadResult.extra.totalCount = totalCount;
                  d.resolve(data3, loadResult.extra);
                }).fail(d.reject);
              }).fail(d.reject);
            }, that.option("loadingTimeout"));
            return d.fail(function() {
              that._eventsStrategy.fireEvent("loadError", arguments);
            }).always(() => {
              this._isLoadingAll = false;
            }).promise();
          } else {
            return dataSource.load();
          }
        },
        reload: function(full) {
          return full ? this._dataSource.reload() : this._dataSource.load();
        },
        getCachedStoreData: function() {
          return this._cachedStoreData;
        }
      };
    }());
  }
});

// node_modules/devextreme/esm/ui/grid_core/ui.grid_core.data_controller.js
var dataControllerModule;
var init_ui_grid_core_data_controller = __esm({
  "node_modules/devextreme/esm/ui/grid_core/ui.grid_core.data_controller.js"() {
    init_renderer();
    init_ui_grid_core_modules();
    init_ui_grid_core_utils();
    init_array_store();
    init_custom_store();
    init_ui_errors();
    init_common();
    init_iterator();
    init_type();
    init_extend();
    init_data_helper();
    init_deferred();
    init_array_compare();
    dataControllerModule = {
      defaultOptions: function() {
        return {
          loadingTimeout: 0,
          dataSource: null,
          cacheEnabled: true,
          repaintChangesOnly: false,
          highlightChanges: false,
          onDataErrorOccurred: null,
          remoteOperations: "auto",
          paging: {
            enabled: true,
            pageSize: void 0,
            pageIndex: void 0
          }
        };
      },
      controllers: {
        data: ui_grid_core_modules_default.Controller.inherit({}).include(data_helper_default).inherit(function() {
          var changePaging = function(that, optionName, value2) {
            var dataSource = that._dataSource;
            if (dataSource) {
              if (void 0 !== value2) {
                if (dataSource[optionName]() !== value2) {
                  if ("pageSize" === optionName) {
                    dataSource.pageIndex(0);
                  }
                  dataSource[optionName](value2);
                  that._skipProcessingPagingChange = true;
                  that.option("paging." + optionName, value2);
                  that._skipProcessingPagingChange = false;
                  return dataSource["pageIndex" === optionName ? "load" : "reload"]().done(that.pageChanged.fire.bind(that.pageChanged));
                }
                return Deferred().resolve().promise();
              }
              return dataSource[optionName]();
            }
            return 0;
          };
          var members = {
            init: function() {
              var that = this;
              that._items = [];
              that._columnsController = that.getController("columns");
              that._currentOperationTypes = null;
              that._dataChangedHandler = (e) => {
                that._currentOperationTypes = this._dataSource.operationTypes();
                that._handleDataChanged(e);
                that._currentOperationTypes = null;
              };
              that._columnsChangedHandler = that._handleColumnsChanged.bind(that);
              that._loadingChangedHandler = that._handleLoadingChanged.bind(that);
              that._loadErrorHandler = that._handleLoadError.bind(that);
              that._customizeStoreLoadOptionsHandler = that._handleCustomizeStoreLoadOptions.bind(that);
              that._changingHandler = that._handleChanging.bind(that);
              that._dataPushedHandler = that._handleDataPushed.bind(that);
              that._columnsController.columnsChanged.add(that._columnsChangedHandler);
              that._isLoading = false;
              that._isCustomLoading = false;
              that._repaintChangesOnly = void 0;
              that._changes = [];
              that.createAction("onDataErrorOccurred");
              that.dataErrorOccurred.add(function(error) {
                return that.executeAction("onDataErrorOccurred", {
                  error
                });
              });
              that._refreshDataSource();
            },
            callbackNames: function() {
              return ["changed", "loadingChanged", "dataErrorOccurred", "pageChanged", "dataSourceChanged", "pushed"];
            },
            callbackFlags: function(name2) {
              if ("dataErrorOccurred" === name2) {
                return {
                  stopOnFalse: true
                };
              }
            },
            publicMethods: function() {
              return ["beginCustomLoading", "endCustomLoading", "refresh", "filter", "clearFilter", "getCombinedFilter", "keyOf", "byKey", "getDataByKeys", "pageIndex", "pageSize", "pageCount", "totalCount", "_disposeDataSource", "getKeyByRowIndex", "getRowIndexByKey", "getDataSource", "getVisibleRows", "repaintRows"];
            },
            reset: function() {
              this._columnsController.reset();
              this._items = [];
              this._refreshDataSource();
            },
            optionChanged: function(args) {
              var dataSource;
              function handled() {
                args.handled = true;
              }
              if ("dataSource" === args.name && args.name === args.fullName && (args.value === args.previousValue || this.option("columns") && Array.isArray(args.value) && Array.isArray(args.previousValue))) {
                if (args.value !== args.previousValue) {
                  var store = this.store();
                  if (store) {
                    store._array = args.value;
                  }
                }
                handled();
                this.refresh(this.option("repaintChangesOnly"));
                return;
              }
              switch (args.name) {
                case "cacheEnabled":
                case "repaintChangesOnly":
                case "highlightChanges":
                case "loadingTimeout":
                  handled();
                  break;
                case "remoteOperations":
                case "keyExpr":
                case "dataSource":
                case "scrolling":
                  handled();
                  this.reset();
                  break;
                case "paging":
                  dataSource = this.dataSource();
                  if (dataSource && this._setPagingOptions(dataSource)) {
                    dataSource.load().done(this.pageChanged.fire.bind(this.pageChanged));
                  }
                  handled();
                  break;
                case "rtlEnabled":
                  this.reset();
                  break;
                case "columns":
                  dataSource = this.dataSource();
                  if (dataSource && dataSource.isLoading() && args.name === args.fullName) {
                    this._useSortingGroupingFromColumns = true;
                    dataSource.load();
                  }
                  break;
                default:
                  this.callBase(args);
              }
            },
            isReady: function() {
              return !this._isLoading;
            },
            getDataSource: function() {
              return this._dataSource && this._dataSource._dataSource;
            },
            getCombinedFilter: function(returnDataField) {
              return this.combinedFilter(void 0, returnDataField);
            },
            combinedFilter: function(filter, returnDataField) {
              var dataSource = this._dataSource;
              var columnsController = this._columnsController;
              if (dataSource) {
                if (void 0 === filter) {
                  filter = dataSource.filter();
                }
                var additionalFilter = this._calculateAdditionalFilter();
                if (additionalFilter) {
                  if (columnsController.isDataSourceApplied() || columnsController.isAllDataTypesDefined()) {
                    filter = ui_grid_core_utils_default.combineFilters([additionalFilter, filter]);
                  }
                }
                filter = columnsController.updateFilter(filter, returnDataField || dataSource.remoteOperations().filtering);
              }
              return filter;
            },
            waitReady: function() {
              if (this._updateLockCount) {
                this._readyDeferred = new Deferred();
                return this._readyDeferred;
              }
              return when();
            },
            _endUpdateCore: function() {
              var changes = this._changes;
              if (changes.length) {
                this._changes = [];
                var repaintChangesOnly = changes.every((change) => change.repaintChangesOnly);
                this.updateItems(1 === changes.length ? changes[0] : {
                  repaintChangesOnly
                });
              }
              if (this._readyDeferred) {
                this._readyDeferred.resolve();
                this._readyDeferred = null;
              }
            },
            _handleCustomizeStoreLoadOptions: function(e) {
              var _storeLoadOptions$fil;
              var columnsController = this._columnsController;
              var dataSource = this._dataSource;
              var storeLoadOptions = e.storeLoadOptions;
              if (e.isCustomLoading && !storeLoadOptions.isLoadingAll) {
                return;
              }
              storeLoadOptions.filter = this.combinedFilter(storeLoadOptions.filter);
              if (1 === (null === (_storeLoadOptions$fil = storeLoadOptions.filter) || void 0 === _storeLoadOptions$fil ? void 0 : _storeLoadOptions$fil.length) && "!" === storeLoadOptions.filter[0]) {
                e.data = [];
                e.extra = e.extra || {};
                e.extra.totalCount = 0;
              }
              if (!columnsController.isDataSourceApplied()) {
                columnsController.updateColumnDataTypes(dataSource);
              }
              this._columnsUpdating = true;
              columnsController.updateSortingGrouping(dataSource, !this._useSortingGroupingFromColumns);
              this._columnsUpdating = false;
              storeLoadOptions.sort = columnsController.getSortDataSourceParameters();
              storeLoadOptions.group = columnsController.getGroupDataSourceParameters();
              dataSource.sort(storeLoadOptions.sort);
              dataSource.group(storeLoadOptions.group);
              storeLoadOptions.sort = columnsController.getSortDataSourceParameters(!dataSource.remoteOperations().sorting);
              e.group = columnsController.getGroupDataSourceParameters(!dataSource.remoteOperations().grouping);
            },
            _handleColumnsChanged: function(e) {
              var that = this;
              var changeTypes = e.changeTypes;
              var optionNames = e.optionNames;
              var filterValue;
              var filterValues;
              var filterApplied;
              if (changeTypes.sorting || changeTypes.grouping) {
                if (that._dataSource && !that._columnsUpdating) {
                  that._dataSource.group(that._columnsController.getGroupDataSourceParameters());
                  that._dataSource.sort(that._columnsController.getSortDataSourceParameters());
                  that.reload();
                }
              } else if (changeTypes.columns) {
                if (optionNames.filterValues || optionNames.filterValue || optionNames.selectedFilterOperation) {
                  filterValue = that._columnsController.columnOption(e.columnIndex, "filterValue");
                  filterValues = that._columnsController.columnOption(e.columnIndex, "filterValues");
                  if (Array.isArray(filterValues) || void 0 === e.columnIndex || isDefined(filterValue) || !optionNames.selectedFilterOperation || optionNames.filterValue) {
                    that._applyFilter();
                    filterApplied = true;
                  }
                }
                if (!that._needApplyFilter && !ui_grid_core_utils_default.checkChanges(optionNames, ["width", "visibleWidth", "filterValue", "bufferedFilterValue", "selectedFilterOperation", "filterValues", "filterType"])) {
                  that._columnsController.columnsChanged.add(function updateItemsHandler(change) {
                    var _change$changeTypes;
                    that._columnsController.columnsChanged.remove(updateItemsHandler);
                    that.updateItems(null !== change && void 0 !== change && null !== (_change$changeTypes = change.changeTypes) && void 0 !== _change$changeTypes && _change$changeTypes.virtualColumnsScrolling ? {
                      virtualColumnsScrolling: true
                    } : {});
                  });
                }
                if (isDefined(optionNames.visible)) {
                  var column = that._columnsController.columnOption(e.columnIndex);
                  if (column && (isDefined(column.filterValue) || isDefined(column.filterValues))) {
                    that._applyFilter();
                    filterApplied = true;
                  }
                }
              }
              if (!filterApplied && changeTypes.filtering) {
                that.reload();
              }
            },
            _handleDataChanged: function(e) {
              var that = this;
              var dataSource = that._dataSource;
              var columnsController = that._columnsController;
              var isAsyncDataSourceApplying = false;
              this._useSortingGroupingFromColumns = false;
              if (dataSource && !that._isDataSourceApplying) {
                that._isDataSourceApplying = true;
                when(that._columnsController.applyDataSource(dataSource)).done(function() {
                  if (that._isLoading) {
                    that._handleLoadingChanged(false);
                  }
                  if (isAsyncDataSourceApplying && e && e.isDelayed) {
                    e.isDelayed = false;
                  }
                  that._isDataSourceApplying = false;
                  var needApplyFilter = that._needApplyFilter;
                  that._needApplyFilter = false;
                  if (needApplyFilter && !that._isAllDataTypesDefined && (additionalFilter = that._calculateAdditionalFilter(), additionalFilter && additionalFilter.length)) {
                    ui_errors_default.log("W1005", that.component.NAME);
                    that._applyFilter();
                  } else {
                    that.updateItems(e, true);
                  }
                  var additionalFilter;
                }).fail(function() {
                  that._isDataSourceApplying = false;
                });
                if (that._isDataSourceApplying) {
                  isAsyncDataSourceApplying = true;
                  that._handleLoadingChanged(true);
                }
                that._needApplyFilter = !that._columnsController.isDataSourceApplied();
                that._isAllDataTypesDefined = columnsController.isAllDataTypesDefined();
              }
            },
            _handleLoadingChanged: function(isLoading) {
              this._isLoading = isLoading;
              this._fireLoadingChanged();
            },
            _handleLoadError: function(e) {
              this.dataErrorOccurred.fire(e);
            },
            _handleDataPushed: function(changes) {
              this.pushed.fire(changes);
            },
            fireError: function() {
              this.dataErrorOccurred.fire(ui_errors_default.Error.apply(ui_errors_default, arguments));
            },
            _setPagingOptions: function(dataSource) {
              var pageIndex = this.option("paging.pageIndex");
              var pageSize = this.option("paging.pageSize");
              var pagingEnabled = this.option("paging.enabled");
              var scrollingMode = this.option("scrolling.mode");
              var appendMode = "infinite" === scrollingMode;
              var virtualMode = "virtual" === scrollingMode;
              var paginate = pagingEnabled || virtualMode || appendMode;
              var isChanged = false;
              dataSource.requireTotalCount(!appendMode);
              if (void 0 !== pagingEnabled && dataSource.paginate() !== paginate) {
                dataSource.paginate(paginate);
                isChanged = true;
              }
              if (void 0 !== pageSize && dataSource.pageSize() !== pageSize) {
                dataSource.pageSize(pageSize);
                isChanged = true;
              }
              if (void 0 !== pageIndex && dataSource.pageIndex() !== pageIndex) {
                dataSource.pageIndex(pageIndex);
                isChanged = true;
              }
              return isChanged;
            },
            _getSpecificDataSourceOption: function() {
              var dataSource = this.option("dataSource");
              if (Array.isArray(dataSource)) {
                return {
                  store: {
                    type: "array",
                    data: dataSource,
                    key: this.option("keyExpr")
                  }
                };
              }
              return dataSource;
            },
            _initDataSource: function() {
              var dataSource = this.option("dataSource");
              var oldDataSource = this._dataSource;
              this.callBase();
              dataSource = this._dataSource;
              this._useSortingGroupingFromColumns = true;
              if (dataSource) {
                this._setPagingOptions(dataSource);
                this.setDataSource(dataSource);
              } else if (oldDataSource) {
                this.updateItems();
              }
            },
            _loadDataSource: function() {
              var dataSource = this._dataSource;
              var result2 = new Deferred();
              when(this._columnsController.refresh(true)).always(function() {
                if (dataSource) {
                  dataSource.load().done(result2.resolve).fail(result2.reject);
                } else {
                  result2.resolve();
                }
              });
              return result2.promise();
            },
            _beforeProcessItems: function(items) {
              return items.slice(0);
            },
            getRowIndexDelta: function() {
              return 0;
            },
            _processItems: function(items, change) {
              var that = this;
              var rowIndexDelta = that.getRowIndexDelta();
              var changeType = change.changeType;
              var visibleColumns = that._columnsController.getVisibleColumns(null, "loadingAll" === changeType);
              var visibleItems = that._items;
              var lastVisibleItem = "append" === changeType && visibleItems.length > 0 ? visibleItems[visibleItems.length - 1] : null;
              var dataIndex = isDefined(null === lastVisibleItem || void 0 === lastVisibleItem ? void 0 : lastVisibleItem.dataIndex) ? lastVisibleItem.dataIndex + 1 : 0;
              var options2 = {
                visibleColumns,
                dataIndex
              };
              var result2 = [];
              each(items, function(index2, item) {
                if (isDefined(item)) {
                  options2.rowIndex = index2 - rowIndexDelta;
                  item = that._processItem(item, options2);
                  result2.push(item);
                }
              });
              return result2;
            },
            _processItem: function(item, options2) {
              item = this._generateDataItem(item, options2);
              item = this._processDataItem(item, options2);
              item.dataIndex = options2.dataIndex++;
              return item;
            },
            _generateDataItem: function(data2) {
              return {
                rowType: "data",
                data: data2,
                key: this.keyOf(data2)
              };
            },
            _processDataItem: function(dataItem, options2) {
              dataItem.values = this.generateDataValues(dataItem.data, options2.visibleColumns);
              return dataItem;
            },
            generateDataValues: function(data2, columns, isModified) {
              var values = [];
              var value2;
              for (var i = 0; i < columns.length; i++) {
                var column = columns[i];
                value2 = isModified ? void 0 : null;
                if (!column.command) {
                  if (column.calculateCellValue) {
                    value2 = column.calculateCellValue(data2);
                  } else if (column.dataField) {
                    value2 = data2[column.dataField];
                  }
                }
                values.push(value2);
              }
              return values;
            },
            _applyChange: function(change) {
              if ("update" === change.changeType) {
                this._applyChangeUpdate(change);
              } else if (this.items().length && change.repaintChangesOnly && "refresh" === change.changeType) {
                this._applyChangesOnly(change);
              } else if ("refresh" === change.changeType) {
                this._applyChangeFull(change);
              }
            },
            _applyChangeFull: function(change) {
              this._items = change.items.slice(0);
            },
            _getRowIndices: function(change) {
              var rowIndices = change.rowIndices.slice(0);
              var rowIndexDelta = this.getRowIndexDelta();
              rowIndices.sort(function(a, b) {
                return a - b;
              });
              for (var i = 0; i < rowIndices.length; i++) {
                var correctedRowIndex = rowIndices[i];
                if (change.allowInvisibleRowIndices) {
                  correctedRowIndex += rowIndexDelta;
                }
                if (correctedRowIndex < 0) {
                  rowIndices.splice(i, 1);
                  i--;
                }
              }
              return rowIndices;
            },
            _applyChangeUpdate: function(change) {
              var that = this;
              var items = change.items;
              var rowIndices = that._getRowIndices(change);
              var rowIndexDelta = that.getRowIndexDelta();
              var repaintChangesOnly = that.option("repaintChangesOnly");
              var prevIndex = -1;
              var rowIndexCorrection = 0;
              var changeType;
              change.items = [];
              change.rowIndices = [];
              change.columnIndices = [];
              change.changeTypes = [];
              var equalItems = function(item1, item2, strict) {
                var result2 = item1 && item2 && equalByValue(item1.key, item2.key);
                if (result2 && strict) {
                  result2 = item1.rowType === item2.rowType && ("detail" !== item2.rowType || item1.isEditing === item2.isEditing);
                }
                return result2;
              };
              each(rowIndices, function(index2, rowIndex) {
                var columnIndices;
                rowIndex += rowIndexCorrection + rowIndexDelta;
                if (prevIndex === rowIndex) {
                  return;
                }
                prevIndex = rowIndex;
                var oldItem = that._items[rowIndex];
                var oldNextItem = that._items[rowIndex + 1];
                var newItem = items[rowIndex];
                var newNextItem = items[rowIndex + 1];
                var strict = equalItems(oldItem, oldNextItem) || equalItems(newItem, newNextItem);
                if (newItem) {
                  newItem.rowIndex = rowIndex;
                  change.items.push(newItem);
                }
                if (oldItem && newItem && equalItems(oldItem, newItem, strict)) {
                  changeType = "update";
                  that._items[rowIndex] = newItem;
                  if (oldItem.visible !== newItem.visible) {
                    change.items.splice(-1, 1, {
                      visible: newItem.visible
                    });
                  } else if (repaintChangesOnly && !change.isFullUpdate) {
                    columnIndices = that._partialUpdateRow(oldItem, newItem, rowIndex - rowIndexDelta);
                  }
                } else if (newItem && !oldItem || newNextItem && equalItems(oldItem, newNextItem, strict)) {
                  changeType = "insert";
                  that._items.splice(rowIndex, 0, newItem);
                  rowIndexCorrection++;
                } else if (oldItem && !newItem || oldNextItem && equalItems(newItem, oldNextItem, strict)) {
                  changeType = "remove";
                  that._items.splice(rowIndex, 1);
                  rowIndexCorrection--;
                  prevIndex = -1;
                } else if (newItem) {
                  changeType = "update";
                  that._items[rowIndex] = newItem;
                } else {
                  return;
                }
                change.rowIndices.push(rowIndex - rowIndexDelta);
                change.changeTypes.push(changeType);
                change.columnIndices.push(columnIndices);
              });
            },
            _isCellChanged: function(oldRow, newRow, visibleRowIndex, columnIndex, isLiveUpdate) {
              if (JSON.stringify(oldRow.values[columnIndex]) !== JSON.stringify(newRow.values[columnIndex])) {
                return true;
              }
              function isCellModified(row, columnIndex2) {
                return row.modifiedValues ? void 0 !== row.modifiedValues[columnIndex2] : false;
              }
              if (isCellModified(oldRow, columnIndex) !== isCellModified(newRow, columnIndex)) {
                return true;
              }
              return false;
            },
            _getChangedColumnIndices: function(oldItem, newItem, visibleRowIndex, isLiveUpdate) {
              if (oldItem.rowType === newItem.rowType && "group" !== newItem.rowType && "groupFooter" !== newItem.rowType) {
                var columnIndices = [];
                if ("detail" !== newItem.rowType) {
                  for (var columnIndex = 0; columnIndex < oldItem.values.length; columnIndex++) {
                    if (this._isCellChanged(oldItem, newItem, visibleRowIndex, columnIndex, isLiveUpdate)) {
                      columnIndices.push(columnIndex);
                    }
                  }
                }
                return columnIndices;
              }
            },
            _partialUpdateRow: function(oldItem, newItem, visibleRowIndex, isLiveUpdate) {
              var changedColumnIndices = this._getChangedColumnIndices(oldItem, newItem, visibleRowIndex, isLiveUpdate);
              if (changedColumnIndices) {
                oldItem.cells && oldItem.cells.forEach(function(cell, columnIndex) {
                  var isCellChanged = changedColumnIndices.indexOf(columnIndex) >= 0;
                  if (!isCellChanged && cell && cell.update) {
                    cell.update(newItem);
                  }
                });
                newItem.update = oldItem.update;
                newItem.watch = oldItem.watch;
                newItem.cells = oldItem.cells;
                if (isLiveUpdate) {
                  newItem.oldValues = oldItem.values;
                }
                oldItem.update && oldItem.update(newItem);
              }
              return changedColumnIndices;
            },
            _isItemEquals: function(item1, item2) {
              if (JSON.stringify(item1.values) !== JSON.stringify(item2.values)) {
                return false;
              }
              if (["modified", "isNewRow", "removed", "isEditing"].some((field) => item1[field] !== item2[field])) {
                return false;
              }
              if ("group" === item1.rowType || "groupFooter" === item1.rowType) {
                var _item1$data, _item2$data, _item1$data2, _item2$data2;
                var expandedMatch = item1.isExpanded === item2.isExpanded;
                var summaryCellsMatch = JSON.stringify(item1.summaryCells) === JSON.stringify(item2.summaryCells);
                var continuationMatch = (null === (_item1$data = item1.data) || void 0 === _item1$data ? void 0 : _item1$data.isContinuation) === (null === (_item2$data = item2.data) || void 0 === _item2$data ? void 0 : _item2$data.isContinuation) && (null === (_item1$data2 = item1.data) || void 0 === _item1$data2 ? void 0 : _item1$data2.isContinuationOnNextPage) === (null === (_item2$data2 = item2.data) || void 0 === _item2$data2 ? void 0 : _item2$data2.isContinuationOnNextPage);
                if (!expandedMatch || !summaryCellsMatch || !continuationMatch) {
                  return false;
                }
              }
              return true;
            },
            _applyChangesOnly: function(change) {
              var _change$isLiveUpdate;
              var rowIndices = [];
              var columnIndices = [];
              var changeTypes = [];
              var items = [];
              var newIndexByKey = {};
              var isLiveUpdate = null !== (_change$isLiveUpdate = null === change || void 0 === change ? void 0 : change.isLiveUpdate) && void 0 !== _change$isLiveUpdate ? _change$isLiveUpdate : true;
              function getRowKey(row) {
                if (row) {
                  return row.rowType + "," + JSON.stringify(row.key);
                }
              }
              var currentItems = this._items;
              var oldItems = currentItems.slice();
              change.items.forEach(function(item, index2) {
                var key = getRowKey(item);
                newIndexByKey[key] = index2;
                item.rowIndex = index2;
              });
              var result2 = findChanges(oldItems, change.items, getRowKey, (item1, item2) => {
                if (!this._isItemEquals(item1, item2)) {
                  return false;
                }
                if (item1.cells) {
                  item1.update && item1.update(item2);
                  item1.cells.forEach(function(cell) {
                    if (cell && cell.update) {
                      cell.update(item2, true);
                    }
                  });
                }
                return true;
              });
              if (!result2) {
                this._applyChangeFull(change);
                return;
              }
              result2.forEach((change2) => {
                switch (change2.type) {
                  case "update":
                    var index2 = change2.index;
                    var newItem = change2.data;
                    var oldItem = change2.oldItem;
                    var changedColumnIndices = this._partialUpdateRow(oldItem, newItem, index2, isLiveUpdate);
                    rowIndices.push(index2);
                    changeTypes.push("update");
                    items.push(newItem);
                    currentItems[index2] = newItem;
                    columnIndices.push(changedColumnIndices);
                    break;
                  case "insert":
                    rowIndices.push(change2.index);
                    changeTypes.push("insert");
                    items.push(change2.data);
                    columnIndices.push(void 0);
                    currentItems.splice(change2.index, 0, change2.data);
                    break;
                  case "remove":
                    rowIndices.push(change2.index);
                    changeTypes.push("remove");
                    currentItems.splice(change2.index, 1);
                    items.push(change2.oldItem);
                    columnIndices.push(void 0);
                }
              });
              change.repaintChangesOnly = true;
              change.changeType = "update";
              change.rowIndices = rowIndices;
              change.columnIndices = columnIndices;
              change.changeTypes = changeTypes;
              change.items = items;
              if (oldItems.length) {
                change.isLiveUpdate = true;
              }
              this._correctRowIndices(function(rowIndex) {
                var oldItem = oldItems[rowIndex];
                var key = getRowKey(oldItem);
                var newRowIndex = newIndexByKey[key];
                return newRowIndex >= 0 ? newRowIndex - rowIndex : 0;
              });
            },
            _correctRowIndices: noop2,
            _afterProcessItems: function(items) {
              return items;
            },
            _updateItemsCore: function(change) {
              var items;
              var dataSource = this._dataSource;
              var changeType = change.changeType || "refresh";
              change.changeType = changeType;
              if (dataSource) {
                items = change.items || dataSource.items();
                items = this._beforeProcessItems(items);
                items = this._processItems(items, change);
                items = this._afterProcessItems(items, change);
                change.items = items;
                var oldItems = this._items.length === items.length && this._items;
                this._applyChange(change);
                var rowIndexDelta = this.getRowIndexDelta();
                each(this._items, (index2, item) => {
                  item.rowIndex = index2 - rowIndexDelta;
                  if (oldItems) {
                    item.cells = oldItems[index2].cells || [];
                  }
                });
              } else {
                this._items = [];
              }
            },
            _handleChanging: function(e) {
              var rows = this.getVisibleRows();
              var dataSource = this.dataSource();
              if (dataSource) {
                e.changes.forEach(function(change) {
                  if ("insert" === change.type && change.index >= 0) {
                    var dataIndex = 0;
                    for (var i = 0; i < change.index; i++) {
                      var row = rows[i];
                      if (row && ("data" === row.rowType || "group" === row.rowType)) {
                        dataIndex++;
                      }
                    }
                    change.index = dataIndex;
                  }
                });
              }
            },
            updateItems: function(change, isDataChanged) {
              change = change || {};
              if (void 0 !== this._repaintChangesOnly) {
                change.repaintChangesOnly = this._repaintChangesOnly;
              } else if (change.changes) {
                change.repaintChangesOnly = this.option("repaintChangesOnly");
              } else if (isDataChanged) {
                var operationTypes = this.dataSource().operationTypes();
                change.repaintChangesOnly = operationTypes && !operationTypes.grouping && !operationTypes.filtering && this.option("repaintChangesOnly");
                change.isDataChanged = true;
                if (operationTypes && (operationTypes.reload || operationTypes.paging || operationTypes.groupExpanding)) {
                  change.needUpdateDimensions = true;
                }
              }
              if (this._updateLockCount && !change.cancel) {
                this._changes.push(change);
                return;
              }
              this._updateItemsCore(change);
              if (change.cancel) {
                return;
              }
              this._fireChanged(change);
            },
            loadingOperationTypes: function() {
              var dataSource = this.dataSource();
              return dataSource && dataSource.loadingOperationTypes() || {};
            },
            _fireChanged: function(change) {
              if (this._currentOperationTypes) {
                change.operationTypes = this._currentOperationTypes;
                this._currentOperationTypes = null;
              }
              deferRender(() => {
                this.changed.fire(change);
              });
            },
            isLoading: function() {
              return this._isLoading || this._isCustomLoading;
            },
            _fireLoadingChanged: function() {
              this.loadingChanged.fire(this.isLoading(), this._loadingText);
            },
            _calculateAdditionalFilter: function() {
              return null;
            },
            _applyFilter: function() {
              var dataSource = this._dataSource;
              if (dataSource) {
                dataSource.pageIndex(0);
                this._isFilterApplying = true;
                return this.reload().done(() => {
                  if (this._isFilterApplying) {
                    this.pageChanged.fire();
                  }
                });
              }
            },
            resetFilterApplying: function() {
              this._isFilterApplying = false;
            },
            filter: function(filterExpr) {
              var dataSource = this._dataSource;
              var filter = dataSource && dataSource.filter();
              if (0 === arguments.length) {
                return filter;
              }
              filterExpr = arguments.length > 1 ? Array.prototype.slice.call(arguments, 0) : filterExpr;
              if (ui_grid_core_utils_default.equalFilterParameters(filter, filterExpr)) {
                return;
              }
              if (dataSource) {
                dataSource.filter(filterExpr);
              }
              this._applyFilter();
            },
            clearFilter: function(filterName) {
              var that = this;
              var columnsController = that._columnsController;
              var clearColumnOption = function(optionName) {
                var columnCount = columnsController.columnCount();
                for (var index2 = 0; index2 < columnCount; index2++) {
                  columnsController.columnOption(index2, optionName, void 0);
                }
              };
              that.component.beginUpdate();
              if (arguments.length > 0) {
                switch (filterName) {
                  case "dataSource":
                    that.filter(null);
                    break;
                  case "search":
                    that.searchByText("");
                    break;
                  case "header":
                    clearColumnOption("filterValues");
                    break;
                  case "row":
                    clearColumnOption("filterValue");
                }
              } else {
                that.filter(null);
                that.searchByText("");
                clearColumnOption("filterValue");
                clearColumnOption("bufferedFilterValue");
                clearColumnOption("filterValues");
              }
              that.component.endUpdate();
            },
            _fireDataSourceChanged: function() {
              var that = this;
              that.changed.add(function changedHandler() {
                that.changed.remove(changedHandler);
                that.dataSourceChanged.fire();
              });
            },
            _getDataSourceAdapter: noop2,
            _createDataSourceAdapterCore: function(dataSource, remoteOperations) {
              var dataSourceAdapterProvider = this._getDataSourceAdapter();
              var dataSourceAdapter = dataSourceAdapterProvider.create(this.component);
              dataSourceAdapter.init(dataSource, remoteOperations);
              return dataSourceAdapter;
            },
            isLocalStore: function(store) {
              store = store || this.store();
              return store instanceof array_store_default;
            },
            isCustomStore: function(store) {
              store = store || this.store();
              return store instanceof custom_store_default;
            },
            _createDataSourceAdapter: function(dataSource) {
              var remoteOperations = this.option("remoteOperations");
              var store = dataSource.store();
              var enabledRemoteOperations = {
                filtering: true,
                sorting: true,
                paging: true,
                grouping: true,
                summary: true
              };
              if (remoteOperations && remoteOperations.groupPaging) {
                remoteOperations = extend2({}, enabledRemoteOperations, remoteOperations);
              }
              if ("auto" === remoteOperations) {
                remoteOperations = this.isLocalStore(store) || this.isCustomStore(store) ? {} : {
                  filtering: true,
                  sorting: true,
                  paging: true
                };
              }
              if (true === remoteOperations) {
                remoteOperations = enabledRemoteOperations;
              }
              return this._createDataSourceAdapterCore(dataSource, remoteOperations);
            },
            setDataSource: function(dataSource) {
              var oldDataSource = this._dataSource;
              if (!dataSource && oldDataSource) {
                oldDataSource.cancelAll();
                oldDataSource.changed.remove(this._dataChangedHandler);
                oldDataSource.loadingChanged.remove(this._loadingChangedHandler);
                oldDataSource.loadError.remove(this._loadErrorHandler);
                oldDataSource.customizeStoreLoadOptions.remove(this._customizeStoreLoadOptionsHandler);
                oldDataSource.changing.remove(this._changingHandler);
                oldDataSource.pushed.remove(this._dataPushedHandler);
                oldDataSource.dispose(this._isSharedDataSource);
              }
              if (dataSource) {
                dataSource = this._createDataSourceAdapter(dataSource);
              }
              this._dataSource = dataSource;
              if (dataSource) {
                this._fireDataSourceChanged();
                this._isLoading = !dataSource.isLoaded();
                this._needApplyFilter = true;
                this._isAllDataTypesDefined = this._columnsController.isAllDataTypesDefined();
                dataSource.changed.add(this._dataChangedHandler);
                dataSource.loadingChanged.add(this._loadingChangedHandler);
                dataSource.loadError.add(this._loadErrorHandler);
                dataSource.customizeStoreLoadOptions.add(this._customizeStoreLoadOptionsHandler);
                dataSource.changing.add(this._changingHandler);
                dataSource.pushed.add(this._dataPushedHandler);
              }
            },
            items: function() {
              return this._items;
            },
            isEmpty: function() {
              return !this.items().length;
            },
            pageCount: function() {
              return this._dataSource ? this._dataSource.pageCount() : 1;
            },
            dataSource: function() {
              return this._dataSource;
            },
            store: function() {
              var dataSource = this._dataSource;
              return dataSource && dataSource.store();
            },
            loadAll: function(data2) {
              var that = this;
              var d = new Deferred();
              var dataSource = that._dataSource;
              if (dataSource) {
                if (data2) {
                  var options2 = {
                    data: data2,
                    isCustomLoading: true,
                    storeLoadOptions: {
                      isLoadingAll: true
                    },
                    loadOptions: {
                      filter: that.getCombinedFilter(),
                      group: dataSource.group(),
                      sort: dataSource.sort()
                    }
                  };
                  dataSource._handleDataLoaded(options2);
                  when(options2.data).done(function(data3) {
                    data3 = that._beforeProcessItems(data3);
                    d.resolve(that._processItems(data3, {
                      changeType: "loadingAll"
                    }), options2.extra && options2.extra.summary);
                  }).fail(d.reject);
                } else if (!dataSource.isLoading()) {
                  var loadOptions = extend2({}, dataSource.loadOptions(), {
                    isLoadingAll: true,
                    requireTotalCount: false
                  });
                  dataSource.load(loadOptions).done(function(items, extra) {
                    items = that._beforeProcessItems(items);
                    items = that._processItems(items, {
                      changeType: "loadingAll"
                    });
                    d.resolve(items, extra && extra.summary);
                  }).fail(d.reject);
                } else {
                  d.reject();
                }
              } else {
                d.resolve([]);
              }
              return d;
            },
            getKeyByRowIndex: function(rowIndex, byLoaded) {
              var item = this.items(byLoaded)[rowIndex];
              if (item) {
                return item.key;
              }
            },
            getRowIndexByKey: function(key, byLoaded) {
              return ui_grid_core_utils_default.getIndexByKey(key, this.items(byLoaded));
            },
            keyOf: function(data2) {
              var store = this.store();
              if (store) {
                return store.keyOf(data2);
              }
            },
            byKey: function(key) {
              var store = this.store();
              var rowIndex = this.getRowIndexByKey(key);
              var result2;
              if (!store) {
                return;
              }
              if (rowIndex >= 0) {
                result2 = new Deferred().resolve(this.items()[rowIndex].data);
              }
              return result2 || store.byKey(key);
            },
            key: function() {
              var store = this.store();
              if (store) {
                return store.key();
              }
            },
            getRowIndexOffset: function() {
              return 0;
            },
            getDataByKeys: function(rowKeys) {
              var that = this;
              var result2 = new Deferred();
              var deferreds = [];
              var data2 = [];
              each(rowKeys, function(index2, key) {
                deferreds.push(that.byKey(key).done(function(keyData) {
                  data2[index2] = keyData;
                }));
              });
              when.apply(renderer_default, deferreds).always(function() {
                result2.resolve(data2);
              });
              return result2;
            },
            pageIndex: function(value2) {
              return changePaging(this, "pageIndex", value2);
            },
            pageSize: function(value2) {
              return changePaging(this, "pageSize", value2);
            },
            beginCustomLoading: function(messageText) {
              this._isCustomLoading = true;
              this._loadingText = messageText || "";
              this._fireLoadingChanged();
            },
            endCustomLoading: function() {
              this._isCustomLoading = false;
              this._loadingText = void 0;
              this._fireLoadingChanged();
            },
            refresh: function(options2) {
              if (true === options2) {
                options2 = {
                  reload: true,
                  changesOnly: true
                };
              } else if (!options2) {
                options2 = {
                  lookup: true,
                  selection: true,
                  reload: true
                };
              }
              var that = this;
              var dataSource = that.getDataSource();
              var changesOnly = options2.changesOnly;
              var d = new Deferred();
              var customizeLoadResult = function() {
                that._repaintChangesOnly = !!changesOnly;
              };
              when(!options2.lookup || that._columnsController.refresh()).always(function() {
                if (options2.load || options2.reload) {
                  dataSource && dataSource.on("customizeLoadResult", customizeLoadResult);
                  when(that.reload(options2.reload, changesOnly)).always(function() {
                    dataSource && dataSource.off("customizeLoadResult", customizeLoadResult);
                    that._repaintChangesOnly = void 0;
                  }).done(d.resolve).fail(d.reject);
                } else {
                  that.updateItems({
                    repaintChangesOnly: options2.changesOnly
                  });
                  d.resolve();
                }
              });
              return d.promise();
            },
            getVisibleRows: function() {
              return this.items();
            },
            _disposeDataSource: function() {
              this.setDataSource(null);
            },
            dispose: function() {
              this._disposeDataSource();
              this.callBase.apply(this, arguments);
            },
            repaintRows: function(rowIndexes, changesOnly) {
              rowIndexes = Array.isArray(rowIndexes) ? rowIndexes : [rowIndexes];
              if (rowIndexes.length > 1 || isDefined(rowIndexes[0])) {
                this.updateItems({
                  changeType: "update",
                  rowIndices: rowIndexes,
                  isFullUpdate: !changesOnly
                });
              }
            },
            skipProcessingPagingChange: function(fullName) {
              return this._skipProcessingPagingChange && ("paging.pageIndex" === fullName || "paging.pageSize" === fullName);
            },
            getUserState: function() {
              return {
                searchText: this.option("searchPanel.text"),
                pageIndex: this.pageIndex(),
                pageSize: this.pageSize()
              };
            },
            getCachedStoreData: function() {
              return this._dataSource && this._dataSource.getCachedStoreData();
            }
          };
          ui_grid_core_utils_default.proxyMethod(members, "load");
          ui_grid_core_utils_default.proxyMethod(members, "reload");
          ui_grid_core_utils_default.proxyMethod(members, "push");
          ui_grid_core_utils_default.proxyMethod(members, "itemsCount", 0);
          ui_grid_core_utils_default.proxyMethod(members, "totalItemsCount", 0);
          ui_grid_core_utils_default.proxyMethod(members, "hasKnownLastPage", true);
          ui_grid_core_utils_default.proxyMethod(members, "isLoaded", true);
          ui_grid_core_utils_default.proxyMethod(members, "totalCount", 0);
          return members;
        }())
      }
    };
  }
});

// node_modules/devextreme/esm/ui/grid_core/ui.grid_core.sorting_mixin.js
var SORT_CLASS, SORT_NONE_CLASS, SORTUP_CLASS, SORTDOWN_CLASS, SORT_INDEX_CLASS, SORT_INDEX_ICON_CLASS, HEADERS_ACTION_CLASS, ui_grid_core_sorting_mixin_default;
var init_ui_grid_core_sorting_mixin = __esm({
  "node_modules/devextreme/esm/ui/grid_core/ui.grid_core.sorting_mixin.js"() {
    init_type();
    init_renderer();
    SORT_CLASS = "dx-sort";
    SORT_NONE_CLASS = "dx-sort-none";
    SORTUP_CLASS = "dx-sort-up";
    SORTDOWN_CLASS = "dx-sort-down";
    SORT_INDEX_CLASS = "dx-sort-index";
    SORT_INDEX_ICON_CLASS = "dx-sort-index-icon";
    HEADERS_ACTION_CLASS = "action";
    ui_grid_core_sorting_mixin_default = {
      _applyColumnState: function(options2) {
        var ariaSortState;
        var $sortIndicator;
        var sortingMode = this.option("sorting.mode");
        var rootElement = options2.rootElement;
        var column = options2.column;
        var $indicatorsContainer = this._getIndicatorContainer(rootElement);
        if ("sort" === options2.name) {
          rootElement.find("." + SORT_CLASS).remove();
          !$indicatorsContainer.children().length && $indicatorsContainer.remove();
          var isSortingAllowed = "none" !== sortingMode && column.allowSorting;
          if (!isDefined(column.groupIndex) && (isSortingAllowed || isDefined(column.sortOrder))) {
            ariaSortState = "asc" === column.sortOrder ? "ascending" : "descending";
            $sortIndicator = this.callBase(options2).toggleClass(SORTUP_CLASS, "asc" === column.sortOrder).toggleClass(SORTDOWN_CLASS, "desc" === column.sortOrder);
            var hasSeveralSortIndexes = this.getController && !!this.getController("columns").columnOption("sortIndex:1");
            if (hasSeveralSortIndexes && this.option("sorting.showSortIndexes") && column.sortIndex >= 0) {
              renderer_default("<span>").addClass(SORT_INDEX_ICON_CLASS).text(column.sortIndex + 1).appendTo($sortIndicator);
              $sortIndicator.addClass(SORT_INDEX_CLASS);
            }
            if (isSortingAllowed) {
              options2.rootElement.addClass(this.addWidgetPrefix(HEADERS_ACTION_CLASS));
            }
          }
          if (!isDefined(column.sortOrder)) {
            this.setAria("sort", "none", rootElement);
          } else {
            this.setAria("sort", ariaSortState, rootElement);
          }
          return $sortIndicator;
        } else {
          return this.callBase(options2);
        }
      },
      _getIndicatorClassName: function(name2) {
        if ("sort" === name2) {
          return SORT_CLASS;
        } else if ("sortIndex" === name2) {
          return SORT_INDEX_ICON_CLASS;
        }
        return this.callBase(name2);
      },
      _renderIndicator: function(options2) {
        var column = options2.column;
        var $container = options2.container;
        var $indicator = options2.indicator;
        if ("sort" === options2.name) {
          var rtlEnabled = this.option("rtlEnabled");
          if (!isDefined(column.sortOrder)) {
            $indicator && $indicator.addClass(SORT_NONE_CLASS);
          }
          if ($container.children().length && (!rtlEnabled && "left" === options2.columnAlignment || rtlEnabled && "right" === options2.columnAlignment)) {
            $container.prepend($indicator);
            return;
          }
        }
        this.callBase(options2);
      },
      _updateIndicator: function($cell, column, indicatorName) {
        if ("sort" === indicatorName && isDefined(column.groupIndex)) {
          return;
        }
        return this.callBase.apply(this, arguments);
      },
      _getIndicatorElements: function($cell, returnAll) {
        var $indicatorElements = this.callBase($cell);
        return returnAll ? $indicatorElements : $indicatorElements && $indicatorElements.not("." + SORT_NONE_CLASS);
      }
    };
  }
});

// node_modules/devextreme/esm/ui/grid_core/ui.grid_core.sorting.js
var COLUMN_HEADERS_VIEW_NAMESPACE, ColumnHeadersViewSortingExtender, HeaderPanelSortingExtender, sortingModule;
var init_ui_grid_core_sorting = __esm({
  "node_modules/devextreme/esm/ui/grid_core/ui.grid_core.sorting.js"() {
    init_renderer();
    init_events_engine();
    init_click();
    init_type();
    init_extend();
    init_ui_grid_core_sorting_mixin();
    init_message();
    init_utils2();
    COLUMN_HEADERS_VIEW_NAMESPACE = "dxDataGridColumnHeadersView";
    ColumnHeadersViewSortingExtender = extend2({}, ui_grid_core_sorting_mixin_default, {
      _createRow(row) {
        var $row = this.callBase(row);
        if ("header" === row.rowType) {
          events_engine_default.on($row, addNamespace2(CLICK_EVENT_NAME, COLUMN_HEADERS_VIEW_NAMESPACE), "td", this.createAction((e) => {
            this._processHeaderAction(e.event, $row);
          }));
        }
        return $row;
      },
      _processHeaderAction: function(event, $row) {
        if (renderer_default(event.currentTarget).parent().get(0) !== $row.get(0)) {
          return;
        }
        var that = this;
        var keyName = null;
        var $cellElementFromEvent = renderer_default(event.currentTarget);
        var rowIndex = $cellElementFromEvent.parent().index();
        var columnIndex = -1;
        [].slice.call(that.getCellElements(rowIndex)).some(($cellElement, index2) => {
          if ($cellElement === $cellElementFromEvent.get(0)) {
            columnIndex = index2;
            return true;
          }
        });
        var visibleColumns = that._columnsController.getVisibleColumns(rowIndex);
        var column = visibleColumns[columnIndex];
        var editingController = that.getController("editing");
        var editingMode = that.option("editing.mode");
        var isCellEditing = editingController && editingController.isEditing() && ("batch" === editingMode || "cell" === editingMode);
        if (isCellEditing || !that._isSortableElement(renderer_default(event.target))) {
          return;
        }
        if (column && !isDefined(column.groupIndex) && !column.command) {
          if (event.shiftKey) {
            keyName = "shift";
          } else if (isCommandKeyPressed(event)) {
            keyName = "ctrl";
          }
          setTimeout(() => {
            that._columnsController.changeSortOrder(column.index, keyName);
          });
        }
      },
      _renderCellContent($cell, options2) {
        var column = options2.column;
        if (!column.command && "header" === options2.rowType) {
          this._applyColumnState({
            name: "sort",
            rootElement: $cell,
            column,
            showColumnLines: this.option("showColumnLines")
          });
        }
        this.callBase($cell, options2);
      },
      _columnOptionChanged(e) {
        var changeTypes = e.changeTypes;
        if (1 === changeTypes.length && changeTypes.sorting) {
          this._updateIndicators("sort");
          return;
        }
        this.callBase(e);
      },
      optionChanged(args) {
        switch (args.name) {
          case "sorting":
            this._invalidate();
            args.handled = true;
            break;
          default:
            this.callBase(args);
        }
      }
    });
    HeaderPanelSortingExtender = extend2({}, ui_grid_core_sorting_mixin_default, {
      _createGroupPanelItem($rootElement, groupColumn) {
        var that = this;
        var $item = that.callBase(...arguments);
        events_engine_default.on($item, addNamespace2(CLICK_EVENT_NAME, "dxDataGridHeaderPanel"), that.createAction(() => {
          that._processGroupItemAction(groupColumn.index);
        }));
        that._applyColumnState({
          name: "sort",
          rootElement: $item,
          column: {
            alignment: that.option("rtlEnabled") ? "right" : "left",
            allowSorting: groupColumn.allowSorting,
            sortOrder: "desc" === groupColumn.sortOrder ? "desc" : "asc"
          },
          showColumnLines: true
        });
        return $item;
      },
      _processGroupItemAction(groupColumnIndex) {
        setTimeout(() => this.getController("columns").changeSortOrder(groupColumnIndex));
      },
      optionChanged(args) {
        switch (args.name) {
          case "sorting":
            this._invalidate();
            args.handled = true;
            break;
          default:
            this.callBase(args);
        }
      }
    });
    sortingModule = {
      defaultOptions: () => ({
        sorting: {
          mode: "single",
          ascendingText: message_default.format("dxDataGrid-sortingAscendingText"),
          descendingText: message_default.format("dxDataGrid-sortingDescendingText"),
          clearText: message_default.format("dxDataGrid-sortingClearText"),
          showSortIndexes: true
        }
      }),
      extenders: {
        views: {
          columnHeadersView: ColumnHeadersViewSortingExtender,
          headerPanel: HeaderPanelSortingExtender
        }
      }
    };
  }
});

// node_modules/devextreme/esm/ui/grid_core/ui.grid_core.rows.js
function getMaxHorizontalScrollOffset(scrollable) {
  return scrollable ? Math.round(scrollable.scrollWidth() - scrollable.clientWidth()) : 0;
}
var ROWS_VIEW_CLASS3, CONTENT_CLASS5, NOWRAP_CLASS2, GROUP_ROW_CLASS5, GROUP_CELL_CLASS4, DATA_ROW_CLASS4, FREE_SPACE_CLASS, ROW_LINES_CLASS2, COLUMN_LINES_CLASS3, ROW_ALTERNATION_CLASS, LAST_ROW_BORDER, EMPTY_CLASS, ROW_INSERTED_ANIMATION_CLASS, LOADPANEL_HIDE_TIMEOUT, rowsModule;
var init_ui_grid_core_rows = __esm({
  "node_modules/devextreme/esm/ui/grid_core/ui.grid_core.rows.js"() {
    init_extends();
    init_renderer();
    init_window();
    init_events_engine();
    init_common();
    init_style();
    init_type();
    init_iterator();
    init_extend();
    init_position();
    init_string();
    init_data();
    init_ui_grid_core_utils();
    init_ui_grid_core_columns_view();
    init_ui_scrollable();
    init_remove();
    init_message();
    init_browser();
    ROWS_VIEW_CLASS3 = "rowsview";
    CONTENT_CLASS5 = "content";
    NOWRAP_CLASS2 = "nowrap";
    GROUP_ROW_CLASS5 = "dx-group-row";
    GROUP_CELL_CLASS4 = "dx-group-cell";
    DATA_ROW_CLASS4 = "dx-data-row";
    FREE_SPACE_CLASS = "dx-freespace-row";
    ROW_LINES_CLASS2 = "dx-row-lines";
    COLUMN_LINES_CLASS3 = "dx-column-lines";
    ROW_ALTERNATION_CLASS = "dx-row-alt";
    LAST_ROW_BORDER = "dx-last-row-border";
    EMPTY_CLASS = "dx-empty";
    ROW_INSERTED_ANIMATION_CLASS = "row-inserted-animation";
    LOADPANEL_HIDE_TIMEOUT = 200;
    rowsModule = {
      defaultOptions: function() {
        return {
          hoverStateEnabled: false,
          scrolling: {
            useNative: "auto"
          },
          loadPanel: {
            enabled: "auto",
            text: message_default.format("Loading"),
            width: 200,
            height: 90,
            showIndicator: true,
            indicatorSrc: "",
            showPane: true
          },
          rowTemplate: null,
          columnAutoWidth: false,
          noDataText: message_default.format("dxDataGrid-noDataText"),
          wordWrapEnabled: false,
          showColumnLines: true,
          showRowLines: false,
          rowAlternationEnabled: false,
          activeStateEnabled: false,
          twoWayBindingEnabled: true
        };
      },
      views: {
        rowsView: ColumnsView.inherit(function() {
          var defaultCellTemplate = function($container, options2) {
            var isDataTextEmpty = isEmpty(options2.text) && "data" === options2.rowType;
            var text = options2.text;
            var container = $container.get(0);
            if (isDataTextEmpty) {
              ui_grid_core_utils_default.setEmptyText($container);
            } else if (options2.column.encodeHtml) {
              container.textContent = text;
            } else {
              container.innerHTML = text;
            }
          };
          return {
            _getDefaultTemplate: function(column) {
              switch (column.command) {
                case "empty":
                  return function(container) {
                    container.html("&nbsp;");
                  };
                default:
                  return defaultCellTemplate;
              }
            },
            _getDefaultGroupTemplate: function(column) {
              var summaryTexts = this.option("summary.texts");
              return function($container, options2) {
                var data2 = options2.data;
                var text = options2.column.caption + ": " + options2.text;
                var container = $container.get(0);
                if (options2.summaryItems && options2.summaryItems.length) {
                  text += " " + ui_grid_core_utils_default.getGroupRowSummaryText(options2.summaryItems, summaryTexts);
                }
                if (data2) {
                  if (options2.groupContinuedMessage && options2.groupContinuesMessage) {
                    text += " (" + options2.groupContinuedMessage + ". " + options2.groupContinuesMessage + ")";
                  } else if (options2.groupContinuesMessage) {
                    text += " (" + options2.groupContinuesMessage + ")";
                  } else if (options2.groupContinuedMessage) {
                    text += " (" + options2.groupContinuedMessage + ")";
                  }
                }
                $container.addClass(GROUP_CELL_CLASS4);
                if (column.encodeHtml) {
                  container.textContent = text;
                } else {
                  container.innerHTML = text;
                }
              };
            },
            _update: function() {
            },
            _getCellTemplate: function(options2) {
              var column = options2.column;
              var template;
              if ("group" === options2.rowType && isDefined(column.groupIndex) && !column.showWhenGrouped && !column.command) {
                template = column.groupCellTemplate || {
                  allowRenderToDetachedContainer: true,
                  render: this._getDefaultGroupTemplate(column)
                };
              } else if (("data" === options2.rowType || column.command) && column.cellTemplate) {
                template = column.cellTemplate;
              } else {
                template = {
                  allowRenderToDetachedContainer: true,
                  render: this._getDefaultTemplate(column)
                };
              }
              return template;
            },
            _createRow: function(row) {
              var $row = this.callBase(row);
              if (row) {
                var isGroup2 = "group" === row.rowType;
                var isDataRow2 = "data" === row.rowType;
                isDataRow2 && $row.addClass(DATA_ROW_CLASS4);
                isDataRow2 && this.option("showRowLines") && $row.addClass(ROW_LINES_CLASS2);
                this.option("showColumnLines") && $row.addClass(COLUMN_LINES_CLASS3);
                if (false === row.visible) {
                  $row.hide();
                }
                if (isGroup2) {
                  $row.addClass(GROUP_ROW_CLASS5);
                  var isRowExpanded = row.isExpanded;
                  this.setAria("role", "row", $row);
                  this.setAria("expanded", isDefined(isRowExpanded) && isRowExpanded.toString(), $row);
                }
              }
              return $row;
            },
            _rowPrepared: function($row, rowOptions, row) {
              if ("data" === rowOptions.rowType) {
                if (this.option("rowAlternationEnabled")) {
                  this._isAltRow(row) && $row.addClass(ROW_ALTERNATION_CLASS);
                  rowOptions.watch && rowOptions.watch(() => this._isAltRow(row), (value2) => {
                    $row.toggleClass(ROW_ALTERNATION_CLASS, value2);
                  });
                }
                this._setAriaRowIndex(rowOptions, $row);
                rowOptions.watch && rowOptions.watch(() => rowOptions.rowIndex, () => this._setAriaRowIndex(rowOptions, $row));
              }
              this.callBase.apply(this, arguments);
            },
            _setAriaRowIndex: function(row, $row) {
              var component = this.component;
              var isPagerMode = "standard" === component.option("scrolling.mode") && "virtual" !== component.option("scrolling.rowRenderingMode");
              var rowIndex = row.rowIndex + 1;
              if (isPagerMode) {
                rowIndex = component.pageIndex() * component.pageSize() + rowIndex;
              } else {
                rowIndex += this._dataController.getRowIndexOffset();
              }
              this.setAria("rowindex", rowIndex, $row);
            },
            _afterRowPrepared: function(e) {
              var arg = e.args[0];
              var dataController = this._dataController;
              var row = dataController.getVisibleRows()[arg.rowIndex];
              var watch = this.option("integrationOptions.watchMethod");
              if (!arg.data || "data" !== arg.rowType || arg.isNewRow || !this.option("twoWayBindingEnabled") || !watch || !row) {
                return;
              }
              var dispose = watch(() => dataController.generateDataValues(arg.data, arg.columns), () => {
                dataController.repaintRows([row.rowIndex], this.option("repaintChangesOnly"));
              }, {
                deep: true,
                skipImmediate: true
              });
              events_engine_default.on(arg.rowElement, removeEvent, dispose);
            },
            _renderScrollable: function(force) {
              var $element = this.element();
              if (!$element.children().length) {
                $element.append("<div>");
              }
              if (force || !this._loadPanel) {
                this._renderLoadPanel($element, $element.parent(), this._dataController.isLocalStore());
              }
              if ((force || !this.getScrollable()) && this._dataController.isLoaded()) {
                var columns = this.getColumns();
                var allColumnsHasWidth = true;
                for (var i = 0; i < columns.length; i++) {
                  if (!columns[i].width && !columns[i].minWidth) {
                    allColumnsHasWidth = false;
                    break;
                  }
                }
                if (this.option("columnAutoWidth") || this._hasHeight || allColumnsHasWidth || this._columnsController._isColumnFixing()) {
                  this._renderScrollableCore($element);
                }
              }
            },
            _handleScroll: function(e) {
              var rtlEnabled = this.option("rtlEnabled");
              var isNativeScrolling = e.component.option("useNative");
              this._isScrollByEvent = !!e.event;
              this._scrollTop = e.scrollOffset.top;
              this._scrollLeft = e.scrollOffset.left;
              var scrollLeft = e.scrollOffset.left;
              if (rtlEnabled) {
                this._scrollRight = getMaxHorizontalScrollOffset(e.component) - this._scrollLeft;
                if (isNativeScrolling) {
                  var isIE3 = browser_default.msie && browser_default.version < 12;
                  scrollLeft = isIE3 ? this._scrollRight : -this._scrollRight;
                }
                if (!this.isScrollbarVisible(true)) {
                  this._scrollLeft = -1;
                }
              }
              this.scrollChanged.fire(_extends({}, e.scrollOffset, {
                left: scrollLeft
              }), this.name);
            },
            _renderScrollableCore: function($element) {
              var dxScrollableOptions = this._createScrollableOptions();
              var scrollHandler = this._handleScroll.bind(this);
              dxScrollableOptions.onScroll = scrollHandler;
              this._scrollable = this._createComponent($element, ui_scrollable_default, dxScrollableOptions);
              this._scrollableContainer = this._scrollable && renderer_default(this._scrollable.container());
            },
            _renderLoadPanel: ui_grid_core_utils_default.renderLoadPanel,
            _renderContent: function(contentElement, tableElement) {
              contentElement.empty().append(tableElement);
              return this._findContentElement();
            },
            _updateContent: function(newTableElement, change) {
              var that = this;
              var tableElement = that.getTableElement();
              var contentElement = that._findContentElement();
              var changeType = change && change.changeType;
              var executors = [];
              var highlightChanges = this.option("highlightChanges");
              var rowInsertedClass = this.addWidgetPrefix(ROW_INSERTED_ANIMATION_CLASS);
              switch (changeType) {
                case "update":
                  each(change.rowIndices, function(index2, rowIndex) {
                    var $newRowElement = that._getRowElements(newTableElement).eq(index2);
                    var changeType2 = change.changeTypes && change.changeTypes[index2];
                    var item = change.items && change.items[index2];
                    executors.push(function() {
                      var $rowsElement = that._getRowElements();
                      var $rowElement = $rowsElement.eq(rowIndex);
                      switch (changeType2) {
                        case "update":
                          if (item) {
                            var columnIndices = change.columnIndices && change.columnIndices[index2];
                            if (isDefined(item.visible) && item.visible !== $rowElement.is(":visible")) {
                              $rowElement.toggle(item.visible);
                            } else if (columnIndices) {
                              that._updateCells($rowElement, $newRowElement, columnIndices);
                            } else {
                              $rowElement.replaceWith($newRowElement);
                            }
                          }
                          break;
                        case "insert":
                          if (!$rowsElement.length) {
                            if (tableElement) {
                              var target = $newRowElement.is("tbody") ? tableElement : tableElement.children("tbody");
                              $newRowElement.prependTo(target);
                            }
                          } else if ($rowElement.length) {
                            $newRowElement.insertBefore($rowElement);
                          } else {
                            $newRowElement.insertAfter($rowsElement.last());
                          }
                          if (highlightChanges && change.isLiveUpdate) {
                            $newRowElement.addClass(rowInsertedClass);
                          }
                          break;
                        case "remove":
                          $rowElement.remove();
                      }
                    });
                  });
                  each(executors, function() {
                    this();
                  });
                  newTableElement.remove();
                  break;
                default:
                  that.setTableElement(newTableElement);
                  contentElement.addClass(that.addWidgetPrefix(CONTENT_CLASS5));
                  that._renderContent(contentElement, newTableElement);
              }
            },
            _createEmptyRow: function(className, isFixed, height) {
              var $cell;
              var $row = this._createRow();
              var columns = isFixed ? this.getFixedColumns() : this.getColumns();
              $row.addClass(className).toggleClass(COLUMN_LINES_CLASS3, this.option("showColumnLines"));
              for (var i = 0; i < columns.length; i++) {
                $cell = this._createCell({
                  column: columns[i],
                  rowType: "freeSpace",
                  columnIndex: i,
                  columns
                });
                isNumeric(height) && $cell.css("height", height);
                $row.append($cell);
              }
              this.setAria("role", "presentation", $row);
              return $row;
            },
            _appendEmptyRow: function($table, $emptyRow, location) {
              var $tBodies = this._getBodies($table);
              var isTableContainer = !$tBodies.length || $emptyRow.is("tbody");
              var $container = isTableContainer ? $table : $tBodies;
              if ("top" === location) {
                $container.first().prepend($emptyRow);
                if (isTableContainer) {
                  var $colgroup = $container.children("colgroup");
                  $container.prepend($colgroup);
                }
              } else {
                $container.last().append($emptyRow);
              }
            },
            _renderFreeSpaceRow: function($tableElement) {
              var $freeSpaceRowElement = this._createEmptyRow(FREE_SPACE_CLASS);
              $freeSpaceRowElement = this._wrapRowIfNeed($tableElement, $freeSpaceRowElement);
              this._appendEmptyRow($tableElement, $freeSpaceRowElement);
            },
            _checkRowKeys: function(options2) {
              var that = this;
              var rows = that._getRows(options2);
              var keyExpr = that._dataController.store() && that._dataController.store().key();
              keyExpr && rows.some(function(row) {
                if ("data" === row.rowType && void 0 === row.key) {
                  that._dataController.fireError("E1046", keyExpr);
                  return true;
                }
              });
            },
            _needUpdateRowHeight: function(itemsCount) {
              return itemsCount > 0 && !this._rowHeight;
            },
            _getRowsHeight: function($tableElement) {
              var $rowElements = $tableElement.children("tbody").children().not(".dx-virtual-row").not("." + FREE_SPACE_CLASS);
              return $rowElements.toArray().reduce(function(sum, row) {
                return sum + getBoundingRect(row).height;
              }, 0);
            },
            _updateRowHeight: function() {
              var $tableElement = this.getTableElement();
              var itemsCount = this._dataController.items().length;
              if ($tableElement && this._needUpdateRowHeight(itemsCount)) {
                var rowsHeight = this._getRowsHeight($tableElement);
                this._rowHeight = rowsHeight / itemsCount;
              }
            },
            _findContentElement: function() {
              var $content = this.element();
              var scrollable = this.getScrollable();
              if ($content) {
                if (scrollable) {
                  $content = renderer_default(scrollable.content());
                }
                return $content.children().first();
              }
            },
            _getRowElements: function(tableElement) {
              var $rows = this.callBase(tableElement);
              return $rows && $rows.not("." + FREE_SPACE_CLASS);
            },
            _getFreeSpaceRowElements: function($table) {
              var tableElements = $table || this.getTableElements();
              return tableElements && tableElements.children("tbody").children("." + FREE_SPACE_CLASS);
            },
            _getNoDataText: function() {
              return this.option("noDataText");
            },
            _rowClick: function(e) {
              var item = this._dataController.items()[e.rowIndex] || {};
              this.executeAction("onRowClick", extend2({
                evaluate: function(expr) {
                  var getter = compileGetter(expr);
                  return getter(item.data);
                }
              }, e, item));
            },
            _rowDblClick: function(e) {
              var item = this._dataController.items()[e.rowIndex] || {};
              this.executeAction("onRowDblClick", extend2({}, e, item));
            },
            _getColumnsCountBeforeGroups: function(columns) {
              for (var i = 0; i < columns.length; i++) {
                if ("groupExpand" === columns[i].type) {
                  return i;
                }
              }
              return 0;
            },
            _getGroupCellOptions: function(options2) {
              var columnsCountBeforeGroups = this._getColumnsCountBeforeGroups(options2.columns);
              var columnIndex = (options2.row.groupIndex || 0) + columnsCountBeforeGroups;
              return {
                columnIndex,
                colspan: options2.columns.length - columnIndex - 1
              };
            },
            _renderCells: function($row, options2) {
              if ("group" === options2.row.rowType) {
                this._renderGroupedCells($row, options2);
              } else if (options2.row.values) {
                this.callBase($row, options2);
              }
            },
            _renderGroupedCells: function($row, options2) {
              var row = options2.row;
              var expandColumn;
              var columns = options2.columns;
              var rowIndex = row.rowIndex;
              var isExpanded;
              var groupCellOptions = this._getGroupCellOptions(options2);
              for (var i = 0; i <= groupCellOptions.columnIndex; i++) {
                if (i === groupCellOptions.columnIndex && columns[i].allowCollapsing && "infinite" !== options2.scrollingMode) {
                  isExpanded = !!row.isExpanded;
                  expandColumn = columns[i];
                } else {
                  isExpanded = null;
                  expandColumn = {
                    command: "expand",
                    cssClass: columns[i].cssClass
                  };
                }
                this._renderCell($row, {
                  value: isExpanded,
                  row,
                  rowIndex,
                  column: expandColumn,
                  columnIndex: i
                });
              }
              var groupColumnAlignment = getDefaultAlignment(this.option("rtlEnabled"));
              var groupColumn = extend2({}, columns[groupCellOptions.columnIndex], {
                command: null,
                cssClass: null,
                width: null,
                showWhenGrouped: false,
                alignment: groupColumnAlignment
              });
              if (groupCellOptions.colspan > 1) {
                groupColumn.colspan = groupCellOptions.colspan;
              }
              this._renderCell($row, {
                value: row.values[row.groupIndex],
                row,
                rowIndex,
                column: groupColumn,
                columnIndex: groupCellOptions.columnIndex
              });
            },
            _renderRows: function($table, options2) {
              var scrollingMode = this.option("scrolling.mode");
              this.callBase($table, extend2({
                scrollingMode
              }, options2));
              this._checkRowKeys(options2.change);
              this._renderFreeSpaceRow($table);
              if (!this._hasHeight) {
                this.updateFreeSpaceRowHeight($table);
              }
            },
            _renderRow: function($table, options2) {
              var row = options2.row;
              var rowTemplate = this.option("rowTemplate");
              if (("data" === row.rowType || "group" === row.rowType) && !isDefined(row.groupIndex) && rowTemplate) {
                this.renderTemplate($table, rowTemplate, extend2({
                  columns: options2.columns
                }, row), true);
              } else {
                this.callBase($table, options2);
              }
            },
            _renderTable: function(options2) {
              var that = this;
              var $table = that.callBase(options2);
              if (!isDefined(that.getTableElement())) {
                that.setTableElement($table);
                that._renderScrollable(true);
                that.resizeCompleted.add(function resizeCompletedHandler() {
                  var scrollableInstance = that.getScrollable();
                  if (scrollableInstance && that.element().closest(getWindow().document).length) {
                    that.resizeCompleted.remove(resizeCompletedHandler);
                    scrollableInstance._visibilityChanged(true);
                  }
                });
              } else {
                that._renderScrollable();
              }
              return $table;
            },
            _createTable: function() {
              var $table = this.callBase.apply(this, arguments);
              if (this.option("rowTemplate")) {
                $table.appendTo(this.component.$element());
              }
              return $table;
            },
            _renderCore: function(change) {
              var $element = this.element();
              $element.addClass(this.addWidgetPrefix(ROWS_VIEW_CLASS3)).toggleClass(this.addWidgetPrefix(NOWRAP_CLASS2), !this.option("wordWrapEnabled"));
              $element.toggleClass(EMPTY_CLASS, 0 === this._dataController.items().length);
              this.setAria("role", "presentation", $element);
              var $table = this._renderTable({
                change
              });
              this._updateContent($table, change);
              this.callBase(change);
              this._lastColumnWidths = null;
            },
            _getRows: function(change) {
              return change && change.items || this._dataController.items();
            },
            _getCellOptions: function(options2) {
              var column = options2.column;
              var row = options2.row;
              var data2 = row.data;
              var summaryCells = row && row.summaryCells;
              var value2 = options2.value;
              var displayValue = ui_grid_core_utils_default.getDisplayValue(column, value2, data2, row.rowType);
              var parameters = this.callBase(options2);
              parameters.value = value2;
              parameters.oldValue = options2.oldValue;
              parameters.displayValue = displayValue;
              parameters.row = row;
              parameters.key = row.key;
              parameters.data = data2;
              parameters.rowType = row.rowType;
              parameters.values = row.values;
              parameters.text = !column.command ? ui_grid_core_utils_default.formatValue(displayValue, column) : "";
              parameters.rowIndex = row.rowIndex;
              parameters.summaryItems = summaryCells && summaryCells[options2.columnIndex];
              parameters.resized = column.resizedCallbacks;
              if (isDefined(column.groupIndex) && !column.command) {
                var groupingTextsOptions = this.option("grouping.texts");
                var scrollingMode = this.option("scrolling.mode");
                if ("virtual" !== scrollingMode && "infinite" !== scrollingMode) {
                  parameters.groupContinuesMessage = data2 && data2.isContinuationOnNextPage && groupingTextsOptions && groupingTextsOptions.groupContinuesMessage;
                  parameters.groupContinuedMessage = data2 && data2.isContinuation && groupingTextsOptions && groupingTextsOptions.groupContinuedMessage;
                }
              }
              return parameters;
            },
            _setRowsOpacityCore: function($rows, visibleColumns, columnIndex, value2) {
              var columnsController = this._columnsController;
              var columns = columnsController.getColumns();
              var column = columns && columns[columnIndex];
              var columnID = column && column.isBand && column.index;
              each($rows, function(rowIndex, row) {
                if (!renderer_default(row).hasClass(GROUP_ROW_CLASS5)) {
                  for (var i = 0; i < visibleColumns.length; i++) {
                    if (isNumeric(columnID) && columnsController.isParentBandColumn(visibleColumns[i].index, columnID) || visibleColumns[i].index === columnIndex) {
                      $rows.eq(rowIndex).children().eq(i).css({
                        opacity: value2
                      });
                      if (!isNumeric(columnID)) {
                        break;
                      }
                    }
                  }
                }
              });
            },
            _getDevicePixelRatio: function() {
              return getWindow().devicePixelRatio;
            },
            renderNoDataText: ui_grid_core_utils_default.renderNoDataText,
            getCellOptions: function(rowIndex, columnIdentifier) {
              var rowOptions = this._dataController.items()[rowIndex];
              var cellOptions;
              var column;
              if (rowOptions) {
                if (isString2(columnIdentifier)) {
                  column = this._columnsController.columnOption(columnIdentifier);
                } else {
                  column = this._columnsController.getVisibleColumns()[columnIdentifier];
                }
                if (column) {
                  cellOptions = this._getCellOptions({
                    value: column.calculateCellValue(rowOptions.data),
                    rowIndex: rowOptions.rowIndex,
                    row: rowOptions,
                    column
                  });
                }
              }
              return cellOptions;
            },
            getRow: function(index2) {
              if (index2 >= 0) {
                var rows = this._getRowElements();
                if (rows.length > index2) {
                  return renderer_default(rows[index2]);
                }
              }
            },
            updateFreeSpaceRowHeight: function($table) {
              var dataController = this._dataController;
              var itemCount = dataController.items(true).length;
              var contentElement = this._findContentElement();
              var freeSpaceRowElements = this._getFreeSpaceRowElements($table);
              if (freeSpaceRowElements && contentElement && dataController.totalCount() >= 0) {
                var isFreeSpaceRowVisible = false;
                if (itemCount > 0) {
                  if (!this._hasHeight) {
                    var freeSpaceRowCount = dataController.pageSize() - itemCount;
                    var scrollingMode = this.option("scrolling.mode");
                    if (freeSpaceRowCount > 0 && dataController.pageCount() > 1 && "virtual" !== scrollingMode && "infinite" !== scrollingMode) {
                      setHeight(freeSpaceRowElements, freeSpaceRowCount * this._rowHeight);
                      isFreeSpaceRowVisible = true;
                    }
                    if (!isFreeSpaceRowVisible && $table) {
                      setHeight(freeSpaceRowElements, 0);
                    } else {
                      freeSpaceRowElements.toggle(isFreeSpaceRowVisible);
                    }
                    this._updateLastRowBorder(isFreeSpaceRowVisible);
                  } else {
                    freeSpaceRowElements.hide();
                    deferUpdate(() => {
                      var scrollbarWidth2 = this.getScrollbarWidth(true);
                      var elementHeightWithoutScrollbar = this.element().height() - scrollbarWidth2;
                      var contentHeight = contentElement.outerHeight();
                      var showFreeSpaceRow = elementHeightWithoutScrollbar - contentHeight > 0;
                      var rowsHeight = this._getRowsHeight(contentElement.children().first());
                      var $tableElement = $table || this.getTableElements();
                      var borderTopWidth = Math.ceil(parseFloat($tableElement.css("borderTopWidth")));
                      var heightCorrection = this._getHeightCorrection();
                      var resultHeight = elementHeightWithoutScrollbar - rowsHeight - borderTopWidth - heightCorrection;
                      if (showFreeSpaceRow) {
                        deferRender(() => {
                          freeSpaceRowElements.css("height", resultHeight);
                          isFreeSpaceRowVisible = true;
                          freeSpaceRowElements.show();
                        });
                      }
                      deferRender(() => this._updateLastRowBorder(isFreeSpaceRowVisible));
                    });
                  }
                } else {
                  freeSpaceRowElements.css("height", 0);
                  freeSpaceRowElements.show();
                  this._updateLastRowBorder(true);
                }
              }
            },
            _getHeightCorrection: function() {
              var isZoomedWebkit = browser_default.webkit && this._getDevicePixelRatio() >= 2;
              var isChromeLatest = browser_default.chrome && browser_default.version >= 91;
              var hasExtraBorderTop = browser_default.mozilla && browser_default.version >= 70 && !this.option("showRowLines");
              return isZoomedWebkit || hasExtraBorderTop || isChromeLatest ? 1 : 0;
            },
            _columnOptionChanged: function(e) {
              var optionNames = e.optionNames;
              if (e.changeTypes.grouping) {
                return;
              }
              if (optionNames.width || optionNames.visibleWidth) {
                this.callBase(e);
                this._fireColumnResizedCallbacks();
              }
            },
            getScrollable: function() {
              return this._scrollable;
            },
            init: function() {
              var that = this;
              var dataController = that.getController("data");
              that.callBase();
              that._editorFactoryController = that.getController("editorFactory");
              that._rowHeight = 0;
              that._scrollTop = 0;
              that._scrollLeft = -1;
              that._scrollRight = 0;
              that._hasHeight = false;
              dataController.loadingChanged.add(function(isLoading, messageText) {
                that.setLoading(isLoading, messageText);
              });
              dataController.dataSourceChanged.add(function() {
                if (that._scrollLeft >= 0) {
                  that._handleScroll({
                    component: that.getScrollable(),
                    scrollOffset: {
                      top: that._scrollTop,
                      left: that._scrollLeft
                    }
                  });
                }
              });
            },
            _handleDataChanged: function(change) {
              switch (change.changeType) {
                case "refresh":
                case "prepend":
                case "append":
                case "update":
                  this.render(null, change);
                  break;
                default:
                  this._update(change);
              }
            },
            publicMethods: function() {
              return ["isScrollbarVisible", "getTopVisibleRowData", "getScrollbarWidth", "getCellElement", "getRowElement", "getScrollable"];
            },
            contentWidth: function() {
              return this.element().width() - this.getScrollbarWidth();
            },
            getScrollbarWidth: function(isHorizontal) {
              var scrollableContainer = this._scrollableContainer && this._scrollableContainer.get(0);
              var scrollbarWidth2 = 0;
              if (scrollableContainer) {
                if (!isHorizontal) {
                  scrollbarWidth2 = scrollableContainer.clientWidth ? scrollableContainer.offsetWidth - scrollableContainer.clientWidth : 0;
                } else {
                  scrollbarWidth2 = scrollableContainer.clientHeight ? scrollableContainer.offsetHeight - scrollableContainer.clientHeight : 0;
                  scrollbarWidth2 += (that = this, scrollable = that.getScrollable(), scrollable ? Math.ceil(parseFloat(renderer_default(scrollable.content()).css("paddingBottom"))) : 0);
                }
              }
              var that, scrollable;
              return scrollbarWidth2 > 0 ? scrollbarWidth2 : 0;
            },
            _fireColumnResizedCallbacks: function() {
              var lastColumnWidths = this._lastColumnWidths || [];
              var columnWidths = [];
              var columns = this.getColumns();
              for (var i = 0; i < columns.length; i++) {
                columnWidths[i] = columns[i].visibleWidth;
                if (columns[i].resizedCallbacks && !isDefined(columns[i].groupIndex) && lastColumnWidths[i] !== columnWidths[i]) {
                  columns[i].resizedCallbacks.fire(columnWidths[i]);
                }
              }
              this._lastColumnWidths = columnWidths;
            },
            _updateLastRowBorder: function(isFreeSpaceRowVisible) {
              if (this.option("showBorders") && this.option("showRowLines") && !isFreeSpaceRowVisible) {
                this.element().addClass(LAST_ROW_BORDER);
              } else {
                this.element().removeClass(LAST_ROW_BORDER);
              }
            },
            _updateScrollable: function() {
              var dxScrollable = ui_scrollable_default.getInstance(this.element());
              if (dxScrollable) {
                dxScrollable.update();
                this._updateHorizontalScrollPosition();
              }
            },
            _updateHorizontalScrollPosition: function() {
              var scrollable = this.getScrollable();
              var scrollLeft = scrollable && scrollable.scrollOffset().left;
              var rtlEnabled = this.option("rtlEnabled");
              if (rtlEnabled) {
                var maxHorizontalScrollOffset = getMaxHorizontalScrollOffset(scrollable);
                var scrollRight = maxHorizontalScrollOffset - scrollLeft;
                if (scrollRight !== this._scrollRight) {
                  this._scrollLeft = maxHorizontalScrollOffset - this._scrollRight;
                }
              }
              if (this._scrollLeft >= 0 && scrollLeft !== this._scrollLeft) {
                scrollable.scrollTo({
                  x: this._scrollLeft
                });
              }
            },
            _resizeCore: function() {
              var that = this;
              that._fireColumnResizedCallbacks();
              that._updateRowHeight();
              deferRender(function() {
                that._renderScrollable();
                that.renderNoDataText();
                that.updateFreeSpaceRowHeight();
                deferUpdate(function() {
                  that._updateScrollable();
                });
              });
            },
            scrollTo: function(location) {
              var $element = this.element();
              var dxScrollable = $element && ui_scrollable_default.getInstance($element);
              if (dxScrollable) {
                dxScrollable.scrollTo(location);
              }
            },
            height: function(_height, hasHeight) {
              var that = this;
              var $element = this.element();
              if (0 === arguments.length) {
                return $element ? $element.outerHeight(true) : 0;
              }
              that._hasHeight = void 0 === hasHeight ? "auto" !== _height : hasHeight;
              if (isDefined(_height) && $element) {
                setHeight($element, _height);
              }
            },
            setLoading: function(isLoading, messageText) {
              var loadPanel = this._loadPanel;
              var dataController = this._dataController;
              var loadPanelOptions = this.option("loadPanel") || {};
              var animation3 = dataController.isLoaded() ? loadPanelOptions.animation : null;
              var $element = this.element();
              if (!hasWindow()) {
                return;
              }
              if (!loadPanel && void 0 !== messageText && dataController.isLocalStore() && "auto" === loadPanelOptions.enabled && $element) {
                this._renderLoadPanel($element, $element.parent());
                loadPanel = this._loadPanel;
              }
              if (loadPanel) {
                var visibilityOptions = {
                  message: messageText || loadPanelOptions.text,
                  animation: animation3,
                  visible: isLoading
                };
                clearTimeout(this._hideLoadingTimeoutID);
                if (loadPanel.option("visible") && !isLoading) {
                  this._hideLoadingTimeoutID = setTimeout(function() {
                    loadPanel.option(visibilityOptions);
                  }, LOADPANEL_HIDE_TIMEOUT);
                } else {
                  loadPanel.option(visibilityOptions);
                }
              }
            },
            setRowsOpacity: function(columnIndex, value2) {
              var $rows = this._getRowElements().not("." + GROUP_ROW_CLASS5) || [];
              this._setRowsOpacityCore($rows, this.getColumns(), columnIndex, value2);
            },
            _getCellElementsCore: function(rowIndex) {
              var $cells = this.callBase.apply(this, arguments);
              if ($cells) {
                var groupCellIndex = $cells.filter("." + GROUP_CELL_CLASS4).index();
                if (groupCellIndex >= 0 && $cells.length > groupCellIndex + 1) {
                  return $cells.slice(0, groupCellIndex + 1);
                }
              }
              return $cells;
            },
            getTopVisibleItemIndex: function(isFloor) {
              var itemIndex = 0;
              var prevOffsetTop = 0;
              var offsetTop = 0;
              var scrollPosition = this._scrollTop;
              var $contentElement = this._findContentElement();
              var contentElementOffsetTop = $contentElement && $contentElement.offset().top;
              var items = this._dataController.items();
              var tableElement = this.getTableElement();
              if (items.length && tableElement) {
                var rowElements = this._getRowElements(tableElement).filter(":visible");
                for (itemIndex = 0; itemIndex < items.length; itemIndex++) {
                  prevOffsetTop = offsetTop;
                  var rowElement = rowElements.eq(itemIndex);
                  if (rowElement.length) {
                    offsetTop = rowElement.offset().top - contentElementOffsetTop;
                    if (offsetTop > scrollPosition) {
                      if (itemIndex) {
                        if (isFloor || 2 * scrollPosition < Math.round(offsetTop + prevOffsetTop)) {
                          itemIndex--;
                        }
                      }
                      break;
                    }
                  }
                }
                if (itemIndex && itemIndex === items.length) {
                  itemIndex--;
                }
              }
              return itemIndex;
            },
            getTopVisibleRowData: function() {
              var itemIndex = this.getTopVisibleItemIndex();
              var items = this._dataController.items();
              if (items[itemIndex]) {
                return items[itemIndex].data;
              }
            },
            _scrollToElement: function($element, offset2) {
              var scrollable = this.getScrollable();
              scrollable && scrollable.scrollToElement($element, offset2);
            },
            optionChanged: function(args) {
              this.callBase(args);
              switch (args.name) {
                case "wordWrapEnabled":
                case "showColumnLines":
                case "showRowLines":
                case "rowAlternationEnabled":
                case "rowTemplate":
                case "twoWayBindingEnabled":
                  this._invalidate(true, true);
                  args.handled = true;
                  break;
                case "scrolling":
                  this._rowHeight = null;
                  this._tableElement = null;
                  args.handled = true;
                  break;
                case "rtlEnabled":
                  this._rowHeight = null;
                  this._tableElement = null;
                  break;
                case "loadPanel":
                  this._tableElement = null;
                  this._invalidate(true, "loadPanel.enabled" !== args.fullName);
                  args.handled = true;
                  break;
                case "noDataText":
                  this.renderNoDataText();
                  args.handled = true;
              }
            },
            dispose: function() {
              clearTimeout(this._hideLoadingTimeoutID);
              this._scrollable && this._scrollable.dispose();
            },
            setScrollerSpacing: function() {
            }
          };
        }())
      }
    };
  }
});

// node_modules/devextreme/esm/ui/grid_core/ui.grid_core.context_menu.js
var CONTEXT_MENU, viewName, VIEW_NAMES, ContextMenuController, ContextMenuView, contextMenuModule;
var init_ui_grid_core_context_menu = __esm({
  "node_modules/devextreme/esm/ui/grid_core/ui.grid_core.context_menu.js"() {
    init_renderer();
    init_element();
    init_common();
    init_iterator();
    init_ui_grid_core_modules();
    init_context_menu();
    CONTEXT_MENU = "dx-context-menu";
    viewName = {
      columnHeadersView: "header",
      rowsView: "content",
      footerView: "footer",
      headerPanel: "headerPanel"
    };
    VIEW_NAMES = ["columnHeadersView", "rowsView", "footerView", "headerPanel"];
    ContextMenuController = ui_grid_core_modules_default.ViewController.inherit({
      init: function() {
        this.createAction("onContextMenuPreparing");
      },
      getContextMenuItems: function(dxEvent) {
        if (!dxEvent) {
          return false;
        }
        var that = this;
        var $targetElement = renderer_default(dxEvent.target);
        var $element;
        var $targetRowElement;
        var $targetCellElement;
        var menuItems;
        each(VIEW_NAMES, function() {
          var view = that.getView(this);
          $element = view && view.element();
          if ($element && ($element.is($targetElement) || $element.find($targetElement).length)) {
            var _rowOptions$cells, _rowOptions$cells$col;
            $targetCellElement = $targetElement.closest(".dx-row > td, .dx-row > tr");
            $targetRowElement = $targetCellElement.parent();
            var rowIndex = view.getRowIndex($targetRowElement);
            var columnIndex = $targetCellElement[0] && $targetCellElement[0].cellIndex;
            var rowOptions = $targetRowElement.data("options");
            var options2 = {
              event: dxEvent,
              targetElement: getPublicElement($targetElement),
              target: viewName[this],
              rowIndex,
              row: view._getRows()[rowIndex],
              columnIndex,
              column: null === rowOptions || void 0 === rowOptions ? void 0 : null === (_rowOptions$cells = rowOptions.cells) || void 0 === _rowOptions$cells ? void 0 : null === (_rowOptions$cells$col = _rowOptions$cells[columnIndex]) || void 0 === _rowOptions$cells$col ? void 0 : _rowOptions$cells$col.column
            };
            options2.items = view.getContextMenuItems && view.getContextMenuItems(options2);
            that.executeAction("onContextMenuPreparing", options2);
            that._contextMenuPrepared(options2);
            menuItems = options2.items;
            if (menuItems) {
              return false;
            }
          }
        });
        return menuItems;
      },
      _contextMenuPrepared: noop2
    });
    ContextMenuView = ui_grid_core_modules_default.View.inherit({
      _renderCore: function() {
        var that = this;
        var $element = that.element().addClass(CONTEXT_MENU);
        this.setAria("role", "presentation", $element);
        this._createComponent($element, context_menu_default, {
          onPositioning: function(actionArgs) {
            var event = actionArgs.event;
            var contextMenuInstance = actionArgs.component;
            var items = that.getController("contextMenu").getContextMenuItems(event);
            if (items) {
              contextMenuInstance.option("items", items);
              event.stopPropagation();
            } else {
              actionArgs.cancel = true;
            }
          },
          onItemClick: function(params) {
            params.itemData.onItemClick && params.itemData.onItemClick(params);
          },
          cssClass: that.getWidgetContainerClass(),
          target: that.component.$element()
        });
      }
    });
    contextMenuModule = {
      defaultOptions: function() {
        return {
          onContextMenuPreparing: null
        };
      },
      controllers: {
        contextMenu: ContextMenuController
      },
      views: {
        contextMenuView: ContextMenuView
      }
    };
  }
});

// node_modules/devextreme/esm/ui/grid_core/ui.grid_core.error_handling.js
var ERROR_ROW_CLASS2, ERROR_MESSAGE_CLASS, ERROR_CLOSEBUTTON_CLASS, ACTION_CLASS, ErrorHandlingController, errorHandlingModule;
var init_ui_grid_core_error_handling = __esm({
  "node_modules/devextreme/esm/ui/grid_core/ui.grid_core.error_handling.js"() {
    init_renderer();
    init_events_engine();
    init_click();
    init_iterator();
    init_ui_grid_core_modules();
    ERROR_ROW_CLASS2 = "dx-error-row";
    ERROR_MESSAGE_CLASS = "dx-error-message";
    ERROR_CLOSEBUTTON_CLASS = "dx-closebutton";
    ACTION_CLASS = "action";
    ErrorHandlingController = ui_grid_core_modules_default.ViewController.inherit({
      init: function() {
        this._columnHeadersView = this.getView("columnHeadersView");
        this._rowsView = this.getView("rowsView");
      },
      _createErrorRow: function(error, $tableElements) {
        var that = this;
        var $errorRow;
        var $closeButton;
        var $errorMessage = this._renderErrorMessage(error);
        if ($tableElements) {
          $errorRow = renderer_default("<tr>").addClass(ERROR_ROW_CLASS2);
          $closeButton = renderer_default("<div>").addClass(ERROR_CLOSEBUTTON_CLASS).addClass(that.addWidgetPrefix(ACTION_CLASS));
          events_engine_default.on($closeButton, CLICK_EVENT_NAME, that.createAction(function(args) {
            var e = args.event;
            var $errorRow2;
            var errorRowIndex = renderer_default(e.currentTarget).closest("." + ERROR_ROW_CLASS2).index();
            e.stopPropagation();
            each($tableElements, function(_2, tableElement) {
              $errorRow2 = renderer_default(tableElement).children("tbody").children("tr").eq(errorRowIndex);
              that.removeErrorRow($errorRow2);
            });
            that.getController("resizing") && that.getController("resizing").fireContentReadyAction();
          }));
          renderer_default("<td>").attr({
            colSpan: that.getController("columns").getVisibleColumns().length,
            role: "presentation"
          }).prepend($closeButton).append($errorMessage).appendTo($errorRow);
          return $errorRow;
        }
        return $errorMessage;
      },
      _renderErrorMessage: function(error) {
        var message = error.url ? error.message.replace(error.url, "") : error.message || error;
        var $message = renderer_default("<div>").addClass(ERROR_MESSAGE_CLASS).text(message);
        if (error.url) {
          renderer_default("<a>").attr("href", error.url).text(error.url).appendTo($message);
        }
        return $message;
      },
      renderErrorRow: function(error, rowIndex, $popupContent) {
        var that = this;
        var $errorMessageElement;
        var $firstErrorRow;
        if ($popupContent) {
          $popupContent.find("." + ERROR_MESSAGE_CLASS).remove();
          $errorMessageElement = that._createErrorRow(error);
          $popupContent.prepend($errorMessageElement);
          return $errorMessageElement;
        }
        var viewElement = rowIndex >= 0 || !that._columnHeadersView.isVisible() ? that._rowsView : that._columnHeadersView;
        var $tableElements = viewElement.getTableElements();
        each($tableElements, function(_2, tableElement) {
          $errorMessageElement = that._createErrorRow(error, $tableElements);
          $firstErrorRow = $firstErrorRow || $errorMessageElement;
          if (rowIndex >= 0) {
            var $row = viewElement._getRowElements(renderer_default(tableElement)).eq(rowIndex);
            that.removeErrorRow($row.next());
            $errorMessageElement.insertAfter($row);
          } else {
            var $tbody = renderer_default(tableElement).children("tbody");
            var rowElements = $tbody.children("tr");
            if (that._columnHeadersView.isVisible()) {
              that.removeErrorRow(rowElements.last());
              renderer_default(tableElement).append($errorMessageElement);
            } else {
              that.removeErrorRow(rowElements.first());
              $tbody.first().prepend($errorMessageElement);
            }
          }
        });
        var resizingController = that.getController("resizing");
        resizingController && resizingController.fireContentReadyAction();
        return $firstErrorRow;
      },
      removeErrorRow: function($row) {
        if (!$row) {
          var $columnHeaders = this._columnHeadersView && this._columnHeadersView.element();
          $row = $columnHeaders && $columnHeaders.find("." + ERROR_ROW_CLASS2);
          if (!$row || !$row.length) {
            var $rowsViewElement = this._rowsView.element();
            $row = $rowsViewElement && $rowsViewElement.find("." + ERROR_ROW_CLASS2);
          }
        }
        $row && $row.hasClass(ERROR_ROW_CLASS2) && $row.remove();
      },
      optionChanged: function(args) {
        switch (args.name) {
          case "errorRowEnabled":
            args.handled = true;
            break;
          default:
            this.callBase(args);
        }
      }
    });
    errorHandlingModule = {
      defaultOptions: function() {
        return {
          errorRowEnabled: true
        };
      },
      controllers: {
        errorHandling: ErrorHandlingController
      },
      extenders: {
        controllers: {
          data: {
            init: function() {
              var that = this;
              var errorHandlingController = that.getController("errorHandling");
              that.callBase();
              that.dataErrorOccurred.add(function(error, $popupContent) {
                if (that.option("errorRowEnabled")) {
                  errorHandlingController.renderErrorRow(error, void 0, $popupContent);
                }
              });
              that.changed.add(function(e) {
                if (e && "loadError" === e.changeType) {
                  return;
                }
                var errorHandlingController2 = that.getController("errorHandling");
                var editingController = that.getController("editing");
                if (editingController && !editingController.hasChanges()) {
                  errorHandlingController2 && errorHandlingController2.removeErrorRow();
                }
              });
            }
          }
        }
      }
    };
  }
});

// node_modules/devextreme/esm/ui/grid_core/ui.grid_core.grid_view.js
var BORDERS_CLASS, TABLE_FIXED_CLASS2, IMPORTANT_MARGIN_CLASS, GRIDBASE_CONTAINER_CLASS, HIDDEN_COLUMNS_WIDTH3, VIEW_NAMES2, isPercentWidth, isPixelWidth, getContainerHeight2, calculateFreeWidth, calculateFreeWidthWithCurrentMinWidth, restoreFocus2, ResizingController, SynchronizeScrollingController, GridView, gridViewModule;
var init_ui_grid_core_grid_view = __esm({
  "node_modules/devextreme/esm/ui/grid_core/ui.grid_core.grid_view.js"() {
    init_renderer();
    init_ui_grid_core_modules();
    init_common();
    init_window();
    init_iterator();
    init_type();
    init_position();
    init_ui_grid_core_utils();
    init_message();
    init_deferred();
    init_dom_adapter();
    init_browser();
    init_accessibility();
    BORDERS_CLASS = "borders";
    TABLE_FIXED_CLASS2 = "table-fixed";
    IMPORTANT_MARGIN_CLASS = "important-margin";
    GRIDBASE_CONTAINER_CLASS = "dx-gridbase-container";
    HIDDEN_COLUMNS_WIDTH3 = "adaptiveHidden";
    VIEW_NAMES2 = ["columnsSeparatorView", "blockSeparatorView", "trackerView", "headerPanel", "columnHeadersView", "rowsView", "footerView", "columnChooserView", "filterPanelView", "pagerView", "draggingHeaderView", "contextMenuView", "errorView", "headerFilterView", "filterBuilderView"];
    isPercentWidth = function(width) {
      return isString2(width) && "%" === width.slice(-1);
    };
    isPixelWidth = function(width) {
      return isString2(width) && "px" === width.slice(-2);
    };
    getContainerHeight2 = function($container) {
      var clientHeight = $container.get(0).clientHeight;
      var paddingTop = parseFloat($container.css("paddingTop"));
      var paddingBottom = parseFloat($container.css("paddingBottom"));
      return clientHeight - paddingTop - paddingBottom;
    };
    calculateFreeWidth = function(that, widths) {
      var contentWidth = that._rowsView.contentWidth();
      var totalWidth = that._getTotalWidth(widths, contentWidth);
      return contentWidth - totalWidth;
    };
    calculateFreeWidthWithCurrentMinWidth = function(that, columnIndex, currentMinWidth, widths) {
      return calculateFreeWidth(that, widths.map(function(width, index2) {
        return index2 === columnIndex ? currentMinWidth : width;
      }));
    };
    restoreFocus2 = function(focusedElement, selectionRange) {
      hiddenFocus(focusedElement);
      ui_grid_core_utils_default.setSelectionRange(focusedElement, selectionRange);
    };
    ResizingController = ui_grid_core_modules_default.ViewController.inherit({
      _initPostRenderHandlers: function() {
        var that = this;
        var dataController = that._dataController;
        if (!that._refreshSizesHandler) {
          that._refreshSizesHandler = function(e) {
            dataController.changed.remove(that._refreshSizesHandler);
            var resizeDeferred;
            var changeType = e && e.changeType;
            var isDelayed = e && e.isDelayed;
            var items = dataController.items();
            if (!e || "refresh" === changeType || "prepend" === changeType || "append" === changeType) {
              if (!isDelayed) {
                resizeDeferred = that.resize();
              }
            } else if ("update" === changeType && e.changeTypes) {
              if ((items.length > 1 || "insert" !== e.changeTypes[0]) && !(0 === items.length && "remove" === e.changeTypes[0]) && !e.needUpdateDimensions) {
                deferUpdate(() => deferRender(() => deferUpdate(() => {
                  that._setScrollerSpacing(that._hasHeight);
                  that._rowsView.resize();
                })));
              } else {
                resizeDeferred = that.resize();
              }
            }
            if (changeType && "updateSelection" !== changeType && "updateFocusedRow" !== changeType && !isDelayed) {
              when(resizeDeferred).done(function() {
                that._setAriaRowColCount();
                that.fireContentReadyAction();
              });
            }
          };
          that._dataController.changed.add(function() {
            that._dataController.changed.add(that._refreshSizesHandler);
          });
        }
      },
      fireContentReadyAction: function() {
        this.component._fireContentReadyAction();
      },
      _setAriaRowColCount: function() {
        var component = this.component;
        component.setAria({
          rowCount: this._dataController.totalItemsCount(),
          colCount: component.columnCount()
        }, component.$element().children("." + GRIDBASE_CONTAINER_CLASS));
      },
      _getBestFitWidths: function() {
        var _widths;
        var rowsView = this._rowsView;
        var columnHeadersView = this._columnHeadersView;
        var widths = rowsView.getColumnWidths();
        if (!(null !== (_widths = widths) && void 0 !== _widths && _widths.length)) {
          var _rowsView$getTableEle;
          var headersTableElement = columnHeadersView.getTableElement();
          columnHeadersView.setTableElement(null === (_rowsView$getTableEle = rowsView.getTableElement()) || void 0 === _rowsView$getTableEle ? void 0 : _rowsView$getTableEle.children(".dx-header"));
          widths = columnHeadersView.getColumnWidths();
          columnHeadersView.setTableElement(headersTableElement);
        }
        return widths;
      },
      _setVisibleWidths: function(visibleColumns, widths) {
        var columnsController = this._columnsController;
        columnsController.beginUpdate();
        each(visibleColumns, function(index2, column) {
          var columnId = columnsController.getColumnId(column);
          columnsController.columnOption(columnId, "visibleWidth", widths[index2]);
        });
        columnsController.endUpdate();
      },
      _toggleBestFitModeForView: function(view, className, isBestFit) {
        if (!view || !view.isVisible()) {
          return;
        }
        var $rowsTables = this._rowsView.getTableElements();
        var $viewTables = view.getTableElements();
        each($rowsTables, (index2, tableElement) => {
          var $tableBody;
          var $rowsTable = renderer_default(tableElement);
          var $viewTable = $viewTables.eq(index2);
          if ($viewTable && $viewTable.length) {
            if (isBestFit) {
              $tableBody = $viewTable.children("tbody").appendTo($rowsTable);
            } else {
              $tableBody = $rowsTable.children("." + className).appendTo($viewTable);
            }
            $tableBody.toggleClass(className, isBestFit);
            $tableBody.toggleClass(this.addWidgetPrefix("best-fit"), isBestFit);
          }
        });
      },
      _toggleBestFitMode: function(isBestFit) {
        var $rowsTable = this._rowsView.getTableElement();
        var $rowsFixedTable = this._rowsView.getTableElements().eq(1);
        if (!$rowsTable) {
          return;
        }
        $rowsTable.css("tableLayout", isBestFit ? "auto" : "fixed");
        $rowsTable.children("colgroup").css("display", isBestFit ? "none" : "");
        $rowsFixedTable.toggleClass(this.addWidgetPrefix(TABLE_FIXED_CLASS2), !isBestFit);
        this._toggleBestFitModeForView(this._columnHeadersView, "dx-header", isBestFit);
        this._toggleBestFitModeForView(this._footerView, "dx-footer", isBestFit);
        if (this._needStretch()) {
          $rowsTable.get(0).style.width = isBestFit ? "auto" : "";
        }
        if (browser_default.msie && 11 === parseInt(browser_default.version)) {
          $rowsTable.find("." + this.addWidgetPrefix(TABLE_FIXED_CLASS2)).each(function() {
            this.style.width = isBestFit ? "10px" : "";
          });
        }
      },
      _synchronizeColumns: function() {
        var columnsController = this._columnsController;
        var visibleColumns = columnsController.getVisibleColumns();
        var columnAutoWidth = this.option("columnAutoWidth");
        var needBestFit = this._needBestFit();
        var hasMinWidth = false;
        var resetBestFitMode;
        var isColumnWidthsCorrected = false;
        var resultWidths = [];
        var focusedElement;
        var selectionRange;
        !needBestFit && each(visibleColumns, function(index2, column) {
          if ("auto" === column.width) {
            needBestFit = true;
            return false;
          }
        });
        each(visibleColumns, function(index2, column) {
          if (column.minWidth) {
            hasMinWidth = true;
            return false;
          }
        });
        this._setVisibleWidths(visibleColumns, []);
        if (needBestFit) {
          focusedElement = dom_adapter_default.getActiveElement();
          selectionRange = ui_grid_core_utils_default.getSelectionRange(focusedElement);
          this._toggleBestFitMode(true);
          resetBestFitMode = true;
        }
        var $element = this.component.$element();
        if ($element && $element[0] && this._maxWidth) {
          delete this._maxWidth;
          $element[0].style.maxWidth = "";
        }
        deferUpdate(() => {
          if (needBestFit) {
            resultWidths = this._getBestFitWidths();
            each(visibleColumns, function(index2, column) {
              var columnId = columnsController.getColumnId(column);
              columnsController.columnOption(columnId, "bestFitWidth", resultWidths[index2], true);
            });
          } else if (hasMinWidth) {
            resultWidths = this._getBestFitWidths();
          }
          each(visibleColumns, function(index2) {
            var width = this.width;
            if ("auto" !== width) {
              if (isDefined(width)) {
                resultWidths[index2] = isNumeric(width) || isPixelWidth(width) ? parseFloat(width) : width;
              } else if (!columnAutoWidth) {
                resultWidths[index2] = void 0;
              }
            }
          });
          if (resetBestFitMode) {
            this._toggleBestFitMode(false);
            resetBestFitMode = false;
            if (focusedElement && focusedElement !== dom_adapter_default.getActiveElement()) {
              var isFocusOutsideWindow = getBoundingRect(focusedElement).bottom < 0;
              if (!isFocusOutsideWindow) {
                if (browser_default.msie) {
                  setTimeout(function() {
                    restoreFocus2(focusedElement, selectionRange);
                  });
                } else {
                  restoreFocus2(focusedElement, selectionRange);
                }
              }
            }
          }
          isColumnWidthsCorrected = this._correctColumnWidths(resultWidths, visibleColumns);
          if (columnAutoWidth) {
            !function() {
              var expandColumnWidth;
              each(visibleColumns, function(index2, column) {
                if ("groupExpand" === column.type) {
                  expandColumnWidth = resultWidths[index2];
                }
              });
              each(visibleColumns, function(index2, column) {
                if ("groupExpand" === column.type && expandColumnWidth) {
                  resultWidths[index2] = expandColumnWidth;
                }
              });
            }();
            if (this._needStretch()) {
              this._processStretch(resultWidths, visibleColumns);
            }
          }
          deferRender(() => {
            if (needBestFit || isColumnWidthsCorrected) {
              this._setVisibleWidths(visibleColumns, resultWidths);
            }
          });
        });
      },
      _needBestFit: function() {
        return this.option("columnAutoWidth");
      },
      _needStretch: function() {
        return this._columnsController.getVisibleColumns().some((c) => "auto" === c.width && !c.command);
      },
      _getAverageColumnsWidth: function(resultWidths) {
        var freeWidth = calculateFreeWidth(this, resultWidths);
        var columnCountWithoutWidth = resultWidths.filter(function(width) {
          return void 0 === width;
        }).length;
        return freeWidth / columnCountWithoutWidth;
      },
      _correctColumnWidths: function(resultWidths, visibleColumns) {
        var that = this;
        var i;
        var hasPercentWidth = false;
        var hasAutoWidth = false;
        var isColumnWidthsCorrected = false;
        var $element = that.component.$element();
        var hasWidth = that._hasWidth;
        var _loop = function() {
          var index2 = i;
          var column = visibleColumns[index2];
          var isHiddenColumn = resultWidths[index2] === HIDDEN_COLUMNS_WIDTH3;
          var width = resultWidths[index2];
          var minWidth = column.minWidth;
          if (minWidth) {
            if (void 0 === width) {
              var averageColumnsWidth = that._getAverageColumnsWidth(resultWidths);
              width = averageColumnsWidth;
            } else if (isPercentWidth(width)) {
              var freeWidth = calculateFreeWidthWithCurrentMinWidth(that, index2, minWidth, resultWidths);
              if (freeWidth < 0) {
                width = -1;
              }
            }
          }
          var realColumnWidth = that._getRealColumnWidth(index2, resultWidths.map(function(columnWidth, columnIndex) {
            return index2 === columnIndex ? width : columnWidth;
          }));
          if (minWidth && !isHiddenColumn && realColumnWidth < minWidth) {
            resultWidths[index2] = minWidth;
            isColumnWidthsCorrected = true;
            i = -1;
          }
          if (!isDefined(column.width)) {
            hasAutoWidth = true;
          }
          if (isPercentWidth(column.width)) {
            hasPercentWidth = true;
          }
        };
        for (i = 0; i < visibleColumns.length; i++) {
          _loop();
        }
        if (!hasAutoWidth && resultWidths.length) {
          var $rowsViewElement = that._rowsView.element();
          var contentWidth = that._rowsView.contentWidth();
          var scrollbarWidth2 = that._rowsView.getScrollbarWidth();
          var totalWidth = that._getTotalWidth(resultWidths, contentWidth);
          if (totalWidth < contentWidth) {
            var lastColumnIndex = ui_grid_core_utils_default.getLastResizableColumnIndex(visibleColumns, resultWidths);
            if (lastColumnIndex >= 0) {
              resultWidths[lastColumnIndex] = "auto";
              isColumnWidthsCorrected = true;
              if (false === hasWidth && !hasPercentWidth) {
                var borderWidth = that.option("showBorders") ? Math.ceil($rowsViewElement.outerWidth() - $rowsViewElement.innerWidth()) : 0;
                that._maxWidth = totalWidth + scrollbarWidth2 + borderWidth;
                $element.css("maxWidth", that._maxWidth);
              }
            }
          }
        }
        return isColumnWidthsCorrected;
      },
      _processStretch: function(resultSizes, visibleColumns) {
        var groupSize = this._rowsView.contentWidth();
        var tableSize = this._getTotalWidth(resultSizes, groupSize);
        var unusedIndexes = {
          length: 0
        };
        if (!resultSizes.length) {
          return;
        }
        each(visibleColumns, function(index2) {
          if (this.width || resultSizes[index2] === HIDDEN_COLUMNS_WIDTH3) {
            unusedIndexes[index2] = true;
            unusedIndexes.length++;
          }
        });
        var diff = groupSize - tableSize;
        var diffElement = Math.floor(diff / (resultSizes.length - unusedIndexes.length));
        var onePixelElementsCount = diff - diffElement * (resultSizes.length - unusedIndexes.length);
        if (diff >= 0) {
          for (var i = 0; i < resultSizes.length; i++) {
            if (unusedIndexes[i]) {
              continue;
            }
            resultSizes[i] += diffElement;
            if (onePixelElementsCount > 0) {
              if (onePixelElementsCount < 1) {
                resultSizes[i] += onePixelElementsCount;
                onePixelElementsCount = 0;
              } else {
                resultSizes[i]++;
                onePixelElementsCount--;
              }
            }
          }
        }
      },
      _getRealColumnWidth: function(columnIndex, columnWidths, groupWidth) {
        var ratio = 1;
        var width = columnWidths[columnIndex];
        if (!isPercentWidth(width)) {
          return parseFloat(width);
        }
        var percentTotalWidth = columnWidths.reduce((sum, width2, index2) => {
          if (!isPercentWidth(width2)) {
            return sum;
          }
          return sum + parseFloat(width2);
        }, 0);
        var pixelTotalWidth = columnWidths.reduce((sum, width2) => {
          if (!width2 || width2 === HIDDEN_COLUMNS_WIDTH3 || isPercentWidth(width2)) {
            return sum;
          }
          return sum + parseFloat(width2);
        }, 0);
        groupWidth = groupWidth || this._rowsView.contentWidth();
        var freeSpace = groupWidth - pixelTotalWidth;
        var percentTotalWidthInPixel = percentTotalWidth * groupWidth / 100;
        if (pixelTotalWidth > 0 && percentTotalWidthInPixel + pixelTotalWidth >= groupWidth) {
          ratio = percentTotalWidthInPixel > freeSpace ? freeSpace / percentTotalWidthInPixel : 1;
        }
        return parseFloat(width) * groupWidth * ratio / 100;
      },
      _getTotalWidth: function(widths, groupWidth) {
        var result2 = 0;
        for (var i = 0; i < widths.length; i++) {
          var width = widths[i];
          if (width && width !== HIDDEN_COLUMNS_WIDTH3) {
            result2 += this._getRealColumnWidth(i, widths, groupWidth);
          }
        }
        return Math.ceil(result2);
      },
      updateSize: function(rootElement) {
        var $groupElement;
        var width;
        var $rootElement = renderer_default(rootElement);
        var importantMarginClass = this.addWidgetPrefix(IMPORTANT_MARGIN_CLASS);
        if (void 0 === this._hasHeight && $rootElement && $rootElement.is(":visible") && $rootElement.width()) {
          $groupElement = $rootElement.children("." + this.getWidgetContainerClass());
          if ($groupElement.length) {
            $groupElement.detach();
          }
          this._hasHeight = !!getContainerHeight2($rootElement);
          width = $rootElement.width();
          $rootElement.addClass(importantMarginClass);
          this._hasWidth = $rootElement.width() === width;
          $rootElement.removeClass(importantMarginClass);
          if ($groupElement.length) {
            $groupElement.appendTo($rootElement);
          }
        }
      },
      publicMethods: function() {
        return ["resize", "updateDimensions"];
      },
      resize: function() {
        return !this.component._requireResize && this.updateDimensions();
      },
      updateDimensions: function(checkSize) {
        var that = this;
        that._initPostRenderHandlers();
        if (!that._checkSize(checkSize)) {
          return;
        }
        var prevResult = that._resizeDeferred;
        var result2 = that._resizeDeferred = new Deferred();
        when(prevResult).always(function() {
          deferRender(function() {
            if (that._dataController.isLoaded()) {
              that._synchronizeColumns();
            }
            that._resetGroupElementHeight();
            deferUpdate(function() {
              deferRender(function() {
                deferUpdate(function() {
                  that._updateDimensionsCore();
                });
              });
            });
          }).done(result2.resolve).fail(result2.reject);
        });
        return result2.promise();
      },
      _resetGroupElementHeight: function() {
        var groupElement = this.component.$element().children().get(0);
        var scrollable = this._rowsView.getScrollable();
        if (groupElement && groupElement.style.height && (!scrollable || !scrollable.scrollTop())) {
          groupElement.style.height = "";
        }
      },
      _checkSize: function(checkSize) {
        var $rootElement = this.component.$element();
        if (checkSize && (this._lastWidth === $rootElement.width() && this._lastHeight === $rootElement.height() && this._devicePixelRatio === getWindow().devicePixelRatio || !$rootElement.is(":visible"))) {
          return false;
        }
        return true;
      },
      _setScrollerSpacingCore: function(hasHeight) {
        var that = this;
        var vScrollbarWidth = hasHeight ? that._rowsView.getScrollbarWidth() : 0;
        var hScrollbarWidth = that._rowsView.getScrollbarWidth(true);
        deferRender(function() {
          that._columnHeadersView && that._columnHeadersView.setScrollerSpacing(vScrollbarWidth);
          that._footerView && that._footerView.setScrollerSpacing(vScrollbarWidth);
          that._rowsView.setScrollerSpacing(vScrollbarWidth, hScrollbarWidth);
        });
      },
      _setScrollerSpacing: function(hasHeight) {
        if (true === this.option("scrolling.useNative")) {
          deferRender(() => {
            deferUpdate(() => {
              this._setScrollerSpacingCore(hasHeight);
            });
          });
        } else {
          this._setScrollerSpacingCore(hasHeight);
        }
      },
      _updateDimensionsCore: function() {
        var that = this;
        var dataController = that._dataController;
        var rowsView = that._rowsView;
        var $rootElement = that.component.$element();
        var groupElement = $rootElement.children().get(0);
        var rootElementHeight = $rootElement && ($rootElement.get(0).clientHeight || $rootElement.height());
        var maxHeight = parseInt($rootElement.css("maxHeight"));
        var maxHeightHappened = maxHeight && rootElementHeight >= maxHeight;
        var height = that.option("height") || $rootElement.get(0).style.height;
        var editorFactory = that.getController("editorFactory");
        var isMaxHeightApplied = maxHeightHappened && groupElement.scrollHeight === groupElement.offsetHeight;
        var $testDiv;
        that.updateSize($rootElement);
        var hasHeight = that._hasHeight || maxHeightHappened;
        if (height && that._hasHeight ^ "auto" !== height) {
          $testDiv = renderer_default("<div>").height(height).appendTo($rootElement);
          that._hasHeight = !!$testDiv.height();
          $testDiv.remove();
        }
        deferRender(function() {
          rowsView.height(null, hasHeight);
          if (maxHeightHappened && !isMaxHeightApplied) {
            renderer_default(groupElement).css("height", maxHeight);
          }
          if (!dataController.isLoaded()) {
            rowsView.setLoading(dataController.isLoading());
            return;
          }
          deferUpdate(function() {
            that._updateLastSizes($rootElement);
            that._setScrollerSpacing(hasHeight);
            each(VIEW_NAMES2, function(index2, viewName2) {
              var view = that.getView(viewName2);
              if (view) {
                view.resize();
              }
            });
            editorFactory && editorFactory.resize();
          });
        });
      },
      _updateLastSizes: function($rootElement) {
        this._lastWidth = $rootElement.width();
        this._lastHeight = $rootElement.height();
        this._devicePixelRatio = getWindow().devicePixelRatio;
      },
      optionChanged: function(args) {
        switch (args.name) {
          case "width":
          case "height":
            this.component._renderDimensions();
            this.resize();
          case "renderAsync":
            args.handled = true;
            return;
          default:
            this.callBase(args);
        }
      },
      init: function() {
        this._dataController = this.getController("data");
        this._columnsController = this.getController("columns");
        this._columnHeadersView = this.getView("columnHeadersView");
        this._footerView = this.getView("footerView");
        this._rowsView = this.getView("rowsView");
      }
    });
    SynchronizeScrollingController = ui_grid_core_modules_default.ViewController.inherit({
      _scrollChangedHandler: function(views, pos, viewName2) {
        for (var j = 0; j < views.length; j++) {
          if (views[j] && views[j].name !== viewName2) {
            views[j].scrollTo({
              left: pos.left,
              top: pos.top
            });
          }
        }
      },
      init: function() {
        var views = [this.getView("columnHeadersView"), this.getView("footerView"), this.getView("rowsView")];
        for (var i = 0; i < views.length; i++) {
          var view = views[i];
          if (view) {
            view.scrollChanged.add(this._scrollChangedHandler.bind(this, views));
          }
        }
      }
    });
    GridView = ui_grid_core_modules_default.View.inherit({
      _endUpdateCore: function() {
        if (this.component._requireResize) {
          this.component._requireResize = false;
          this._resizingController.resize();
        }
      },
      _getWidgetAriaLabel: function() {
        return "dxDataGrid-ariaDataGrid";
      },
      init: function() {
        this._resizingController = this.getController("resizing");
        this._dataController = this.getController("data");
      },
      getView: function(name2) {
        return this.component._views[name2];
      },
      element: function() {
        return this._groupElement;
      },
      optionChanged: function(args) {
        if (isDefined(this._groupElement) && "showBorders" === args.name) {
          this._groupElement.toggleClass(this.addWidgetPrefix(BORDERS_CLASS), !!args.value);
          args.handled = true;
        } else {
          this.callBase(args);
        }
      },
      _renderViews: function($groupElement) {
        var that = this;
        each(VIEW_NAMES2, function(index2, viewName2) {
          var view = that.getView(viewName2);
          if (view) {
            view.render($groupElement);
          }
        });
      },
      _getTableRoleName: function() {
        return "grid";
      },
      render: function($rootElement) {
        var isFirstRender = !this._groupElement;
        var $groupElement = this._groupElement || renderer_default("<div>").addClass(this.getWidgetContainerClass());
        $groupElement.addClass(GRIDBASE_CONTAINER_CLASS);
        $groupElement.toggleClass(this.addWidgetPrefix(BORDERS_CLASS), !!this.option("showBorders"));
        this.setAria("role", "presentation", $rootElement);
        this.component.setAria({
          role: this._getTableRoleName(),
          label: message_default.format(this._getWidgetAriaLabel())
        }, $groupElement);
        this._rootElement = $rootElement || this._rootElement;
        if (isFirstRender) {
          this._groupElement = $groupElement;
          hasWindow() && this.getController("resizing").updateSize($rootElement);
          $groupElement.appendTo($rootElement);
        }
        this._renderViews($groupElement);
      },
      update: function() {
        var $rootElement = this._rootElement;
        var $groupElement = this._groupElement;
        var resizingController = this.getController("resizing");
        if ($rootElement && $groupElement) {
          resizingController.resize();
          if (this._dataController.isLoaded()) {
            this._resizingController.fireContentReadyAction();
          }
        }
      }
    });
    gridViewModule = {
      defaultOptions: function() {
        return {
          showBorders: false,
          renderAsync: false
        };
      },
      controllers: {
        resizing: ResizingController,
        synchronizeScrolling: SynchronizeScrollingController
      },
      views: {
        gridView: GridView
      },
      VIEW_NAMES: VIEW_NAMES2
    };
  }
});

// node_modules/devextreme/esm/ui/toolbar/ui.toolbar.strategy.js
var abstract10, TOOLBAR_MENU_CONTAINER_CLASS, ToolbarStrategy, ui_toolbar_strategy_default;
var init_ui_toolbar_strategy = __esm({
  "node_modules/devextreme/esm/ui/toolbar/ui.toolbar.strategy.js"() {
    init_renderer();
    init_common();
    init_iterator();
    init_data();
    init_class();
    abstract10 = class_default.abstract;
    TOOLBAR_MENU_CONTAINER_CLASS = "dx-toolbar-menu-container";
    ToolbarStrategy = class_default.inherit({
      ctor: function(toolbar) {
        this._toolbar = toolbar;
      },
      _widgetOptions: function() {
        var itemClickAction = this._toolbar._createActionByOption("onItemClick");
        return {
          itemTemplate: this._getMenuItemTemplate.bind(this),
          onItemClick: (function(e) {
            this._toolbar.option("overflowMenuVisible", false);
            itemClickAction(e);
          }).bind(this)
        };
      },
      _getMenuItemTemplate: function() {
        return this._toolbar._getTemplateByOption("menuItemTemplate");
      },
      _renderWidget: function() {
        var $menu = renderer_default("<div>").appendTo(this._menuContainer());
        this._menu = this._toolbar._createComponent($menu, this._menuWidget(), this._widgetOptions());
        this.renderMenuItems();
      },
      _menuContainer: abstract10,
      _menuWidget: abstract10,
      _hasVisibleMenuItems: function(items) {
        var menuItems = items || this._toolbar.option("items");
        var result2 = false;
        var optionGetter = compileGetter("visible");
        var overflowGetter = compileGetter("locateInMenu");
        each(menuItems, function(index2, item) {
          var itemVisible = optionGetter(item, {
            functionsAsIs: true
          });
          var itemOverflow = overflowGetter(item, {
            functionsAsIs: true
          });
          if (false !== itemVisible && ("auto" === itemOverflow || "always" === itemOverflow) || "menu" === item.location) {
            result2 = true;
          }
        });
        return result2;
      },
      _getMenuItems: function() {
        return this._toolbar._getMenuItems();
      },
      _updateMenuVisibility: noop2,
      _renderMenuButtonContainer: function() {
        var $afterSection = this._toolbar._$afterSection;
        this._$menuButtonContainer = renderer_default("<div>").appendTo($afterSection).addClass(this._toolbar._buttonClass()).addClass(TOOLBAR_MENU_CONTAINER_CLASS);
      },
      renderMenuItems: function() {
        this._menu && this._menu.option("items", this._getMenuItems());
      },
      widgetOption: function(name2, value2) {
        this._menu && this._menu.option(name2, value2);
      }
    });
    ui_toolbar_strategy_default = ToolbarStrategy;
  }
});

// node_modules/devextreme/esm/ui/toolbar/ui.toolbar.strategy.action_sheet.js
var TOOLBAR_MENU_BUTTON_CLASS, ActionSheetStrategy, ui_toolbar_strategy_action_sheet_default;
var init_ui_toolbar_strategy_action_sheet = __esm({
  "node_modules/devextreme/esm/ui/toolbar/ui.toolbar.strategy.action_sheet.js"() {
    init_renderer();
    init_ui_toolbar_strategy();
    init_extend();
    init_action_sheet();
    init_button();
    TOOLBAR_MENU_BUTTON_CLASS = "dx-toolbar-menu-button";
    ActionSheetStrategy = ui_toolbar_strategy_default.inherit({
      NAME: "actionSheet",
      _getMenuItemTemplate: function() {
        return this._toolbar._getTemplate("actionSheetItem");
      },
      render: function() {
        if (!this._hasVisibleMenuItems()) {
          return;
        }
        this._renderMenuButton();
        this._renderWidget();
      },
      _renderMenuButton: function() {
        this._renderMenuButtonContainer();
        this._$button = renderer_default("<div>").appendTo(this._$menuButtonContainer).addClass(TOOLBAR_MENU_BUTTON_CLASS);
        this._toolbar._createComponent(this._$button, button_default, {
          icon: "overflow",
          onClick: () => {
            this._toolbar.option("overflowMenuVisible", !this._toolbar.option("overflowMenuVisible"));
          }
        });
      },
      _menuWidget: function() {
        return action_sheet_default;
      },
      _menuContainer: function() {
        return this._toolbar.$element();
      },
      _widgetOptions: function() {
        return extend2(this.callBase(), {
          target: this._$button,
          showTitle: false,
          onOptionChanged: (_ref) => {
            var {
              name: name2,
              value: value2
            } = _ref;
            if ("visible" === name2) {
              this._toolbar.option("overflowMenuVisible", value2);
            }
          }
        });
      }
    });
    ui_toolbar_strategy_action_sheet_default = ActionSheetStrategy;
  }
});

// node_modules/devextreme/esm/ui/toolbar/ui.toolbar.menu.js
var TOOLBAR_MENU_ACTION_CLASS, TOOLBAR_HIDDEN_BUTTON_CLASS, TOOLBAR_HIDDEN_BUTTON_GROUP_CLASS, TOOLBAR_MENU_SECTION_CLASS, TOOLBAR_MENU_LAST_SECTION_CLASS, ToolbarMenu, ui_toolbar_menu_default;
var init_ui_toolbar_menu = __esm({
  "node_modules/devextreme/esm/ui/toolbar/ui.toolbar.menu.js"() {
    init_renderer();
    init_component_registrator();
    init_iterator();
    init_ui_list_base();
    TOOLBAR_MENU_ACTION_CLASS = "dx-toolbar-menu-action";
    TOOLBAR_HIDDEN_BUTTON_CLASS = "dx-toolbar-hidden-button";
    TOOLBAR_HIDDEN_BUTTON_GROUP_CLASS = "dx-toolbar-hidden-button-group";
    TOOLBAR_MENU_SECTION_CLASS = "dx-toolbar-menu-section";
    TOOLBAR_MENU_LAST_SECTION_CLASS = "dx-toolbar-menu-last-section";
    ToolbarMenu = ListBase.inherit({
      _activeStateUnit: "." + TOOLBAR_MENU_ACTION_CLASS,
      _initMarkup: function() {
        this._renderSections();
        this.callBase();
      },
      _getSections: function() {
        return this._itemContainer().children();
      },
      _itemElements: function() {
        return this._getSections().children(this._itemSelector());
      },
      _renderSections: function() {
        var that = this;
        var $container = this._itemContainer();
        each(["before", "center", "after", "menu"], function() {
          var sectionName = "_$" + this + "Section";
          var $section = that[sectionName];
          if (!$section) {
            that[sectionName] = $section = renderer_default("<div>").addClass(TOOLBAR_MENU_SECTION_CLASS);
          }
          $section.appendTo($container);
        });
      },
      _renderItems: function() {
        this.callBase.apply(this, arguments);
        this._updateSections();
      },
      _updateSections: function() {
        var $sections = this.$element().find("." + TOOLBAR_MENU_SECTION_CLASS);
        $sections.removeClass(TOOLBAR_MENU_LAST_SECTION_CLASS);
        $sections.not(":empty").eq(-1).addClass(TOOLBAR_MENU_LAST_SECTION_CLASS);
      },
      _renderItem: function(index2, item, itemContainer, $after) {
        var location = item.location || "menu";
        var $container = this["_$" + location + "Section"];
        var itemElement = this.callBase(index2, item, $container, $after);
        if (this._getItemTemplateName({
          itemData: item
        })) {
          itemElement.addClass("dx-toolbar-menu-custom");
        }
        if ("menu" === location || "dxButton" === item.widget || "dxButtonGroup" === item.widget || item.isAction) {
          itemElement.addClass(TOOLBAR_MENU_ACTION_CLASS);
        }
        if ("dxButton" === item.widget) {
          itemElement.addClass(TOOLBAR_HIDDEN_BUTTON_CLASS);
        }
        if ("dxButtonGroup" === item.widget) {
          itemElement.addClass(TOOLBAR_HIDDEN_BUTTON_GROUP_CLASS);
        }
        itemElement.addClass(item.cssClass);
        return itemElement;
      },
      _getItemTemplateName: function(args) {
        var template = this.callBase(args);
        var data2 = args.itemData;
        var menuTemplate = data2 && data2.menuItemTemplate;
        return menuTemplate || template;
      },
      _itemClickHandler: function(e, args, config2) {
        if (renderer_default(e.target).closest("." + TOOLBAR_MENU_ACTION_CLASS).length) {
          this.callBase(e, args, config2);
        }
      },
      _clean: function() {
        this._getSections().empty();
        this.callBase();
      }
    });
    component_registrator_default("dxToolbarMenu", ToolbarMenu);
    ui_toolbar_menu_default = ToolbarMenu;
  }
});

// node_modules/devextreme/esm/ui/drop_down_menu.js
var window28, DROP_DOWN_MENU_CLASS, DROP_DOWN_MENU_POPUP_CLASS, DROP_DOWN_MENU_POPUP_WRAPPER_CLASS, DROP_DOWN_MENU_LIST_CLASS, DROP_DOWN_MENU_BUTTON_CLASS, POPUP_OPTION_MAP, BUTTON_OPTION_MAP, DropDownMenu, drop_down_menu_default;
var init_drop_down_menu = __esm({
  "node_modules/devextreme/esm/ui/drop_down_menu.js"() {
    init_renderer();
    init_window();
    init_devices();
    init_component_registrator();
    init_extend();
    init_ui_widget();
    init_button();
    init_popover();
    init_data_helper();
    init_list();
    init_themes();
    init_child_default_template();
    window28 = getWindow();
    DROP_DOWN_MENU_CLASS = "dx-dropdownmenu";
    DROP_DOWN_MENU_POPUP_CLASS = "dx-dropdownmenu-popup";
    DROP_DOWN_MENU_POPUP_WRAPPER_CLASS = "dx-dropdownmenu-popup-wrapper";
    DROP_DOWN_MENU_LIST_CLASS = "dx-dropdownmenu-list";
    DROP_DOWN_MENU_BUTTON_CLASS = "dx-dropdownmenu-button";
    POPUP_OPTION_MAP = {
      popupWidth: "width",
      popupHeight: "height",
      popupMaxHeight: "maxHeight",
      popupAutoResizeEnabled: "autoResizeEnabled"
    };
    BUTTON_OPTION_MAP = {
      buttonIcon: "icon",
      buttonText: "text",
      buttonWidth: "width",
      buttonHeight: "height",
      buttonTemplate: "template"
    };
    DropDownMenu = ui_widget_default.inherit({
      _supportedKeys: function() {
        var extension = {};
        if (!this.option("opened") || !this._list.option("focusedElement")) {
          extension = this._button._supportedKeys();
        }
        return extend2(this.callBase(), extension, {
          tab: function() {
            this._popup && this._popup.hide();
          }
        });
      },
      _getDefaultOptions: function() {
        return extend2(this.callBase(), {
          items: [],
          onItemClick: null,
          dataSource: null,
          itemTemplate: "item",
          buttonText: "",
          buttonIcon: "overflow",
          buttonWidth: void 0,
          buttonHeight: void 0,
          buttonTemplate: "content",
          onButtonClick: null,
          usePopover: false,
          popupWidth: "auto",
          popupHeight: "auto",
          activeStateEnabled: true,
          hoverStateEnabled: true,
          opened: false,
          selectionMode: "none",
          selectedItemKeys: [],
          deferRendering: false,
          popupPosition: {
            my: "top center",
            at: "bottom center",
            collision: "fit flip",
            offset: {
              v: 1
            }
          },
          popupAnimation: void 0,
          onItemRendered: null,
          menuWidget: list_default,
          popupMaxHeight: void 0,
          closeOnClick: true,
          useInkRipple: false,
          container: void 0,
          popupAutoResizeEnabled: false
        });
      },
      _defaultOptionsRules: function() {
        return this.callBase().concat([{
          device: {
            platform: "ios"
          },
          options: {
            usePopover: true
          }
        }, {
          device: {
            platform: "generic"
          },
          options: {
            popupPosition: {
              offset: {
                v: 4
              }
            }
          }
        }, {
          device: function() {
            return "desktop" === devices_default.real().deviceType && !devices_default.isSimulator();
          },
          options: {
            focusStateEnabled: true
          }
        }, {
          device: {
            platform: "android"
          },
          options: {
            popupPosition: {
              my: "top " + (this.option("rtlEnabled") ? "left" : "right"),
              at: "top " + (this.option("rtlEnabled") ? "left" : "right"),
              collision: "flipfit"
            },
            popupAnimation: {
              show: {
                type: "pop",
                duration: 200,
                from: {
                  scale: 0
                },
                to: {
                  scale: 1
                }
              },
              hide: {
                type: "pop",
                duration: 200,
                from: {
                  scale: 1
                },
                to: {
                  scale: 0
                }
              }
            }
          }
        }, {
          device: function() {
            return isMaterial();
          },
          options: {
            useInkRipple: true
          }
        }]);
      },
      _initOptions: function(options2) {
        if ("android" === devices_default.current().platform) {
          if (!options2.popupPosition) {
            options2.popupPosition = {
              at: (options2.usePopover ? "bottom " : "top ") + (options2.rtlEnabled ? "left" : "right")
            };
          }
        }
        this.callBase(options2);
      },
      _dataSourceOptions: function() {
        return {
          paginate: false
        };
      },
      _init: function() {
        this.callBase();
        this.$element().addClass(DROP_DOWN_MENU_CLASS);
        this._initDataSource();
        this._initItemClickAction();
        this._initButtonClickAction();
      },
      _initItemClickAction: function() {
        this._itemClickAction = this._createActionByOption("onItemClick");
      },
      _initButtonClickAction: function() {
        this._buttonClickAction = this._createActionByOption("onButtonClick");
      },
      _initTemplates: function() {
        this._templateManager.addDefaultTemplates({
          content: new ChildDefaultTemplate("content")
        });
        this.callBase();
      },
      _initMarkup: function() {
        this._renderButton();
        this.callBase();
      },
      _render: function() {
        this.callBase();
        this.setAria({
          role: "menubar",
          haspopup: true,
          expanded: this.option("opened")
        });
      },
      _renderContentImpl: function() {
        if (this.option("opened")) {
          this._renderPopup();
        }
      },
      _clean: function() {
        this._cleanFocusState();
        if (this._popup) {
          this._popup.$element().remove();
          delete this._$popup;
        }
      },
      _renderButton: function() {
        var $button = this.$element().addClass(DROP_DOWN_MENU_BUTTON_CLASS);
        var config2 = this._buttonOptions();
        this._button = this._createComponent($button, button_default, config2);
      },
      _toggleActiveState: function($element, value2, e) {
        this._button._toggleActiveState($element, value2, e);
      },
      _buttonOptions: function() {
        return {
          text: this.option("buttonText"),
          icon: this.option("buttonIcon"),
          width: this.option("buttonWidth"),
          height: this.option("buttonHeight"),
          useInkRipple: this.option("useInkRipple"),
          template: this.option("buttonTemplate"),
          focusStateEnabled: false,
          onClick: (function(e) {
            this.option("opened", !this.option("opened"));
            this._buttonClickAction(e);
          }).bind(this)
        };
      },
      _toggleMenuVisibility: function(opened) {
        var state = void 0 === opened ? !this._popup.option("visible") : opened;
        if (opened) {
          this._renderPopup();
        }
        this._popup.toggle(state);
        this.setAria("expanded", state);
      },
      _renderPopup: function() {
        if (this._$popup) {
          return;
        }
        var $popup = this._$popup = renderer_default("<div>").appendTo(this.$element());
        var config2 = this._popupOptions();
        this._popup = this._createComponent($popup, popover_default, config2);
      },
      _popupOptions: function() {
        var usePopup = !this.option("usePopover");
        return {
          onInitialized: function(args) {
            args.component.$wrapper().addClass(DROP_DOWN_MENU_POPUP_WRAPPER_CLASS).toggleClass(DROP_DOWN_MENU_POPUP_CLASS, usePopup);
          },
          visible: this.option("opened"),
          deferRendering: false,
          contentTemplate: (function(contentElement) {
            this._renderList(contentElement);
          }).bind(this),
          position: this.option("popupPosition"),
          animation: this.option("popupAnimation"),
          onOptionChanged: (function(args) {
            if ("visible" === args.name) {
              this.option("opened", args.value);
            }
          }).bind(this),
          target: this.$element(),
          height: this.option("popupHeight"),
          width: this.option("popupWidth"),
          maxHeight: this.option("popupMaxHeight"),
          container: this.option("container"),
          autoResizeEnabled: this.option("popupAutoResizeEnabled")
        };
      },
      _renderList: function(contentElement) {
        var $content = renderer_default(contentElement);
        var listConfig = this._listOptions();
        $content.addClass(DROP_DOWN_MENU_LIST_CLASS);
        this._list = this._createComponent($content, this.option("menuWidget"), listConfig);
        this._list._getAriaTarget = (function() {
          return this.$element();
        }).bind(this);
        this._setListDataSource();
        var listMaxHeight = 0.5 * renderer_default(window28).height();
        if ($content.height() > listMaxHeight) {
          $content.height(listMaxHeight);
        }
      },
      _listOptions: function() {
        return {
          pageLoadMode: "scrollBottom",
          indicateLoading: false,
          noDataText: "",
          selectionMode: this.option("selectionMode"),
          selectedItemKeys: this.option("selectedItemKeys"),
          itemTemplate: this.option("itemTemplate"),
          onItemClick: (function(e) {
            if (this.option("closeOnClick")) {
              this.option("opened", false);
            }
            this._itemClickAction(e);
          }).bind(this),
          tabIndex: -1,
          focusStateEnabled: this.option("focusStateEnabled"),
          activeStateEnabled: this.option("activeStateEnabled"),
          onItemRendered: this.option("onItemRendered"),
          _itemAttributes: {
            role: "menuitem"
          }
        };
      },
      _setListDataSource: function() {
        if (this._list) {
          this._list.option("dataSource", this._dataSource || this.option("items"));
        }
        delete this._deferRendering;
      },
      _getKeyboardListeners() {
        return this.callBase().concat([this._list]);
      },
      _toggleVisibility: function(visible2) {
        this.callBase(visible2);
        this._button.option("visible", visible2);
      },
      _optionChanged: function(args) {
        var name2 = args.name;
        var value2 = args.value;
        switch (name2) {
          case "items":
          case "dataSource":
            if (this.option("deferRendering") && !this.option("opened")) {
              this._deferRendering = true;
            } else {
              this._refreshDataSource();
              this._setListDataSource();
            }
            break;
          case "itemTemplate":
            if (this._list) {
              this._list.option(name2, this._getTemplate(value2));
            }
            break;
          case "onItemClick":
            this._initItemClickAction();
            break;
          case "onButtonClick":
            this._buttonClickAction();
            break;
          case "buttonIcon":
          case "buttonText":
          case "buttonWidth":
          case "buttonHeight":
          case "buttonTemplate":
            this._button.option(BUTTON_OPTION_MAP[name2], value2);
            this._renderPopup();
            break;
          case "popupWidth":
          case "popupHeight":
          case "popupMaxHeight":
          case "popupAutoResizeEnabled":
            this._popup.option(POPUP_OPTION_MAP[name2], value2);
            break;
          case "usePopover":
          case "menuWidget":
          case "useInkRipple":
            this._invalidate();
            break;
          case "focusStateEnabled":
          case "activeStateEnabled":
            if (this._list) {
              this._list.option(name2, value2);
            }
            this.callBase(args);
            break;
          case "selectionMode":
          case "selectedItemKeys":
          case "onItemRendered":
            if (this._list) {
              this._list.option(name2, value2);
            }
            break;
          case "opened":
            if (this._deferRendering) {
              this._refreshDataSource();
              this._setListDataSource();
            }
            this._toggleMenuVisibility(value2);
            break;
          case "deferRendering":
          case "popupPosition":
          case "closeOnClick":
            break;
          case "container":
            this._popup && this._popup.option(args.name, args.value);
            break;
          default:
            this.callBase(args);
        }
      },
      open: function() {
        this.option("opened", true);
      },
      close: function() {
        this.option("opened", false);
      }
    }).include(data_helper_default);
    component_registrator_default("dxDropDownMenu", DropDownMenu);
    drop_down_menu_default = DropDownMenu;
  }
});

// node_modules/devextreme/esm/ui/toolbar/ui.toolbar.strategy.drop_down_menu.js
var MENU_INVISIBLE_CLASS, DropDownMenuStrategy, ui_toolbar_strategy_drop_down_menu_default;
var init_ui_toolbar_strategy_drop_down_menu = __esm({
  "node_modules/devextreme/esm/ui/toolbar/ui.toolbar.strategy.drop_down_menu.js"() {
    init_extend();
    init_dom_adapter();
    init_ui_toolbar_strategy();
    init_ui_toolbar_menu();
    init_drop_down_menu();
    init_devices();
    init_popover_contants();
    MENU_INVISIBLE_CLASS = "dx-state-invisible";
    DropDownMenuStrategy = ui_toolbar_strategy_default.inherit({
      NAME: "dropDownMenu",
      render: function() {
        if (!this._hasVisibleMenuItems()) {
          return;
        }
        this._renderMenuButtonContainer();
        this._renderWidget();
      },
      renderMenuItems: function() {
        if (!this._menu) {
          this.render();
        }
        this.callBase();
        if (this._menu && !this._menu.option("items").length) {
          this._menu.close();
        }
      },
      _menuWidget: function() {
        return drop_down_menu_default;
      },
      _widgetOptions: function() {
        var topAndBottomOffset = 2 * POPOVER_BOUNDARY_OFFSET;
        return extend2(this.callBase(), {
          deferRendering: true,
          container: this._toolbar.option("menuContainer"),
          popupMaxHeight: "android" === devices_default.current().platform ? dom_adapter_default.getDocumentElement().clientHeight - topAndBottomOffset : void 0,
          menuWidget: ui_toolbar_menu_default,
          onOptionChanged: (_ref) => {
            var {
              name: name2,
              value: value2
            } = _ref;
            if ("opened" === name2) {
              this._toolbar.option("overflowMenuVisible", value2);
            }
            if ("items" === name2) {
              this._updateMenuVisibility(value2);
            }
          },
          popupPosition: {
            at: "bottom right",
            my: "top right"
          }
        });
      },
      _updateMenuVisibility: function(menuItems) {
        var items = menuItems || this._getMenuItems();
        var isMenuVisible = items.length && this._hasVisibleMenuItems(items);
        this._toggleMenuVisibility(isMenuVisible);
      },
      _toggleMenuVisibility: function(value2) {
        if (!this._menuContainer()) {
          return;
        }
        this._menuContainer().toggleClass(MENU_INVISIBLE_CLASS, !value2);
      },
      _menuContainer: function() {
        return this._$menuButtonContainer;
      }
    });
    ui_toolbar_strategy_drop_down_menu_default = DropDownMenuStrategy;
  }
});

// node_modules/devextreme/esm/ui/toolbar.js
var STRATEGIES2, TOOLBAR_AUTO_HIDE_ITEM_CLASS, TOOLBAR_AUTO_HIDE_TEXT_CLASS, TOOLBAR_HIDDEN_ITEM, Toolbar, toolbar_default;
var init_toolbar = __esm({
  "node_modules/devextreme/esm/ui/toolbar.js"() {
    init_renderer();
    init_component_registrator();
    init_common();
    init_extend();
    init_array();
    init_iterator();
    init_ui_toolbar_strategy_action_sheet();
    init_ui_toolbar_strategy_drop_down_menu();
    init_ui_toolbar_base();
    init_child_default_template();
    STRATEGIES2 = {
      actionSheet: ui_toolbar_strategy_action_sheet_default,
      dropDownMenu: ui_toolbar_strategy_drop_down_menu_default
    };
    TOOLBAR_AUTO_HIDE_ITEM_CLASS = "dx-toolbar-item-auto-hide";
    TOOLBAR_AUTO_HIDE_TEXT_CLASS = "dx-toolbar-text-auto-hide";
    TOOLBAR_HIDDEN_ITEM = "dx-toolbar-item-invisible";
    Toolbar = ui_toolbar_base_default.inherit({
      _getDefaultOptions: function() {
        return extend2(this.callBase(), {
          menuItemTemplate: "menuItem",
          submenuType: "dropDownMenu",
          menuContainer: void 0,
          overflowMenuVisible: false
        });
      },
      _dimensionChanged: function(dimension) {
        if ("height" === dimension) {
          return;
        }
        this.callBase();
        this._menuStrategy.renderMenuItems();
      },
      _initTemplates: function() {
        this.callBase();
        this._templateManager.addDefaultTemplates({
          actionSheetItem: new ChildDefaultTemplate("item")
        });
      },
      _initMarkup: function() {
        this.callBase();
        this._renderMenu();
      },
      _postProcessRenderItems: function() {
        this._hideOverflowItems();
        this._menuStrategy._updateMenuVisibility();
        this.callBase();
        deferRender(() => {
          this._menuStrategy.renderMenuItems();
        });
      },
      _renderItem: function(index2, item, itemContainer, $after) {
        var itemElement = this.callBase(index2, item, itemContainer, $after);
        if ("auto" === item.locateInMenu) {
          itemElement.addClass(TOOLBAR_AUTO_HIDE_ITEM_CLASS);
        }
        if ("dxButton" === item.widget && "inMenu" === item.showText) {
          itemElement.toggleClass(TOOLBAR_AUTO_HIDE_TEXT_CLASS);
        }
        return itemElement;
      },
      _getItemsWidth: function() {
        return this._getSummaryItemsWidth([this._$beforeSection, this._$centerSection, this._$afterSection]);
      },
      _hideOverflowItems: function(elementWidth) {
        var overflowItems = this.$element().find("." + TOOLBAR_AUTO_HIDE_ITEM_CLASS);
        if (!overflowItems.length) {
          return;
        }
        elementWidth = elementWidth || this.$element().width();
        renderer_default(overflowItems).removeClass(TOOLBAR_HIDDEN_ITEM);
        var itemsWidth = this._getItemsWidth();
        while (overflowItems.length && elementWidth < itemsWidth) {
          var $item = overflowItems.eq(-1);
          itemsWidth -= $item.outerWidth();
          $item.addClass(TOOLBAR_HIDDEN_ITEM);
          overflowItems.splice(-1, 1);
        }
      },
      _getMenuItems: function() {
        var that = this;
        var menuItems = grep(this.option("items") || [], function(item) {
          return that._isMenuItem(item);
        });
        var $hiddenItems = this._itemContainer().children("." + TOOLBAR_AUTO_HIDE_ITEM_CLASS + "." + TOOLBAR_HIDDEN_ITEM).not(".dx-state-invisible");
        this._restoreItems = this._restoreItems || [];
        var overflowItems = [].slice.call($hiddenItems).map((item) => {
          var itemData = that._getItemData(item);
          var $itemContainer = renderer_default(item).children();
          var $itemMarkup = $itemContainer.children();
          return extend2({
            menuItemTemplate: function() {
              that._restoreItems.push({
                container: $itemContainer,
                item: $itemMarkup
              });
              var $container = renderer_default("<div>").addClass(TOOLBAR_AUTO_HIDE_ITEM_CLASS);
              return $container.append($itemMarkup);
            }
          }, itemData);
        });
        return merge(overflowItems, menuItems);
      },
      _getToolbarItems: function() {
        var that = this;
        return grep(this.option("items") || [], function(item) {
          return !that._isMenuItem(item);
        });
      },
      _renderMenu: function() {
        this._renderMenuStrategy();
        deferRender(() => {
          this._menuStrategy.render();
        });
      },
      _renderMenuStrategy: function() {
        var strategyName = this.option("submenuType");
        if (this._requireDropDownStrategy()) {
          strategyName = "dropDownMenu";
        }
        var strategy3 = STRATEGIES2[strategyName];
        if (!(this._menuStrategy && this._menuStrategy.NAME === strategyName)) {
          this._menuStrategy = new strategy3(this);
        }
      },
      _requireDropDownStrategy: function() {
        var items = this.option("items") || [];
        var result2 = false;
        each(items, function(index2, item) {
          if ("auto" === item.locateInMenu) {
            result2 = true;
          } else if ("always" === item.locateInMenu && item.widget) {
            result2 = true;
          }
        });
        return result2;
      },
      _arrangeItems: function() {
        if (this.$element().is(":hidden")) {
          return;
        }
        this._$centerSection.css({
          margin: "0 auto",
          float: "none"
        });
        each(this._restoreItems || [], function(_2, obj) {
          renderer_default(obj.container).append(obj.item);
        });
        this._restoreItems = [];
        var elementWidth = this.$element().width();
        this._hideOverflowItems(elementWidth);
        this.callBase(elementWidth);
      },
      _itemOptionChanged: function(item, property, value2) {
        if (this._isMenuItem(item)) {
          this._menuStrategy.renderMenuItems();
        } else if (this._isToolbarItem(item)) {
          this.callBase(item, property, value2);
        } else {
          this.callBase(item, property, value2);
          this._menuStrategy.renderMenuItems();
        }
        if ("location" === property) {
          this.repaint();
        }
      },
      _isMenuItem: function(itemData) {
        return "menu" === itemData.location || "always" === itemData.locateInMenu;
      },
      _isToolbarItem: function(itemData) {
        return void 0 === itemData.location || "never" === itemData.locateInMenu;
      },
      _optionChanged: function(args) {
        var {
          name: name2,
          value: value2
        } = args;
        switch (name2) {
          case "submenuType":
            this._invalidate();
            break;
          case "menuItemTemplate":
            this._changeMenuOption("itemTemplate", this._getTemplate(value2));
            break;
          case "onItemClick":
            this._changeMenuOption(name2, value2);
            this.callBase.apply(this, arguments);
            break;
          case "menuContainer":
            this._changeMenuOption("container", value2);
            break;
          case "overflowMenuVisible":
            this._changeMenuOption("dropDownMenu" === this._menuStrategy.NAME ? "opened" : "visible", value2);
            break;
          default:
            this.callBase.apply(this, arguments);
        }
      },
      _changeMenuOption: function(name2, value2) {
        this._menuStrategy.widgetOption(name2, value2);
      }
    });
    component_registrator_default("dxToolbar", Toolbar);
    toolbar_default = Toolbar;
  }
});

// node_modules/devextreme/esm/ui/grid_core/ui.grid_core.header_panel.js
var HEADER_PANEL_CLASS2, TOOLBAR_BUTTON_CLASS2, TOOLBAR_ARIA_LABEL, HeaderPanel, headerPanelModule;
var init_ui_grid_core_header_panel = __esm({
  "node_modules/devextreme/esm/ui/grid_core/ui.grid_core.header_panel.js"() {
    init_renderer();
    init_toolbar();
    init_ui_grid_core_columns_view();
    init_common();
    init_type();
    init_visibility_change();
    init_message();
    init_drop_down_menu();
    HEADER_PANEL_CLASS2 = "header-panel";
    TOOLBAR_BUTTON_CLASS2 = "toolbar-button";
    TOOLBAR_ARIA_LABEL = "-ariaToolbar";
    HeaderPanel = ColumnsView.inherit({
      _getToolbarItems: function() {
        return [];
      },
      _getButtonContainer: function() {
        return renderer_default("<div>").addClass(this.addWidgetPrefix(TOOLBAR_BUTTON_CLASS2));
      },
      _getToolbarButtonClass: function(specificClass) {
        var secondClass = specificClass ? " " + specificClass : "";
        return this.addWidgetPrefix(TOOLBAR_BUTTON_CLASS2) + secondClass;
      },
      _getToolbarOptions: function() {
        var options2 = {
          toolbarOptions: {
            items: this._getToolbarItems(),
            onItemRendered: function(e) {
              var itemRenderedCallback = e.itemData.onItemRendered;
              if (itemRenderedCallback) {
                itemRenderedCallback(e);
              }
            }
          }
        };
        this.executeAction("onToolbarPreparing", options2);
        if (options2.toolbarOptions && !isDefined(options2.toolbarOptions.visible)) {
          var toolbarItems = options2.toolbarOptions.items;
          options2.toolbarOptions.visible = !!(toolbarItems && toolbarItems.length);
        }
        return options2.toolbarOptions;
      },
      _renderCore: function() {
        if (!this._toolbar) {
          var $headerPanel = this.element();
          $headerPanel.addClass(this.addWidgetPrefix(HEADER_PANEL_CLASS2));
          var label = message_default.format(this.component.NAME + TOOLBAR_ARIA_LABEL);
          var $toolbar = renderer_default("<div>").attr("aria-label", label).appendTo($headerPanel);
          this._toolbar = this._createComponent($toolbar, toolbar_default, this._toolbarOptions);
        } else {
          this._toolbar.option(this._toolbarOptions);
        }
      },
      _columnOptionChanged: noop2,
      _handleDataChanged: function() {
        if (this._requireReady) {
          this.render();
        }
      },
      init: function() {
        this.callBase();
        this.createAction("onToolbarPreparing", {
          excludeValidators: ["disabled", "readOnly"]
        });
      },
      render: function() {
        this._toolbarOptions = this._getToolbarOptions();
        this.callBase.apply(this, arguments);
      },
      setToolbarItemDisabled: function(name2, optionValue) {
        var toolbarInstance = this._toolbar;
        if (toolbarInstance) {
          var items = toolbarInstance.option("items") || [];
          var itemIndex = items.indexOf(items.filter(function(item) {
            return item.name === name2;
          })[0]);
          if (itemIndex >= 0) {
            var itemOptionPrefix = "items[" + itemIndex + "]";
            if (toolbarInstance.option(itemOptionPrefix + ".options")) {
              toolbarInstance.option(itemOptionPrefix + ".options.disabled", optionValue);
            } else {
              toolbarInstance.option(itemOptionPrefix + ".disabled", optionValue);
            }
          }
        }
      },
      updateToolbarDimensions: function() {
        if (this._toolbar) {
          triggerResizeEvent(this.getHeaderPanel());
        }
      },
      getHeaderPanel: function() {
        return this.element();
      },
      getHeight: function() {
        return this.getElementHeight();
      },
      optionChanged: function(args) {
        if ("onToolbarPreparing" === args.name) {
          this._invalidate();
          args.handled = true;
        }
        this.callBase(args);
      },
      isVisible: function() {
        return this._toolbarOptions && this._toolbarOptions.visible;
      },
      allowDragging: noop2
    });
    headerPanelModule = {
      defaultOptions: function() {
        return {};
      },
      views: {
        headerPanel: HeaderPanel
      },
      extenders: {
        controllers: {
          resizing: {
            _updateDimensionsCore: function() {
              this.callBase.apply(this, arguments);
              this.getView("headerPanel").updateToolbarDimensions();
            }
          }
        }
      }
    };
  }
});

// node_modules/devextreme/esm/ui/grid_core/ui.grid_core.editor_factory.js
var EDITOR_INLINE_BLOCK2, CELL_FOCUS_DISABLED_CLASS8, FOCUS_OVERLAY_CLASS2, CONTENT_CLASS6, FOCUSED_ELEMENT_CLASS, ROW_CLASS7, MODULE_NAMESPACE2, UPDATE_FOCUS_EVENTS, DX_HIDDEN, EditorFactory2, editorFactoryModule;
var init_ui_grid_core_editor_factory = __esm({
  "node_modules/devextreme/esm/ui/grid_core/ui.grid_core.editor_factory.js"() {
    init_renderer();
    init_dom_adapter();
    init_events_engine();
    init_ui_grid_core_modules();
    init_click();
    init_pointer();
    init_position2();
    init_utils2();
    init_browser();
    init_extend();
    init_position();
    init_ui_editor_factory_mixin();
    init_ui_grid_core_utils();
    EDITOR_INLINE_BLOCK2 = "dx-editor-inline-block";
    CELL_FOCUS_DISABLED_CLASS8 = "dx-cell-focus-disabled";
    FOCUS_OVERLAY_CLASS2 = "focus-overlay";
    CONTENT_CLASS6 = "content";
    FOCUSED_ELEMENT_CLASS = "dx-focused";
    ROW_CLASS7 = "dx-row";
    MODULE_NAMESPACE2 = "dxDataGridEditorFactory";
    UPDATE_FOCUS_EVENTS = addNamespace2([pointer_default.down, "focusin", CLICK_EVENT_NAME].join(" "), MODULE_NAMESPACE2);
    DX_HIDDEN = "dx-hidden";
    EditorFactory2 = ui_grid_core_modules_default.ViewController.inherit({
      _getFocusedElement: function($dataGridElement) {
        var rowSelector = this.option("focusedRowEnabled") ? "tr[tabindex]:focus" : "tr[tabindex]:not(.dx-data-row):focus";
        var focusedElementSelector = "td[tabindex]:focus, ".concat(rowSelector, ", input:focus, textarea:focus, .dx-lookup-field:focus, .dx-checkbox:focus, .dx-switch:focus, .dx-dropdownbutton .dx-buttongroup:focus");
        var $focusedElement = $dataGridElement.find(focusedElementSelector);
        return this.elementIsInsideGrid($focusedElement) && $focusedElement;
      },
      _getFocusCellSelector: function() {
        return ".dx-row > td";
      },
      _updateFocusCore: function() {
        var $focus = this._$focusedElement;
        var $dataGridElement = this.component && this.component.$element();
        var $focusCell;
        var hideBorders;
        if ($dataGridElement) {
          $focus = this._getFocusedElement($dataGridElement);
          if ($focus && $focus.length) {
            if (!$focus.hasClass(CELL_FOCUS_DISABLED_CLASS8) && !$focus.hasClass(ROW_CLASS7)) {
              $focusCell = $focus.closest(this._getFocusCellSelector() + ", ." + CELL_FOCUS_DISABLED_CLASS8);
              hideBorders = $focusCell.get(0) !== $focus.get(0) && $focusCell.hasClass(EDITOR_INLINE_BLOCK2);
              $focus = $focusCell;
            }
            if ($focus.length && !$focus.hasClass(CELL_FOCUS_DISABLED_CLASS8)) {
              this.focus($focus, hideBorders);
              return;
            }
          }
        }
        this.loseFocus();
      },
      _updateFocus: function(e) {
        var that = this;
        var isFocusOverlay = e && e.event && renderer_default(e.event.target).hasClass(that.addWidgetPrefix(FOCUS_OVERLAY_CLASS2));
        that._isFocusOverlay = that._isFocusOverlay || isFocusOverlay;
        clearTimeout(that._updateFocusTimeoutID);
        that._updateFocusTimeoutID = setTimeout(function() {
          delete that._updateFocusTimeoutID;
          if (!that._isFocusOverlay) {
            that._updateFocusCore();
          }
          that._isFocusOverlay = false;
        });
      },
      _updateFocusOverlaySize: function($element, position3) {
        $element.hide();
        var location = position_default.calculate($element, extend2({
          collision: "fit"
        }, position3));
        if (location.h.oversize > 0) {
          $element.outerWidth($element.outerWidth() - location.h.oversize);
        }
        if (location.v.oversize > 0) {
          $element.outerHeight($element.outerHeight() - location.v.oversize);
        }
        $element.show();
      },
      callbackNames: function() {
        return ["focused"];
      },
      focus: function($element, hideBorder) {
        var that = this;
        if (void 0 === $element) {
          return that._$focusedElement;
        } else if ($element) {
          if (!$element.is(that._$focusedElement)) {
            that._$focusedElement && that._$focusedElement.removeClass(FOCUSED_ELEMENT_CLASS);
          }
          that._$focusedElement = $element;
          clearTimeout(that._focusTimeoutID);
          that._focusTimeoutID = setTimeout(function() {
            delete that._focusTimeoutID;
            that.renderFocusOverlay($element, hideBorder);
            $element.addClass(FOCUSED_ELEMENT_CLASS);
            that.focused.fire($element);
          });
        }
      },
      refocus: function() {
        var $focus = this.focus();
        this.focus($focus);
      },
      renderFocusOverlay: function($element, hideBorder) {
        if (!ui_grid_core_utils_default.isElementInCurrentGrid(this, $element)) {
          return;
        }
        if (!this._$focusOverlay) {
          this._$focusOverlay = renderer_default("<div>").addClass(this.addWidgetPrefix(FOCUS_OVERLAY_CLASS2));
        }
        if (hideBorder) {
          this._$focusOverlay.addClass(DX_HIDDEN);
        } else if ($element.length) {
          var align = browser_default.msie ? "left bottom" : browser_default.mozilla ? "right bottom" : "left top";
          var $content = $element.closest("." + this.addWidgetPrefix(CONTENT_CLASS6));
          var elemCoord = getBoundingRect($element.get(0));
          this._$focusOverlay.removeClass(DX_HIDDEN).appendTo($content).outerWidth(elemCoord.right - elemCoord.left + 1).outerHeight(elemCoord.bottom - elemCoord.top + 1);
          var focusOverlayPosition = {
            precise: true,
            my: align,
            at: align,
            of: $element,
            boundary: $content.length && $content
          };
          this._updateFocusOverlaySize(this._$focusOverlay, focusOverlayPosition);
          position_default.setup(this._$focusOverlay, focusOverlayPosition);
          this._$focusOverlay.css("visibility", "visible");
        }
      },
      resize: function() {
        var $focusedElement = this._$focusedElement;
        if ($focusedElement) {
          this.focus($focusedElement);
        }
      },
      loseFocus: function() {
        this._$focusedElement && this._$focusedElement.removeClass(FOCUSED_ELEMENT_CLASS);
        this._$focusedElement = null;
        this._$focusOverlay && this._$focusOverlay.addClass(DX_HIDDEN);
      },
      init: function() {
        this.createAction("onEditorPreparing", {
          excludeValidators: ["disabled", "readOnly"],
          category: "rendering"
        });
        this.createAction("onEditorPrepared", {
          excludeValidators: ["disabled", "readOnly"],
          category: "rendering"
        });
        this._updateFocusHandler = this._updateFocusHandler || this.createAction(this._updateFocus.bind(this));
        events_engine_default.on(dom_adapter_default.getDocument(), UPDATE_FOCUS_EVENTS, this._updateFocusHandler);
        this._attachContainerEventHandlers();
      },
      _attachContainerEventHandlers: function() {
        var that = this;
        var $container = that.component && that.component.$element();
        if ($container) {
          events_engine_default.on($container, addNamespace2("keydown", MODULE_NAMESPACE2), function(e) {
            if ("tab" === normalizeKeyName(e)) {
              that._updateFocusHandler(e);
            }
          });
        }
      },
      dispose: function() {
        clearTimeout(this._focusTimeoutID);
        clearTimeout(this._updateFocusTimeoutID);
        events_engine_default.off(dom_adapter_default.getDocument(), UPDATE_FOCUS_EVENTS, this._updateFocusHandler);
      }
    }).include(ui_editor_factory_mixin_default);
    editorFactoryModule = {
      defaultOptions: function() {
        return {};
      },
      controllers: {
        editorFactory: EditorFactory2
      }
    };
  }
});

export {
  isBoolean,
  isDate,
  isDefined,
  isFunction,
  isString2 as isString,
  isObject2 as isObject,
  isEmptyObject,
  isPlainObject,
  init_type,
  map,
  each,
  init_iterator,
  logger,
  init_console,
  extend2 as extend,
  init_extend,
  encodeHtml,
  format,
  init_string,
  init_version,
  class_default,
  init_class,
  Deferred,
  when,
  init_deferred,
  compileGetter,
  compileSetter,
  toComparable,
  init_data,
  deferRender,
  noop2 as noop,
  equalByValue,
  init_common,
  dom_adapter_default,
  init_dom_adapter,
  getWindow,
  getNavigator,
  init_window,
  browser_default,
  init_browser,
  merge,
  init_array,
  events_engine_default,
  init_events_engine,
  init_inflector,
  renderer_default,
  init_renderer,
  component_registrator_default,
  init_component_registrator,
  devices_default,
  init_devices,
  init_dom,
  ui_widget_default,
  init_ui_widget,
  getDefaultAlignment,
  init_position,
  core_default,
  init_core,
  message_default,
  init_message,
  ui_errors_default,
  init_ui_errors,
  isMaterial,
  init_themes,
  normalizeSortingInfo,
  aggregators,
  keysEqual,
  init_utils3 as init_utils,
  init_currency,
  number_default2 as number_default,
  init_number3 as init_number,
  getFormat2 as getFormat,
  init_date_format,
  date_default3 as date_default,
  init_date3 as init_date,
  ui_grid_core_utils_default,
  init_ui_grid_core_utils,
  ui_grid_core_modules_default,
  init_ui_grid_core_modules,
  ui_data_grid_core_default,
  init_ui_data_grid_core,
  ColumnsView,
  init_ui_grid_core_columns_view,
  restoreFocus,
  setTabIndex,
  init_accessibility,
  registerKeyboardAction2 as registerKeyboardAction,
  init_ui_grid_core_accessibility,
  columnHeadersModule,
  init_ui_grid_core_column_headers,
  errors,
  init_errors2 as init_errors,
  store_helper_default,
  init_store_helper,
  createObjectWithChanges,
  init_array_utils,
  init_ajax,
  query_default,
  init_query,
  array_store_default,
  init_array_store,
  columnsControllerModule,
  init_ui_grid_core_columns_controller,
  ui_grid_core_data_source_adapter_default,
  init_ui_grid_core_data_source_adapter,
  dataControllerModule,
  init_ui_grid_core_data_controller,
  sortingModule,
  init_ui_grid_core_sorting,
  rowsModule,
  init_ui_grid_core_rows,
  button_default,
  init_button,
  context_menu_default,
  init_context_menu,
  contextMenuModule,
  init_ui_grid_core_context_menu,
  errorHandlingModule,
  init_ui_grid_core_error_handling,
  gridViewModule,
  init_ui_grid_core_grid_view,
  list_default,
  init_list,
  headerPanelModule,
  init_ui_grid_core_header_panel,
  stateStoringModule,
  init_ui_grid_core_state_storing,
  selectionModule,
  init_ui_grid_core_selection,
  columnChooserModule,
  init_ui_grid_core_column_chooser,
  masterDetailModule,
  init_ui_grid_core_master_detail,
  editorFactoryModule,
  init_ui_grid_core_editor_factory,
  editingModule,
  init_ui_grid_core_editing,
  editingRowBasedModule,
  init_ui_grid_core_editing_row_based,
  editingFormBasedModule,
  init_ui_grid_core_editing_form_based,
  ui_grid_core_editing_cell_based_default,
  init_ui_grid_core_editing_cell_based,
  validatingModule,
  init_ui_grid_core_validating,
  virtualScrollingModule,
  init_ui_grid_core_virtual_scrolling,
  filterRowModule,
  init_ui_grid_core_filter_row,
  headerFilterModule,
  init_ui_grid_core_header_filter,
  filterSyncModule,
  init_ui_grid_core_filter_sync,
  filterBuilderModule,
  init_ui_grid_core_filter_builder,
  filterPanelModule,
  init_ui_grid_core_filter_panel,
  searchModule,
  init_ui_grid_core_search,
  pagerModule,
  init_ui_grid_core_pager,
  columnsResizingReorderingModule,
  init_ui_grid_core_columns_resizing_reordering,
  keyboardNavigationModule,
  init_ui_grid_core_keyboard_navigation,
  columnFixingModule,
  init_ui_grid_core_column_fixing,
  adaptivityModule,
  init_ui_grid_core_adaptivity,
  virtualColumnsModule,
  init_ui_grid_core_virtual_columns,
  focusModule,
  init_ui_grid_core_focus,
  rowDraggingModule,
  init_ui_grid_core_row_dragging,
  require_core
};
/*! Bundled license information:

@vue/compiler-core/dist/compiler-core.esm-bundler.js:
  (**
  * @vue/compiler-core v3.4.10
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **)

@vue/compiler-dom/dist/compiler-dom.esm-bundler.js:
  (**
  * @vue/compiler-dom v3.4.10
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **)

vue/dist/vue.cjs.js:
  (**
  * vue v3.4.10
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **)

devextreme-vue/core/strategy/vue2/children-processing.js:
  (*!
   * devextreme-vue
   * Version: 21.1.12
   * Build date: Fri Apr 07 2023
   *
   * Copyright (c) 2012 - 2023 Developer Express Inc. ALL RIGHTS RESERVED
   *
   * This software may be modified and distributed under the terms
   * of the MIT license. See the LICENSE file in the root of the project for details.
   *
   * https://github.com/DevExpress/devextreme-vue
   *)

devextreme-vue/core/strategy/vue2/helpers.js:
  (*!
   * devextreme-vue
   * Version: 21.1.12
   * Build date: Fri Apr 07 2023
   *
   * Copyright (c) 2012 - 2023 Developer Express Inc. ALL RIGHTS RESERVED
   *
   * This software may be modified and distributed under the terms
   * of the MIT license. See the LICENSE file in the root of the project for details.
   *
   * https://github.com/DevExpress/devextreme-vue
   *)

devextreme-vue/core/strategy/vue2/configuration.js:
  (*!
   * devextreme-vue
   * Version: 21.1.12
   * Build date: Fri Apr 07 2023
   *
   * Copyright (c) 2012 - 2023 Developer Express Inc. ALL RIGHTS RESERVED
   *
   * This software may be modified and distributed under the terms
   * of the MIT license. See the LICENSE file in the root of the project for details.
   *
   * https://github.com/DevExpress/devextreme-vue
   *)

devextreme-vue/core/strategy/vue2/configuration-component.js:
  (*!
   * devextreme-vue
   * Version: 21.1.12
   * Build date: Fri Apr 07 2023
   *
   * Copyright (c) 2012 - 2023 Developer Express Inc. ALL RIGHTS RESERVED
   *
   * This software may be modified and distributed under the terms
   * of the MIT license. See the LICENSE file in the root of the project for details.
   *
   * https://github.com/DevExpress/devextreme-vue
   *)

devextreme-vue/core/strategy/vue2/constants.js:
  (*!
   * devextreme-vue
   * Version: 21.1.12
   * Build date: Fri Apr 07 2023
   *
   * Copyright (c) 2012 - 2023 Developer Express Inc. ALL RIGHTS RESERVED
   *
   * This software may be modified and distributed under the terms
   * of the MIT license. See the LICENSE file in the root of the project for details.
   *
   * https://github.com/DevExpress/devextreme-vue
   *)

devextreme-vue/core/strategy/vue2/config.js:
  (*!
   * devextreme-vue
   * Version: 21.1.12
   * Build date: Fri Apr 07 2023
   *
   * Copyright (c) 2012 - 2023 Developer Express Inc. ALL RIGHTS RESERVED
   *
   * This software may be modified and distributed under the terms
   * of the MIT license. See the LICENSE file in the root of the project for details.
   *
   * https://github.com/DevExpress/devextreme-vue
   *)

devextreme-vue/core/strategy/vue2/errors.js:
  (*!
   * devextreme-vue
   * Version: 21.1.12
   * Build date: Fri Apr 07 2023
   *
   * Copyright (c) 2012 - 2023 Developer Express Inc. ALL RIGHTS RESERVED
   *
   * This software may be modified and distributed under the terms
   * of the MIT license. See the LICENSE file in the root of the project for details.
   *
   * https://github.com/DevExpress/devextreme-vue
   *)

devextreme-vue/core/strategy/vue2/templates-discovering.js:
  (*!
   * devextreme-vue
   * Version: 21.1.12
   * Build date: Fri Apr 07 2023
   *
   * Copyright (c) 2012 - 2023 Developer Express Inc. ALL RIGHTS RESERVED
   *
   * This software may be modified and distributed under the terms
   * of the MIT license. See the LICENSE file in the root of the project for details.
   *
   * https://github.com/DevExpress/devextreme-vue
   *)

devextreme-vue/core/strategy/vue2/templates-manager.js:
  (*!
   * devextreme-vue
   * Version: 21.1.12
   * Build date: Fri Apr 07 2023
   *
   * Copyright (c) 2012 - 2023 Developer Express Inc. ALL RIGHTS RESERVED
   *
   * This software may be modified and distributed under the terms
   * of the MIT license. See the LICENSE file in the root of the project for details.
   *
   * https://github.com/DevExpress/devextreme-vue
   *)

devextreme-vue/core/strategy/vue2/component.js:
  (*!
   * devextreme-vue
   * Version: 21.1.12
   * Build date: Fri Apr 07 2023
   *
   * Copyright (c) 2012 - 2023 Developer Express Inc. ALL RIGHTS RESERVED
   *
   * This software may be modified and distributed under the terms
   * of the MIT license. See the LICENSE file in the root of the project for details.
   *
   * https://github.com/DevExpress/devextreme-vue
   *)

devextreme-vue/core/strategy/vue2/extension-component.js:
  (*!
   * devextreme-vue
   * Version: 21.1.12
   * Build date: Fri Apr 07 2023
   *
   * Copyright (c) 2012 - 2023 Developer Express Inc. ALL RIGHTS RESERVED
   *
   * This software may be modified and distributed under the terms
   * of the MIT license. See the LICENSE file in the root of the project for details.
   *
   * https://github.com/DevExpress/devextreme-vue
   *)

devextreme-vue/core/strategy/vue2/index.js:
  (*!
   * devextreme-vue
   * Version: 21.1.12
   * Build date: Fri Apr 07 2023
   *
   * Copyright (c) 2012 - 2023 Developer Express Inc. ALL RIGHTS RESERVED
   *
   * This software may be modified and distributed under the terms
   * of the MIT license. See the LICENSE file in the root of the project for details.
   *
   * https://github.com/DevExpress/devextreme-vue
   *)

devextreme-vue/core/helpers.js:
  (*!
   * devextreme-vue
   * Version: 21.1.12
   * Build date: Fri Apr 07 2023
   *
   * Copyright (c) 2012 - 2023 Developer Express Inc. ALL RIGHTS RESERVED
   *
   * This software may be modified and distributed under the terms
   * of the MIT license. See the LICENSE file in the root of the project for details.
   *
   * https://github.com/DevExpress/devextreme-vue
   *)

devextreme-vue/core/children-processing.js:
  (*!
   * devextreme-vue
   * Version: 21.1.12
   * Build date: Fri Apr 07 2023
   *
   * Copyright (c) 2012 - 2023 Developer Express Inc. ALL RIGHTS RESERVED
   *
   * This software may be modified and distributed under the terms
   * of the MIT license. See the LICENSE file in the root of the project for details.
   *
   * https://github.com/DevExpress/devextreme-vue
   *)

devextreme-vue/core/vue-helper.js:
  (*!
   * devextreme-vue
   * Version: 21.1.12
   * Build date: Fri Apr 07 2023
   *
   * Copyright (c) 2012 - 2023 Developer Express Inc. ALL RIGHTS RESERVED
   *
   * This software may be modified and distributed under the terms
   * of the MIT license. See the LICENSE file in the root of the project for details.
   *
   * https://github.com/DevExpress/devextreme-vue
   *)

devextreme-vue/core/config.js:
  (*!
   * devextreme-vue
   * Version: 21.1.12
   * Build date: Fri Apr 07 2023
   *
   * Copyright (c) 2012 - 2023 Developer Express Inc. ALL RIGHTS RESERVED
   *
   * This software may be modified and distributed under the terms
   * of the MIT license. See the LICENSE file in the root of the project for details.
   *
   * https://github.com/DevExpress/devextreme-vue
   *)

devextreme-vue/core/configuration.js:
  (*!
   * devextreme-vue
   * Version: 21.1.12
   * Build date: Fri Apr 07 2023
   *
   * Copyright (c) 2012 - 2023 Developer Express Inc. ALL RIGHTS RESERVED
   *
   * This software may be modified and distributed under the terms
   * of the MIT license. See the LICENSE file in the root of the project for details.
   *
   * https://github.com/DevExpress/devextreme-vue
   *)

devextreme-vue/core/configuration-component.js:
  (*!
   * devextreme-vue
   * Version: 21.1.12
   * Build date: Fri Apr 07 2023
   *
   * Copyright (c) 2012 - 2023 Developer Express Inc. ALL RIGHTS RESERVED
   *
   * This software may be modified and distributed under the terms
   * of the MIT license. See the LICENSE file in the root of the project for details.
   *
   * https://github.com/DevExpress/devextreme-vue
   *)

devextreme-vue/core/constants.js:
  (*!
   * devextreme-vue
   * Version: 21.1.12
   * Build date: Fri Apr 07 2023
   *
   * Copyright (c) 2012 - 2023 Developer Express Inc. ALL RIGHTS RESERVED
   *
   * This software may be modified and distributed under the terms
   * of the MIT license. See the LICENSE file in the root of the project for details.
   *
   * https://github.com/DevExpress/devextreme-vue
   *)

devextreme-vue/core/templates-discovering.js:
  (*!
   * devextreme-vue
   * Version: 21.1.12
   * Build date: Fri Apr 07 2023
   *
   * Copyright (c) 2012 - 2023 Developer Express Inc. ALL RIGHTS RESERVED
   *
   * This software may be modified and distributed under the terms
   * of the MIT license. See the LICENSE file in the root of the project for details.
   *
   * https://github.com/DevExpress/devextreme-vue
   *)

devextreme-vue/core/templates-manager.js:
  (*!
   * devextreme-vue
   * Version: 21.1.12
   * Build date: Fri Apr 07 2023
   *
   * Copyright (c) 2012 - 2023 Developer Express Inc. ALL RIGHTS RESERVED
   *
   * This software may be modified and distributed under the terms
   * of the MIT license. See the LICENSE file in the root of the project for details.
   *
   * https://github.com/DevExpress/devextreme-vue
   *)

devextreme-vue/core/component.js:
  (*!
   * devextreme-vue
   * Version: 21.1.12
   * Build date: Fri Apr 07 2023
   *
   * Copyright (c) 2012 - 2023 Developer Express Inc. ALL RIGHTS RESERVED
   *
   * This software may be modified and distributed under the terms
   * of the MIT license. See the LICENSE file in the root of the project for details.
   *
   * https://github.com/DevExpress/devextreme-vue
   *)

devextreme-vue/core/extension-component.js:
  (*!
   * devextreme-vue
   * Version: 21.1.12
   * Build date: Fri Apr 07 2023
   *
   * Copyright (c) 2012 - 2023 Developer Express Inc. ALL RIGHTS RESERVED
   *
   * This software may be modified and distributed under the terms
   * of the MIT license. See the LICENSE file in the root of the project for details.
   *
   * https://github.com/DevExpress/devextreme-vue
   *)

devextreme-vue/core/strategy/vue3/index.js:
  (*!
   * devextreme-vue
   * Version: 21.1.12
   * Build date: Fri Apr 07 2023
   *
   * Copyright (c) 2012 - 2023 Developer Express Inc. ALL RIGHTS RESERVED
   *
   * This software may be modified and distributed under the terms
   * of the MIT license. See the LICENSE file in the root of the project for details.
   *
   * https://github.com/DevExpress/devextreme-vue
   *)

devextreme-vue/core/version.js:
  (*!
   * devextreme-vue
   * Version: 21.1.12
   * Build date: Fri Apr 07 2023
   *
   * Copyright (c) 2012 - 2023 Developer Express Inc. ALL RIGHTS RESERVED
   *
   * This software may be modified and distributed under the terms
   * of the MIT license. See the LICENSE file in the root of the project for details.
   *
   * https://github.com/DevExpress/devextreme-vue
   *)

devextreme-vue/core/index.js:
  (*!
   * devextreme-vue
   * Version: 21.1.12
   * Build date: Fri Apr 07 2023
   *
   * Copyright (c) 2012 - 2023 Developer Express Inc. ALL RIGHTS RESERVED
   *
   * This software may be modified and distributed under the terms
   * of the MIT license. See the LICENSE file in the root of the project for details.
   *
   * https://github.com/DevExpress/devextreme-vue
   *)
*/
//# sourceMappingURL=chunk-ZMSIPWJ6.js.map
